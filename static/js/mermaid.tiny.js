"use strict";
var __esbuild_esm_mermaid_nm;
(__esbuild_esm_mermaid_nm ||= {}).mermaid = (() => {
  var Klt = Object.create;
  var Um = Object.defineProperty;
  var Qlt = Object.getOwnPropertyDescriptor;
  var Zlt = Object.getOwnPropertyNames;
  var Jlt = Object.getPrototypeOf,
    tct = Object.prototype.hasOwnProperty;
  var a = (e, t) => Um(e, "name", { value: t, configurable: !0 });
  var x = (e, t) => () => (e && (t = e((e = 0))), t);
  var to = (e, t) => () => (
      t || e((t = { exports: {} }).exports, t),
      t.exports
    ),
    Oe = (e, t) => {
      for (var r in t) Um(e, r, { get: t[r], enumerable: !0 });
    },
    ix = (e, t, r, n) => {
      if ((t && typeof t == "object") || typeof t == "function")
        for (let i of Zlt(t))
          !tct.call(e, i) &&
            i !== r &&
            Um(e, i, {
              get: () => t[i],
              enumerable: !(n = Qlt(t, i)) || n.enumerable,
            });
      return e;
    },
    qe = (e, t, r) => (ix(e, t, "default"), r && ix(r, t, "default")),
    Ts = (e, t, r) => (
      (r = e != null ? Klt(Jlt(e)) : {}),
      ix(
        t || !e || !e.__esModule
          ? Um(r, "default", { value: e, enumerable: !0 })
          : r,
        e,
      )
    ),
    ect = (e) => ix(Um({}, "__esModule", { value: !0 }), e);
  var rct,
    af,
    DC,
    j8,
    sx = x(() => {
      "use strict";
      ((rct = Object.freeze({ left: 0, top: 0, width: 16, height: 16 })),
        (af = Object.freeze({ rotate: 0, vFlip: !1, hFlip: !1 })),
        (DC = Object.freeze({ ...rct, ...af })),
        (j8 = Object.freeze({ ...DC, body: "", hidden: !1 })));
    });
  var nct,
    q8,
    H8 = x(() => {
      "use strict";
      sx();
      ((nct = Object.freeze({ width: null, height: null })),
        (q8 = Object.freeze({ ...nct, ...af })));
    });
  var NC,
    ax,
    Y8 = x(() => {
      "use strict";
      ((NC = a((e, t, r, n = "") => {
        let i = e.split(":");
        if (e.slice(0, 1) === "@") {
          if (i.length < 2 || i.length > 3) return null;
          n = i.shift().slice(1);
        }
        if (i.length > 3 || !i.length) return null;
        if (i.length > 1) {
          let l = i.pop(),
            u = i.pop(),
            h = { provider: i.length > 0 ? i[0] : n, prefix: u, name: l };
          return t && !ax(h) ? null : h;
        }
        let s = i[0],
          o = s.split("-");
        if (o.length > 1) {
          let l = { provider: n, prefix: o.shift(), name: o.join("-") };
          return t && !ax(l) ? null : l;
        }
        if (r && n === "") {
          let l = { provider: n, prefix: "", name: s };
          return t && !ax(l, r) ? null : l;
        }
        return null;
      }, "stringToIcon")),
        (ax = a(
          (e, t) =>
            e ? !!(((t && e.prefix === "") || e.prefix) && e.name) : !1,
          "validateIconName",
        )));
    });
  function X8(e, t) {
    let r = {};
    (!e.hFlip != !t.hFlip && (r.hFlip = !0),
      !e.vFlip != !t.vFlip && (r.vFlip = !0));
    let n = ((e.rotate || 0) + (t.rotate || 0)) % 4;
    return (n && (r.rotate = n), r);
  }
  var K8 = x(() => {
    "use strict";
    a(X8, "mergeIconTransformations");
  });
  function IC(e, t) {
    let r = X8(e, t);
    for (let n in j8)
      n in af
        ? n in e && !(n in r) && (r[n] = af[n])
        : n in t
          ? (r[n] = t[n])
          : n in e && (r[n] = e[n]);
    return r;
  }
  var Q8 = x(() => {
    "use strict";
    sx();
    K8();
    a(IC, "mergeIconData");
  });
  function Z8(e, t) {
    let r = e.icons,
      n = e.aliases || Object.create(null),
      i = Object.create(null);
    function s(o) {
      if (r[o]) return (i[o] = []);
      if (!(o in i)) {
        i[o] = null;
        let l = n[o] && n[o].parent,
          u = l && s(l);
        u && (i[o] = [l].concat(u));
      }
      return i[o];
    }
    return (
      a(s, "resolve"),
      (t || Object.keys(r).concat(Object.keys(n))).forEach(s),
      i
    );
  }
  var J8 = x(() => {
    "use strict";
    a(Z8, "getIconsTree");
  });
  function tI(e, t, r) {
    let n = e.icons,
      i = e.aliases || Object.create(null),
      s = {};
    function o(l) {
      s = IC(n[l] || i[l], s);
    }
    return (a(o, "parse"), o(t), r.forEach(o), IC(e, s));
  }
  function MC(e, t) {
    if (e.icons[t]) return tI(e, t, []);
    let r = Z8(e, [t])[t];
    return r ? tI(e, t, r) : null;
  }
  var eI = x(() => {
    "use strict";
    Q8();
    J8();
    a(tI, "internalGetIconData");
    a(MC, "getIconData");
  });
  function OC(e, t, r) {
    if (t === 1) return e;
    if (((r = r || 100), typeof e == "number")) return Math.ceil(e * t * r) / r;
    if (typeof e != "string") return e;
    let n = e.split(ict);
    if (n === null || !n.length) return e;
    let i = [],
      s = n.shift(),
      o = sct.test(s);
    for (;;) {
      if (o) {
        let l = parseFloat(s);
        isNaN(l) ? i.push(s) : i.push(Math.ceil(l * t * r) / r);
      } else i.push(s);
      if (((s = n.shift()), s === void 0)) return i.join("");
      o = !o;
    }
  }
  var ict,
    sct,
    rI = x(() => {
      "use strict";
      ((ict = /(-?[0-9.]*[0-9]+[0-9.]*)/g),
        (sct = /^-?[0-9.]*[0-9]+[0-9.]*$/g));
      a(OC, "calculateSize");
    });
  function act(e, t = "defs") {
    let r = "",
      n = e.indexOf("<" + t);
    for (; n >= 0; ) {
      let i = e.indexOf(">", n),
        s = e.indexOf("</" + t);
      if (i === -1 || s === -1) break;
      let o = e.indexOf(">", s);
      if (o === -1) break;
      ((r += e.slice(i + 1, s).trim()),
        (e = e.slice(0, n).trim() + e.slice(o + 1)));
    }
    return { defs: r, content: e };
  }
  function oct(e, t) {
    return e ? "<defs>" + e + "</defs>" + t : t;
  }
  function nI(e, t, r) {
    let n = act(e);
    return oct(n.defs, t + n.content + r);
  }
  var iI = x(() => {
    "use strict";
    a(act, "splitSVGDefs");
    a(oct, "mergeDefsAndContent");
    a(nI, "wrapSVGContent");
  });
  function PC(e, t) {
    let r = { ...DC, ...e },
      n = { ...q8, ...t },
      i = { left: r.left, top: r.top, width: r.width, height: r.height },
      s = r.body;
    [r, n].forEach((y) => {
      let b = [],
        k = y.hFlip,
        T = y.vFlip,
        C = y.rotate;
      k
        ? T
          ? (C += 2)
          : (b.push(
              "translate(" +
                (i.width + i.left).toString() +
                " " +
                (0 - i.top).toString() +
                ")",
            ),
            b.push("scale(-1 1)"),
            (i.top = i.left = 0))
        : T &&
          (b.push(
            "translate(" +
              (0 - i.left).toString() +
              " " +
              (i.height + i.top).toString() +
              ")",
          ),
          b.push("scale(1 -1)"),
          (i.top = i.left = 0));
      let L;
      switch ((C < 0 && (C -= Math.floor(C / 4) * 4), (C = C % 4), C)) {
        case 1:
          ((L = i.height / 2 + i.top),
            b.unshift("rotate(90 " + L.toString() + " " + L.toString() + ")"));
          break;
        case 2:
          b.unshift(
            "rotate(180 " +
              (i.width / 2 + i.left).toString() +
              " " +
              (i.height / 2 + i.top).toString() +
              ")",
          );
          break;
        case 3:
          ((L = i.width / 2 + i.left),
            b.unshift("rotate(-90 " + L.toString() + " " + L.toString() + ")"));
          break;
      }
      (C % 2 === 1 &&
        (i.left !== i.top && ((L = i.left), (i.left = i.top), (i.top = L)),
        i.width !== i.height &&
          ((L = i.width), (i.width = i.height), (i.height = L))),
        b.length && (s = nI(s, '<g transform="' + b.join(" ") + '">', "</g>")));
    });
    let o = n.width,
      l = n.height,
      u = i.width,
      h = i.height,
      f,
      d;
    o === null
      ? ((d = l === null ? "1em" : l === "auto" ? h : l), (f = OC(d, u / h)))
      : ((f = o === "auto" ? u : o),
        (d = l === null ? OC(f, h / u) : l === "auto" ? h : l));
    let p = {},
      m = a((y, b) => {
        lct(b) || (p[y] = b.toString());
      }, "setAttr");
    (m("width", f), m("height", d));
    let g = [i.left, i.top, u, h];
    return ((p.viewBox = g.join(" ")), { attributes: p, viewBox: g, body: s });
  }
  var lct,
    sI = x(() => {
      "use strict";
      sx();
      H8();
      rI();
      iI();
      lct = a(
        (e) => e === "unset" || e === "undefined" || e === "none",
        "isUnsetKeyword",
      );
      a(PC, "iconToSVG");
    });
  function BC(e, t = uct) {
    let r = [],
      n;
    for (; (n = cct.exec(e)); ) r.push(n[1]);
    if (!r.length) return e;
    let i = "suffix" + ((Math.random() * 16777216) | Date.now()).toString(16);
    return (
      r.forEach((s) => {
        let o = typeof t == "function" ? t(s) : t + (hct++).toString(),
          l = s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
        e = e.replace(
          new RegExp('([#;"])(' + l + ')([")]|\\.[a-z])', "g"),
          "$1" + o + i + "$3",
        );
      }),
      (e = e.replace(new RegExp(i, "g"), "")),
      e
    );
  }
  var cct,
    uct,
    hct,
    aI = x(() => {
      "use strict";
      ((cct = /\sid="(\S+)"/g),
        (uct =
          "IconifyId" +
          Date.now().toString(16) +
          ((Math.random() * 16777216) | 0).toString(16)),
        (hct = 0));
      a(BC, "replaceIDs");
    });
  function FC(e, t) {
    let r =
      e.indexOf("xlink:") === -1
        ? ""
        : ' xmlns:xlink="http://www.w3.org/1999/xlink"';
    for (let n in t) r += " " + n + '="' + t[n] + '"';
    return '<svg xmlns="http://www.w3.org/2000/svg"' + r + ">" + e + "</svg>";
  }
  var oI = x(() => {
    "use strict";
    a(FC, "iconToHTML");
  });
  var lI = x(() => {
    "use strict";
    Y8();
    eI();
    sI();
    aI();
    oI();
  });
  var $C,
    Xr,
    of = x(() => {
      "use strict";
      (($C = a((e, t, { depth: r = 2, clobber: n = !1 } = {}) => {
        let i = { depth: r, clobber: n };
        return Array.isArray(t) && !Array.isArray(e)
          ? (t.forEach((s) => $C(e, s, i)), e)
          : Array.isArray(t) && Array.isArray(e)
            ? (t.forEach((s) => {
                e.includes(s) || e.push(s);
              }),
              e)
            : e === void 0 || r <= 0
              ? e != null && typeof e == "object" && typeof t == "object"
                ? Object.assign(e, t)
                : t
              : (t !== void 0 &&
                  typeof e == "object" &&
                  typeof t == "object" &&
                  Object.keys(t).forEach((s) => {
                    typeof t[s] == "object" &&
                    (e[s] === void 0 || typeof e[s] == "object")
                      ? (e[s] === void 0 &&
                          (e[s] = Array.isArray(t[s]) ? [] : {}),
                        (e[s] = $C(e[s], t[s], { depth: r - 1, clobber: n })))
                      : (n ||
                          (typeof e[s] != "object" &&
                            typeof t[s] != "object")) &&
                        (e[s] = t[s]);
                  }),
                e);
      }, "assignWithDepth")),
        (Xr = $C));
    });
  var ox = to((GC, VC) => {
    "use strict";
    (function (e, t) {
      typeof GC == "object" && typeof VC < "u"
        ? (VC.exports = t())
        : typeof define == "function" && define.amd
          ? define(t)
          : ((e = typeof globalThis < "u" ? globalThis : e || self).dayjs =
              t());
    })(GC, function () {
      "use strict";
      var e = 1e3,
        t = 6e4,
        r = 36e5,
        n = "millisecond",
        i = "second",
        s = "minute",
        o = "hour",
        l = "day",
        u = "week",
        h = "month",
        f = "quarter",
        d = "year",
        p = "date",
        m = "Invalid Date",
        g =
          /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/,
        y =
          /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g,
        b = {
          name: "en",
          weekdays:
            "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split(
              "_",
            ),
          months:
            "January_February_March_April_May_June_July_August_September_October_November_December".split(
              "_",
            ),
          ordinal: a(function (O) {
            var v = ["th", "st", "nd", "rd"],
              _ = O % 100;
            return "[" + O + (v[(_ - 20) % 10] || v[_] || v[0]) + "]";
          }, "ordinal"),
        },
        k = a(function (O, v, _) {
          var A = String(O);
          return !A || A.length >= v
            ? O
            : "" + Array(v + 1 - A.length).join(_) + O;
        }, "m"),
        T = {
          s: k,
          z: a(function (O) {
            var v = -O.utcOffset(),
              _ = Math.abs(v),
              A = Math.floor(_ / 60),
              N = _ % 60;
            return (v <= 0 ? "+" : "-") + k(A, 2, "0") + ":" + k(N, 2, "0");
          }, "z"),
          m: a(function O(v, _) {
            if (v.date() < _.date()) return -O(_, v);
            var A = 12 * (_.year() - v.year()) + (_.month() - v.month()),
              N = v.clone().add(A, h),
              B = _ - N < 0,
              M = v.clone().add(A + (B ? -1 : 1), h);
            return +(-(A + (_ - N) / (B ? N - M : M - N)) || 0);
          }, "t"),
          a: a(function (O) {
            return O < 0 ? Math.ceil(O) || 0 : Math.floor(O);
          }, "a"),
          p: a(function (O) {
            return (
              { M: h, y: d, w: u, d: l, D: p, h: o, m: s, s: i, ms: n, Q: f }[
                O
              ] ||
              String(O || "")
                .toLowerCase()
                .replace(/s$/, "")
            );
          }, "p"),
          u: a(function (O) {
            return O === void 0;
          }, "u"),
        },
        C = "en",
        L = {};
      L[C] = b;
      var w = "$isDayjsObject",
        D = a(function (O) {
          return O instanceof F || !(!O || !O[w]);
        }, "S"),
        G = a(function O(v, _, A) {
          var N;
          if (!v) return C;
          if (typeof v == "string") {
            var B = v.toLowerCase();
            (L[B] && (N = B), _ && ((L[B] = _), (N = B)));
            var M = v.split("-");
            if (!N && M.length > 1) return O(M[0]);
          } else {
            var I = v.name;
            ((L[I] = v), (N = I));
          }
          return (!A && N && (C = N), N || (!A && C));
        }, "t"),
        E = a(function (O, v) {
          if (D(O)) return O.clone();
          var _ = typeof v == "object" ? v : {};
          return ((_.date = O), (_.args = arguments), new F(_));
        }, "O"),
        R = T;
      ((R.l = G),
        (R.i = D),
        (R.w = function (O, v) {
          return E(O, { locale: v.$L, utc: v.$u, x: v.$x, $offset: v.$offset });
        }));
      var F = (function () {
          function O(_) {
            ((this.$L = G(_.locale, null, !0)),
              this.parse(_),
              (this.$x = this.$x || _.x || {}),
              (this[w] = !0));
          }
          a(O, "M");
          var v = O.prototype;
          return (
            (v.parse = function (_) {
              ((this.$d = (function (A) {
                var N = A.date,
                  B = A.utc;
                if (N === null) return new Date(NaN);
                if (R.u(N)) return new Date();
                if (N instanceof Date) return new Date(N);
                if (typeof N == "string" && !/Z$/i.test(N)) {
                  var M = N.match(g);
                  if (M) {
                    var I = M[2] - 1 || 0,
                      V = (M[7] || "0").substring(0, 3);
                    return B
                      ? new Date(
                          Date.UTC(
                            M[1],
                            I,
                            M[3] || 1,
                            M[4] || 0,
                            M[5] || 0,
                            M[6] || 0,
                            V,
                          ),
                        )
                      : new Date(
                          M[1],
                          I,
                          M[3] || 1,
                          M[4] || 0,
                          M[5] || 0,
                          M[6] || 0,
                          V,
                        );
                  }
                }
                return new Date(N);
              })(_)),
                this.init());
            }),
            (v.init = function () {
              var _ = this.$d;
              ((this.$y = _.getFullYear()),
                (this.$M = _.getMonth()),
                (this.$D = _.getDate()),
                (this.$W = _.getDay()),
                (this.$H = _.getHours()),
                (this.$m = _.getMinutes()),
                (this.$s = _.getSeconds()),
                (this.$ms = _.getMilliseconds()));
            }),
            (v.$utils = function () {
              return R;
            }),
            (v.isValid = function () {
              return this.$d.toString() !== m;
            }),
            (v.isSame = function (_, A) {
              var N = E(_);
              return this.startOf(A) <= N && N <= this.endOf(A);
            }),
            (v.isAfter = function (_, A) {
              return E(_) < this.startOf(A);
            }),
            (v.isBefore = function (_, A) {
              return this.endOf(A) < E(_);
            }),
            (v.$g = function (_, A, N) {
              return R.u(_) ? this[A] : this.set(N, _);
            }),
            (v.unix = function () {
              return Math.floor(this.valueOf() / 1e3);
            }),
            (v.valueOf = function () {
              return this.$d.getTime();
            }),
            (v.startOf = function (_, A) {
              var N = this,
                B = !!R.u(A) || A,
                M = R.p(_),
                I = a(function (ft, yt) {
                  var ot = R.w(
                    N.$u ? Date.UTC(N.$y, yt, ft) : new Date(N.$y, yt, ft),
                    N,
                  );
                  return B ? ot : ot.endOf(l);
                }, "l"),
                V = a(function (ft, yt) {
                  return R.w(
                    N.toDate()[ft].apply(
                      N.toDate("s"),
                      (B ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(yt),
                    ),
                    N,
                  );
                }, "$"),
                $ = this.$W,
                q = this.$M,
                tt = this.$D,
                ht = "set" + (this.$u ? "UTC" : "");
              switch (M) {
                case d:
                  return B ? I(1, 0) : I(31, 11);
                case h:
                  return B ? I(1, q) : I(0, q + 1);
                case u:
                  var H = this.$locale().weekStart || 0,
                    kt = ($ < H ? $ + 7 : $) - H;
                  return I(B ? tt - kt : tt + (6 - kt), q);
                case l:
                case p:
                  return V(ht + "Hours", 0);
                case o:
                  return V(ht + "Minutes", 1);
                case s:
                  return V(ht + "Seconds", 2);
                case i:
                  return V(ht + "Milliseconds", 3);
                default:
                  return this.clone();
              }
            }),
            (v.endOf = function (_) {
              return this.startOf(_, !1);
            }),
            (v.$set = function (_, A) {
              var N,
                B = R.p(_),
                M = "set" + (this.$u ? "UTC" : ""),
                I = ((N = {}),
                (N[l] = M + "Date"),
                (N[p] = M + "Date"),
                (N[h] = M + "Month"),
                (N[d] = M + "FullYear"),
                (N[o] = M + "Hours"),
                (N[s] = M + "Minutes"),
                (N[i] = M + "Seconds"),
                (N[n] = M + "Milliseconds"),
                N)[B],
                V = B === l ? this.$D + (A - this.$W) : A;
              if (B === h || B === d) {
                var $ = this.clone().set(p, 1);
                ($.$d[I](V),
                  $.init(),
                  (this.$d = $.set(p, Math.min(this.$D, $.daysInMonth())).$d));
              } else I && this.$d[I](V);
              return (this.init(), this);
            }),
            (v.set = function (_, A) {
              return this.clone().$set(_, A);
            }),
            (v.get = function (_) {
              return this[R.p(_)]();
            }),
            (v.add = function (_, A) {
              var N,
                B = this;
              _ = Number(_);
              var M = R.p(A),
                I = a(function (q) {
                  var tt = E(B);
                  return R.w(tt.date(tt.date() + Math.round(q * _)), B);
                }, "y");
              if (M === h) return this.set(h, this.$M + _);
              if (M === d) return this.set(d, this.$y + _);
              if (M === l) return I(1);
              if (M === u) return I(7);
              var V = ((N = {}), (N[s] = t), (N[o] = r), (N[i] = e), N)[M] || 1,
                $ = this.$d.getTime() + _ * V;
              return R.w($, this);
            }),
            (v.subtract = function (_, A) {
              return this.add(-1 * _, A);
            }),
            (v.format = function (_) {
              var A = this,
                N = this.$locale();
              if (!this.isValid()) return N.invalidDate || m;
              var B = _ || "YYYY-MM-DDTHH:mm:ssZ",
                M = R.z(this),
                I = this.$H,
                V = this.$m,
                $ = this.$M,
                q = N.weekdays,
                tt = N.months,
                ht = N.meridiem,
                H = a(function (yt, ot, dt, nt) {
                  return (yt && (yt[ot] || yt(A, B))) || dt[ot].slice(0, nt);
                }, "h"),
                kt = a(function (yt) {
                  return R.s(I % 12 || 12, yt, "0");
                }, "d"),
                ft =
                  ht ||
                  function (yt, ot, dt) {
                    var nt = yt < 12 ? "AM" : "PM";
                    return dt ? nt.toLowerCase() : nt;
                  };
              return B.replace(y, function (yt, ot) {
                return (
                  ot ||
                  (function (dt) {
                    switch (dt) {
                      case "YY":
                        return String(A.$y).slice(-2);
                      case "YYYY":
                        return R.s(A.$y, 4, "0");
                      case "M":
                        return $ + 1;
                      case "MM":
                        return R.s($ + 1, 2, "0");
                      case "MMM":
                        return H(N.monthsShort, $, tt, 3);
                      case "MMMM":
                        return H(tt, $);
                      case "D":
                        return A.$D;
                      case "DD":
                        return R.s(A.$D, 2, "0");
                      case "d":
                        return String(A.$W);
                      case "dd":
                        return H(N.weekdaysMin, A.$W, q, 2);
                      case "ddd":
                        return H(N.weekdaysShort, A.$W, q, 3);
                      case "dddd":
                        return q[A.$W];
                      case "H":
                        return String(I);
                      case "HH":
                        return R.s(I, 2, "0");
                      case "h":
                        return kt(1);
                      case "hh":
                        return kt(2);
                      case "a":
                        return ft(I, V, !0);
                      case "A":
                        return ft(I, V, !1);
                      case "m":
                        return String(V);
                      case "mm":
                        return R.s(V, 2, "0");
                      case "s":
                        return String(A.$s);
                      case "ss":
                        return R.s(A.$s, 2, "0");
                      case "SSS":
                        return R.s(A.$ms, 3, "0");
                      case "Z":
                        return M;
                    }
                    return null;
                  })(yt) ||
                  M.replace(":", "")
                );
              });
            }),
            (v.utcOffset = function () {
              return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
            }),
            (v.diff = function (_, A, N) {
              var B,
                M = this,
                I = R.p(A),
                V = E(_),
                $ = (V.utcOffset() - this.utcOffset()) * t,
                q = this - V,
                tt = a(function () {
                  return R.m(M, V);
                }, "D");
              switch (I) {
                case d:
                  B = tt() / 12;
                  break;
                case h:
                  B = tt();
                  break;
                case f:
                  B = tt() / 3;
                  break;
                case u:
                  B = (q - $) / 6048e5;
                  break;
                case l:
                  B = (q - $) / 864e5;
                  break;
                case o:
                  B = q / r;
                  break;
                case s:
                  B = q / t;
                  break;
                case i:
                  B = q / e;
                  break;
                default:
                  B = q;
              }
              return N ? B : R.a(B);
            }),
            (v.daysInMonth = function () {
              return this.endOf(h).$D;
            }),
            (v.$locale = function () {
              return L[this.$L];
            }),
            (v.locale = function (_, A) {
              if (!_) return this.$L;
              var N = this.clone(),
                B = G(_, A, !0);
              return (B && (N.$L = B), N);
            }),
            (v.clone = function () {
              return R.w(this.$d, this);
            }),
            (v.toDate = function () {
              return new Date(this.valueOf());
            }),
            (v.toJSON = function () {
              return this.isValid() ? this.toISOString() : null;
            }),
            (v.toISOString = function () {
              return this.$d.toISOString();
            }),
            (v.toString = function () {
              return this.$d.toUTCString();
            }),
            O
          );
        })(),
        S = F.prototype;
      return (
        (E.prototype = S),
        [
          ["$ms", n],
          ["$s", i],
          ["$m", s],
          ["$H", o],
          ["$W", l],
          ["$M", h],
          ["$y", d],
          ["$D", p],
        ].forEach(function (O) {
          S[O[1]] = function (v) {
            return this.$g(v, O[0], O[1]);
          };
        }),
        (E.extend = function (O, v) {
          return (O.$i || (O(v, F, E), (O.$i = !0)), E);
        }),
        (E.locale = G),
        (E.isDayjs = D),
        (E.unix = function (O) {
          return E(1e3 * O);
        }),
        (E.en = L[C]),
        (E.Ls = L),
        (E.p = {}),
        E
      );
    });
  });
  var cI,
    Qo,
    P,
    jm,
    Ws,
    Vt = x(() => {
      "use strict";
      ((cI = Ts(ox(), 1)),
        (Qo = { trace: 0, debug: 1, info: 2, warn: 3, error: 4, fatal: 5 }),
        (P = {
          trace: a((...e) => {}, "trace"),
          debug: a((...e) => {}, "debug"),
          info: a((...e) => {}, "info"),
          warn: a((...e) => {}, "warn"),
          error: a((...e) => {}, "error"),
          fatal: a((...e) => {}, "fatal"),
        }),
        (jm = a(function (e = "fatal") {
          let t = Qo.fatal;
          (typeof e == "string"
            ? e.toLowerCase() in Qo && (t = Qo[e])
            : typeof e == "number" && (t = e),
            (P.trace = () => {}),
            (P.debug = () => {}),
            (P.info = () => {}),
            (P.warn = () => {}),
            (P.error = () => {}),
            (P.fatal = () => {}),
            t <= Qo.fatal &&
              (P.fatal = console.error
                ? console.error.bind(console, Ws("FATAL"), "color: orange")
                : console.log.bind(console, "\x1B[35m", Ws("FATAL"))),
            t <= Qo.error &&
              (P.error = console.error
                ? console.error.bind(console, Ws("ERROR"), "color: orange")
                : console.log.bind(console, "\x1B[31m", Ws("ERROR"))),
            t <= Qo.warn &&
              (P.warn = console.warn
                ? console.warn.bind(console, Ws("WARN"), "color: orange")
                : console.log.bind(console, "\x1B[33m", Ws("WARN"))),
            t <= Qo.info &&
              (P.info = console.info
                ? console.info.bind(console, Ws("INFO"), "color: lightblue")
                : console.log.bind(console, "\x1B[34m", Ws("INFO"))),
            t <= Qo.debug &&
              (P.debug = console.debug
                ? console.debug.bind(console, Ws("DEBUG"), "color: lightgreen")
                : console.log.bind(console, "\x1B[32m", Ws("DEBUG"))),
            t <= Qo.trace &&
              (P.trace = console.debug
                ? console.debug.bind(console, Ws("TRACE"), "color: lightgreen")
                : console.log.bind(console, "\x1B[32m", Ws("TRACE"))));
        }, "setLogLevel")),
        (Ws = a(
          (e) => `%c${(0, cI.default)().format("ss.SSS")} : ${e} : `,
          "format",
        )));
    });
  var lx,
    uI,
    hI = x(() => {
      "use strict";
      ((lx = {
        min: { r: 0, g: 0, b: 0, s: 0, l: 0, a: 0 },
        max: { r: 255, g: 255, b: 255, h: 360, s: 100, l: 100, a: 1 },
        clamp: {
          r: a((e) => (e >= 255 ? 255 : e < 0 ? 0 : e), "r"),
          g: a((e) => (e >= 255 ? 255 : e < 0 ? 0 : e), "g"),
          b: a((e) => (e >= 255 ? 255 : e < 0 ? 0 : e), "b"),
          h: a((e) => e % 360, "h"),
          s: a((e) => (e >= 100 ? 100 : e < 0 ? 0 : e), "s"),
          l: a((e) => (e >= 100 ? 100 : e < 0 ? 0 : e), "l"),
          a: a((e) => (e >= 1 ? 1 : e < 0 ? 0 : e), "a"),
        },
        toLinear: a((e) => {
          let t = e / 255;
          return e > 0.03928 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92;
        }, "toLinear"),
        hue2rgb: a(
          (e, t, r) => (
            r < 0 && (r += 1),
            r > 1 && (r -= 1),
            r < 0.16666666666666666
              ? e + (t - e) * 6 * r
              : r < 0.5
                ? t
                : r < 0.6666666666666666
                  ? e + (t - e) * (0.6666666666666666 - r) * 6
                  : e
          ),
          "hue2rgb",
        ),
        hsl2rgb: a(({ h: e, s: t, l: r }, n) => {
          if (!t) return r * 2.55;
          ((e /= 360), (t /= 100), (r /= 100));
          let i = r < 0.5 ? r * (1 + t) : r + t - r * t,
            s = 2 * r - i;
          switch (n) {
            case "r":
              return lx.hue2rgb(s, i, e + 0.3333333333333333) * 255;
            case "g":
              return lx.hue2rgb(s, i, e) * 255;
            case "b":
              return lx.hue2rgb(s, i, e - 0.3333333333333333) * 255;
          }
        }, "hsl2rgb"),
        rgb2hsl: a(({ r: e, g: t, b: r }, n) => {
          ((e /= 255), (t /= 255), (r /= 255));
          let i = Math.max(e, t, r),
            s = Math.min(e, t, r),
            o = (i + s) / 2;
          if (n === "l") return o * 100;
          if (i === s) return 0;
          let l = i - s,
            u = o > 0.5 ? l / (2 - i - s) : l / (i + s);
          if (n === "s") return u * 100;
          switch (i) {
            case e:
              return ((t - r) / l + (t < r ? 6 : 0)) * 60;
            case t:
              return ((r - e) / l + 2) * 60;
            case r:
              return ((e - t) / l + 4) * 60;
            default:
              return -1;
          }
        }, "rgb2hsl"),
      }),
        (uI = lx));
    });
  var fct,
    fI,
    dI = x(() => {
      "use strict";
      ((fct = {
        clamp: a(
          (e, t, r) =>
            t > r ? Math.min(t, Math.max(r, e)) : Math.min(r, Math.max(t, e)),
          "clamp",
        ),
        round: a((e) => Math.round(e * 1e10) / 1e10, "round"),
      }),
        (fI = fct));
    });
  var dct,
    pI,
    mI = x(() => {
      "use strict";
      ((dct = {
        dec2hex: a((e) => {
          let t = Math.round(e).toString(16);
          return t.length > 1 ? t : `0${t}`;
        }, "dec2hex"),
      }),
        (pI = dct));
    });
  var pct,
    de,
    eo = x(() => {
      "use strict";
      hI();
      dI();
      mI();
      ((pct = { channel: uI, lang: fI, unit: pI }), (de = pct));
    });
  var Zo,
    In,
    qm = x(() => {
      "use strict";
      eo();
      Zo = {};
      for (let e = 0; e <= 255; e++) Zo[e] = de.unit.dec2hex(e);
      In = { ALL: 0, RGB: 1, HSL: 2 };
    });
  var zC,
    gI,
    yI = x(() => {
      "use strict";
      qm();
      ((zC = class {
        static {
          a(this, "Type");
        }
        constructor() {
          this.type = In.ALL;
        }
        get() {
          return this.type;
        }
        set(t) {
          if (this.type && this.type !== t)
            throw new Error(
              "Cannot change both RGB and HSL channels at the same time",
            );
          this.type = t;
        }
        reset() {
          this.type = In.ALL;
        }
        is(t) {
          return this.type === t;
        }
      }),
        (gI = zC));
    });
  var WC,
    xI,
    bI = x(() => {
      "use strict";
      eo();
      yI();
      qm();
      ((WC = class {
        static {
          a(this, "Channels");
        }
        constructor(t, r) {
          ((this.color = r),
            (this.changed = !1),
            (this.data = t),
            (this.type = new gI()));
        }
        set(t, r) {
          return (
            (this.color = r),
            (this.changed = !1),
            (this.data = t),
            (this.type.type = In.ALL),
            this
          );
        }
        _ensureHSL() {
          let t = this.data,
            { h: r, s: n, l: i } = t;
          (r === void 0 && (t.h = de.channel.rgb2hsl(t, "h")),
            n === void 0 && (t.s = de.channel.rgb2hsl(t, "s")),
            i === void 0 && (t.l = de.channel.rgb2hsl(t, "l")));
        }
        _ensureRGB() {
          let t = this.data,
            { r, g: n, b: i } = t;
          (r === void 0 && (t.r = de.channel.hsl2rgb(t, "r")),
            n === void 0 && (t.g = de.channel.hsl2rgb(t, "g")),
            i === void 0 && (t.b = de.channel.hsl2rgb(t, "b")));
        }
        get r() {
          let t = this.data,
            r = t.r;
          return !this.type.is(In.HSL) && r !== void 0
            ? r
            : (this._ensureHSL(), de.channel.hsl2rgb(t, "r"));
        }
        get g() {
          let t = this.data,
            r = t.g;
          return !this.type.is(In.HSL) && r !== void 0
            ? r
            : (this._ensureHSL(), de.channel.hsl2rgb(t, "g"));
        }
        get b() {
          let t = this.data,
            r = t.b;
          return !this.type.is(In.HSL) && r !== void 0
            ? r
            : (this._ensureHSL(), de.channel.hsl2rgb(t, "b"));
        }
        get h() {
          let t = this.data,
            r = t.h;
          return !this.type.is(In.RGB) && r !== void 0
            ? r
            : (this._ensureRGB(), de.channel.rgb2hsl(t, "h"));
        }
        get s() {
          let t = this.data,
            r = t.s;
          return !this.type.is(In.RGB) && r !== void 0
            ? r
            : (this._ensureRGB(), de.channel.rgb2hsl(t, "s"));
        }
        get l() {
          let t = this.data,
            r = t.l;
          return !this.type.is(In.RGB) && r !== void 0
            ? r
            : (this._ensureRGB(), de.channel.rgb2hsl(t, "l"));
        }
        get a() {
          return this.data.a;
        }
        set r(t) {
          (this.type.set(In.RGB), (this.changed = !0), (this.data.r = t));
        }
        set g(t) {
          (this.type.set(In.RGB), (this.changed = !0), (this.data.g = t));
        }
        set b(t) {
          (this.type.set(In.RGB), (this.changed = !0), (this.data.b = t));
        }
        set h(t) {
          (this.type.set(In.HSL), (this.changed = !0), (this.data.h = t));
        }
        set s(t) {
          (this.type.set(In.HSL), (this.changed = !0), (this.data.s = t));
        }
        set l(t) {
          (this.type.set(In.HSL), (this.changed = !0), (this.data.l = t));
        }
        set a(t) {
          ((this.changed = !0), (this.data.a = t));
        }
      }),
        (xI = WC));
    });
  var mct,
    Ul,
    Hm = x(() => {
      "use strict";
      bI();
      ((mct = new xI({ r: 0, g: 0, b: 0, a: 0 }, "transparent")), (Ul = mct));
    });
  var kI,
    mu,
    UC = x(() => {
      "use strict";
      Hm();
      qm();
      ((kI = {
        re: /^#((?:[a-f0-9]{2}){2,4}|[a-f0-9]{3})$/i,
        parse: a((e) => {
          if (e.charCodeAt(0) !== 35) return;
          let t = e.match(kI.re);
          if (!t) return;
          let r = t[1],
            n = parseInt(r, 16),
            i = r.length,
            s = i % 4 === 0,
            o = i > 4,
            l = o ? 1 : 17,
            u = o ? 8 : 4,
            h = s ? 0 : -1,
            f = o ? 255 : 15;
          return Ul.set(
            {
              r: ((n >> (u * (h + 3))) & f) * l,
              g: ((n >> (u * (h + 2))) & f) * l,
              b: ((n >> (u * (h + 1))) & f) * l,
              a: s ? ((n & f) * l) / 255 : 1,
            },
            e,
          );
        }, "parse"),
        stringify: a((e) => {
          let { r: t, g: r, b: n, a: i } = e;
          return i < 1
            ? `#${Zo[Math.round(t)]}${Zo[Math.round(r)]}${Zo[Math.round(n)]}${Zo[Math.round(i * 255)]}`
            : `#${Zo[Math.round(t)]}${Zo[Math.round(r)]}${Zo[Math.round(n)]}`;
        }, "stringify"),
      }),
        (mu = kI));
    });
  var cx,
    Ym,
    TI = x(() => {
      "use strict";
      eo();
      Hm();
      ((cx = {
        re: /^hsla?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(?:deg|grad|rad|turn)?)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?%)(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e-?\d+)?(%)?))?\s*?\)$/i,
        hueRe: /^(.+?)(deg|grad|rad|turn)$/i,
        _hue2deg: a((e) => {
          let t = e.match(cx.hueRe);
          if (t) {
            let [, r, n] = t;
            switch (n) {
              case "grad":
                return de.channel.clamp.h(parseFloat(r) * 0.9);
              case "rad":
                return de.channel.clamp.h((parseFloat(r) * 180) / Math.PI);
              case "turn":
                return de.channel.clamp.h(parseFloat(r) * 360);
            }
          }
          return de.channel.clamp.h(parseFloat(e));
        }, "_hue2deg"),
        parse: a((e) => {
          let t = e.charCodeAt(0);
          if (t !== 104 && t !== 72) return;
          let r = e.match(cx.re);
          if (!r) return;
          let [, n, i, s, o, l] = r;
          return Ul.set(
            {
              h: cx._hue2deg(n),
              s: de.channel.clamp.s(parseFloat(i)),
              l: de.channel.clamp.l(parseFloat(s)),
              a: o
                ? de.channel.clamp.a(l ? parseFloat(o) / 100 : parseFloat(o))
                : 1,
            },
            e,
          );
        }, "parse"),
        stringify: a((e) => {
          let { h: t, s: r, l: n, a: i } = e;
          return i < 1
            ? `hsla(${de.lang.round(t)}, ${de.lang.round(r)}%, ${de.lang.round(n)}%, ${i})`
            : `hsl(${de.lang.round(t)}, ${de.lang.round(r)}%, ${de.lang.round(n)}%)`;
        }, "stringify"),
      }),
        (Ym = cx));
    });
  var ux,
    jC,
    SI = x(() => {
      "use strict";
      UC();
      ((ux = {
        colors: {
          aliceblue: "#f0f8ff",
          antiquewhite: "#faebd7",
          aqua: "#00ffff",
          aquamarine: "#7fffd4",
          azure: "#f0ffff",
          beige: "#f5f5dc",
          bisque: "#ffe4c4",
          black: "#000000",
          blanchedalmond: "#ffebcd",
          blue: "#0000ff",
          blueviolet: "#8a2be2",
          brown: "#a52a2a",
          burlywood: "#deb887",
          cadetblue: "#5f9ea0",
          chartreuse: "#7fff00",
          chocolate: "#d2691e",
          coral: "#ff7f50",
          cornflowerblue: "#6495ed",
          cornsilk: "#fff8dc",
          crimson: "#dc143c",
          cyanaqua: "#00ffff",
          darkblue: "#00008b",
          darkcyan: "#008b8b",
          darkgoldenrod: "#b8860b",
          darkgray: "#a9a9a9",
          darkgreen: "#006400",
          darkgrey: "#a9a9a9",
          darkkhaki: "#bdb76b",
          darkmagenta: "#8b008b",
          darkolivegreen: "#556b2f",
          darkorange: "#ff8c00",
          darkorchid: "#9932cc",
          darkred: "#8b0000",
          darksalmon: "#e9967a",
          darkseagreen: "#8fbc8f",
          darkslateblue: "#483d8b",
          darkslategray: "#2f4f4f",
          darkslategrey: "#2f4f4f",
          darkturquoise: "#00ced1",
          darkviolet: "#9400d3",
          deeppink: "#ff1493",
          deepskyblue: "#00bfff",
          dimgray: "#696969",
          dimgrey: "#696969",
          dodgerblue: "#1e90ff",
          firebrick: "#b22222",
          floralwhite: "#fffaf0",
          forestgreen: "#228b22",
          fuchsia: "#ff00ff",
          gainsboro: "#dcdcdc",
          ghostwhite: "#f8f8ff",
          gold: "#ffd700",
          goldenrod: "#daa520",
          gray: "#808080",
          green: "#008000",
          greenyellow: "#adff2f",
          grey: "#808080",
          honeydew: "#f0fff0",
          hotpink: "#ff69b4",
          indianred: "#cd5c5c",
          indigo: "#4b0082",
          ivory: "#fffff0",
          khaki: "#f0e68c",
          lavender: "#e6e6fa",
          lavenderblush: "#fff0f5",
          lawngreen: "#7cfc00",
          lemonchiffon: "#fffacd",
          lightblue: "#add8e6",
          lightcoral: "#f08080",
          lightcyan: "#e0ffff",
          lightgoldenrodyellow: "#fafad2",
          lightgray: "#d3d3d3",
          lightgreen: "#90ee90",
          lightgrey: "#d3d3d3",
          lightpink: "#ffb6c1",
          lightsalmon: "#ffa07a",
          lightseagreen: "#20b2aa",
          lightskyblue: "#87cefa",
          lightslategray: "#778899",
          lightslategrey: "#778899",
          lightsteelblue: "#b0c4de",
          lightyellow: "#ffffe0",
          lime: "#00ff00",
          limegreen: "#32cd32",
          linen: "#faf0e6",
          magenta: "#ff00ff",
          maroon: "#800000",
          mediumaquamarine: "#66cdaa",
          mediumblue: "#0000cd",
          mediumorchid: "#ba55d3",
          mediumpurple: "#9370db",
          mediumseagreen: "#3cb371",
          mediumslateblue: "#7b68ee",
          mediumspringgreen: "#00fa9a",
          mediumturquoise: "#48d1cc",
          mediumvioletred: "#c71585",
          midnightblue: "#191970",
          mintcream: "#f5fffa",
          mistyrose: "#ffe4e1",
          moccasin: "#ffe4b5",
          navajowhite: "#ffdead",
          navy: "#000080",
          oldlace: "#fdf5e6",
          olive: "#808000",
          olivedrab: "#6b8e23",
          orange: "#ffa500",
          orangered: "#ff4500",
          orchid: "#da70d6",
          palegoldenrod: "#eee8aa",
          palegreen: "#98fb98",
          paleturquoise: "#afeeee",
          palevioletred: "#db7093",
          papayawhip: "#ffefd5",
          peachpuff: "#ffdab9",
          peru: "#cd853f",
          pink: "#ffc0cb",
          plum: "#dda0dd",
          powderblue: "#b0e0e6",
          purple: "#800080",
          rebeccapurple: "#663399",
          red: "#ff0000",
          rosybrown: "#bc8f8f",
          royalblue: "#4169e1",
          saddlebrown: "#8b4513",
          salmon: "#fa8072",
          sandybrown: "#f4a460",
          seagreen: "#2e8b57",
          seashell: "#fff5ee",
          sienna: "#a0522d",
          silver: "#c0c0c0",
          skyblue: "#87ceeb",
          slateblue: "#6a5acd",
          slategray: "#708090",
          slategrey: "#708090",
          snow: "#fffafa",
          springgreen: "#00ff7f",
          tan: "#d2b48c",
          teal: "#008080",
          thistle: "#d8bfd8",
          transparent: "#00000000",
          turquoise: "#40e0d0",
          violet: "#ee82ee",
          wheat: "#f5deb3",
          white: "#ffffff",
          whitesmoke: "#f5f5f5",
          yellow: "#ffff00",
          yellowgreen: "#9acd32",
        },
        parse: a((e) => {
          e = e.toLowerCase();
          let t = ux.colors[e];
          if (t) return mu.parse(t);
        }, "parse"),
        stringify: a((e) => {
          let t = mu.stringify(e);
          for (let r in ux.colors) if (ux.colors[r] === t) return r;
        }, "stringify"),
      }),
        (jC = ux));
    });
  var _I,
    Xm,
    CI = x(() => {
      "use strict";
      eo();
      Hm();
      ((_I = {
        re: /^rgba?\(\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))\s*?(?:,|\s)\s*?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?))(?:\s*?(?:,|\/)\s*?\+?(-?(?:\d+(?:\.\d+)?|(?:\.\d+))(?:e\d+)?(%?)))?\s*?\)$/i,
        parse: a((e) => {
          let t = e.charCodeAt(0);
          if (t !== 114 && t !== 82) return;
          let r = e.match(_I.re);
          if (!r) return;
          let [, n, i, s, o, l, u, h, f] = r;
          return Ul.set(
            {
              r: de.channel.clamp.r(i ? parseFloat(n) * 2.55 : parseFloat(n)),
              g: de.channel.clamp.g(o ? parseFloat(s) * 2.55 : parseFloat(s)),
              b: de.channel.clamp.b(u ? parseFloat(l) * 2.55 : parseFloat(l)),
              a: h
                ? de.channel.clamp.a(f ? parseFloat(h) / 100 : parseFloat(h))
                : 1,
            },
            e,
          );
        }, "parse"),
        stringify: a((e) => {
          let { r: t, g: r, b: n, a: i } = e;
          return i < 1
            ? `rgba(${de.lang.round(t)}, ${de.lang.round(r)}, ${de.lang.round(n)}, ${de.lang.round(i)})`
            : `rgb(${de.lang.round(t)}, ${de.lang.round(r)}, ${de.lang.round(n)})`;
        }, "stringify"),
      }),
        (Xm = _I));
    });
  var gct,
    Mn,
    Jo = x(() => {
      "use strict";
      UC();
      TI();
      SI();
      CI();
      qm();
      ((gct = {
        format: { keyword: jC, hex: mu, rgb: Xm, rgba: Xm, hsl: Ym, hsla: Ym },
        parse: a((e) => {
          if (typeof e != "string") return e;
          let t = mu.parse(e) || Xm.parse(e) || Ym.parse(e) || jC.parse(e);
          if (t) return t;
          throw new Error(`Unsupported color format: "${e}"`);
        }, "parse"),
        stringify: a(
          (e) =>
            !e.changed && e.color
              ? e.color
              : e.type.is(In.HSL) || e.data.r === void 0
                ? Ym.stringify(e)
                : e.a < 1 ||
                    !Number.isInteger(e.r) ||
                    !Number.isInteger(e.g) ||
                    !Number.isInteger(e.b)
                  ? Xm.stringify(e)
                  : mu.stringify(e),
          "stringify",
        ),
      }),
        (Mn = gct));
    });
  var yct,
    hx,
    qC = x(() => {
      "use strict";
      eo();
      Jo();
      ((yct = a((e, t) => {
        let r = Mn.parse(e);
        for (let n in t) r[n] = de.channel.clamp[n](t[n]);
        return Mn.stringify(r);
      }, "change")),
        (hx = yct));
    });
  var xct,
    Di,
    HC = x(() => {
      "use strict";
      eo();
      Hm();
      Jo();
      qC();
      ((xct = a((e, t, r = 0, n = 1) => {
        if (typeof e != "number") return hx(e, { a: t });
        let i = Ul.set({
          r: de.channel.clamp.r(e),
          g: de.channel.clamp.g(t),
          b: de.channel.clamp.b(r),
          a: de.channel.clamp.a(n),
        });
        return Mn.stringify(i);
      }, "rgba")),
        (Di = xct));
    });
  var bct,
    gu,
    wI = x(() => {
      "use strict";
      eo();
      Jo();
      ((bct = a((e, t) => de.lang.round(Mn.parse(e)[t]), "channel")),
        (gu = bct));
    });
  var kct,
    vI,
    EI = x(() => {
      "use strict";
      eo();
      Jo();
      ((kct = a((e) => {
        let { r: t, g: r, b: n } = Mn.parse(e),
          i =
            0.2126 * de.channel.toLinear(t) +
            0.7152 * de.channel.toLinear(r) +
            0.0722 * de.channel.toLinear(n);
        return de.lang.round(i);
      }, "luminance")),
        (vI = kct));
    });
  var Tct,
    AI,
    LI = x(() => {
      "use strict";
      EI();
      ((Tct = a((e) => vI(e) >= 0.5, "isLight")), (AI = Tct));
    });
  var Sct,
    Ni,
    RI = x(() => {
      "use strict";
      LI();
      ((Sct = a((e) => !AI(e), "isDark")), (Ni = Sct));
    });
  var _ct,
    fx,
    YC = x(() => {
      "use strict";
      eo();
      Jo();
      ((_ct = a((e, t, r) => {
        let n = Mn.parse(e),
          i = n[t],
          s = de.channel.clamp[t](i + r);
        return (i !== s && (n[t] = s), Mn.stringify(n));
      }, "adjustChannel")),
        (fx = _ct));
    });
  var Cct,
    Yt,
    DI = x(() => {
      "use strict";
      YC();
      ((Cct = a((e, t) => fx(e, "l", t), "lighten")), (Yt = Cct));
    });
  var wct,
    ee,
    NI = x(() => {
      "use strict";
      YC();
      ((wct = a((e, t) => fx(e, "l", -t), "darken")), (ee = wct));
    });
  var vct,
    ut,
    II = x(() => {
      "use strict";
      Jo();
      qC();
      ((vct = a((e, t) => {
        let r = Mn.parse(e),
          n = {};
        for (let i in t) t[i] && (n[i] = r[i] + t[i]);
        return hx(e, n);
      }, "adjust")),
        (ut = vct));
    });
  var Ect,
    MI,
    OI = x(() => {
      "use strict";
      Jo();
      HC();
      ((Ect = a((e, t, r = 50) => {
        let { r: n, g: i, b: s, a: o } = Mn.parse(e),
          { r: l, g: u, b: h, a: f } = Mn.parse(t),
          d = r / 100,
          p = d * 2 - 1,
          m = o - f,
          y = ((p * m === -1 ? p : (p + m) / (1 + p * m)) + 1) / 2,
          b = 1 - y,
          k = n * y + l * b,
          T = i * y + u * b,
          C = s * y + h * b,
          L = o * d + f * (1 - d);
        return Di(k, T, C, L);
      }, "mix")),
        (MI = Ect));
    });
  var Act,
    Ut,
    PI = x(() => {
      "use strict";
      Jo();
      OI();
      ((Act = a((e, t = 100) => {
        let r = Mn.parse(e);
        return (
          (r.r = 255 - r.r),
          (r.g = 255 - r.g),
          (r.b = 255 - r.b),
          MI(r, e, t)
        );
      }, "invert")),
        (Ut = Act));
    });
  var BI = x(() => {
    "use strict";
    HC();
    wI();
    RI();
    DI();
    NI();
    II();
    PI();
  });
  var Us = x(() => {
    "use strict";
    BI();
  });
  var jl,
    ql,
    Km = x(() => {
      "use strict";
      ((jl = "#ffffff"), (ql = "#f2f2f2"));
    });
  var wn,
    lf = x(() => {
      "use strict";
      Us();
      wn = a(
        (e, t) => (t ? ut(e, { s: -40, l: 10 }) : ut(e, { s: -40, l: -10 })),
        "mkBorder",
      );
    });
  var KC,
    FI,
    $I = x(() => {
      "use strict";
      Us();
      Km();
      lf();
      ((KC = class {
        static {
          a(this, "Theme");
        }
        constructor() {
          ((this.background = "#f4f4f4"),
            (this.primaryColor = "#fff4dd"),
            (this.noteBkgColor = "#fff5ad"),
            (this.noteTextColor = "#333"),
            (this.THEME_COLOR_LIMIT = 12),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = "16px"));
        }
        updateColors() {
          if (
            ((this.primaryTextColor =
              this.primaryTextColor || (this.darkMode ? "#eee" : "#333")),
            (this.secondaryColor =
              this.secondaryColor || ut(this.primaryColor, { h: -120 })),
            (this.tertiaryColor =
              this.tertiaryColor || ut(this.primaryColor, { h: 180, l: 5 })),
            (this.primaryBorderColor =
              this.primaryBorderColor || wn(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor =
              this.secondaryBorderColor ||
              wn(this.secondaryColor, this.darkMode)),
            (this.tertiaryBorderColor =
              this.tertiaryBorderColor ||
              wn(this.tertiaryColor, this.darkMode)),
            (this.noteBorderColor =
              this.noteBorderColor || wn(this.noteBkgColor, this.darkMode)),
            (this.noteBkgColor = this.noteBkgColor || "#fff5ad"),
            (this.noteTextColor = this.noteTextColor || "#333"),
            (this.secondaryTextColor =
              this.secondaryTextColor || Ut(this.secondaryColor)),
            (this.tertiaryTextColor =
              this.tertiaryTextColor || Ut(this.tertiaryColor)),
            (this.lineColor = this.lineColor || Ut(this.background)),
            (this.arrowheadColor = this.arrowheadColor || Ut(this.background)),
            (this.textColor = this.textColor || this.primaryTextColor),
            (this.border2 = this.border2 || this.tertiaryBorderColor),
            (this.nodeBkg = this.nodeBkg || this.primaryColor),
            (this.mainBkg = this.mainBkg || this.primaryColor),
            (this.nodeBorder = this.nodeBorder || this.primaryBorderColor),
            (this.clusterBkg = this.clusterBkg || this.tertiaryColor),
            (this.clusterBorder =
              this.clusterBorder || this.tertiaryBorderColor),
            (this.defaultLinkColor = this.defaultLinkColor || this.lineColor),
            (this.titleColor = this.titleColor || this.tertiaryTextColor),
            (this.edgeLabelBackground =
              this.edgeLabelBackground ||
              (this.darkMode
                ? ee(this.secondaryColor, 30)
                : this.secondaryColor)),
            (this.nodeTextColor = this.nodeTextColor || this.primaryTextColor),
            (this.actorBorder = this.actorBorder || this.primaryBorderColor),
            (this.actorBkg = this.actorBkg || this.mainBkg),
            (this.actorTextColor =
              this.actorTextColor || this.primaryTextColor),
            (this.actorLineColor = this.actorLineColor || this.actorBorder),
            (this.labelBoxBkgColor = this.labelBoxBkgColor || this.actorBkg),
            (this.signalColor = this.signalColor || this.textColor),
            (this.signalTextColor = this.signalTextColor || this.textColor),
            (this.labelBoxBorderColor =
              this.labelBoxBorderColor || this.actorBorder),
            (this.labelTextColor = this.labelTextColor || this.actorTextColor),
            (this.loopTextColor = this.loopTextColor || this.actorTextColor),
            (this.activationBorderColor =
              this.activationBorderColor || ee(this.secondaryColor, 10)),
            (this.activationBkgColor =
              this.activationBkgColor || this.secondaryColor),
            (this.sequenceNumberColor =
              this.sequenceNumberColor || Ut(this.lineColor)),
            (this.sectionBkgColor = this.sectionBkgColor || this.tertiaryColor),
            (this.altSectionBkgColor = this.altSectionBkgColor || "white"),
            (this.sectionBkgColor =
              this.sectionBkgColor || this.secondaryColor),
            (this.sectionBkgColor2 =
              this.sectionBkgColor2 || this.primaryColor),
            (this.excludeBkgColor = this.excludeBkgColor || "#eeeeee"),
            (this.taskBorderColor =
              this.taskBorderColor || this.primaryBorderColor),
            (this.taskBkgColor = this.taskBkgColor || this.primaryColor),
            (this.activeTaskBorderColor =
              this.activeTaskBorderColor || this.primaryColor),
            (this.activeTaskBkgColor =
              this.activeTaskBkgColor || Yt(this.primaryColor, 23)),
            (this.gridColor = this.gridColor || "lightgrey"),
            (this.doneTaskBkgColor = this.doneTaskBkgColor || "lightgrey"),
            (this.doneTaskBorderColor = this.doneTaskBorderColor || "grey"),
            (this.critBorderColor = this.critBorderColor || "#ff8888"),
            (this.critBkgColor = this.critBkgColor || "red"),
            (this.todayLineColor = this.todayLineColor || "red"),
            (this.vertLineColor = this.vertLineColor || "navy"),
            (this.taskTextColor = this.taskTextColor || this.textColor),
            (this.taskTextOutsideColor =
              this.taskTextOutsideColor || this.textColor),
            (this.taskTextLightColor =
              this.taskTextLightColor || this.textColor),
            (this.taskTextColor = this.taskTextColor || this.primaryTextColor),
            (this.taskTextDarkColor = this.taskTextDarkColor || this.textColor),
            (this.taskTextClickableColor =
              this.taskTextClickableColor || "#003163"),
            (this.personBorder = this.personBorder || this.primaryBorderColor),
            (this.personBkg = this.personBkg || this.mainBkg),
            this.darkMode
              ? ((this.rowOdd =
                  this.rowOdd || ee(this.mainBkg, 5) || "#ffffff"),
                (this.rowEven = this.rowEven || ee(this.mainBkg, 10)))
              : ((this.rowOdd =
                  this.rowOdd || Yt(this.mainBkg, 75) || "#ffffff"),
                (this.rowEven = this.rowEven || Yt(this.mainBkg, 5))),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor =
              this.transitionLabelColor || this.textColor),
            (this.stateLabelColor =
              this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor =
              this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground ||
              this.background ||
              this.tertiaryColor),
            (this.altBackground = this.altBackground || this.tertiaryColor),
            (this.compositeTitleBackground =
              this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.nodeBorder),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor =
              this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.specialStateColor = this.lineColor),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 =
              this.cScale8 || ut(this.primaryColor, { h: 210, l: 150 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 =
              this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 =
              this.cScale11 || ut(this.primaryColor, { h: 330 })),
            this.darkMode)
          )
            for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
              this["cScale" + r] = ee(this["cScale" + r], 75);
          else
            for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
              this["cScale" + r] = ee(this["cScale" + r], 25);
          for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
            this["cScaleInv" + r] =
              this["cScaleInv" + r] || Ut(this["cScale" + r]);
          for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
            this.darkMode
              ? (this["cScalePeer" + r] =
                  this["cScalePeer" + r] || Yt(this["cScale" + r], 10))
              : (this["cScalePeer" + r] =
                  this["cScalePeer" + r] || ee(this["cScale" + r], 10));
          this.scaleLabelColor = this.scaleLabelColor || this.labelTextColor;
          for (let r = 0; r < this.THEME_COLOR_LIMIT; r++)
            this["cScaleLabel" + r] =
              this["cScaleLabel" + r] || this.scaleLabelColor;
          let t = this.darkMode ? -4 : -1;
          for (let r = 0; r < 5; r++)
            ((this["surface" + r] =
              this["surface" + r] ||
              ut(this.mainBkg, { h: 180, s: -15, l: t * (5 + r * 3) })),
              (this["surfacePeer" + r] =
                this["surfacePeer" + r] ||
                ut(this.mainBkg, { h: 180, s: -15, l: t * (8 + r * 3) })));
          ((this.classText = this.classText || this.textColor),
            (this.fillType0 = this.fillType0 || this.primaryColor),
            (this.fillType1 = this.fillType1 || this.secondaryColor),
            (this.fillType2 =
              this.fillType2 || ut(this.primaryColor, { h: 64 })),
            (this.fillType3 =
              this.fillType3 || ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 =
              this.fillType4 || ut(this.primaryColor, { h: -64 })),
            (this.fillType5 =
              this.fillType5 || ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 =
              this.fillType6 || ut(this.primaryColor, { h: 128 })),
            (this.fillType7 =
              this.fillType7 || ut(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || this.tertiaryColor),
            (this.pie4 = this.pie4 || ut(this.primaryColor, { l: -10 })),
            (this.pie5 = this.pie5 || ut(this.secondaryColor, { l: -10 })),
            (this.pie6 = this.pie6 || ut(this.tertiaryColor, { l: -10 })),
            (this.pie7 = this.pie7 || ut(this.primaryColor, { h: 60, l: -10 })),
            (this.pie8 =
              this.pie8 || ut(this.primaryColor, { h: -60, l: -10 })),
            (this.pie9 = this.pie9 || ut(this.primaryColor, { h: 120, l: 0 })),
            (this.pie10 =
              this.pie10 || ut(this.primaryColor, { h: 60, l: -20 })),
            (this.pie11 =
              this.pie11 || ut(this.primaryColor, { h: -60, l: -20 })),
            (this.pie12 =
              this.pie12 || ut(this.primaryColor, { h: 120, l: -10 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || "25px"),
            (this.pieTitleTextColor =
              this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || "17px"),
            (this.pieSectionTextColor =
              this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || "17px"),
            (this.pieLegendTextColor =
              this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || "black"),
            (this.pieStrokeWidth = this.pieStrokeWidth || "2px"),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px"),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black"),
            (this.pieOpacity = this.pieOpacity || "0.7"),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.archEdgeColor = this.archEdgeColor || "#777"),
            (this.archEdgeArrowColor = this.archEdgeArrowColor || "#777"),
            (this.archEdgeWidth = this.archEdgeWidth || "3"),
            (this.archGroupBorderColor = this.archGroupBorderColor || "#000"),
            (this.archGroupBorderWidth = this.archGroupBorderWidth || "2px"),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill ||
              ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill ||
              ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill ||
              ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill =
              this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill ||
              ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill ||
              ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill ||
              ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ni(this.quadrant1Fill)
                ? Yt(this.quadrant1Fill)
                : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill =
              this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill =
              this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill =
              this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill =
              this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor:
                this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor:
                this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor:
                this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor:
                this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor:
                this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor:
                this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor:
                this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor:
                this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                "#FFF4DD,#FFD8B1,#FFA07A,#ECEFF1,#D6DBDF,#C3E0A8,#FFB6A4,#FFD74D,#738FA7,#FFFFF0",
            }),
            (this.requirementBackground =
              this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor =
              this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || "1"),
            (this.requirementTextColor =
              this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground ||
              (this.darkMode
                ? ee(this.secondaryColor, 30)
                : this.secondaryColor)),
            (this.relationLabelColor =
              this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || ut(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Yt(this.git0, 25)),
                (this.git1 = Yt(this.git1, 25)),
                (this.git2 = Yt(this.git2, 25)),
                (this.git3 = Yt(this.git3, 25)),
                (this.git4 = Yt(this.git4, 25)),
                (this.git5 = Yt(this.git5, 25)),
                (this.git6 = Yt(this.git6, 25)),
                (this.git7 = Yt(this.git7, 25)))
              : ((this.git0 = ee(this.git0, 25)),
                (this.git1 = ee(this.git1, 25)),
                (this.git2 = ee(this.git2, 25)),
                (this.git3 = ee(this.git3, 25)),
                (this.git4 = ee(this.git4, 25)),
                (this.git5 = ee(this.git5, 25)),
                (this.git6 = ee(this.git6, 25)),
                (this.git7 = ee(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.branchLabelColor =
              this.branchLabelColor ||
              (this.darkMode ? "black" : this.labelTextColor)),
            (this.gitBranchLabel0 =
              this.gitBranchLabel0 || this.branchLabelColor),
            (this.gitBranchLabel1 =
              this.gitBranchLabel1 || this.branchLabelColor),
            (this.gitBranchLabel2 =
              this.gitBranchLabel2 || this.branchLabelColor),
            (this.gitBranchLabel3 =
              this.gitBranchLabel3 || this.branchLabelColor),
            (this.gitBranchLabel4 =
              this.gitBranchLabel4 || this.branchLabelColor),
            (this.gitBranchLabel5 =
              this.gitBranchLabel5 || this.branchLabelColor),
            (this.gitBranchLabel6 =
              this.gitBranchLabel6 || this.branchLabelColor),
            (this.gitBranchLabel7 =
              this.gitBranchLabel7 || this.branchLabelColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground =
              this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || "10px"),
            (this.commitLabelColor =
              this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground =
              this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || "10px"),
            (this.attributeBackgroundColorOdd =
              this.attributeBackgroundColorOdd || jl),
            (this.attributeBackgroundColorEven =
              this.attributeBackgroundColorEven || ql));
        }
        calculate(t) {
          if (typeof t != "object") {
            this.updateColors();
            return;
          }
          let r = Object.keys(t);
          (r.forEach((n) => {
            this[n] = t[n];
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n];
            }));
        }
      }),
        (FI = a((e) => {
          let t = new KC();
          return (t.calculate(e), t);
        }, "getThemeVariables")));
    });
  var QC,
    GI,
    VI = x(() => {
      "use strict";
      Us();
      lf();
      ((QC = class {
        static {
          a(this, "Theme");
        }
        constructor() {
          ((this.background = "#333"),
            (this.primaryColor = "#1f2020"),
            (this.secondaryColor = Yt(this.primaryColor, 16)),
            (this.tertiaryColor = ut(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = Ut(this.background)),
            (this.secondaryBorderColor = wn(
              this.secondaryColor,
              this.darkMode,
            )),
            (this.tertiaryBorderColor = wn(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.tertiaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.mainBkg = "#1f2020"),
            (this.secondBkg = "calculated"),
            (this.mainContrastColor = "lightgrey"),
            (this.darkTextColor = Yt(Ut("#323D47"), 10)),
            (this.lineColor = "calculated"),
            (this.border1 = "#ccc"),
            (this.border2 = Di(255, 255, 255, 0.25)),
            (this.arrowheadColor = "calculated"),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = "16px"),
            (this.labelBackground = "#181818"),
            (this.textColor = "#ccc"),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = "calculated"),
            (this.nodeBorder = "calculated"),
            (this.clusterBkg = "calculated"),
            (this.clusterBorder = "calculated"),
            (this.defaultLinkColor = "calculated"),
            (this.titleColor = "#F9FFFE"),
            (this.edgeLabelBackground = "calculated"),
            (this.actorBorder = "calculated"),
            (this.actorBkg = "calculated"),
            (this.actorTextColor = "calculated"),
            (this.actorLineColor = "calculated"),
            (this.signalColor = "calculated"),
            (this.signalTextColor = "calculated"),
            (this.labelBoxBkgColor = "calculated"),
            (this.labelBoxBorderColor = "calculated"),
            (this.labelTextColor = "calculated"),
            (this.loopTextColor = "calculated"),
            (this.noteBorderColor = "calculated"),
            (this.noteBkgColor = "#fff5ad"),
            (this.noteTextColor = "calculated"),
            (this.activationBorderColor = "calculated"),
            (this.activationBkgColor = "calculated"),
            (this.sequenceNumberColor = "black"),
            (this.sectionBkgColor = ee("#EAE8D9", 30)),
            (this.altSectionBkgColor = "calculated"),
            (this.sectionBkgColor2 = "#EAE8D9"),
            (this.excludeBkgColor = ee(this.sectionBkgColor, 10)),
            (this.taskBorderColor = Di(255, 255, 255, 70)),
            (this.taskBkgColor = "calculated"),
            (this.taskTextColor = "calculated"),
            (this.taskTextLightColor = "calculated"),
            (this.taskTextOutsideColor = "calculated"),
            (this.taskTextClickableColor = "#003163"),
            (this.activeTaskBorderColor = Di(255, 255, 255, 50)),
            (this.activeTaskBkgColor = "#81B1DB"),
            (this.gridColor = "calculated"),
            (this.doneTaskBkgColor = "calculated"),
            (this.doneTaskBorderColor = "grey"),
            (this.critBorderColor = "#E83737"),
            (this.critBkgColor = "#E83737"),
            (this.taskTextDarkColor = "calculated"),
            (this.todayLineColor = "#DB5757"),
            (this.vertLineColor = "#00BFFF"),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = "calculated"),
            (this.archEdgeArrowColor = "calculated"),
            (this.archEdgeWidth = "3"),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = "2px"),
            (this.rowOdd = this.rowOdd || Yt(this.mainBkg, 5) || "#ffffff"),
            (this.rowEven = this.rowEven || ee(this.mainBkg, 10)),
            (this.labelColor = "calculated"),
            (this.errorBkgColor = "#a44141"),
            (this.errorTextColor = "#ddd"));
        }
        updateColors() {
          ((this.secondBkg = Yt(this.mainBkg, 16)),
            (this.lineColor = this.mainContrastColor),
            (this.arrowheadColor = this.mainContrastColor),
            (this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.edgeLabelBackground = Yt(this.labelBackground, 25)),
            (this.actorBorder = this.border1),
            (this.actorBkg = this.mainBkg),
            (this.actorTextColor = this.mainContrastColor),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = this.mainContrastColor),
            (this.signalTextColor = this.mainContrastColor),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.mainContrastColor),
            (this.loopTextColor = this.mainContrastColor),
            (this.noteBorderColor = this.secondaryBorderColor),
            (this.noteBkgColor = this.secondBkg),
            (this.noteTextColor = this.secondaryTextColor),
            (this.activationBorderColor = this.border1),
            (this.activationBkgColor = this.secondBkg),
            (this.altSectionBkgColor = this.background),
            (this.taskBkgColor = Yt(this.mainBkg, 23)),
            (this.taskTextColor = this.darkTextColor),
            (this.taskTextLightColor = this.mainContrastColor),
            (this.taskTextOutsideColor = this.taskTextLightColor),
            (this.gridColor = this.mainContrastColor),
            (this.doneTaskBkgColor = this.mainContrastColor),
            (this.taskTextDarkColor = this.darkTextColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor =
              this.transitionLabelColor || this.textColor),
            (this.stateLabelColor =
              this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor =
              this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground ||
              this.background ||
              this.tertiaryColor),
            (this.altBackground = this.altBackground || "#555"),
            (this.compositeTitleBackground =
              this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = "#f4f4f4"),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor =
              this.errorTextColor || this.tertiaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 })),
            (this.cScale1 = this.cScale1 || "#0b0000"),
            (this.cScale2 = this.cScale2 || "#4d1037"),
            (this.cScale3 = this.cScale3 || "#3f5258"),
            (this.cScale4 = this.cScale4 || "#4f2f1b"),
            (this.cScale5 = this.cScale5 || "#6e0a0a"),
            (this.cScale6 = this.cScale6 || "#3b0048"),
            (this.cScale7 = this.cScale7 || "#995a01"),
            (this.cScale8 = this.cScale8 || "#154706"),
            (this.cScale9 = this.cScale9 || "#161722"),
            (this.cScale10 = this.cScale10 || "#00296f"),
            (this.cScale11 = this.cScale11 || "#01629c"),
            (this.cScale12 = this.cScale12 || "#010029"),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || ut(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 =
              this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 =
              this.cScale11 || ut(this.primaryColor, { h: 330 })));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] =
              this["cScaleInv" + t] || Ut(this["cScale" + t]);
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScalePeer" + t] =
              this["cScalePeer" + t] || Yt(this["cScale" + t], 10);
          for (let t = 0; t < 5; t++)
            ((this["surface" + t] =
              this["surface" + t] ||
              ut(this.mainBkg, { h: 30, s: -30, l: -(-10 + t * 4) })),
              (this["surfacePeer" + t] =
                this["surfacePeer" + t] ||
                ut(this.mainBkg, { h: 30, s: -30, l: -(-7 + t * 4) })));
          this.scaleLabelColor =
            this.scaleLabelColor ||
            (this.darkMode ? "black" : this.labelTextColor);
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleLabel" + t] =
              this["cScaleLabel" + t] || this.scaleLabelColor;
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["pie" + t] = this["cScale" + t];
          ((this.pieTitleTextSize = this.pieTitleTextSize || "25px"),
            (this.pieTitleTextColor =
              this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || "17px"),
            (this.pieSectionTextColor =
              this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || "17px"),
            (this.pieLegendTextColor =
              this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || "black"),
            (this.pieStrokeWidth = this.pieStrokeWidth || "2px"),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px"),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black"),
            (this.pieOpacity = this.pieOpacity || "0.7"),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill ||
              ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill ||
              ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill ||
              ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill =
              this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill ||
              ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill ||
              ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill ||
              ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ni(this.quadrant1Fill)
                ? Yt(this.quadrant1Fill)
                : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill =
              this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill =
              this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill =
              this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill =
              this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor:
                this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor:
                this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor:
                this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor:
                this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor:
                this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor:
                this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor:
                this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor:
                this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                "#3498db,#2ecc71,#e74c3c,#f1c40f,#bdc3c7,#ffffff,#34495e,#9b59b6,#1abc9c,#e67e22",
            }),
            (this.packet = {
              startByteColor: this.primaryTextColor,
              endByteColor: this.primaryTextColor,
              labelColor: this.primaryTextColor,
              titleColor: this.primaryTextColor,
              blockStrokeColor: this.primaryTextColor,
              blockFillColor: this.background,
            }),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.classText = this.primaryTextColor),
            (this.requirementBackground =
              this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor =
              this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || "1"),
            (this.requirementTextColor =
              this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground ||
              (this.darkMode
                ? ee(this.secondaryColor, 30)
                : this.secondaryColor)),
            (this.relationLabelColor =
              this.relationLabelColor || this.actorTextColor),
            (this.git0 = Yt(this.secondaryColor, 20)),
            (this.git1 = Yt(this.pie2 || this.secondaryColor, 20)),
            (this.git2 = Yt(this.pie3 || this.tertiaryColor, 20)),
            (this.git3 = Yt(
              this.pie4 || ut(this.primaryColor, { h: -30 }),
              20,
            )),
            (this.git4 = Yt(
              this.pie5 || ut(this.primaryColor, { h: -60 }),
              20,
            )),
            (this.git5 = Yt(
              this.pie6 || ut(this.primaryColor, { h: -90 }),
              10,
            )),
            (this.git6 = Yt(this.pie7 || ut(this.primaryColor, { h: 60 }), 10)),
            (this.git7 = Yt(
              this.pie8 || ut(this.primaryColor, { h: 120 }),
              20,
            )),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.gitBranchLabel0 =
              this.gitBranchLabel0 || Ut(this.labelTextColor)),
            (this.gitBranchLabel1 =
              this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 =
              this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 =
              this.gitBranchLabel3 || Ut(this.labelTextColor)),
            (this.gitBranchLabel4 =
              this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 =
              this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 =
              this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 =
              this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground =
              this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || "10px"),
            (this.commitLabelColor =
              this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground =
              this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || "10px"),
            (this.attributeBackgroundColorOdd =
              this.attributeBackgroundColorOdd || Yt(this.background, 12)),
            (this.attributeBackgroundColorEven =
              this.attributeBackgroundColorEven || Yt(this.background, 2)),
            (this.nodeBorder = this.nodeBorder || "#999"));
        }
        calculate(t) {
          if (typeof t != "object") {
            this.updateColors();
            return;
          }
          let r = Object.keys(t);
          (r.forEach((n) => {
            this[n] = t[n];
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n];
            }));
        }
      }),
        (GI = a((e) => {
          let t = new QC();
          return (t.calculate(e), t);
        }, "getThemeVariables")));
    });
  var ZC,
    Hl,
    Qm = x(() => {
      "use strict";
      Us();
      lf();
      Km();
      ((ZC = class {
        static {
          a(this, "Theme");
        }
        constructor() {
          ((this.background = "#f4f4f4"),
            (this.primaryColor = "#ECECFF"),
            (this.secondaryColor = ut(this.primaryColor, { h: 120 })),
            (this.secondaryColor = "#ffffde"),
            (this.tertiaryColor = ut(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = wn(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = wn(
              this.secondaryColor,
              this.darkMode,
            )),
            (this.tertiaryBorderColor = wn(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.tertiaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.background = "white"),
            (this.mainBkg = "#ECECFF"),
            (this.secondBkg = "#ffffde"),
            (this.lineColor = "#333333"),
            (this.border1 = "#9370DB"),
            (this.border2 = "#aaaa33"),
            (this.arrowheadColor = "#333333"),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = "16px"),
            (this.labelBackground = "rgba(232,232,232, 0.8)"),
            (this.textColor = "#333"),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = "calculated"),
            (this.nodeBorder = "calculated"),
            (this.clusterBkg = "calculated"),
            (this.clusterBorder = "calculated"),
            (this.defaultLinkColor = "calculated"),
            (this.titleColor = "calculated"),
            (this.edgeLabelBackground = "calculated"),
            (this.actorBorder = "calculated"),
            (this.actorBkg = "calculated"),
            (this.actorTextColor = "black"),
            (this.actorLineColor = "calculated"),
            (this.signalColor = "calculated"),
            (this.signalTextColor = "calculated"),
            (this.labelBoxBkgColor = "calculated"),
            (this.labelBoxBorderColor = "calculated"),
            (this.labelTextColor = "calculated"),
            (this.loopTextColor = "calculated"),
            (this.noteBorderColor = "calculated"),
            (this.noteBkgColor = "#fff5ad"),
            (this.noteTextColor = "calculated"),
            (this.activationBorderColor = "#666"),
            (this.activationBkgColor = "#f4f4f4"),
            (this.sequenceNumberColor = "white"),
            (this.sectionBkgColor = "calculated"),
            (this.altSectionBkgColor = "calculated"),
            (this.sectionBkgColor2 = "calculated"),
            (this.excludeBkgColor = "#eeeeee"),
            (this.taskBorderColor = "calculated"),
            (this.taskBkgColor = "calculated"),
            (this.taskTextLightColor = "calculated"),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextDarkColor = "calculated"),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.taskTextClickableColor = "calculated"),
            (this.activeTaskBorderColor = "calculated"),
            (this.activeTaskBkgColor = "calculated"),
            (this.gridColor = "calculated"),
            (this.doneTaskBkgColor = "calculated"),
            (this.doneTaskBorderColor = "calculated"),
            (this.critBorderColor = "calculated"),
            (this.critBkgColor = "calculated"),
            (this.todayLineColor = "calculated"),
            (this.vertLineColor = "calculated"),
            (this.sectionBkgColor = Di(102, 102, 255, 0.49)),
            (this.altSectionBkgColor = "white"),
            (this.sectionBkgColor2 = "#fff400"),
            (this.taskBorderColor = "#534fbc"),
            (this.taskBkgColor = "#8a90dd"),
            (this.taskTextLightColor = "white"),
            (this.taskTextColor = "calculated"),
            (this.taskTextDarkColor = "black"),
            (this.taskTextOutsideColor = "calculated"),
            (this.taskTextClickableColor = "#003163"),
            (this.activeTaskBorderColor = "#534fbc"),
            (this.activeTaskBkgColor = "#bfc7ff"),
            (this.gridColor = "lightgrey"),
            (this.doneTaskBkgColor = "lightgrey"),
            (this.doneTaskBorderColor = "grey"),
            (this.critBorderColor = "#ff8888"),
            (this.critBkgColor = "red"),
            (this.todayLineColor = "red"),
            (this.vertLineColor = "navy"),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = "calculated"),
            (this.archEdgeArrowColor = "calculated"),
            (this.archEdgeWidth = "3"),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = "2px"),
            (this.rowOdd = "calculated"),
            (this.rowEven = "calculated"),
            (this.labelColor = "black"),
            (this.errorBkgColor = "#552222"),
            (this.errorTextColor = "#552222"),
            this.updateColors());
        }
        updateColors() {
          ((this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || ut(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 =
              this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 =
              this.cScale11 || ut(this.primaryColor, { h: 330 })),
            (this.cScalePeer1 =
              this.cScalePeer1 || ee(this.secondaryColor, 45)),
            (this.cScalePeer2 =
              this.cScalePeer2 || ee(this.tertiaryColor, 40)));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            ((this["cScale" + t] = ee(this["cScale" + t], 10)),
              (this["cScalePeer" + t] =
                this["cScalePeer" + t] || ee(this["cScale" + t], 25)));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] =
              this["cScaleInv" + t] || ut(this["cScale" + t], { h: 180 });
          for (let t = 0; t < 5; t++)
            ((this["surface" + t] =
              this["surface" + t] ||
              ut(this.mainBkg, { h: 30, l: -(5 + t * 5) })),
              (this["surfacePeer" + t] =
                this["surfacePeer" + t] ||
                ut(this.mainBkg, { h: 30, l: -(7 + t * 5) })));
          if (
            ((this.scaleLabelColor =
              this.scaleLabelColor !== "calculated" && this.scaleLabelColor
                ? this.scaleLabelColor
                : this.labelTextColor),
            this.labelTextColor !== "calculated")
          ) {
            ((this.cScaleLabel0 = this.cScaleLabel0 || Ut(this.labelTextColor)),
              (this.cScaleLabel3 =
                this.cScaleLabel3 || Ut(this.labelTextColor)));
            for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
              this["cScaleLabel" + t] =
                this["cScaleLabel" + t] || this.labelTextColor;
          }
          ((this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.titleColor = this.textColor),
            (this.edgeLabelBackground = this.labelBackground),
            (this.actorBorder = Yt(this.border1, 23)),
            (this.actorBkg = this.mainBkg),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.signalColor = this.textColor),
            (this.signalTextColor = this.textColor),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.actorTextColor),
            (this.loopTextColor = this.actorTextColor),
            (this.noteBorderColor = this.border2),
            (this.noteTextColor = this.actorTextColor),
            (this.actorLineColor = this.actorBorder),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.rowOdd =
              this.rowOdd || Yt(this.primaryColor, 75) || "#ffffff"),
            (this.rowEven = this.rowEven || Yt(this.primaryColor, 1)),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor =
              this.transitionLabelColor || this.textColor),
            (this.stateLabelColor =
              this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor =
              this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground ||
              this.background ||
              this.tertiaryColor),
            (this.altBackground = this.altBackground || "#f0f0f0"),
            (this.compositeTitleBackground =
              this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.nodeBorder),
            (this.specialStateColor = this.lineColor),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor =
              this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || ut(this.tertiaryColor, { l: -40 })),
            (this.pie4 = this.pie4 || ut(this.primaryColor, { l: -10 })),
            (this.pie5 = this.pie5 || ut(this.secondaryColor, { l: -30 })),
            (this.pie6 = this.pie6 || ut(this.tertiaryColor, { l: -20 })),
            (this.pie7 = this.pie7 || ut(this.primaryColor, { h: 60, l: -20 })),
            (this.pie8 =
              this.pie8 || ut(this.primaryColor, { h: -60, l: -40 })),
            (this.pie9 =
              this.pie9 || ut(this.primaryColor, { h: 120, l: -40 })),
            (this.pie10 =
              this.pie10 || ut(this.primaryColor, { h: 60, l: -40 })),
            (this.pie11 =
              this.pie11 || ut(this.primaryColor, { h: -90, l: -40 })),
            (this.pie12 =
              this.pie12 || ut(this.primaryColor, { h: 120, l: -30 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || "25px"),
            (this.pieTitleTextColor =
              this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || "17px"),
            (this.pieSectionTextColor =
              this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || "17px"),
            (this.pieLegendTextColor =
              this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || "black"),
            (this.pieStrokeWidth = this.pieStrokeWidth || "2px"),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px"),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black"),
            (this.pieOpacity = this.pieOpacity || "0.7"),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill ||
              ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill ||
              ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill ||
              ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill =
              this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill ||
              ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill ||
              ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill ||
              ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ni(this.quadrant1Fill)
                ? Yt(this.quadrant1Fill)
                : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill =
              this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill =
              this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill =
              this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill =
              this.quadrantTitleFill || this.primaryTextColor),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor:
                this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor:
                this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor:
                this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor:
                this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor:
                this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor:
                this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor:
                this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor:
                this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                "#ECECFF,#8493A6,#FFC3A0,#DCDDE1,#B8E994,#D1A36F,#C3CDE6,#FFB6C1,#496078,#F8F3E3",
            }),
            (this.requirementBackground =
              this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor =
              this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || "1"),
            (this.requirementTextColor =
              this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground || this.labelBackground),
            (this.relationLabelColor =
              this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || ut(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Yt(this.git0, 25)),
                (this.git1 = Yt(this.git1, 25)),
                (this.git2 = Yt(this.git2, 25)),
                (this.git3 = Yt(this.git3, 25)),
                (this.git4 = Yt(this.git4, 25)),
                (this.git5 = Yt(this.git5, 25)),
                (this.git6 = Yt(this.git6, 25)),
                (this.git7 = Yt(this.git7, 25)))
              : ((this.git0 = ee(this.git0, 25)),
                (this.git1 = ee(this.git1, 25)),
                (this.git2 = ee(this.git2, 25)),
                (this.git3 = ee(this.git3, 25)),
                (this.git4 = ee(this.git4, 25)),
                (this.git5 = ee(this.git5, 25)),
                (this.git6 = ee(this.git6, 25)),
                (this.git7 = ee(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || ee(Ut(this.git0), 25)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.gitBranchLabel0 =
              this.gitBranchLabel0 || Ut(this.labelTextColor)),
            (this.gitBranchLabel1 =
              this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 =
              this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 =
              this.gitBranchLabel3 || Ut(this.labelTextColor)),
            (this.gitBranchLabel4 =
              this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 =
              this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 =
              this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 =
              this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground =
              this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || "10px"),
            (this.commitLabelColor =
              this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground =
              this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || "10px"),
            (this.attributeBackgroundColorOdd =
              this.attributeBackgroundColorOdd || jl),
            (this.attributeBackgroundColorEven =
              this.attributeBackgroundColorEven || ql));
        }
        calculate(t) {
          if (
            (Object.keys(this).forEach((n) => {
              this[n] === "calculated" && (this[n] = void 0);
            }),
            typeof t != "object")
          ) {
            this.updateColors();
            return;
          }
          let r = Object.keys(t);
          (r.forEach((n) => {
            this[n] = t[n];
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n];
            }));
        }
      }),
        (Hl = a((e) => {
          let t = new ZC();
          return (t.calculate(e), t);
        }, "getThemeVariables")));
    });
  var JC,
    zI,
    WI = x(() => {
      "use strict";
      Us();
      Km();
      lf();
      ((JC = class {
        static {
          a(this, "Theme");
        }
        constructor() {
          ((this.background = "#f4f4f4"),
            (this.primaryColor = "#cde498"),
            (this.secondaryColor = "#cdffb2"),
            (this.background = "white"),
            (this.mainBkg = "#cde498"),
            (this.secondBkg = "#cdffb2"),
            (this.lineColor = "green"),
            (this.border1 = "#13540c"),
            (this.border2 = "#6eaa49"),
            (this.arrowheadColor = "green"),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = "16px"),
            (this.tertiaryColor = Yt("#cde498", 10)),
            (this.primaryBorderColor = wn(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = wn(
              this.secondaryColor,
              this.darkMode,
            )),
            (this.tertiaryBorderColor = wn(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.primaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = "calculated"),
            (this.nodeBorder = "calculated"),
            (this.clusterBkg = "calculated"),
            (this.clusterBorder = "calculated"),
            (this.defaultLinkColor = "calculated"),
            (this.titleColor = "#333"),
            (this.edgeLabelBackground = "#e8e8e8"),
            (this.actorBorder = "calculated"),
            (this.actorBkg = "calculated"),
            (this.actorTextColor = "black"),
            (this.actorLineColor = "calculated"),
            (this.signalColor = "#333"),
            (this.signalTextColor = "#333"),
            (this.labelBoxBkgColor = "calculated"),
            (this.labelBoxBorderColor = "#326932"),
            (this.labelTextColor = "calculated"),
            (this.loopTextColor = "calculated"),
            (this.noteBorderColor = "calculated"),
            (this.noteBkgColor = "#fff5ad"),
            (this.noteTextColor = "calculated"),
            (this.activationBorderColor = "#666"),
            (this.activationBkgColor = "#f4f4f4"),
            (this.sequenceNumberColor = "white"),
            (this.sectionBkgColor = "#6eaa49"),
            (this.altSectionBkgColor = "white"),
            (this.sectionBkgColor2 = "#6eaa49"),
            (this.excludeBkgColor = "#eeeeee"),
            (this.taskBorderColor = "calculated"),
            (this.taskBkgColor = "#487e3a"),
            (this.taskTextLightColor = "white"),
            (this.taskTextColor = "calculated"),
            (this.taskTextDarkColor = "black"),
            (this.taskTextOutsideColor = "calculated"),
            (this.taskTextClickableColor = "#003163"),
            (this.activeTaskBorderColor = "calculated"),
            (this.activeTaskBkgColor = "calculated"),
            (this.gridColor = "lightgrey"),
            (this.doneTaskBkgColor = "lightgrey"),
            (this.doneTaskBorderColor = "grey"),
            (this.critBorderColor = "#ff8888"),
            (this.critBkgColor = "red"),
            (this.todayLineColor = "red"),
            (this.vertLineColor = "#00BFFF"),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = "calculated"),
            (this.archEdgeArrowColor = "calculated"),
            (this.archEdgeWidth = "3"),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = "2px"),
            (this.labelColor = "black"),
            (this.errorBkgColor = "#552222"),
            (this.errorTextColor = "#552222"));
        }
        updateColors() {
          ((this.actorBorder = ee(this.mainBkg, 20)),
            (this.actorBkg = this.mainBkg),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelTextColor = this.actorTextColor),
            (this.loopTextColor = this.actorTextColor),
            (this.noteBorderColor = this.border2),
            (this.noteTextColor = this.actorTextColor),
            (this.actorLineColor = this.actorBorder),
            (this.cScale0 = this.cScale0 || this.primaryColor),
            (this.cScale1 = this.cScale1 || this.secondaryColor),
            (this.cScale2 = this.cScale2 || this.tertiaryColor),
            (this.cScale3 = this.cScale3 || ut(this.primaryColor, { h: 30 })),
            (this.cScale4 = this.cScale4 || ut(this.primaryColor, { h: 60 })),
            (this.cScale5 = this.cScale5 || ut(this.primaryColor, { h: 90 })),
            (this.cScale6 = this.cScale6 || ut(this.primaryColor, { h: 120 })),
            (this.cScale7 = this.cScale7 || ut(this.primaryColor, { h: 150 })),
            (this.cScale8 = this.cScale8 || ut(this.primaryColor, { h: 210 })),
            (this.cScale9 = this.cScale9 || ut(this.primaryColor, { h: 270 })),
            (this.cScale10 =
              this.cScale10 || ut(this.primaryColor, { h: 300 })),
            (this.cScale11 =
              this.cScale11 || ut(this.primaryColor, { h: 330 })),
            (this.cScalePeer1 =
              this.cScalePeer1 || ee(this.secondaryColor, 45)),
            (this.cScalePeer2 =
              this.cScalePeer2 || ee(this.tertiaryColor, 40)));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            ((this["cScale" + t] = ee(this["cScale" + t], 10)),
              (this["cScalePeer" + t] =
                this["cScalePeer" + t] || ee(this["cScale" + t], 25)));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] =
              this["cScaleInv" + t] || ut(this["cScale" + t], { h: 180 });
          this.scaleLabelColor =
            this.scaleLabelColor !== "calculated" && this.scaleLabelColor
              ? this.scaleLabelColor
              : this.labelTextColor;
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleLabel" + t] =
              this["cScaleLabel" + t] || this.scaleLabelColor;
          for (let t = 0; t < 5; t++)
            ((this["surface" + t] =
              this["surface" + t] ||
              ut(this.mainBkg, { h: 30, s: -30, l: -(5 + t * 5) })),
              (this["surfacePeer" + t] =
                this["surfacePeer" + t] ||
                ut(this.mainBkg, { h: 30, s: -30, l: -(8 + t * 5) })));
          ((this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.taskBorderColor = this.border1),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.activeTaskBorderColor = this.taskBorderColor),
            (this.activeTaskBkgColor = this.mainBkg),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.rowOdd = this.rowOdd || Yt(this.mainBkg, 75) || "#ffffff"),
            (this.rowEven = this.rowEven || Yt(this.mainBkg, 20)),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.transitionLabelColor =
              this.transitionLabelColor || this.textColor),
            (this.stateLabelColor =
              this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor =
              this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground ||
              this.background ||
              this.tertiaryColor),
            (this.altBackground = this.altBackground || "#f0f0f0"),
            (this.compositeTitleBackground =
              this.compositeTitleBackground || this.mainBkg),
            (this.compositeBorder = this.compositeBorder || this.nodeBorder),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = this.lineColor),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor =
              this.errorTextColor || this.tertiaryTextColor),
            (this.transitionColor = this.transitionColor || this.lineColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 })),
            (this.pie1 = this.pie1 || this.primaryColor),
            (this.pie2 = this.pie2 || this.secondaryColor),
            (this.pie3 = this.pie3 || this.tertiaryColor),
            (this.pie4 = this.pie4 || ut(this.primaryColor, { l: -30 })),
            (this.pie5 = this.pie5 || ut(this.secondaryColor, { l: -30 })),
            (this.pie6 =
              this.pie6 || ut(this.tertiaryColor, { h: 40, l: -40 })),
            (this.pie7 = this.pie7 || ut(this.primaryColor, { h: 60, l: -10 })),
            (this.pie8 =
              this.pie8 || ut(this.primaryColor, { h: -60, l: -10 })),
            (this.pie9 = this.pie9 || ut(this.primaryColor, { h: 120, l: 0 })),
            (this.pie10 =
              this.pie10 || ut(this.primaryColor, { h: 60, l: -50 })),
            (this.pie11 =
              this.pie11 || ut(this.primaryColor, { h: -60, l: -50 })),
            (this.pie12 =
              this.pie12 || ut(this.primaryColor, { h: 120, l: -50 })),
            (this.pieTitleTextSize = this.pieTitleTextSize || "25px"),
            (this.pieTitleTextColor =
              this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || "17px"),
            (this.pieSectionTextColor =
              this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || "17px"),
            (this.pieLegendTextColor =
              this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || "black"),
            (this.pieStrokeWidth = this.pieStrokeWidth || "2px"),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px"),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black"),
            (this.pieOpacity = this.pieOpacity || "0.7"),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill ||
              ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill ||
              ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill ||
              ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill =
              this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill ||
              ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill ||
              ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill ||
              ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ni(this.quadrant1Fill)
                ? Yt(this.quadrant1Fill)
                : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill =
              this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill =
              this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill =
              this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill =
              this.quadrantTitleFill || this.primaryTextColor),
            (this.packet = {
              startByteColor: this.primaryTextColor,
              endByteColor: this.primaryTextColor,
              labelColor: this.primaryTextColor,
              titleColor: this.primaryTextColor,
              blockStrokeColor: this.primaryTextColor,
              blockFillColor: this.mainBkg,
            }),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor:
                this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor:
                this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor:
                this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor:
                this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor:
                this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor:
                this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor:
                this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor:
                this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                "#CDE498,#FF6B6B,#A0D2DB,#D7BDE2,#F0F0F0,#FFC3A0,#7FD8BE,#FF9A8B,#FAF3E0,#FFF176",
            }),
            (this.requirementBackground =
              this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor =
              this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || "1"),
            (this.requirementTextColor =
              this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground || this.edgeLabelBackground),
            (this.relationLabelColor =
              this.relationLabelColor || this.actorTextColor),
            (this.git0 = this.git0 || this.primaryColor),
            (this.git1 = this.git1 || this.secondaryColor),
            (this.git2 = this.git2 || this.tertiaryColor),
            (this.git3 = this.git3 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.git4 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.git5 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.git6 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.git7 || ut(this.primaryColor, { h: 120 })),
            this.darkMode
              ? ((this.git0 = Yt(this.git0, 25)),
                (this.git1 = Yt(this.git1, 25)),
                (this.git2 = Yt(this.git2, 25)),
                (this.git3 = Yt(this.git3, 25)),
                (this.git4 = Yt(this.git4, 25)),
                (this.git5 = Yt(this.git5, 25)),
                (this.git6 = Yt(this.git6, 25)),
                (this.git7 = Yt(this.git7, 25)))
              : ((this.git0 = ee(this.git0, 25)),
                (this.git1 = ee(this.git1, 25)),
                (this.git2 = ee(this.git2, 25)),
                (this.git3 = ee(this.git3, 25)),
                (this.git4 = ee(this.git4, 25)),
                (this.git5 = ee(this.git5, 25)),
                (this.git6 = ee(this.git6, 25)),
                (this.git7 = ee(this.git7, 25))),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.gitBranchLabel0 =
              this.gitBranchLabel0 || Ut(this.labelTextColor)),
            (this.gitBranchLabel1 =
              this.gitBranchLabel1 || this.labelTextColor),
            (this.gitBranchLabel2 =
              this.gitBranchLabel2 || this.labelTextColor),
            (this.gitBranchLabel3 =
              this.gitBranchLabel3 || Ut(this.labelTextColor)),
            (this.gitBranchLabel4 =
              this.gitBranchLabel4 || this.labelTextColor),
            (this.gitBranchLabel5 =
              this.gitBranchLabel5 || this.labelTextColor),
            (this.gitBranchLabel6 =
              this.gitBranchLabel6 || this.labelTextColor),
            (this.gitBranchLabel7 =
              this.gitBranchLabel7 || this.labelTextColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground =
              this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || "10px"),
            (this.commitLabelColor =
              this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground =
              this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || "10px"),
            (this.attributeBackgroundColorOdd =
              this.attributeBackgroundColorOdd || jl),
            (this.attributeBackgroundColorEven =
              this.attributeBackgroundColorEven || ql));
        }
        calculate(t) {
          if (typeof t != "object") {
            this.updateColors();
            return;
          }
          let r = Object.keys(t);
          (r.forEach((n) => {
            this[n] = t[n];
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n];
            }));
        }
      }),
        (zI = a((e) => {
          let t = new JC();
          return (t.calculate(e), t);
        }, "getThemeVariables")));
    });
  var tw,
    UI,
    jI = x(() => {
      "use strict";
      Us();
      lf();
      Km();
      ((tw = class {
        static {
          a(this, "Theme");
        }
        constructor() {
          ((this.primaryColor = "#eee"),
            (this.contrast = "#707070"),
            (this.secondaryColor = Yt(this.contrast, 55)),
            (this.background = "#ffffff"),
            (this.tertiaryColor = ut(this.primaryColor, { h: -160 })),
            (this.primaryBorderColor = wn(this.primaryColor, this.darkMode)),
            (this.secondaryBorderColor = wn(
              this.secondaryColor,
              this.darkMode,
            )),
            (this.tertiaryBorderColor = wn(this.tertiaryColor, this.darkMode)),
            (this.primaryTextColor = Ut(this.primaryColor)),
            (this.secondaryTextColor = Ut(this.secondaryColor)),
            (this.tertiaryTextColor = Ut(this.tertiaryColor)),
            (this.lineColor = Ut(this.background)),
            (this.textColor = Ut(this.background)),
            (this.mainBkg = "#eee"),
            (this.secondBkg = "calculated"),
            (this.lineColor = "#666"),
            (this.border1 = "#999"),
            (this.border2 = "calculated"),
            (this.note = "#ffa"),
            (this.text = "#333"),
            (this.critical = "#d42"),
            (this.done = "#bbb"),
            (this.arrowheadColor = "#333333"),
            (this.fontFamily = '"trebuchet ms", verdana, arial, sans-serif'),
            (this.fontSize = "16px"),
            (this.THEME_COLOR_LIMIT = 12),
            (this.nodeBkg = "calculated"),
            (this.nodeBorder = "calculated"),
            (this.clusterBkg = "calculated"),
            (this.clusterBorder = "calculated"),
            (this.defaultLinkColor = "calculated"),
            (this.titleColor = "calculated"),
            (this.edgeLabelBackground = "white"),
            (this.actorBorder = "calculated"),
            (this.actorBkg = "calculated"),
            (this.actorTextColor = "calculated"),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = "calculated"),
            (this.signalTextColor = "calculated"),
            (this.labelBoxBkgColor = "calculated"),
            (this.labelBoxBorderColor = "calculated"),
            (this.labelTextColor = "calculated"),
            (this.loopTextColor = "calculated"),
            (this.noteBorderColor = "calculated"),
            (this.noteBkgColor = "calculated"),
            (this.noteTextColor = "calculated"),
            (this.activationBorderColor = "#666"),
            (this.activationBkgColor = "#f4f4f4"),
            (this.sequenceNumberColor = "white"),
            (this.sectionBkgColor = "calculated"),
            (this.altSectionBkgColor = "white"),
            (this.sectionBkgColor2 = "calculated"),
            (this.excludeBkgColor = "#eeeeee"),
            (this.taskBorderColor = "calculated"),
            (this.taskBkgColor = "calculated"),
            (this.taskTextLightColor = "white"),
            (this.taskTextColor = "calculated"),
            (this.taskTextDarkColor = "calculated"),
            (this.taskTextOutsideColor = "calculated"),
            (this.taskTextClickableColor = "#003163"),
            (this.activeTaskBorderColor = "calculated"),
            (this.activeTaskBkgColor = "calculated"),
            (this.gridColor = "calculated"),
            (this.doneTaskBkgColor = "calculated"),
            (this.doneTaskBorderColor = "calculated"),
            (this.critBkgColor = "calculated"),
            (this.critBorderColor = "calculated"),
            (this.todayLineColor = "calculated"),
            (this.vertLineColor = "calculated"),
            (this.personBorder = this.primaryBorderColor),
            (this.personBkg = this.mainBkg),
            (this.archEdgeColor = "calculated"),
            (this.archEdgeArrowColor = "calculated"),
            (this.archEdgeWidth = "3"),
            (this.archGroupBorderColor = this.primaryBorderColor),
            (this.archGroupBorderWidth = "2px"),
            (this.rowOdd = this.rowOdd || Yt(this.mainBkg, 75) || "#ffffff"),
            (this.rowEven = this.rowEven || "#f4f4f4"),
            (this.labelColor = "black"),
            (this.errorBkgColor = "#552222"),
            (this.errorTextColor = "#552222"));
        }
        updateColors() {
          ((this.secondBkg = Yt(this.contrast, 55)),
            (this.border2 = this.contrast),
            (this.actorBorder = Yt(this.border1, 23)),
            (this.actorBkg = this.mainBkg),
            (this.actorTextColor = this.text),
            (this.actorLineColor = this.actorBorder),
            (this.signalColor = this.text),
            (this.signalTextColor = this.text),
            (this.labelBoxBkgColor = this.actorBkg),
            (this.labelBoxBorderColor = this.actorBorder),
            (this.labelTextColor = this.text),
            (this.loopTextColor = this.text),
            (this.noteBorderColor = "#999"),
            (this.noteBkgColor = "#666"),
            (this.noteTextColor = "#fff"),
            (this.cScale0 = this.cScale0 || "#555"),
            (this.cScale1 = this.cScale1 || "#F4F4F4"),
            (this.cScale2 = this.cScale2 || "#555"),
            (this.cScale3 = this.cScale3 || "#BBB"),
            (this.cScale4 = this.cScale4 || "#777"),
            (this.cScale5 = this.cScale5 || "#999"),
            (this.cScale6 = this.cScale6 || "#DDD"),
            (this.cScale7 = this.cScale7 || "#FFF"),
            (this.cScale8 = this.cScale8 || "#DDD"),
            (this.cScale9 = this.cScale9 || "#BBB"),
            (this.cScale10 = this.cScale10 || "#999"),
            (this.cScale11 = this.cScale11 || "#777"));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleInv" + t] =
              this["cScaleInv" + t] || Ut(this["cScale" + t]);
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this.darkMode
              ? (this["cScalePeer" + t] =
                  this["cScalePeer" + t] || Yt(this["cScale" + t], 10))
              : (this["cScalePeer" + t] =
                  this["cScalePeer" + t] || ee(this["cScale" + t], 10));
          ((this.scaleLabelColor =
            this.scaleLabelColor ||
            (this.darkMode ? "black" : this.labelTextColor)),
            (this.cScaleLabel0 = this.cScaleLabel0 || this.cScale1),
            (this.cScaleLabel2 = this.cScaleLabel2 || this.cScale1));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["cScaleLabel" + t] =
              this["cScaleLabel" + t] || this.scaleLabelColor;
          for (let t = 0; t < 5; t++)
            ((this["surface" + t] =
              this["surface" + t] || ut(this.mainBkg, { l: -(5 + t * 5) })),
              (this["surfacePeer" + t] =
                this["surfacePeer" + t] ||
                ut(this.mainBkg, { l: -(8 + t * 5) })));
          ((this.nodeBkg = this.mainBkg),
            (this.nodeBorder = this.border1),
            (this.clusterBkg = this.secondBkg),
            (this.clusterBorder = this.border2),
            (this.defaultLinkColor = this.lineColor),
            (this.titleColor = this.text),
            (this.sectionBkgColor = Yt(this.contrast, 30)),
            (this.sectionBkgColor2 = Yt(this.contrast, 30)),
            (this.taskBorderColor = ee(this.contrast, 10)),
            (this.taskBkgColor = this.contrast),
            (this.taskTextColor = this.taskTextLightColor),
            (this.taskTextDarkColor = this.text),
            (this.taskTextOutsideColor = this.taskTextDarkColor),
            (this.activeTaskBorderColor = this.taskBorderColor),
            (this.activeTaskBkgColor = this.mainBkg),
            (this.gridColor = Yt(this.border1, 30)),
            (this.doneTaskBkgColor = this.done),
            (this.doneTaskBorderColor = this.lineColor),
            (this.critBkgColor = this.critical),
            (this.critBorderColor = ee(this.critBkgColor, 10)),
            (this.todayLineColor = this.critBkgColor),
            (this.vertLineColor = this.critBkgColor),
            (this.archEdgeColor = this.lineColor),
            (this.archEdgeArrowColor = this.lineColor),
            (this.transitionColor = this.transitionColor || "#000"),
            (this.transitionLabelColor =
              this.transitionLabelColor || this.textColor),
            (this.stateLabelColor =
              this.stateLabelColor || this.stateBkg || this.primaryTextColor),
            (this.stateBkg = this.stateBkg || this.mainBkg),
            (this.labelBackgroundColor =
              this.labelBackgroundColor || this.stateBkg),
            (this.compositeBackground =
              this.compositeBackground ||
              this.background ||
              this.tertiaryColor),
            (this.altBackground = this.altBackground || "#f4f4f4"),
            (this.compositeTitleBackground =
              this.compositeTitleBackground || this.mainBkg),
            (this.stateBorder = this.stateBorder || "#000"),
            (this.innerEndBackground = this.primaryBorderColor),
            (this.specialStateColor = "#222"),
            (this.errorBkgColor = this.errorBkgColor || this.tertiaryColor),
            (this.errorTextColor =
              this.errorTextColor || this.tertiaryTextColor),
            (this.classText = this.primaryTextColor),
            (this.fillType0 = this.primaryColor),
            (this.fillType1 = this.secondaryColor),
            (this.fillType2 = ut(this.primaryColor, { h: 64 })),
            (this.fillType3 = ut(this.secondaryColor, { h: 64 })),
            (this.fillType4 = ut(this.primaryColor, { h: -64 })),
            (this.fillType5 = ut(this.secondaryColor, { h: -64 })),
            (this.fillType6 = ut(this.primaryColor, { h: 128 })),
            (this.fillType7 = ut(this.secondaryColor, { h: 128 })));
          for (let t = 0; t < this.THEME_COLOR_LIMIT; t++)
            this["pie" + t] = this["cScale" + t];
          ((this.pie12 = this.pie0),
            (this.pieTitleTextSize = this.pieTitleTextSize || "25px"),
            (this.pieTitleTextColor =
              this.pieTitleTextColor || this.taskTextDarkColor),
            (this.pieSectionTextSize = this.pieSectionTextSize || "17px"),
            (this.pieSectionTextColor =
              this.pieSectionTextColor || this.textColor),
            (this.pieLegendTextSize = this.pieLegendTextSize || "17px"),
            (this.pieLegendTextColor =
              this.pieLegendTextColor || this.taskTextDarkColor),
            (this.pieStrokeColor = this.pieStrokeColor || "black"),
            (this.pieStrokeWidth = this.pieStrokeWidth || "2px"),
            (this.pieOuterStrokeWidth = this.pieOuterStrokeWidth || "2px"),
            (this.pieOuterStrokeColor = this.pieOuterStrokeColor || "black"),
            (this.pieOpacity = this.pieOpacity || "0.7"),
            (this.quadrant1Fill = this.quadrant1Fill || this.primaryColor),
            (this.quadrant2Fill =
              this.quadrant2Fill ||
              ut(this.primaryColor, { r: 5, g: 5, b: 5 })),
            (this.quadrant3Fill =
              this.quadrant3Fill ||
              ut(this.primaryColor, { r: 10, g: 10, b: 10 })),
            (this.quadrant4Fill =
              this.quadrant4Fill ||
              ut(this.primaryColor, { r: 15, g: 15, b: 15 })),
            (this.quadrant1TextFill =
              this.quadrant1TextFill || this.primaryTextColor),
            (this.quadrant2TextFill =
              this.quadrant2TextFill ||
              ut(this.primaryTextColor, { r: -5, g: -5, b: -5 })),
            (this.quadrant3TextFill =
              this.quadrant3TextFill ||
              ut(this.primaryTextColor, { r: -10, g: -10, b: -10 })),
            (this.quadrant4TextFill =
              this.quadrant4TextFill ||
              ut(this.primaryTextColor, { r: -15, g: -15, b: -15 })),
            (this.quadrantPointFill =
              this.quadrantPointFill || Ni(this.quadrant1Fill)
                ? Yt(this.quadrant1Fill)
                : ee(this.quadrant1Fill)),
            (this.quadrantPointTextFill =
              this.quadrantPointTextFill || this.primaryTextColor),
            (this.quadrantXAxisTextFill =
              this.quadrantXAxisTextFill || this.primaryTextColor),
            (this.quadrantYAxisTextFill =
              this.quadrantYAxisTextFill || this.primaryTextColor),
            (this.quadrantInternalBorderStrokeFill =
              this.quadrantInternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantExternalBorderStrokeFill =
              this.quadrantExternalBorderStrokeFill || this.primaryBorderColor),
            (this.quadrantTitleFill =
              this.quadrantTitleFill || this.primaryTextColor),
            (this.xyChart = {
              backgroundColor: this.xyChart?.backgroundColor || this.background,
              titleColor: this.xyChart?.titleColor || this.primaryTextColor,
              xAxisTitleColor:
                this.xyChart?.xAxisTitleColor || this.primaryTextColor,
              xAxisLabelColor:
                this.xyChart?.xAxisLabelColor || this.primaryTextColor,
              xAxisTickColor:
                this.xyChart?.xAxisTickColor || this.primaryTextColor,
              xAxisLineColor:
                this.xyChart?.xAxisLineColor || this.primaryTextColor,
              yAxisTitleColor:
                this.xyChart?.yAxisTitleColor || this.primaryTextColor,
              yAxisLabelColor:
                this.xyChart?.yAxisLabelColor || this.primaryTextColor,
              yAxisTickColor:
                this.xyChart?.yAxisTickColor || this.primaryTextColor,
              yAxisLineColor:
                this.xyChart?.yAxisLineColor || this.primaryTextColor,
              plotColorPalette:
                this.xyChart?.plotColorPalette ||
                "#EEE,#6BB8E4,#8ACB88,#C7ACD6,#E8DCC2,#FFB2A8,#FFF380,#7E8D91,#FFD8B1,#FAF3E0",
            }),
            (this.radar = {
              axisColor: this.radar?.axisColor || this.lineColor,
              axisStrokeWidth: this.radar?.axisStrokeWidth || 2,
              axisLabelFontSize: this.radar?.axisLabelFontSize || 12,
              curveOpacity: this.radar?.curveOpacity || 0.5,
              curveStrokeWidth: this.radar?.curveStrokeWidth || 2,
              graticuleColor: this.radar?.graticuleColor || "#DEDEDE",
              graticuleStrokeWidth: this.radar?.graticuleStrokeWidth || 1,
              graticuleOpacity: this.radar?.graticuleOpacity || 0.3,
              legendBoxSize: this.radar?.legendBoxSize || 12,
              legendFontSize: this.radar?.legendFontSize || 12,
            }),
            (this.requirementBackground =
              this.requirementBackground || this.primaryColor),
            (this.requirementBorderColor =
              this.requirementBorderColor || this.primaryBorderColor),
            (this.requirementBorderSize = this.requirementBorderSize || "1"),
            (this.requirementTextColor =
              this.requirementTextColor || this.primaryTextColor),
            (this.relationColor = this.relationColor || this.lineColor),
            (this.relationLabelBackground =
              this.relationLabelBackground || this.edgeLabelBackground),
            (this.relationLabelColor =
              this.relationLabelColor || this.actorTextColor),
            (this.git0 = ee(this.pie1, 25) || this.primaryColor),
            (this.git1 = this.pie2 || this.secondaryColor),
            (this.git2 = this.pie3 || this.tertiaryColor),
            (this.git3 = this.pie4 || ut(this.primaryColor, { h: -30 })),
            (this.git4 = this.pie5 || ut(this.primaryColor, { h: -60 })),
            (this.git5 = this.pie6 || ut(this.primaryColor, { h: -90 })),
            (this.git6 = this.pie7 || ut(this.primaryColor, { h: 60 })),
            (this.git7 = this.pie8 || ut(this.primaryColor, { h: 120 })),
            (this.gitInv0 = this.gitInv0 || Ut(this.git0)),
            (this.gitInv1 = this.gitInv1 || Ut(this.git1)),
            (this.gitInv2 = this.gitInv2 || Ut(this.git2)),
            (this.gitInv3 = this.gitInv3 || Ut(this.git3)),
            (this.gitInv4 = this.gitInv4 || Ut(this.git4)),
            (this.gitInv5 = this.gitInv5 || Ut(this.git5)),
            (this.gitInv6 = this.gitInv6 || Ut(this.git6)),
            (this.gitInv7 = this.gitInv7 || Ut(this.git7)),
            (this.branchLabelColor =
              this.branchLabelColor || this.labelTextColor),
            (this.gitBranchLabel0 = this.branchLabelColor),
            (this.gitBranchLabel1 = "white"),
            (this.gitBranchLabel2 = this.branchLabelColor),
            (this.gitBranchLabel3 = "white"),
            (this.gitBranchLabel4 = this.branchLabelColor),
            (this.gitBranchLabel5 = this.branchLabelColor),
            (this.gitBranchLabel6 = this.branchLabelColor),
            (this.gitBranchLabel7 = this.branchLabelColor),
            (this.tagLabelColor = this.tagLabelColor || this.primaryTextColor),
            (this.tagLabelBackground =
              this.tagLabelBackground || this.primaryColor),
            (this.tagLabelBorder = this.tagBorder || this.primaryBorderColor),
            (this.tagLabelFontSize = this.tagLabelFontSize || "10px"),
            (this.commitLabelColor =
              this.commitLabelColor || this.secondaryTextColor),
            (this.commitLabelBackground =
              this.commitLabelBackground || this.secondaryColor),
            (this.commitLabelFontSize = this.commitLabelFontSize || "10px"),
            (this.attributeBackgroundColorOdd =
              this.attributeBackgroundColorOdd || jl),
            (this.attributeBackgroundColorEven =
              this.attributeBackgroundColorEven || ql));
        }
        calculate(t) {
          if (typeof t != "object") {
            this.updateColors();
            return;
          }
          let r = Object.keys(t);
          (r.forEach((n) => {
            this[n] = t[n];
          }),
            this.updateColors(),
            r.forEach((n) => {
              this[n] = t[n];
            }));
        }
      }),
        (UI = a((e) => {
          let t = new tw();
          return (t.calculate(e), t);
        }, "getThemeVariables")));
    });
  var js,
    dx = x(() => {
      "use strict";
      $I();
      VI();
      Qm();
      WI();
      jI();
      js = {
        base: { getThemeVariables: FI },
        dark: { getThemeVariables: GI },
        default: { getThemeVariables: Hl },
        forest: { getThemeVariables: zI },
        neutral: { getThemeVariables: UI },
      };
    });
  var Ta,
    qI = x(() => {
      "use strict";
      Ta = {
        flowchart: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          subGraphTitleMargin: { top: 0, bottom: 0 },
          diagramPadding: 8,
          htmlLabels: !0,
          nodeSpacing: 50,
          rankSpacing: 50,
          curve: "basis",
          padding: 15,
          defaultRenderer: "dagre-wrapper",
          wrappingWidth: 200,
          inheritDir: !1,
        },
        sequence: {
          useMaxWidth: !0,
          hideUnusedParticipants: !1,
          activationWidth: 10,
          diagramMarginX: 50,
          diagramMarginY: 10,
          actorMargin: 50,
          width: 150,
          height: 65,
          boxMargin: 10,
          boxTextMargin: 5,
          noteMargin: 10,
          messageMargin: 35,
          messageAlign: "center",
          mirrorActors: !0,
          forceMenus: !1,
          bottomMarginAdj: 1,
          rightAngles: !1,
          showSequenceNumbers: !1,
          actorFontSize: 14,
          actorFontFamily: '"Open Sans", sans-serif',
          actorFontWeight: 400,
          noteFontSize: 14,
          noteFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
          noteFontWeight: 400,
          noteAlign: "center",
          messageFontSize: 16,
          messageFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
          messageFontWeight: 400,
          wrap: !1,
          wrapPadding: 10,
          labelBoxWidth: 50,
          labelBoxHeight: 20,
        },
        gantt: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          barHeight: 20,
          barGap: 4,
          topPadding: 50,
          rightPadding: 75,
          leftPadding: 75,
          gridLineStartPadding: 35,
          fontSize: 11,
          sectionFontSize: 11,
          numberSectionStyles: 4,
          axisFormat: "%Y-%m-%d",
          topAxis: !1,
          displayMode: "",
          weekday: "sunday",
        },
        journey: {
          useMaxWidth: !0,
          diagramMarginX: 50,
          diagramMarginY: 10,
          leftMargin: 150,
          maxLabelWidth: 360,
          width: 150,
          height: 50,
          boxMargin: 10,
          boxTextMargin: 5,
          noteMargin: 10,
          messageMargin: 35,
          messageAlign: "center",
          bottomMarginAdj: 1,
          rightAngles: !1,
          taskFontSize: 14,
          taskFontFamily: '"Open Sans", sans-serif',
          taskMargin: 50,
          activationWidth: 10,
          textPlacement: "fo",
          actorColours: [
            "#8FBC8F",
            "#7CFC00",
            "#00FFFF",
            "#20B2AA",
            "#B0E0E6",
            "#FFFFE0",
          ],
          sectionFills: [
            "#191970",
            "#8B008B",
            "#4B0082",
            "#2F4F4F",
            "#800000",
            "#8B4513",
            "#00008B",
          ],
          sectionColours: ["#fff"],
          titleColor: "",
          titleFontFamily: '"trebuchet ms", verdana, arial, sans-serif',
          titleFontSize: "4ex",
        },
        class: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          arrowMarkerAbsolute: !1,
          dividerMargin: 10,
          padding: 5,
          textHeight: 10,
          defaultRenderer: "dagre-wrapper",
          htmlLabels: !1,
          hideEmptyMembersBox: !1,
        },
        state: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          dividerMargin: 10,
          sizeUnit: 5,
          padding: 8,
          textHeight: 10,
          titleShift: -15,
          noteMargin: 10,
          forkWidth: 70,
          forkHeight: 7,
          miniPadding: 2,
          fontSizeFactor: 5.02,
          fontSize: 24,
          labelHeight: 16,
          edgeLengthFactor: "20",
          compositTitleSize: 35,
          radius: 5,
          defaultRenderer: "dagre-wrapper",
        },
        er: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          diagramPadding: 20,
          layoutDirection: "TB",
          minEntityWidth: 100,
          minEntityHeight: 75,
          entityPadding: 15,
          nodeSpacing: 140,
          rankSpacing: 80,
          stroke: "gray",
          fill: "honeydew",
          fontSize: 12,
        },
        pie: { useMaxWidth: !0, textPosition: 0.75 },
        quadrantChart: {
          useMaxWidth: !0,
          chartWidth: 500,
          chartHeight: 500,
          titleFontSize: 20,
          titlePadding: 10,
          quadrantPadding: 5,
          xAxisLabelPadding: 5,
          yAxisLabelPadding: 5,
          xAxisLabelFontSize: 16,
          yAxisLabelFontSize: 16,
          quadrantLabelFontSize: 16,
          quadrantTextTopPadding: 5,
          pointTextPadding: 5,
          pointLabelFontSize: 12,
          pointRadius: 5,
          xAxisPosition: "top",
          yAxisPosition: "left",
          quadrantInternalBorderStrokeWidth: 1,
          quadrantExternalBorderStrokeWidth: 2,
        },
        xyChart: {
          useMaxWidth: !0,
          width: 700,
          height: 500,
          titleFontSize: 20,
          titlePadding: 10,
          showDataLabel: !1,
          showTitle: !0,
          xAxis: {
            $ref: "#/$defs/XYChartAxisConfig",
            showLabel: !0,
            labelFontSize: 14,
            labelPadding: 5,
            showTitle: !0,
            titleFontSize: 16,
            titlePadding: 5,
            showTick: !0,
            tickLength: 5,
            tickWidth: 2,
            showAxisLine: !0,
            axisLineWidth: 2,
          },
          yAxis: {
            $ref: "#/$defs/XYChartAxisConfig",
            showLabel: !0,
            labelFontSize: 14,
            labelPadding: 5,
            showTitle: !0,
            titleFontSize: 16,
            titlePadding: 5,
            showTick: !0,
            tickLength: 5,
            tickWidth: 2,
            showAxisLine: !0,
            axisLineWidth: 2,
          },
          chartOrientation: "vertical",
          plotReservedSpacePercent: 50,
        },
        requirement: {
          useMaxWidth: !0,
          rect_fill: "#f9f9f9",
          text_color: "#333",
          rect_border_size: "0.5px",
          rect_border_color: "#bbb",
          rect_min_width: 200,
          rect_min_height: 200,
          fontSize: 14,
          rect_padding: 10,
          line_height: 20,
        },
        mindmap: {
          useMaxWidth: !0,
          padding: 10,
          maxNodeWidth: 200,
          layoutAlgorithm: "cose-bilkent",
        },
        kanban: {
          useMaxWidth: !0,
          padding: 8,
          sectionWidth: 200,
          ticketBaseUrl: "",
        },
        timeline: {
          useMaxWidth: !0,
          diagramMarginX: 50,
          diagramMarginY: 10,
          leftMargin: 150,
          width: 150,
          height: 50,
          boxMargin: 10,
          boxTextMargin: 5,
          noteMargin: 10,
          messageMargin: 35,
          messageAlign: "center",
          bottomMarginAdj: 1,
          rightAngles: !1,
          taskFontSize: 14,
          taskFontFamily: '"Open Sans", sans-serif',
          taskMargin: 50,
          activationWidth: 10,
          textPlacement: "fo",
          actorColours: [
            "#8FBC8F",
            "#7CFC00",
            "#00FFFF",
            "#20B2AA",
            "#B0E0E6",
            "#FFFFE0",
          ],
          sectionFills: [
            "#191970",
            "#8B008B",
            "#4B0082",
            "#2F4F4F",
            "#800000",
            "#8B4513",
            "#00008B",
          ],
          sectionColours: ["#fff"],
          disableMulticolor: !1,
        },
        gitGraph: {
          useMaxWidth: !0,
          titleTopMargin: 25,
          diagramPadding: 8,
          nodeLabel: { width: 75, height: 100, x: -25, y: 0 },
          mainBranchName: "main",
          mainBranchOrder: 0,
          showCommitLabel: !0,
          showBranches: !0,
          rotateCommitLabel: !0,
          parallelCommits: !1,
          arrowMarkerAbsolute: !1,
        },
        c4: {
          useMaxWidth: !0,
          diagramMarginX: 50,
          diagramMarginY: 10,
          c4ShapeMargin: 50,
          c4ShapePadding: 20,
          width: 216,
          height: 60,
          boxMargin: 10,
          c4ShapeInRow: 4,
          nextLinePaddingX: 0,
          c4BoundaryInRow: 2,
          personFontSize: 14,
          personFontFamily: '"Open Sans", sans-serif',
          personFontWeight: "normal",
          external_personFontSize: 14,
          external_personFontFamily: '"Open Sans", sans-serif',
          external_personFontWeight: "normal",
          systemFontSize: 14,
          systemFontFamily: '"Open Sans", sans-serif',
          systemFontWeight: "normal",
          external_systemFontSize: 14,
          external_systemFontFamily: '"Open Sans", sans-serif',
          external_systemFontWeight: "normal",
          system_dbFontSize: 14,
          system_dbFontFamily: '"Open Sans", sans-serif',
          system_dbFontWeight: "normal",
          external_system_dbFontSize: 14,
          external_system_dbFontFamily: '"Open Sans", sans-serif',
          external_system_dbFontWeight: "normal",
          system_queueFontSize: 14,
          system_queueFontFamily: '"Open Sans", sans-serif',
          system_queueFontWeight: "normal",
          external_system_queueFontSize: 14,
          external_system_queueFontFamily: '"Open Sans", sans-serif',
          external_system_queueFontWeight: "normal",
          boundaryFontSize: 14,
          boundaryFontFamily: '"Open Sans", sans-serif',
          boundaryFontWeight: "normal",
          messageFontSize: 12,
          messageFontFamily: '"Open Sans", sans-serif',
          messageFontWeight: "normal",
          containerFontSize: 14,
          containerFontFamily: '"Open Sans", sans-serif',
          containerFontWeight: "normal",
          external_containerFontSize: 14,
          external_containerFontFamily: '"Open Sans", sans-serif',
          external_containerFontWeight: "normal",
          container_dbFontSize: 14,
          container_dbFontFamily: '"Open Sans", sans-serif',
          container_dbFontWeight: "normal",
          external_container_dbFontSize: 14,
          external_container_dbFontFamily: '"Open Sans", sans-serif',
          external_container_dbFontWeight: "normal",
          container_queueFontSize: 14,
          container_queueFontFamily: '"Open Sans", sans-serif',
          container_queueFontWeight: "normal",
          external_container_queueFontSize: 14,
          external_container_queueFontFamily: '"Open Sans", sans-serif',
          external_container_queueFontWeight: "normal",
          componentFontSize: 14,
          componentFontFamily: '"Open Sans", sans-serif',
          componentFontWeight: "normal",
          external_componentFontSize: 14,
          external_componentFontFamily: '"Open Sans", sans-serif',
          external_componentFontWeight: "normal",
          component_dbFontSize: 14,
          component_dbFontFamily: '"Open Sans", sans-serif',
          component_dbFontWeight: "normal",
          external_component_dbFontSize: 14,
          external_component_dbFontFamily: '"Open Sans", sans-serif',
          external_component_dbFontWeight: "normal",
          component_queueFontSize: 14,
          component_queueFontFamily: '"Open Sans", sans-serif',
          component_queueFontWeight: "normal",
          external_component_queueFontSize: 14,
          external_component_queueFontFamily: '"Open Sans", sans-serif',
          external_component_queueFontWeight: "normal",
          wrap: !0,
          wrapPadding: 10,
          person_bg_color: "#08427B",
          person_border_color: "#073B6F",
          external_person_bg_color: "#686868",
          external_person_border_color: "#8A8A8A",
          system_bg_color: "#1168BD",
          system_border_color: "#3C7FC0",
          system_db_bg_color: "#1168BD",
          system_db_border_color: "#3C7FC0",
          system_queue_bg_color: "#1168BD",
          system_queue_border_color: "#3C7FC0",
          external_system_bg_color: "#999999",
          external_system_border_color: "#8A8A8A",
          external_system_db_bg_color: "#999999",
          external_system_db_border_color: "#8A8A8A",
          external_system_queue_bg_color: "#999999",
          external_system_queue_border_color: "#8A8A8A",
          container_bg_color: "#438DD5",
          container_border_color: "#3C7FC0",
          container_db_bg_color: "#438DD5",
          container_db_border_color: "#3C7FC0",
          container_queue_bg_color: "#438DD5",
          container_queue_border_color: "#3C7FC0",
          external_container_bg_color: "#B3B3B3",
          external_container_border_color: "#A6A6A6",
          external_container_db_bg_color: "#B3B3B3",
          external_container_db_border_color: "#A6A6A6",
          external_container_queue_bg_color: "#B3B3B3",
          external_container_queue_border_color: "#A6A6A6",
          component_bg_color: "#85BBF0",
          component_border_color: "#78A8D8",
          component_db_bg_color: "#85BBF0",
          component_db_border_color: "#78A8D8",
          component_queue_bg_color: "#85BBF0",
          component_queue_border_color: "#78A8D8",
          external_component_bg_color: "#CCCCCC",
          external_component_border_color: "#BFBFBF",
          external_component_db_bg_color: "#CCCCCC",
          external_component_db_border_color: "#BFBFBF",
          external_component_queue_bg_color: "#CCCCCC",
          external_component_queue_border_color: "#BFBFBF",
        },
        sankey: {
          useMaxWidth: !0,
          width: 600,
          height: 400,
          linkColor: "gradient",
          nodeAlignment: "justify",
          showValues: !0,
          prefix: "",
          suffix: "",
        },
        block: { useMaxWidth: !0, padding: 8 },
        packet: {
          useMaxWidth: !0,
          rowHeight: 32,
          bitWidth: 32,
          bitsPerRow: 32,
          showBits: !0,
          paddingX: 5,
          paddingY: 5,
        },
        architecture: {
          useMaxWidth: !0,
          padding: 40,
          iconSize: 80,
          fontSize: 16,
        },
        radar: {
          useMaxWidth: !0,
          width: 600,
          height: 600,
          marginTop: 50,
          marginRight: 50,
          marginBottom: 50,
          marginLeft: 50,
          axisScaleFactor: 1,
          axisLabelFactor: 1.05,
          curveTension: 0.17,
        },
        theme: "default",
        look: "classic",
        handDrawnSeed: 0,
        layout: "dagre",
        maxTextSize: 5e4,
        maxEdges: 500,
        darkMode: !1,
        fontFamily: '"trebuchet ms", verdana, arial, sans-serif;',
        logLevel: 5,
        securityLevel: "strict",
        startOnLoad: !0,
        arrowMarkerAbsolute: !1,
        secure: [
          "secure",
          "securityLevel",
          "startOnLoad",
          "maxTextSize",
          "suppressErrorRendering",
          "maxEdges",
        ],
        legacyMathML: !1,
        forceLegacyMathML: !1,
        deterministicIds: !1,
        fontSize: 16,
        markdownAutoWrap: !0,
        suppressErrorRendering: !1,
      };
    });
  var HI,
    YI,
    XI,
    ze,
    Ss = x(() => {
      "use strict";
      dx();
      qI();
      ((HI = {
        ...Ta,
        deterministicIDSeed: void 0,
        elk: {
          mergeEdges: !1,
          nodePlacementStrategy: "BRANDES_KOEPF",
          forceNodeModelOrder: !1,
          considerModelOrder: "NODES_AND_EDGES",
        },
        themeCSS: void 0,
        themeVariables: js.default.getThemeVariables(),
        sequence: {
          ...Ta.sequence,
          messageFont: a(function () {
            return {
              fontFamily: this.messageFontFamily,
              fontSize: this.messageFontSize,
              fontWeight: this.messageFontWeight,
            };
          }, "messageFont"),
          noteFont: a(function () {
            return {
              fontFamily: this.noteFontFamily,
              fontSize: this.noteFontSize,
              fontWeight: this.noteFontWeight,
            };
          }, "noteFont"),
          actorFont: a(function () {
            return {
              fontFamily: this.actorFontFamily,
              fontSize: this.actorFontSize,
              fontWeight: this.actorFontWeight,
            };
          }, "actorFont"),
        },
        class: { hideEmptyMembersBox: !1 },
        gantt: { ...Ta.gantt, tickInterval: void 0, useWidth: void 0 },
        c4: {
          ...Ta.c4,
          useWidth: void 0,
          personFont: a(function () {
            return {
              fontFamily: this.personFontFamily,
              fontSize: this.personFontSize,
              fontWeight: this.personFontWeight,
            };
          }, "personFont"),
          flowchart: { ...Ta.flowchart, inheritDir: !1 },
          external_personFont: a(function () {
            return {
              fontFamily: this.external_personFontFamily,
              fontSize: this.external_personFontSize,
              fontWeight: this.external_personFontWeight,
            };
          }, "external_personFont"),
          systemFont: a(function () {
            return {
              fontFamily: this.systemFontFamily,
              fontSize: this.systemFontSize,
              fontWeight: this.systemFontWeight,
            };
          }, "systemFont"),
          external_systemFont: a(function () {
            return {
              fontFamily: this.external_systemFontFamily,
              fontSize: this.external_systemFontSize,
              fontWeight: this.external_systemFontWeight,
            };
          }, "external_systemFont"),
          system_dbFont: a(function () {
            return {
              fontFamily: this.system_dbFontFamily,
              fontSize: this.system_dbFontSize,
              fontWeight: this.system_dbFontWeight,
            };
          }, "system_dbFont"),
          external_system_dbFont: a(function () {
            return {
              fontFamily: this.external_system_dbFontFamily,
              fontSize: this.external_system_dbFontSize,
              fontWeight: this.external_system_dbFontWeight,
            };
          }, "external_system_dbFont"),
          system_queueFont: a(function () {
            return {
              fontFamily: this.system_queueFontFamily,
              fontSize: this.system_queueFontSize,
              fontWeight: this.system_queueFontWeight,
            };
          }, "system_queueFont"),
          external_system_queueFont: a(function () {
            return {
              fontFamily: this.external_system_queueFontFamily,
              fontSize: this.external_system_queueFontSize,
              fontWeight: this.external_system_queueFontWeight,
            };
          }, "external_system_queueFont"),
          containerFont: a(function () {
            return {
              fontFamily: this.containerFontFamily,
              fontSize: this.containerFontSize,
              fontWeight: this.containerFontWeight,
            };
          }, "containerFont"),
          external_containerFont: a(function () {
            return {
              fontFamily: this.external_containerFontFamily,
              fontSize: this.external_containerFontSize,
              fontWeight: this.external_containerFontWeight,
            };
          }, "external_containerFont"),
          container_dbFont: a(function () {
            return {
              fontFamily: this.container_dbFontFamily,
              fontSize: this.container_dbFontSize,
              fontWeight: this.container_dbFontWeight,
            };
          }, "container_dbFont"),
          external_container_dbFont: a(function () {
            return {
              fontFamily: this.external_container_dbFontFamily,
              fontSize: this.external_container_dbFontSize,
              fontWeight: this.external_container_dbFontWeight,
            };
          }, "external_container_dbFont"),
          container_queueFont: a(function () {
            return {
              fontFamily: this.container_queueFontFamily,
              fontSize: this.container_queueFontSize,
              fontWeight: this.container_queueFontWeight,
            };
          }, "container_queueFont"),
          external_container_queueFont: a(function () {
            return {
              fontFamily: this.external_container_queueFontFamily,
              fontSize: this.external_container_queueFontSize,
              fontWeight: this.external_container_queueFontWeight,
            };
          }, "external_container_queueFont"),
          componentFont: a(function () {
            return {
              fontFamily: this.componentFontFamily,
              fontSize: this.componentFontSize,
              fontWeight: this.componentFontWeight,
            };
          }, "componentFont"),
          external_componentFont: a(function () {
            return {
              fontFamily: this.external_componentFontFamily,
              fontSize: this.external_componentFontSize,
              fontWeight: this.external_componentFontWeight,
            };
          }, "external_componentFont"),
          component_dbFont: a(function () {
            return {
              fontFamily: this.component_dbFontFamily,
              fontSize: this.component_dbFontSize,
              fontWeight: this.component_dbFontWeight,
            };
          }, "component_dbFont"),
          external_component_dbFont: a(function () {
            return {
              fontFamily: this.external_component_dbFontFamily,
              fontSize: this.external_component_dbFontSize,
              fontWeight: this.external_component_dbFontWeight,
            };
          }, "external_component_dbFont"),
          component_queueFont: a(function () {
            return {
              fontFamily: this.component_queueFontFamily,
              fontSize: this.component_queueFontSize,
              fontWeight: this.component_queueFontWeight,
            };
          }, "component_queueFont"),
          external_component_queueFont: a(function () {
            return {
              fontFamily: this.external_component_queueFontFamily,
              fontSize: this.external_component_queueFontSize,
              fontWeight: this.external_component_queueFontWeight,
            };
          }, "external_component_queueFont"),
          boundaryFont: a(function () {
            return {
              fontFamily: this.boundaryFontFamily,
              fontSize: this.boundaryFontSize,
              fontWeight: this.boundaryFontWeight,
            };
          }, "boundaryFont"),
          messageFont: a(function () {
            return {
              fontFamily: this.messageFontFamily,
              fontSize: this.messageFontSize,
              fontWeight: this.messageFontWeight,
            };
          }, "messageFont"),
        },
        pie: { ...Ta.pie, useWidth: 984 },
        xyChart: { ...Ta.xyChart, useWidth: void 0 },
        requirement: { ...Ta.requirement, useWidth: void 0 },
        packet: { ...Ta.packet },
        radar: { ...Ta.radar },
        treemap: {
          useMaxWidth: !0,
          padding: 10,
          diagramPadding: 8,
          showValues: !0,
          nodeWidth: 100,
          nodeHeight: 40,
          borderWidth: 1,
          valueFontSize: 12,
          labelFontSize: 14,
          valueFormat: ",",
        },
      }),
        (YI = a(
          (e, t = "") =>
            Object.keys(e).reduce(
              (r, n) =>
                Array.isArray(e[n])
                  ? r
                  : typeof e[n] == "object" && e[n] !== null
                    ? [...r, t + n, ...YI(e[n], "")]
                    : [...r, t + n],
              [],
            ),
          "keyify",
        )),
        (XI = new Set(YI(HI, ""))),
        (ze = HI));
    });
  var cf,
    Lct,
    ew = x(() => {
      "use strict";
      Ss();
      Vt();
      ((cf = a((e) => {
        if (
          (P.debug("sanitizeDirective called with", e),
          !(typeof e != "object" || e == null))
        ) {
          if (Array.isArray(e)) {
            e.forEach((t) => cf(t));
            return;
          }
          for (let t of Object.keys(e)) {
            if (
              (P.debug("Checking key", t),
              t.startsWith("__") ||
                t.includes("proto") ||
                t.includes("constr") ||
                !XI.has(t) ||
                e[t] == null)
            ) {
              (P.debug("sanitize deleting key: ", t), delete e[t]);
              continue;
            }
            if (typeof e[t] == "object") {
              (P.debug("sanitizing object", t), cf(e[t]));
              continue;
            }
            let r = ["themeCSS", "fontFamily", "altFontFamily"];
            for (let n of r)
              t.includes(n) &&
                (P.debug("sanitizing css option", t), (e[t] = Lct(e[t])));
          }
          if (e.themeVariables)
            for (let t of Object.keys(e.themeVariables)) {
              let r = e.themeVariables[t];
              r?.match &&
                !r.match(/^[\d "#%(),.;A-Za-z]+$/) &&
                (e.themeVariables[t] = "");
            }
          P.debug("After sanitization", e);
        }
      }, "sanitizeDirective")),
        (Lct = a((e) => {
          let t = 0,
            r = 0;
          for (let n of e) {
            if (t < r) return "{ /* ERROR: Unbalanced CSS */ }";
            n === "{" ? t++ : n === "}" && r++;
          }
          return t !== r ? "{ /* ERROR: Unbalanced CSS */ }" : e;
        }, "sanitizeCss")));
    });
  var Yl,
    ts,
    QI,
    uf,
    Zm,
    px,
    rw,
    ZI,
    JI,
    nw,
    mx,
    ke,
    t7,
    e7,
    Jm,
    Rct,
    KI,
    Dct,
    r7,
    un = x(() => {
      "use strict";
      of();
      Vt();
      dx();
      Ss();
      ew();
      ((Yl = Object.freeze(ze)),
        (ts = Xr({}, Yl)),
        (uf = []),
        (Zm = Xr({}, Yl)),
        (px = a((e, t) => {
          let r = Xr({}, e),
            n = {};
          for (let i of t) (t7(i), (n = Xr(n, i)));
          if (((r = Xr(r, n)), n.theme && n.theme in js)) {
            let i = Xr({}, QI),
              s = Xr(i.themeVariables || {}, n.themeVariables);
            r.theme &&
              r.theme in js &&
              (r.themeVariables = js[r.theme].getThemeVariables(s));
          }
          return ((Zm = r), r7(Zm), Zm);
        }, "updateCurrentConfig")),
        (rw = a(
          (e) => (
            (ts = Xr({}, Yl)),
            (ts = Xr(ts, e)),
            e.theme &&
              js[e.theme] &&
              (ts.themeVariables = js[e.theme].getThemeVariables(
                e.themeVariables,
              )),
            px(ts, uf),
            ts
          ),
          "setSiteConfig",
        )),
        (ZI = a((e) => {
          QI = Xr({}, e);
        }, "saveConfigFromInitialize")),
        (JI = a((e) => ((ts = Xr(ts, e)), px(ts, uf), ts), "updateSiteConfig")),
        (nw = a(() => Xr({}, ts), "getSiteConfig")),
        (mx = a((e) => (r7(e), Xr(Zm, e), ke()), "setConfig")),
        (ke = a(() => Xr({}, Zm), "getConfig")),
        (t7 = a((e) => {
          e &&
            (["secure", ...(ts.secure ?? [])].forEach((t) => {
              Object.hasOwn(e, t) &&
                (P.debug(`Denied attempt to modify a secure key ${t}`, e[t]),
                delete e[t]);
            }),
            Object.keys(e).forEach((t) => {
              t.startsWith("__") && delete e[t];
            }),
            Object.keys(e).forEach((t) => {
              (typeof e[t] == "string" &&
                (e[t].includes("<") ||
                  e[t].includes(">") ||
                  e[t].includes("url(data:")) &&
                delete e[t],
                typeof e[t] == "object" && t7(e[t]));
            }));
        }, "sanitize")),
        (e7 = a((e) => {
          (cf(e),
            e.fontFamily &&
              !e.themeVariables?.fontFamily &&
              (e.themeVariables = {
                ...e.themeVariables,
                fontFamily: e.fontFamily,
              }),
            uf.push(e),
            px(ts, uf));
        }, "addDirective")),
        (Jm = a((e = ts) => {
          ((uf = []), px(e, uf));
        }, "reset")),
        (Rct = {
          LAZY_LOAD_DEPRECATED:
            "The configuration options lazyLoadedDiagrams and loadExternalDiagramsAtStartup are deprecated. Please use registerExternalDiagrams instead.",
        }),
        (KI = {}),
        (Dct = a((e) => {
          KI[e] || (P.warn(Rct[e]), (KI[e] = !0));
        }, "issueWarning")),
        (r7 = a((e) => {
          e &&
            (e.lazyLoadedDiagrams || e.loadExternalDiagramsAtStartup) &&
            Dct("LAZY_LOAD_DEPRECATED");
        }, "checkConfig")));
    });
  function Oi(e) {
    return function (t) {
      t instanceof RegExp && (t.lastIndex = 0);
      for (
        var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), i = 1;
        i < r;
        i++
      )
        n[i - 1] = arguments[i];
      return cw(e, t, n);
    };
  }
  function $ct(e) {
    return function () {
      for (var t = arguments.length, r = new Array(t), n = 0; n < t; n++)
        r[n] = arguments[n];
      return uw(e, r);
    };
  }
  function He(e, t) {
    let r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : xx;
    n7 && n7(e, null);
    let n = t.length;
    for (; n--; ) {
      let i = t[n];
      if (typeof i == "string") {
        let s = r(i);
        s !== i && (Nct(t) || (t[n] = s), (i = s));
      }
      e[i] = !0;
    }
    return e;
  }
  function Gct(e) {
    for (let t = 0; t < e.length; t++) Sa(e, t) || (e[t] = null);
    return e;
  }
  function yu(e) {
    let t = d7(null);
    for (let [r, n] of f7(e))
      Sa(e, r) &&
        (Array.isArray(n)
          ? (t[r] = Gct(n))
          : n && typeof n == "object" && n.constructor === Object
            ? (t[r] = yu(n))
            : (t[r] = n));
    return t;
  }
  function ng(e, t) {
    for (; e !== null; ) {
      let n = Mct(e, t);
      if (n) {
        if (n.get) return Oi(n.get);
        if (typeof n.value == "function") return Oi(n.value);
      }
      e = Ict(e);
    }
    function r() {
      return null;
    }
    return (a(r, "fallbackValue"), r);
  }
  function g7() {
    let e =
        arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : Qct(),
      t = a((Zt) => g7(Zt), "DOMPurify");
    if (
      ((t.version = "3.2.5"),
      (t.removed = []),
      !e || !e.document || e.document.nodeType !== ig.document || !e.Element)
    )
      return ((t.isSupported = !1), t);
    let { document: r } = e,
      n = r,
      i = n.currentScript,
      {
        DocumentFragment: s,
        HTMLTemplateElement: o,
        Node: l,
        Element: u,
        NodeFilter: h,
        NamedNodeMap: f = e.NamedNodeMap || e.MozNamedAttrMap,
        HTMLFormElement: d,
        DOMParser: p,
        trustedTypes: m,
      } = e,
      g = u.prototype,
      y = ng(g, "cloneNode"),
      b = ng(g, "remove"),
      k = ng(g, "nextSibling"),
      T = ng(g, "childNodes"),
      C = ng(g, "parentNode");
    if (typeof o == "function") {
      let Zt = r.createElement("template");
      Zt.content && Zt.content.ownerDocument && (r = Zt.content.ownerDocument);
    }
    let L,
      w = "",
      {
        implementation: D,
        createNodeIterator: G,
        createDocumentFragment: E,
        getElementsByTagName: R,
      } = r,
      { importNode: F } = n,
      S = h7();
    t.isSupported =
      typeof f7 == "function" &&
      typeof C == "function" &&
      D &&
      D.createHTMLDocument !== void 0;
    let {
        MUSTACHE_EXPR: O,
        ERB_EXPR: v,
        TMPLIT_EXPR: _,
        DATA_ATTR: A,
        ARIA_ATTR: N,
        IS_SCRIPT_OR_DATA: B,
        ATTR_WHITESPACE: M,
        CUSTOM_ELEMENT: I,
      } = u7,
      { IS_ALLOWED_URI: V } = u7,
      $ = null,
      q = He({}, [...a7, ...sw, ...aw, ...ow, ...o7]),
      tt = null,
      ht = He({}, [...l7, ...lw, ...c7, ...yx]),
      H = Object.seal(
        d7(null, {
          tagNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null,
          },
          attributeNameCheck: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: null,
          },
          allowCustomizedBuiltInElements: {
            writable: !0,
            configurable: !1,
            enumerable: !0,
            value: !1,
          },
        }),
      ),
      kt = null,
      ft = null,
      yt = !0,
      ot = !0,
      dt = !1,
      nt = !0,
      Q = !1,
      et = !0,
      X = !1,
      st = !1,
      U = !1,
      gt = !1,
      z = !1,
      ge = !1,
      lt = !0,
      jt = !1,
      Me = "user-content-",
      se = !0,
      Nt = !1,
      At = {},
      bt = null,
      ct = He({}, [
        "annotation-xml",
        "audio",
        "colgroup",
        "desc",
        "foreignobject",
        "head",
        "iframe",
        "math",
        "mi",
        "mn",
        "mo",
        "ms",
        "mtext",
        "noembed",
        "noframes",
        "noscript",
        "plaintext",
        "script",
        "style",
        "svg",
        "template",
        "thead",
        "title",
        "video",
        "xmp",
      ]),
      Lt = null,
      Z = He({}, ["audio", "video", "img", "source", "image", "track"]),
      Mt = null,
      W = He({}, [
        "alt",
        "class",
        "for",
        "id",
        "label",
        "name",
        "pattern",
        "placeholder",
        "role",
        "summary",
        "title",
        "value",
        "style",
        "xmlns",
      ]),
      Gt = "http://www.w3.org/1998/Math/MathML",
      j = "http://www.w3.org/2000/svg",
      Et = "http://www.w3.org/1999/xhtml",
      mt = Et,
      Xt = !1,
      Ft = null,
      _t = He({}, [Gt, j, Et], iw),
      Qe = He({}, ["mi", "mo", "mn", "ms", "mtext"]),
      It = He({}, ["annotation-xml"]),
      xr = He({}, ["title", "style", "font", "a", "script"]),
      Ze = null,
      mn = ["application/xhtml+xml", "text/html"],
      Ae = "text/html",
      Te = null,
      Je = null,
      Se = r.createElement("form"),
      hr = a(function (it) {
        return it instanceof RegExp || it instanceof Function;
      }, "isRegexOrFunction"),
      Sn = a(function () {
        let it =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        if (!(Je && Je === it)) {
          if (
            ((!it || typeof it != "object") && (it = {}),
            (it = yu(it)),
            (Ze =
              mn.indexOf(it.PARSER_MEDIA_TYPE) === -1
                ? Ae
                : it.PARSER_MEDIA_TYPE),
            (Te = Ze === "application/xhtml+xml" ? iw : xx),
            ($ = Sa(it, "ALLOWED_TAGS") ? He({}, it.ALLOWED_TAGS, Te) : q),
            (tt = Sa(it, "ALLOWED_ATTR") ? He({}, it.ALLOWED_ATTR, Te) : ht),
            (Ft = Sa(it, "ALLOWED_NAMESPACES")
              ? He({}, it.ALLOWED_NAMESPACES, iw)
              : _t),
            (Mt = Sa(it, "ADD_URI_SAFE_ATTR")
              ? He(yu(W), it.ADD_URI_SAFE_ATTR, Te)
              : W),
            (Lt = Sa(it, "ADD_DATA_URI_TAGS")
              ? He(yu(Z), it.ADD_DATA_URI_TAGS, Te)
              : Z),
            (bt = Sa(it, "FORBID_CONTENTS")
              ? He({}, it.FORBID_CONTENTS, Te)
              : ct),
            (kt = Sa(it, "FORBID_TAGS") ? He({}, it.FORBID_TAGS, Te) : {}),
            (ft = Sa(it, "FORBID_ATTR") ? He({}, it.FORBID_ATTR, Te) : {}),
            (At = Sa(it, "USE_PROFILES") ? it.USE_PROFILES : !1),
            (yt = it.ALLOW_ARIA_ATTR !== !1),
            (ot = it.ALLOW_DATA_ATTR !== !1),
            (dt = it.ALLOW_UNKNOWN_PROTOCOLS || !1),
            (nt = it.ALLOW_SELF_CLOSE_IN_ATTR !== !1),
            (Q = it.SAFE_FOR_TEMPLATES || !1),
            (et = it.SAFE_FOR_XML !== !1),
            (X = it.WHOLE_DOCUMENT || !1),
            (gt = it.RETURN_DOM || !1),
            (z = it.RETURN_DOM_FRAGMENT || !1),
            (ge = it.RETURN_TRUSTED_TYPE || !1),
            (U = it.FORCE_BODY || !1),
            (lt = it.SANITIZE_DOM !== !1),
            (jt = it.SANITIZE_NAMED_PROPS || !1),
            (se = it.KEEP_CONTENT !== !1),
            (Nt = it.IN_PLACE || !1),
            (V = it.ALLOWED_URI_REGEXP || p7),
            (mt = it.NAMESPACE || Et),
            (Qe = it.MATHML_TEXT_INTEGRATION_POINTS || Qe),
            (It = it.HTML_INTEGRATION_POINTS || It),
            (H = it.CUSTOM_ELEMENT_HANDLING || {}),
            it.CUSTOM_ELEMENT_HANDLING &&
              hr(it.CUSTOM_ELEMENT_HANDLING.tagNameCheck) &&
              (H.tagNameCheck = it.CUSTOM_ELEMENT_HANDLING.tagNameCheck),
            it.CUSTOM_ELEMENT_HANDLING &&
              hr(it.CUSTOM_ELEMENT_HANDLING.attributeNameCheck) &&
              (H.attributeNameCheck =
                it.CUSTOM_ELEMENT_HANDLING.attributeNameCheck),
            it.CUSTOM_ELEMENT_HANDLING &&
              typeof it.CUSTOM_ELEMENT_HANDLING
                .allowCustomizedBuiltInElements == "boolean" &&
              (H.allowCustomizedBuiltInElements =
                it.CUSTOM_ELEMENT_HANDLING.allowCustomizedBuiltInElements),
            Q && (ot = !1),
            z && (gt = !0),
            At &&
              (($ = He({}, o7)),
              (tt = []),
              At.html === !0 && (He($, a7), He(tt, l7)),
              At.svg === !0 && (He($, sw), He(tt, lw), He(tt, yx)),
              At.svgFilters === !0 && (He($, aw), He(tt, lw), He(tt, yx)),
              At.mathMl === !0 && (He($, ow), He(tt, c7), He(tt, yx))),
            it.ADD_TAGS && ($ === q && ($ = yu($)), He($, it.ADD_TAGS, Te)),
            it.ADD_ATTR &&
              (tt === ht && (tt = yu(tt)), He(tt, it.ADD_ATTR, Te)),
            it.ADD_URI_SAFE_ATTR && He(Mt, it.ADD_URI_SAFE_ATTR, Te),
            it.FORBID_CONTENTS &&
              (bt === ct && (bt = yu(bt)), He(bt, it.FORBID_CONTENTS, Te)),
            se && ($["#text"] = !0),
            X && He($, ["html", "head", "body"]),
            $.table && (He($, ["tbody"]), delete kt.tbody),
            it.TRUSTED_TYPES_POLICY)
          ) {
            if (typeof it.TRUSTED_TYPES_POLICY.createHTML != "function")
              throw rg(
                'TRUSTED_TYPES_POLICY configuration option must provide a "createHTML" hook.',
              );
            if (typeof it.TRUSTED_TYPES_POLICY.createScriptURL != "function")
              throw rg(
                'TRUSTED_TYPES_POLICY configuration option must provide a "createScriptURL" hook.',
              );
            ((L = it.TRUSTED_TYPES_POLICY), (w = L.createHTML("")));
          } else
            (L === void 0 && (L = Zct(m, i)),
              L !== null && typeof w == "string" && (w = L.createHTML("")));
          (Mi && Mi(it), (Je = it));
        }
      }, "_parseConfig"),
      Ee = He({}, [...sw, ...aw, ...Vct]),
      $e = He({}, [...ow, ...zct]),
      Le = a(function (it) {
        let $t = C(it);
        (!$t || !$t.tagName) &&
          ($t = { namespaceURI: mt, tagName: "template" });
        let Kt = xx(it.tagName),
          or = xx($t.tagName);
        return Ft[it.namespaceURI]
          ? it.namespaceURI === j
            ? $t.namespaceURI === Et
              ? Kt === "svg"
              : $t.namespaceURI === Gt
                ? Kt === "svg" && (or === "annotation-xml" || Qe[or])
                : !!Ee[Kt]
            : it.namespaceURI === Gt
              ? $t.namespaceURI === Et
                ? Kt === "math"
                : $t.namespaceURI === j
                  ? Kt === "math" && It[or]
                  : !!$e[Kt]
              : it.namespaceURI === Et
                ? ($t.namespaceURI === j && !It[or]) ||
                  ($t.namespaceURI === Gt && !Qe[or])
                  ? !1
                  : !$e[Kt] && (xr[Kt] || !Ee[Kt])
                : !!(Ze === "application/xhtml+xml" && Ft[it.namespaceURI])
          : !1;
      }, "_checkValidNamespace"),
      xe = a(function (it) {
        tg(t.removed, { element: it });
        try {
          C(it).removeChild(it);
        } catch {
          b(it);
        }
      }, "_forceRemove"),
      fe = a(function (it, $t) {
        try {
          tg(t.removed, { attribute: $t.getAttributeNode(it), from: $t });
        } catch {
          tg(t.removed, { attribute: null, from: $t });
        }
        if (($t.removeAttribute(it), it === "is"))
          if (gt || z)
            try {
              xe($t);
            } catch {}
          else
            try {
              $t.setAttribute(it, "");
            } catch {}
      }, "_removeAttribute"),
      ye = a(function (it) {
        let $t = null,
          Kt = null;
        if (U) it = "<remove></remove>" + it;
        else {
          let _n = s7(it, /^[\r\n\t ]+/);
          Kt = _n && _n[0];
        }
        Ze === "application/xhtml+xml" &&
          mt === Et &&
          (it =
            '<html xmlns="http://www.w3.org/1999/xhtml"><head></head><body>' +
            it +
            "</body></html>");
        let or = L ? L.createHTML(it) : it;
        if (mt === Et)
          try {
            $t = new p().parseFromString(or, Ze);
          } catch {}
        if (!$t || !$t.documentElement) {
          $t = D.createDocument(mt, "template", null);
          try {
            $t.documentElement.innerHTML = Xt ? w : or;
          } catch {}
        }
        let sn = $t.body || $t.documentElement;
        return (
          it &&
            Kt &&
            sn.insertBefore(r.createTextNode(Kt), sn.childNodes[0] || null),
          mt === Et
            ? R.call($t, X ? "html" : "body")[0]
            : X
              ? $t.documentElement
              : sn
        );
      }, "_initDocument"),
      be = a(function (it) {
        return G.call(
          it.ownerDocument || it,
          it,
          h.SHOW_ELEMENT |
            h.SHOW_COMMENT |
            h.SHOW_TEXT |
            h.SHOW_PROCESSING_INSTRUCTION |
            h.SHOW_CDATA_SECTION,
          null,
        );
      }, "_createNodeIterator"),
      Ht = a(function (it) {
        return (
          it instanceof d &&
          (typeof it.nodeName != "string" ||
            typeof it.textContent != "string" ||
            typeof it.removeChild != "function" ||
            !(it.attributes instanceof f) ||
            typeof it.removeAttribute != "function" ||
            typeof it.setAttribute != "function" ||
            typeof it.namespaceURI != "string" ||
            typeof it.insertBefore != "function" ||
            typeof it.hasChildNodes != "function")
        );
      }, "_isClobbered"),
      Dn = a(function (it) {
        return typeof l == "function" && it instanceof l;
      }, "_isNode");
    function ne(Zt, it, $t) {
      gx(Zt, (Kt) => {
        Kt.call(t, it, $t, Je);
      });
    }
    a(ne, "_executeHooks");
    let Li = a(function (it) {
        let $t = null;
        if ((ne(S.beforeSanitizeElements, it, null), Ht(it)))
          return (xe(it), !0);
        let Kt = Te(it.nodeName);
        if (
          (ne(S.uponSanitizeElement, it, { tagName: Kt, allowedTags: $ }),
          (it.hasChildNodes() &&
            !Dn(it.firstElementChild) &&
            Ii(/<[/\w!]/g, it.innerHTML) &&
            Ii(/<[/\w!]/g, it.textContent)) ||
            it.nodeType === ig.progressingInstruction ||
            (et && it.nodeType === ig.comment && Ii(/<[/\w]/g, it.data)))
        )
          return (xe(it), !0);
        if (!$[Kt] || kt[Kt]) {
          if (
            !kt[Kt] &&
            Br(Kt) &&
            ((H.tagNameCheck instanceof RegExp && Ii(H.tagNameCheck, Kt)) ||
              (H.tagNameCheck instanceof Function && H.tagNameCheck(Kt)))
          )
            return !1;
          if (se && !bt[Kt]) {
            let or = C(it) || it.parentNode,
              sn = T(it) || it.childNodes;
            if (sn && or) {
              let _n = sn.length;
              for (let jr = _n - 1; jr >= 0; --jr) {
                let Ji = y(sn[jr], !0);
                ((Ji.__removalCount = (it.__removalCount || 0) + 1),
                  or.insertBefore(Ji, k(it)));
              }
            }
          }
          return (xe(it), !0);
        }
        return (it instanceof u && !Le(it)) ||
          ((Kt === "noscript" || Kt === "noembed" || Kt === "noframes") &&
            Ii(/<\/no(script|embed|frames)/i, it.innerHTML))
          ? (xe(it), !0)
          : (Q &&
              it.nodeType === ig.text &&
              (($t = it.textContent),
              gx([O, v, _], (or) => {
                $t = eg($t, or, " ");
              }),
              it.textContent !== $t &&
                (tg(t.removed, { element: it.cloneNode() }),
                (it.textContent = $t))),
            ne(S.afterSanitizeElements, it, null),
            !1);
      }, "_sanitizeElements"),
      gn = a(function (it, $t, Kt) {
        if (lt && ($t === "id" || $t === "name") && (Kt in r || Kt in Se))
          return !1;
        if (!(ot && !ft[$t] && Ii(A, $t))) {
          if (!(yt && Ii(N, $t))) {
            if (!tt[$t] || ft[$t]) {
              if (
                !(
                  (Br(it) &&
                    ((H.tagNameCheck instanceof RegExp &&
                      Ii(H.tagNameCheck, it)) ||
                      (H.tagNameCheck instanceof Function &&
                        H.tagNameCheck(it))) &&
                    ((H.attributeNameCheck instanceof RegExp &&
                      Ii(H.attributeNameCheck, $t)) ||
                      (H.attributeNameCheck instanceof Function &&
                        H.attributeNameCheck($t)))) ||
                  ($t === "is" &&
                    H.allowCustomizedBuiltInElements &&
                    ((H.tagNameCheck instanceof RegExp &&
                      Ii(H.tagNameCheck, Kt)) ||
                      (H.tagNameCheck instanceof Function &&
                        H.tagNameCheck(Kt))))
                )
              )
                return !1;
            } else if (!Mt[$t]) {
              if (!Ii(V, eg(Kt, M, ""))) {
                if (
                  !(
                    ($t === "src" || $t === "xlink:href" || $t === "href") &&
                    it !== "script" &&
                    Bct(Kt, "data:") === 0 &&
                    Lt[it]
                  )
                ) {
                  if (!(dt && !Ii(B, eg(Kt, M, "")))) {
                    if (Kt) return !1;
                  }
                }
              }
            }
          }
        }
        return !0;
      }, "_isValidAttribute"),
      Br = a(function (it) {
        return it !== "annotation-xml" && s7(it, I);
      }, "_isBasicCustomElement"),
      Er = a(function (it) {
        ne(S.beforeSanitizeAttributes, it, null);
        let { attributes: $t } = it;
        if (!$t || Ht(it)) return;
        let Kt = {
            attrName: "",
            attrValue: "",
            keepAttr: !0,
            allowedAttributes: tt,
            forceKeepAttr: void 0,
          },
          or = $t.length;
        for (; or--; ) {
          let sn = $t[or],
            { name: _n, namespaceURI: jr, value: Ji } = sn,
            hu = Te(_n),
            Nn = _n === "value" ? Ji : Fct(Ji);
          if (
            ((Kt.attrName = hu),
            (Kt.attrValue = Nn),
            (Kt.keepAttr = !0),
            (Kt.forceKeepAttr = void 0),
            ne(S.uponSanitizeAttribute, it, Kt),
            (Nn = Kt.attrValue),
            jt &&
              (hu === "id" || hu === "name") &&
              (fe(_n, it), (Nn = Me + Nn)),
            et && Ii(/((--!?|])>)|<\/(style|title)/i, Nn))
          ) {
            fe(_n, it);
            continue;
          }
          if (Kt.forceKeepAttr || (fe(_n, it), !Kt.keepAttr)) continue;
          if (!nt && Ii(/\/>/i, Nn)) {
            fe(_n, it);
            continue;
          }
          Q &&
            gx([O, v, _], (ce) => {
              Nn = eg(Nn, ce, " ");
            });
          let ka = Te(it.nodeName);
          if (gn(ka, hu, Nn)) {
            if (
              L &&
              typeof m == "object" &&
              typeof m.getAttributeType == "function" &&
              !jr
            )
              switch (m.getAttributeType(ka, hu)) {
                case "TrustedHTML": {
                  Nn = L.createHTML(Nn);
                  break;
                }
                case "TrustedScriptURL": {
                  Nn = L.createScriptURL(Nn);
                  break;
                }
              }
            try {
              (jr ? it.setAttributeNS(jr, _n, Nn) : it.setAttribute(_n, Nn),
                Ht(it) ? xe(it) : i7(t.removed));
            } catch {}
          }
        }
        ne(S.afterSanitizeAttributes, it, null);
      }, "_sanitizeAttributes"),
      pi = a(function Zt(it) {
        let $t = null,
          Kt = be(it);
        for (ne(S.beforeSanitizeShadowDOM, it, null); ($t = Kt.nextNode()); )
          (ne(S.uponSanitizeShadowNode, $t, null),
            Li($t),
            Er($t),
            $t.content instanceof s && Zt($t.content));
        ne(S.afterSanitizeShadowDOM, it, null);
      }, "_sanitizeShadowDOM");
    return (
      (t.sanitize = function (Zt) {
        let it =
            arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {},
          $t = null,
          Kt = null,
          or = null,
          sn = null;
        if (
          ((Xt = !Zt), Xt && (Zt = "<!-->"), typeof Zt != "string" && !Dn(Zt))
        )
          if (typeof Zt.toString == "function") {
            if (((Zt = Zt.toString()), typeof Zt != "string"))
              throw rg("dirty is not a string, aborting");
          } else throw rg("toString is not a function");
        if (!t.isSupported) return Zt;
        if (
          (st || Sn(it),
          (t.removed = []),
          typeof Zt == "string" && (Nt = !1),
          Nt)
        ) {
          if (Zt.nodeName) {
            let Ji = Te(Zt.nodeName);
            if (!$[Ji] || kt[Ji])
              throw rg(
                "root node is forbidden and cannot be sanitized in-place",
              );
          }
        } else if (Zt instanceof l)
          (($t = ye("<!---->")),
            (Kt = $t.ownerDocument.importNode(Zt, !0)),
            (Kt.nodeType === ig.element && Kt.nodeName === "BODY") ||
            Kt.nodeName === "HTML"
              ? ($t = Kt)
              : $t.appendChild(Kt));
        else {
          if (!gt && !Q && !X && Zt.indexOf("<") === -1)
            return L && ge ? L.createHTML(Zt) : Zt;
          if ((($t = ye(Zt)), !$t)) return gt ? null : ge ? w : "";
        }
        $t && U && xe($t.firstChild);
        let _n = be(Nt ? Zt : $t);
        for (; (or = _n.nextNode()); )
          (Li(or), Er(or), or.content instanceof s && pi(or.content));
        if (Nt) return Zt;
        if (gt) {
          if (z)
            for (sn = E.call($t.ownerDocument); $t.firstChild; )
              sn.appendChild($t.firstChild);
          else sn = $t;
          return (
            (tt.shadowroot || tt.shadowrootmode) && (sn = F.call(n, sn, !0)),
            sn
          );
        }
        let jr = X ? $t.outerHTML : $t.innerHTML;
        return (
          X &&
            $["!doctype"] &&
            $t.ownerDocument &&
            $t.ownerDocument.doctype &&
            $t.ownerDocument.doctype.name &&
            Ii(m7, $t.ownerDocument.doctype.name) &&
            (jr =
              "<!DOCTYPE " +
              $t.ownerDocument.doctype.name +
              `>
` +
              jr),
          Q &&
            gx([O, v, _], (Ji) => {
              jr = eg(jr, Ji, " ");
            }),
          L && ge ? L.createHTML(jr) : jr
        );
      }),
      (t.setConfig = function () {
        let Zt =
          arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
        (Sn(Zt), (st = !0));
      }),
      (t.clearConfig = function () {
        ((Je = null), (st = !1));
      }),
      (t.isValidAttribute = function (Zt, it, $t) {
        Je || Sn({});
        let Kt = Te(Zt),
          or = Te(it);
        return gn(Kt, or, $t);
      }),
      (t.addHook = function (Zt, it) {
        typeof it == "function" && tg(S[Zt], it);
      }),
      (t.removeHook = function (Zt, it) {
        if (it !== void 0) {
          let $t = Oct(S[Zt], it);
          return $t === -1 ? void 0 : Pct(S[Zt], $t, 1)[0];
        }
        return i7(S[Zt]);
      }),
      (t.removeHooks = function (Zt) {
        S[Zt] = [];
      }),
      (t.removeAllHooks = function () {
        S = h7();
      }),
      t
    );
  }
  var f7,
    n7,
    Nct,
    Ict,
    Mct,
    Mi,
    qs,
    d7,
    cw,
    uw,
    gx,
    Oct,
    i7,
    tg,
    Pct,
    xx,
    iw,
    s7,
    eg,
    Bct,
    Fct,
    Sa,
    Ii,
    rg,
    a7,
    sw,
    aw,
    Vct,
    ow,
    zct,
    o7,
    l7,
    lw,
    c7,
    yx,
    Wct,
    Uct,
    jct,
    qct,
    Hct,
    p7,
    Yct,
    Xct,
    m7,
    Kct,
    u7,
    ig,
    Qct,
    Zct,
    h7,
    Xl,
    hw = x(() => {
      "use strict";
      (({
        entries: f7,
        setPrototypeOf: n7,
        isFrozen: Nct,
        getPrototypeOf: Ict,
        getOwnPropertyDescriptor: Mct,
      } = Object),
        ({ freeze: Mi, seal: qs, create: d7 } = Object),
        ({ apply: cw, construct: uw } = typeof Reflect < "u" && Reflect));
      Mi ||
        (Mi = a(function (t) {
          return t;
        }, "freeze"));
      qs ||
        (qs = a(function (t) {
          return t;
        }, "seal"));
      cw ||
        (cw = a(function (t, r, n) {
          return t.apply(r, n);
        }, "apply"));
      uw ||
        (uw = a(function (t, r) {
          return new t(...r);
        }, "construct"));
      ((gx = Oi(Array.prototype.forEach)),
        (Oct = Oi(Array.prototype.lastIndexOf)),
        (i7 = Oi(Array.prototype.pop)),
        (tg = Oi(Array.prototype.push)),
        (Pct = Oi(Array.prototype.splice)),
        (xx = Oi(String.prototype.toLowerCase)),
        (iw = Oi(String.prototype.toString)),
        (s7 = Oi(String.prototype.match)),
        (eg = Oi(String.prototype.replace)),
        (Bct = Oi(String.prototype.indexOf)),
        (Fct = Oi(String.prototype.trim)),
        (Sa = Oi(Object.prototype.hasOwnProperty)),
        (Ii = Oi(RegExp.prototype.test)),
        (rg = $ct(TypeError)));
      a(Oi, "unapply");
      a($ct, "unconstruct");
      a(He, "addToSet");
      a(Gct, "cleanArray");
      a(yu, "clone");
      a(ng, "lookupGetter");
      ((a7 = Mi([
        "a",
        "abbr",
        "acronym",
        "address",
        "area",
        "article",
        "aside",
        "audio",
        "b",
        "bdi",
        "bdo",
        "big",
        "blink",
        "blockquote",
        "body",
        "br",
        "button",
        "canvas",
        "caption",
        "center",
        "cite",
        "code",
        "col",
        "colgroup",
        "content",
        "data",
        "datalist",
        "dd",
        "decorator",
        "del",
        "details",
        "dfn",
        "dialog",
        "dir",
        "div",
        "dl",
        "dt",
        "element",
        "em",
        "fieldset",
        "figcaption",
        "figure",
        "font",
        "footer",
        "form",
        "h1",
        "h2",
        "h3",
        "h4",
        "h5",
        "h6",
        "head",
        "header",
        "hgroup",
        "hr",
        "html",
        "i",
        "img",
        "input",
        "ins",
        "kbd",
        "label",
        "legend",
        "li",
        "main",
        "map",
        "mark",
        "marquee",
        "menu",
        "menuitem",
        "meter",
        "nav",
        "nobr",
        "ol",
        "optgroup",
        "option",
        "output",
        "p",
        "picture",
        "pre",
        "progress",
        "q",
        "rp",
        "rt",
        "ruby",
        "s",
        "samp",
        "section",
        "select",
        "shadow",
        "small",
        "source",
        "spacer",
        "span",
        "strike",
        "strong",
        "style",
        "sub",
        "summary",
        "sup",
        "table",
        "tbody",
        "td",
        "template",
        "textarea",
        "tfoot",
        "th",
        "thead",
        "time",
        "tr",
        "track",
        "tt",
        "u",
        "ul",
        "var",
        "video",
        "wbr",
      ])),
        (sw = Mi([
          "svg",
          "a",
          "altglyph",
          "altglyphdef",
          "altglyphitem",
          "animatecolor",
          "animatemotion",
          "animatetransform",
          "circle",
          "clippath",
          "defs",
          "desc",
          "ellipse",
          "filter",
          "font",
          "g",
          "glyph",
          "glyphref",
          "hkern",
          "image",
          "line",
          "lineargradient",
          "marker",
          "mask",
          "metadata",
          "mpath",
          "path",
          "pattern",
          "polygon",
          "polyline",
          "radialgradient",
          "rect",
          "stop",
          "style",
          "switch",
          "symbol",
          "text",
          "textpath",
          "title",
          "tref",
          "tspan",
          "view",
          "vkern",
        ])),
        (aw = Mi([
          "feBlend",
          "feColorMatrix",
          "feComponentTransfer",
          "feComposite",
          "feConvolveMatrix",
          "feDiffuseLighting",
          "feDisplacementMap",
          "feDistantLight",
          "feDropShadow",
          "feFlood",
          "feFuncA",
          "feFuncB",
          "feFuncG",
          "feFuncR",
          "feGaussianBlur",
          "feImage",
          "feMerge",
          "feMergeNode",
          "feMorphology",
          "feOffset",
          "fePointLight",
          "feSpecularLighting",
          "feSpotLight",
          "feTile",
          "feTurbulence",
        ])),
        (Vct = Mi([
          "animate",
          "color-profile",
          "cursor",
          "discard",
          "font-face",
          "font-face-format",
          "font-face-name",
          "font-face-src",
          "font-face-uri",
          "foreignobject",
          "hatch",
          "hatchpath",
          "mesh",
          "meshgradient",
          "meshpatch",
          "meshrow",
          "missing-glyph",
          "script",
          "set",
          "solidcolor",
          "unknown",
          "use",
        ])),
        (ow = Mi([
          "math",
          "menclose",
          "merror",
          "mfenced",
          "mfrac",
          "mglyph",
          "mi",
          "mlabeledtr",
          "mmultiscripts",
          "mn",
          "mo",
          "mover",
          "mpadded",
          "mphantom",
          "mroot",
          "mrow",
          "ms",
          "mspace",
          "msqrt",
          "mstyle",
          "msub",
          "msup",
          "msubsup",
          "mtable",
          "mtd",
          "mtext",
          "mtr",
          "munder",
          "munderover",
          "mprescripts",
        ])),
        (zct = Mi([
          "maction",
          "maligngroup",
          "malignmark",
          "mlongdiv",
          "mscarries",
          "mscarry",
          "msgroup",
          "mstack",
          "msline",
          "msrow",
          "semantics",
          "annotation",
          "annotation-xml",
          "mprescripts",
          "none",
        ])),
        (o7 = Mi(["#text"])),
        (l7 = Mi([
          "accept",
          "action",
          "align",
          "alt",
          "autocapitalize",
          "autocomplete",
          "autopictureinpicture",
          "autoplay",
          "background",
          "bgcolor",
          "border",
          "capture",
          "cellpadding",
          "cellspacing",
          "checked",
          "cite",
          "class",
          "clear",
          "color",
          "cols",
          "colspan",
          "controls",
          "controlslist",
          "coords",
          "crossorigin",
          "datetime",
          "decoding",
          "default",
          "dir",
          "disabled",
          "disablepictureinpicture",
          "disableremoteplayback",
          "download",
          "draggable",
          "enctype",
          "enterkeyhint",
          "face",
          "for",
          "headers",
          "height",
          "hidden",
          "high",
          "href",
          "hreflang",
          "id",
          "inputmode",
          "integrity",
          "ismap",
          "kind",
          "label",
          "lang",
          "list",
          "loading",
          "loop",
          "low",
          "max",
          "maxlength",
          "media",
          "method",
          "min",
          "minlength",
          "multiple",
          "muted",
          "name",
          "nonce",
          "noshade",
          "novalidate",
          "nowrap",
          "open",
          "optimum",
          "pattern",
          "placeholder",
          "playsinline",
          "popover",
          "popovertarget",
          "popovertargetaction",
          "poster",
          "preload",
          "pubdate",
          "radiogroup",
          "readonly",
          "rel",
          "required",
          "rev",
          "reversed",
          "role",
          "rows",
          "rowspan",
          "spellcheck",
          "scope",
          "selected",
          "shape",
          "size",
          "sizes",
          "span",
          "srclang",
          "start",
          "src",
          "srcset",
          "step",
          "style",
          "summary",
          "tabindex",
          "title",
          "translate",
          "type",
          "usemap",
          "valign",
          "value",
          "width",
          "wrap",
          "xmlns",
          "slot",
        ])),
        (lw = Mi([
          "accent-height",
          "accumulate",
          "additive",
          "alignment-baseline",
          "amplitude",
          "ascent",
          "attributename",
          "attributetype",
          "azimuth",
          "basefrequency",
          "baseline-shift",
          "begin",
          "bias",
          "by",
          "class",
          "clip",
          "clippathunits",
          "clip-path",
          "clip-rule",
          "color",
          "color-interpolation",
          "color-interpolation-filters",
          "color-profile",
          "color-rendering",
          "cx",
          "cy",
          "d",
          "dx",
          "dy",
          "diffuseconstant",
          "direction",
          "display",
          "divisor",
          "dur",
          "edgemode",
          "elevation",
          "end",
          "exponent",
          "fill",
          "fill-opacity",
          "fill-rule",
          "filter",
          "filterunits",
          "flood-color",
          "flood-opacity",
          "font-family",
          "font-size",
          "font-size-adjust",
          "font-stretch",
          "font-style",
          "font-variant",
          "font-weight",
          "fx",
          "fy",
          "g1",
          "g2",
          "glyph-name",
          "glyphref",
          "gradientunits",
          "gradienttransform",
          "height",
          "href",
          "id",
          "image-rendering",
          "in",
          "in2",
          "intercept",
          "k",
          "k1",
          "k2",
          "k3",
          "k4",
          "kerning",
          "keypoints",
          "keysplines",
          "keytimes",
          "lang",
          "lengthadjust",
          "letter-spacing",
          "kernelmatrix",
          "kernelunitlength",
          "lighting-color",
          "local",
          "marker-end",
          "marker-mid",
          "marker-start",
          "markerheight",
          "markerunits",
          "markerwidth",
          "maskcontentunits",
          "maskunits",
          "max",
          "mask",
          "media",
          "method",
          "mode",
          "min",
          "name",
          "numoctaves",
          "offset",
          "operator",
          "opacity",
          "order",
          "orient",
          "orientation",
          "origin",
          "overflow",
          "paint-order",
          "path",
          "pathlength",
          "patterncontentunits",
          "patterntransform",
          "patternunits",
          "points",
          "preservealpha",
          "preserveaspectratio",
          "primitiveunits",
          "r",
          "rx",
          "ry",
          "radius",
          "refx",
          "refy",
          "repeatcount",
          "repeatdur",
          "restart",
          "result",
          "rotate",
          "scale",
          "seed",
          "shape-rendering",
          "slope",
          "specularconstant",
          "specularexponent",
          "spreadmethod",
          "startoffset",
          "stddeviation",
          "stitchtiles",
          "stop-color",
          "stop-opacity",
          "stroke-dasharray",
          "stroke-dashoffset",
          "stroke-linecap",
          "stroke-linejoin",
          "stroke-miterlimit",
          "stroke-opacity",
          "stroke",
          "stroke-width",
          "style",
          "surfacescale",
          "systemlanguage",
          "tabindex",
          "tablevalues",
          "targetx",
          "targety",
          "transform",
          "transform-origin",
          "text-anchor",
          "text-decoration",
          "text-rendering",
          "textlength",
          "type",
          "u1",
          "u2",
          "unicode",
          "values",
          "viewbox",
          "visibility",
          "version",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y",
          "width",
          "word-spacing",
          "wrap",
          "writing-mode",
          "xchannelselector",
          "ychannelselector",
          "x",
          "x1",
          "x2",
          "xmlns",
          "y",
          "y1",
          "y2",
          "z",
          "zoomandpan",
        ])),
        (c7 = Mi([
          "accent",
          "accentunder",
          "align",
          "bevelled",
          "close",
          "columnsalign",
          "columnlines",
          "columnspan",
          "denomalign",
          "depth",
          "dir",
          "display",
          "displaystyle",
          "encoding",
          "fence",
          "frame",
          "height",
          "href",
          "id",
          "largeop",
          "length",
          "linethickness",
          "lspace",
          "lquote",
          "mathbackground",
          "mathcolor",
          "mathsize",
          "mathvariant",
          "maxsize",
          "minsize",
          "movablelimits",
          "notation",
          "numalign",
          "open",
          "rowalign",
          "rowlines",
          "rowspacing",
          "rowspan",
          "rspace",
          "rquote",
          "scriptlevel",
          "scriptminsize",
          "scriptsizemultiplier",
          "selection",
          "separator",
          "separators",
          "stretchy",
          "subscriptshift",
          "supscriptshift",
          "symmetric",
          "voffset",
          "width",
          "xmlns",
        ])),
        (yx = Mi([
          "xlink:href",
          "xml:id",
          "xlink:title",
          "xml:space",
          "xmlns:xlink",
        ])),
        (Wct = qs(/\{\{[\w\W]*|[\w\W]*\}\}/gm)),
        (Uct = qs(/<%[\w\W]*|[\w\W]*%>/gm)),
        (jct = qs(/\$\{[\w\W]*/gm)),
        (qct = qs(/^data-[\-\w.\u00B7-\uFFFF]+$/)),
        (Hct = qs(/^aria-[\-\w]+$/)),
        (p7 = qs(
          /^(?:(?:(?:f|ht)tps?|mailto|tel|callto|sms|cid|xmpp):|[^a-z]|[a-z+.\-]+(?:[^a-z+.\-:]|$))/i,
        )),
        (Yct = qs(/^(?:\w+script|data):/i)),
        (Xct = qs(
          /[\u0000-\u0020\u00A0\u1680\u180E\u2000-\u2029\u205F\u3000]/g,
        )),
        (m7 = qs(/^html$/i)),
        (Kct = qs(/^[a-z][.\w]*(-[.\w]+)+$/i)),
        (u7 = Object.freeze({
          __proto__: null,
          ARIA_ATTR: Hct,
          ATTR_WHITESPACE: Xct,
          CUSTOM_ELEMENT: Kct,
          DATA_ATTR: qct,
          DOCTYPE_NAME: m7,
          ERB_EXPR: Uct,
          IS_ALLOWED_URI: p7,
          IS_SCRIPT_OR_DATA: Yct,
          MUSTACHE_EXPR: Wct,
          TMPLIT_EXPR: jct,
        })),
        (ig = {
          element: 1,
          attribute: 2,
          text: 3,
          cdataSection: 4,
          entityReference: 5,
          entityNode: 6,
          progressingInstruction: 7,
          comment: 8,
          document: 9,
          documentType: 10,
          documentFragment: 11,
          notation: 12,
        }),
        (Qct = a(function () {
          return typeof window > "u" ? null : window;
        }, "getGlobal")),
        (Zct = a(function (t, r) {
          if (typeof t != "object" || typeof t.createPolicy != "function")
            return null;
          let n = null,
            i = "data-tt-policy-suffix";
          r && r.hasAttribute(i) && (n = r.getAttribute(i));
          let s = "dompurify" + (n ? "#" + n : "");
          try {
            return t.createPolicy(s, {
              createHTML(o) {
                return o;
              },
              createScriptURL(o) {
                return o;
              },
            });
          } catch {
            return (
              console.warn(
                "TrustedTypes policy " + s + " could not be created.",
              ),
              null
            );
          }
        }, "_createTrustedTypesPolicy")),
        (h7 = a(function () {
          return {
            afterSanitizeAttributes: [],
            afterSanitizeElements: [],
            afterSanitizeShadowDOM: [],
            beforeSanitizeAttributes: [],
            beforeSanitizeElements: [],
            beforeSanitizeShadowDOM: [],
            uponSanitizeAttribute: [],
            uponSanitizeElement: [],
            uponSanitizeShadowNode: [],
          };
        }, "_createHooksMap")));
      a(g7, "createDOMPurify");
      Xl = g7();
    });
  function eut() {
    let e = "data-temp-href-target";
    (Xl.addHook("beforeSanitizeAttributes", (t) => {
      t.tagName === "A" &&
        t.hasAttribute("target") &&
        t.setAttribute(e, t.getAttribute("target") ?? "");
    }),
      Xl.addHook("afterSanitizeAttributes", (t) => {
        t.tagName === "A" &&
          t.hasAttribute(e) &&
          (t.setAttribute("target", t.getAttribute(e) ?? ""),
          t.removeAttribute(e),
          t.getAttribute("target") === "_blank" &&
            t.setAttribute("rel", "noopener"));
      }));
  }
  var ff,
    Jct,
    tut,
    x7,
    y7,
    Ie,
    rut,
    nut,
    iut,
    sut,
    b7,
    tl,
    Pe,
    aut,
    out,
    ro,
    fw,
    lut,
    cut,
    uut,
    dw,
    $r,
    xu,
    hut,
    Kl,
    Rt,
    Be = x(() => {
      "use strict";
      hw();
      ((ff = /<br\s*\/?>/gi),
        (Jct = a(
          (e) => (e ? b7(e).replace(/\\n/g, "#br#").split("#br#") : [""]),
          "getRows",
        )),
        (tut = (() => {
          let e = !1;
          return () => {
            e || (eut(), (e = !0));
          };
        })()));
      a(eut, "setupDompurifyHooks");
      ((x7 = a((e) => (tut(), Xl.sanitize(e)), "removeScript")),
        (y7 = a((e, t) => {
          if (t.flowchart?.htmlLabels !== !1) {
            let r = t.securityLevel;
            r === "antiscript" || r === "strict"
              ? (e = x7(e))
              : r !== "loose" &&
                ((e = b7(e)),
                (e = e.replace(/</g, "&lt;").replace(/>/g, "&gt;")),
                (e = e.replace(/=/g, "&equals;")),
                (e = sut(e)));
          }
          return e;
        }, "sanitizeMore")),
        (Ie = a(
          (e, t) =>
            e &&
            (t.dompurifyConfig
              ? (e = Xl.sanitize(y7(e, t), t.dompurifyConfig).toString())
              : (e = Xl.sanitize(y7(e, t), {
                  FORBID_TAGS: ["style"],
                }).toString()),
            e),
          "sanitizeText",
        )),
        (rut = a(
          (e, t) =>
            typeof e == "string" ? Ie(e, t) : e.flat().map((r) => Ie(r, t)),
          "sanitizeTextOrArray",
        )),
        (nut = a((e) => ff.test(e), "hasBreaks")),
        (iut = a((e) => e.split(ff), "splitBreaks")),
        (sut = a((e) => e.replace(/#br#/g, "<br/>"), "placeholderToBreak")),
        (b7 = a((e) => e.replace(ff, "#br#"), "breakToPlaceholder")),
        (tl = a((e) => {
          let t = "";
          return (
            e &&
              ((t =
                window.location.protocol +
                "//" +
                window.location.host +
                window.location.pathname +
                window.location.search),
              (t = CSS.escape(t))),
            t
          );
        }, "getUrl")),
        (Pe = a(
          (e) =>
            !(
              e === !1 ||
              ["false", "null", "0"].includes(String(e).trim().toLowerCase())
            ),
          "evaluate",
        )),
        (aut = a(function (...e) {
          let t = e.filter((r) => !isNaN(r));
          return Math.max(...t);
        }, "getMax")),
        (out = a(function (...e) {
          let t = e.filter((r) => !isNaN(r));
          return Math.min(...t);
        }, "getMin")),
        (ro = a(function (e) {
          let t = e.split(/(,)/),
            r = [];
          for (let n = 0; n < t.length; n++) {
            let i = t[n];
            if (i === "," && n > 0 && n + 1 < t.length) {
              let s = t[n - 1],
                o = t[n + 1];
              lut(s, o) && ((i = s + "," + o), n++, r.pop());
            }
            r.push(cut(i));
          }
          return r.join("");
        }, "parseGenericTypes")),
        (fw = a(
          (e, t) => Math.max(0, e.split(t).length - 1),
          "countOccurrence",
        )),
        (lut = a((e, t) => {
          let r = fw(e, "~"),
            n = fw(t, "~");
          return r === 1 && n === 1;
        }, "shouldCombineSets")),
        (cut = a((e) => {
          let t = fw(e, "~"),
            r = !1;
          if (t <= 1) return e;
          t % 2 !== 0 && e.startsWith("~") && ((e = e.substring(1)), (r = !0));
          let n = [...e],
            i = n.indexOf("~"),
            s = n.lastIndexOf("~");
          for (; i !== -1 && s !== -1 && i !== s; )
            ((n[i] = "<"),
              (n[s] = ">"),
              (i = n.indexOf("~")),
              (s = n.lastIndexOf("~")));
          return (r && n.unshift("~"), n.join(""));
        }, "processSet")),
        (uut = a(() => window.MathMLElement !== void 0, "isMathMLSupported")),
        (dw = /\$\$(.*)\$\$/g),
        ($r = a((e) => (e.match(dw)?.length ?? 0) > 0, "hasKatex")),
        (xu = a(async (e, t) => {
          let r = document.createElement("div");
          ((r.innerHTML = await Kl(e, t)),
            (r.id = "katex-temp"),
            (r.style.visibility = "hidden"),
            (r.style.position = "absolute"),
            (r.style.top = "0"),
            document
              .querySelector("body")
              ?.insertAdjacentElement("beforeend", r));
          let i = { width: r.clientWidth, height: r.clientHeight };
          return (r.remove(), i);
        }, "calculateMathMLDimensions")),
        (hut = a(
          async (e, t) =>
            $r(e)
              ? uut() || t.legacyMathML || t.forceLegacyMathML
                ? e.replace(
                    dw,
                    "Katex is not supported in @mermaid-js/tiny. Please use the full mermaid library.",
                  )
                : e.replace(dw, "MathML is unsupported in this environment.")
              : e,
          "renderKatexUnsanitized",
        )),
        (Kl = a(
          async (e, t) => Ie(await hut(e, t), t),
          "renderKatexSanitized",
        )),
        (Rt = {
          getRows: Jct,
          sanitizeText: Ie,
          sanitizeTextOrArray: rut,
          hasBreaks: nut,
          splitBreaks: iut,
          lineBreakRegex: ff,
          removeScript: x7,
          getUrl: tl,
          evaluate: Pe,
          getMax: aut,
          getMin: out,
        }));
    });
  var fut,
    pw,
    k7,
    T7,
    S7,
    _7,
    no,
    bu = x(() => {
      "use strict";
      lI();
      un();
      Be();
      Vt();
      ((fut = {
        body: '<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/><text transform="translate(21.16 64.67)" style="fill: #fff; font-family: ArialMT, Arial; font-size: 67.75px;"><tspan x="0" y="0">?</tspan></text></g>',
        height: 80,
        width: 80,
      }),
        (pw = new Map()),
        (k7 = new Map()),
        (T7 = a((e) => {
          for (let t of e) {
            if (!t.name)
              throw new Error(
                'Invalid icon loader. Must have a "name" property with non-empty string value.',
              );
            if ((P.debug("Registering icon pack:", t.name), "loader" in t))
              k7.set(t.name, t.loader);
            else if ("icons" in t) pw.set(t.name, t.icons);
            else
              throw (
                P.error("Invalid icon loader:", t),
                new Error(
                  'Invalid icon loader. Must have either "icons" or "loader" property.',
                )
              );
          }
        }, "registerIconPacks")),
        (S7 = a(async (e, t) => {
          let r = NC(e, !0, t !== void 0);
          if (!r) throw new Error(`Invalid icon name: ${e}`);
          let n = r.prefix || t;
          if (!n) throw new Error(`Icon name must contain a prefix: ${e}`);
          let i = pw.get(n);
          if (!i) {
            let o = k7.get(n);
            if (!o) throw new Error(`Icon set not found: ${r.prefix}`);
            try {
              ((i = { ...(await o()), prefix: n }), pw.set(n, i));
            } catch (l) {
              throw (
                P.error(l),
                new Error(`Failed to load icon set: ${r.prefix}`)
              );
            }
          }
          let s = MC(i, r.name);
          if (!s) throw new Error(`Icon not found: ${e}`);
          return s;
        }, "getRegisteredIconData")),
        (_7 = a(async (e) => {
          try {
            return (await S7(e), !0);
          } catch {
            return !1;
          }
        }, "isIconAvailable")),
        (no = a(async (e, t, r) => {
          let n;
          try {
            n = await S7(e, t?.fallbackPrefix);
          } catch (o) {
            (P.error(o), (n = fut));
          }
          let i = PC(n, t),
            s = FC(BC(i.body), { ...i.attributes, ...r });
          return Ie(s, ke());
        }, "getIconSVG")));
    });
  function bx(e) {
    for (var t = [], r = 1; r < arguments.length; r++) t[r - 1] = arguments[r];
    var n = Array.from(typeof e == "string" ? [e] : e);
    n[n.length - 1] = n[n.length - 1].replace(/\r?\n([\t ]*)$/, "");
    var i = n.reduce(function (l, u) {
      var h = u.match(/\n([\t ]+|(?!\s).)/g);
      return h
        ? l.concat(
            h.map(function (f) {
              var d, p;
              return (p =
                (d = f.match(/[\t ]/g)) === null || d === void 0
                  ? void 0
                  : d.length) !== null && p !== void 0
                ? p
                : 0;
            }),
          )
        : l;
    }, []);
    if (i.length) {
      var s = new RegExp(
        `
[	 ]{` +
          Math.min.apply(Math, i) +
          "}",
        "g",
      );
      n = n.map(function (l) {
        return l.replace(
          s,
          `
`,
        );
      });
    }
    n[0] = n[0].replace(/^\r?\n/, "");
    var o = n[0];
    return (
      t.forEach(function (l, u) {
        var h = o.match(/(?:^|\n)( *)$/),
          f = h ? h[1] : "",
          d = l;
        (typeof l == "string" &&
          l.includes(`
`) &&
          (d = String(l)
            .split(
              `
`,
            )
            .map(function (p, m) {
              return m === 0 ? p : "" + f + p;
            }).join(`
`)),
          (o += d + n[u + 1]));
      }),
      o
    );
  }
  var mw = x(() => {
    "use strict";
    a(bx, "dedent");
  });
  var kx,
    ku,
    C7,
    Tx = x(() => {
      "use strict";
      ((kx = /^-{3}\s*[\n\r](.*?)[\n\r]-{3}\s*[\n\r]+/s),
        (ku =
          /%{2}{\s*(?:(\w+)\s*:|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi),
        (C7 = /\s*%%.*\n/gm));
    });
  var df,
    gw = x(() => {
      "use strict";
      df = class extends Error {
        static {
          a(this, "UnknownDiagramError");
        }
        constructor(t) {
          (super(t), (this.name = "UnknownDiagramError"));
        }
      };
    });
  var el,
    pf,
    Sx,
    yw,
    w7,
    Tu = x(() => {
      "use strict";
      Vt();
      Tx();
      gw();
      ((el = {}),
        (pf = a(function (e, t) {
          e = e
            .replace(kx, "")
            .replace(ku, "")
            .replace(
              C7,
              `
`,
            );
          for (let [r, { detector: n }] of Object.entries(el))
            if (n(e, t)) return r;
          throw new df(
            `No diagram type detected matching given configuration for text: ${e}`,
          );
        }, "detectType")),
        (Sx = a((...e) => {
          for (let { id: t, detector: r, loader: n } of e) yw(t, r, n);
        }, "registerLazyLoadedDiagrams")),
        (yw = a((e, t, r) => {
          (el[e] &&
            P.warn(`Detector with key ${e} already exists. Overwriting.`),
            (el[e] = { detector: t, loader: r }),
            P.debug(`Detector with key ${e} added${r ? " with loader" : ""}`));
        }, "addDetector")),
        (w7 = a((e) => el[e].loader, "getDiagramLoader")));
    });
  var sg,
    v7,
    xw = x(() => {
      "use strict";
      sg = (function () {
        var e = a(function (se, Nt, At, bt) {
            for (At = At || {}, bt = se.length; bt--; At[se[bt]] = Nt);
            return At;
          }, "o"),
          t = [1, 24],
          r = [1, 25],
          n = [1, 26],
          i = [1, 27],
          s = [1, 28],
          o = [1, 63],
          l = [1, 64],
          u = [1, 65],
          h = [1, 66],
          f = [1, 67],
          d = [1, 68],
          p = [1, 69],
          m = [1, 29],
          g = [1, 30],
          y = [1, 31],
          b = [1, 32],
          k = [1, 33],
          T = [1, 34],
          C = [1, 35],
          L = [1, 36],
          w = [1, 37],
          D = [1, 38],
          G = [1, 39],
          E = [1, 40],
          R = [1, 41],
          F = [1, 42],
          S = [1, 43],
          O = [1, 44],
          v = [1, 45],
          _ = [1, 46],
          A = [1, 47],
          N = [1, 48],
          B = [1, 50],
          M = [1, 51],
          I = [1, 52],
          V = [1, 53],
          $ = [1, 54],
          q = [1, 55],
          tt = [1, 56],
          ht = [1, 57],
          H = [1, 58],
          kt = [1, 59],
          ft = [1, 60],
          yt = [14, 42],
          ot = [
            14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50, 51,
            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68,
            69, 70, 71, 72, 73, 74,
          ],
          dt = [
            12, 14, 34, 36, 37, 38, 39, 40, 41, 42, 44, 45, 46, 47, 48, 49, 50,
            51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67,
            68, 69, 70, 71, 72, 73, 74,
          ],
          nt = [1, 82],
          Q = [1, 83],
          et = [1, 84],
          X = [1, 85],
          st = [12, 14, 42],
          U = [12, 14, 33, 42],
          gt = [12, 14, 33, 42, 76, 77, 79, 80],
          z = [12, 33],
          ge = [
            34, 36, 37, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,
            54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,
            71, 72, 73, 74,
          ],
          lt = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              mermaidDoc: 4,
              direction: 5,
              direction_tb: 6,
              direction_bt: 7,
              direction_rl: 8,
              direction_lr: 9,
              graphConfig: 10,
              C4_CONTEXT: 11,
              NEWLINE: 12,
              statements: 13,
              EOF: 14,
              C4_CONTAINER: 15,
              C4_COMPONENT: 16,
              C4_DYNAMIC: 17,
              C4_DEPLOYMENT: 18,
              otherStatements: 19,
              diagramStatements: 20,
              otherStatement: 21,
              title: 22,
              accDescription: 23,
              acc_title: 24,
              acc_title_value: 25,
              acc_descr: 26,
              acc_descr_value: 27,
              acc_descr_multiline_value: 28,
              boundaryStatement: 29,
              boundaryStartStatement: 30,
              boundaryStopStatement: 31,
              boundaryStart: 32,
              LBRACE: 33,
              ENTERPRISE_BOUNDARY: 34,
              attributes: 35,
              SYSTEM_BOUNDARY: 36,
              BOUNDARY: 37,
              CONTAINER_BOUNDARY: 38,
              NODE: 39,
              NODE_L: 40,
              NODE_R: 41,
              RBRACE: 42,
              diagramStatement: 43,
              PERSON: 44,
              PERSON_EXT: 45,
              SYSTEM: 46,
              SYSTEM_DB: 47,
              SYSTEM_QUEUE: 48,
              SYSTEM_EXT: 49,
              SYSTEM_EXT_DB: 50,
              SYSTEM_EXT_QUEUE: 51,
              CONTAINER: 52,
              CONTAINER_DB: 53,
              CONTAINER_QUEUE: 54,
              CONTAINER_EXT: 55,
              CONTAINER_EXT_DB: 56,
              CONTAINER_EXT_QUEUE: 57,
              COMPONENT: 58,
              COMPONENT_DB: 59,
              COMPONENT_QUEUE: 60,
              COMPONENT_EXT: 61,
              COMPONENT_EXT_DB: 62,
              COMPONENT_EXT_QUEUE: 63,
              REL: 64,
              BIREL: 65,
              REL_U: 66,
              REL_D: 67,
              REL_L: 68,
              REL_R: 69,
              REL_B: 70,
              REL_INDEX: 71,
              UPDATE_EL_STYLE: 72,
              UPDATE_REL_STYLE: 73,
              UPDATE_LAYOUT_CONFIG: 74,
              attribute: 75,
              STR: 76,
              STR_KEY: 77,
              STR_VALUE: 78,
              ATTRIBUTE: 79,
              ATTRIBUTE_EMPTY: 80,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              6: "direction_tb",
              7: "direction_bt",
              8: "direction_rl",
              9: "direction_lr",
              11: "C4_CONTEXT",
              12: "NEWLINE",
              14: "EOF",
              15: "C4_CONTAINER",
              16: "C4_COMPONENT",
              17: "C4_DYNAMIC",
              18: "C4_DEPLOYMENT",
              22: "title",
              23: "accDescription",
              24: "acc_title",
              25: "acc_title_value",
              26: "acc_descr",
              27: "acc_descr_value",
              28: "acc_descr_multiline_value",
              33: "LBRACE",
              34: "ENTERPRISE_BOUNDARY",
              36: "SYSTEM_BOUNDARY",
              37: "BOUNDARY",
              38: "CONTAINER_BOUNDARY",
              39: "NODE",
              40: "NODE_L",
              41: "NODE_R",
              42: "RBRACE",
              44: "PERSON",
              45: "PERSON_EXT",
              46: "SYSTEM",
              47: "SYSTEM_DB",
              48: "SYSTEM_QUEUE",
              49: "SYSTEM_EXT",
              50: "SYSTEM_EXT_DB",
              51: "SYSTEM_EXT_QUEUE",
              52: "CONTAINER",
              53: "CONTAINER_DB",
              54: "CONTAINER_QUEUE",
              55: "CONTAINER_EXT",
              56: "CONTAINER_EXT_DB",
              57: "CONTAINER_EXT_QUEUE",
              58: "COMPONENT",
              59: "COMPONENT_DB",
              60: "COMPONENT_QUEUE",
              61: "COMPONENT_EXT",
              62: "COMPONENT_EXT_DB",
              63: "COMPONENT_EXT_QUEUE",
              64: "REL",
              65: "BIREL",
              66: "REL_U",
              67: "REL_D",
              68: "REL_L",
              69: "REL_R",
              70: "REL_B",
              71: "REL_INDEX",
              72: "UPDATE_EL_STYLE",
              73: "UPDATE_REL_STYLE",
              74: "UPDATE_LAYOUT_CONFIG",
              76: "STR",
              77: "STR_KEY",
              78: "STR_VALUE",
              79: "ATTRIBUTE",
              80: "ATTRIBUTE_EMPTY",
            },
            productions_: [
              0,
              [3, 1],
              [3, 1],
              [5, 1],
              [5, 1],
              [5, 1],
              [5, 1],
              [4, 1],
              [10, 4],
              [10, 4],
              [10, 4],
              [10, 4],
              [10, 4],
              [13, 1],
              [13, 1],
              [13, 2],
              [19, 1],
              [19, 2],
              [19, 3],
              [21, 1],
              [21, 1],
              [21, 2],
              [21, 2],
              [21, 1],
              [29, 3],
              [30, 3],
              [30, 3],
              [30, 4],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [32, 2],
              [31, 1],
              [20, 1],
              [20, 2],
              [20, 3],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 1],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [43, 2],
              [35, 1],
              [35, 2],
              [75, 1],
              [75, 2],
              [75, 1],
              [75, 1],
            ],
            performAction: a(function (Nt, At, bt, ct, Lt, Z, Mt) {
              var W = Z.length - 1;
              switch (Lt) {
                case 3:
                  ct.setDirection("TB");
                  break;
                case 4:
                  ct.setDirection("BT");
                  break;
                case 5:
                  ct.setDirection("RL");
                  break;
                case 6:
                  ct.setDirection("LR");
                  break;
                case 8:
                case 9:
                case 10:
                case 11:
                case 12:
                  ct.setC4Type(Z[W - 3]);
                  break;
                case 19:
                  (ct.setTitle(Z[W].substring(6)),
                    (this.$ = Z[W].substring(6)));
                  break;
                case 20:
                  (ct.setAccDescription(Z[W].substring(15)),
                    (this.$ = Z[W].substring(15)));
                  break;
                case 21:
                  ((this.$ = Z[W].trim()), ct.setTitle(this.$));
                  break;
                case 22:
                case 23:
                  ((this.$ = Z[W].trim()), ct.setAccDescription(this.$));
                  break;
                case 28:
                  (Z[W].splice(2, 0, "ENTERPRISE"),
                    ct.addPersonOrSystemBoundary(...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 29:
                  (Z[W].splice(2, 0, "SYSTEM"),
                    ct.addPersonOrSystemBoundary(...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 30:
                  (ct.addPersonOrSystemBoundary(...Z[W]), (this.$ = Z[W]));
                  break;
                case 31:
                  (Z[W].splice(2, 0, "CONTAINER"),
                    ct.addContainerBoundary(...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 32:
                  (ct.addDeploymentNode("node", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 33:
                  (ct.addDeploymentNode("nodeL", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 34:
                  (ct.addDeploymentNode("nodeR", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 35:
                  ct.popBoundaryParseStack();
                  break;
                case 39:
                  (ct.addPersonOrSystem("person", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 40:
                  (ct.addPersonOrSystem("external_person", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 41:
                  (ct.addPersonOrSystem("system", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 42:
                  (ct.addPersonOrSystem("system_db", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 43:
                  (ct.addPersonOrSystem("system_queue", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 44:
                  (ct.addPersonOrSystem("external_system", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 45:
                  (ct.addPersonOrSystem("external_system_db", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 46:
                  (ct.addPersonOrSystem("external_system_queue", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 47:
                  (ct.addContainer("container", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 48:
                  (ct.addContainer("container_db", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 49:
                  (ct.addContainer("container_queue", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 50:
                  (ct.addContainer("external_container", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 51:
                  (ct.addContainer("external_container_db", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 52:
                  (ct.addContainer("external_container_queue", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 53:
                  (ct.addComponent("component", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 54:
                  (ct.addComponent("component_db", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 55:
                  (ct.addComponent("component_queue", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 56:
                  (ct.addComponent("external_component", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 57:
                  (ct.addComponent("external_component_db", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 58:
                  (ct.addComponent("external_component_queue", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 60:
                  (ct.addRel("rel", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 61:
                  (ct.addRel("birel", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 62:
                  (ct.addRel("rel_u", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 63:
                  (ct.addRel("rel_d", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 64:
                  (ct.addRel("rel_l", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 65:
                  (ct.addRel("rel_r", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 66:
                  (ct.addRel("rel_b", ...Z[W]), (this.$ = Z[W]));
                  break;
                case 67:
                  (Z[W].splice(0, 1),
                    ct.addRel("rel", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 68:
                  (ct.updateElStyle("update_el_style", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 69:
                  (ct.updateRelStyle("update_rel_style", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 70:
                  (ct.updateLayoutConfig("update_layout_config", ...Z[W]),
                    (this.$ = Z[W]));
                  break;
                case 71:
                  this.$ = [Z[W]];
                  break;
                case 72:
                  (Z[W].unshift(Z[W - 1]), (this.$ = Z[W]));
                  break;
                case 73:
                case 75:
                  this.$ = Z[W].trim();
                  break;
                case 74:
                  let Gt = {};
                  ((Gt[Z[W - 1].trim()] = Z[W].trim()), (this.$ = Gt));
                  break;
                case 76:
                  this.$ = "";
                  break;
              }
            }, "anonymous"),
            table: [
              {
                3: 1,
                4: 2,
                5: 3,
                6: [1, 5],
                7: [1, 6],
                8: [1, 7],
                9: [1, 8],
                10: 4,
                11: [1, 9],
                15: [1, 10],
                16: [1, 11],
                17: [1, 12],
                18: [1, 13],
              },
              { 1: [3] },
              { 1: [2, 1] },
              { 1: [2, 2] },
              { 1: [2, 7] },
              { 1: [2, 3] },
              { 1: [2, 4] },
              { 1: [2, 5] },
              { 1: [2, 6] },
              { 12: [1, 14] },
              { 12: [1, 15] },
              { 12: [1, 16] },
              { 12: [1, 17] },
              { 12: [1, 18] },
              {
                13: 19,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              },
              {
                13: 70,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              },
              {
                13: 71,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              },
              {
                13: 72,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              },
              {
                13: 73,
                19: 20,
                20: 21,
                21: 22,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              },
              { 14: [1, 74] },
              e(yt, [2, 13], {
                43: 23,
                29: 49,
                30: 61,
                32: 62,
                20: 75,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              }),
              e(yt, [2, 14]),
              e(ot, [2, 16], { 12: [1, 76] }),
              e(yt, [2, 36], { 12: [1, 77] }),
              e(dt, [2, 19]),
              e(dt, [2, 20]),
              { 25: [1, 78] },
              { 27: [1, 79] },
              e(dt, [2, 23]),
              { 35: 80, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 86, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 87, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 88, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 89, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 90, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 91, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 92, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 93, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 94, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 95, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 96, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 97, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 98, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 99, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 100, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 101, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 102, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 103, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 104, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              e(st, [2, 59]),
              { 35: 105, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 106, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 107, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 108, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 109, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 110, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 111, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 112, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 113, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 114, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 115, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              {
                20: 116,
                29: 49,
                30: 61,
                32: 62,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                43: 23,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              },
              { 12: [1, 118], 33: [1, 117] },
              { 35: 119, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 120, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 121, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 122, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 123, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 124, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 35: 125, 75: 81, 76: nt, 77: Q, 79: et, 80: X },
              { 14: [1, 126] },
              { 14: [1, 127] },
              { 14: [1, 128] },
              { 14: [1, 129] },
              { 1: [2, 8] },
              e(yt, [2, 15]),
              e(ot, [2, 17], {
                21: 22,
                19: 130,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
              }),
              e(yt, [2, 37], {
                19: 20,
                20: 21,
                21: 22,
                43: 23,
                29: 49,
                30: 61,
                32: 62,
                13: 131,
                22: t,
                23: r,
                24: n,
                26: i,
                28: s,
                34: o,
                36: l,
                37: u,
                38: h,
                39: f,
                40: d,
                41: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
                51: L,
                52: w,
                53: D,
                54: G,
                55: E,
                56: R,
                57: F,
                58: S,
                59: O,
                60: v,
                61: _,
                62: A,
                63: N,
                64: B,
                65: M,
                66: I,
                67: V,
                68: $,
                69: q,
                70: tt,
                71: ht,
                72: H,
                73: kt,
                74: ft,
              }),
              e(dt, [2, 21]),
              e(dt, [2, 22]),
              e(st, [2, 39]),
              e(U, [2, 71], { 75: 81, 35: 132, 76: nt, 77: Q, 79: et, 80: X }),
              e(gt, [2, 73]),
              { 78: [1, 133] },
              e(gt, [2, 75]),
              e(gt, [2, 76]),
              e(st, [2, 40]),
              e(st, [2, 41]),
              e(st, [2, 42]),
              e(st, [2, 43]),
              e(st, [2, 44]),
              e(st, [2, 45]),
              e(st, [2, 46]),
              e(st, [2, 47]),
              e(st, [2, 48]),
              e(st, [2, 49]),
              e(st, [2, 50]),
              e(st, [2, 51]),
              e(st, [2, 52]),
              e(st, [2, 53]),
              e(st, [2, 54]),
              e(st, [2, 55]),
              e(st, [2, 56]),
              e(st, [2, 57]),
              e(st, [2, 58]),
              e(st, [2, 60]),
              e(st, [2, 61]),
              e(st, [2, 62]),
              e(st, [2, 63]),
              e(st, [2, 64]),
              e(st, [2, 65]),
              e(st, [2, 66]),
              e(st, [2, 67]),
              e(st, [2, 68]),
              e(st, [2, 69]),
              e(st, [2, 70]),
              { 31: 134, 42: [1, 135] },
              { 12: [1, 136] },
              { 33: [1, 137] },
              e(z, [2, 28]),
              e(z, [2, 29]),
              e(z, [2, 30]),
              e(z, [2, 31]),
              e(z, [2, 32]),
              e(z, [2, 33]),
              e(z, [2, 34]),
              { 1: [2, 9] },
              { 1: [2, 10] },
              { 1: [2, 11] },
              { 1: [2, 12] },
              e(ot, [2, 18]),
              e(yt, [2, 38]),
              e(U, [2, 72]),
              e(gt, [2, 74]),
              e(st, [2, 24]),
              e(st, [2, 35]),
              e(ge, [2, 25]),
              e(ge, [2, 26], { 12: [1, 138] }),
              e(ge, [2, 27]),
            ],
            defaultActions: {
              2: [2, 1],
              3: [2, 2],
              4: [2, 7],
              5: [2, 3],
              6: [2, 4],
              7: [2, 5],
              8: [2, 6],
              74: [2, 8],
              126: [2, 9],
              127: [2, 10],
              128: [2, 11],
              129: [2, 12],
            },
            parseError: a(function (Nt, At) {
              if (At.recoverable) this.trace(Nt);
              else {
                var bt = new Error(Nt);
                throw ((bt.hash = At), bt);
              }
            }, "parseError"),
            parse: a(function (Nt) {
              var At = this,
                bt = [0],
                ct = [],
                Lt = [null],
                Z = [],
                Mt = this.table,
                W = "",
                Gt = 0,
                j = 0,
                Et = 0,
                mt = 2,
                Xt = 1,
                Ft = Z.slice.call(arguments, 1),
                _t = Object.create(this.lexer),
                Qe = { yy: {} };
              for (var It in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, It) &&
                  (Qe.yy[It] = this.yy[It]);
              (_t.setInput(Nt, Qe.yy),
                (Qe.yy.lexer = _t),
                (Qe.yy.parser = this),
                typeof _t.yylloc > "u" && (_t.yylloc = {}));
              var xr = _t.yylloc;
              Z.push(xr);
              var Ze = _t.options && _t.options.ranges;
              typeof Qe.yy.parseError == "function"
                ? (this.parseError = Qe.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function mn(Ht) {
                ((bt.length = bt.length - 2 * Ht),
                  (Lt.length = Lt.length - Ht),
                  (Z.length = Z.length - Ht));
              }
              a(mn, "popStack");
              function Ae() {
                var Ht;
                return (
                  (Ht = ct.pop() || _t.lex() || Xt),
                  typeof Ht != "number" &&
                    (Ht instanceof Array && ((ct = Ht), (Ht = ct.pop())),
                    (Ht = At.symbols_[Ht] || Ht)),
                  Ht
                );
              }
              a(Ae, "lex");
              for (var Te, Je, Se, hr, Sn, Ee, $e = {}, Le, xe, fe, ye; ; ) {
                if (
                  ((Se = bt[bt.length - 1]),
                  this.defaultActions[Se]
                    ? (hr = this.defaultActions[Se])
                    : ((Te === null || typeof Te > "u") && (Te = Ae()),
                      (hr = Mt[Se] && Mt[Se][Te])),
                  typeof hr > "u" || !hr.length || !hr[0])
                ) {
                  var be = "";
                  ye = [];
                  for (Le in Mt[Se])
                    this.terminals_[Le] &&
                      Le > mt &&
                      ye.push("'" + this.terminals_[Le] + "'");
                  (_t.showPosition
                    ? (be =
                        "Parse error on line " +
                        (Gt + 1) +
                        `:
` +
                        _t.showPosition() +
                        `
Expecting ` +
                        ye.join(", ") +
                        ", got '" +
                        (this.terminals_[Te] || Te) +
                        "'")
                    : (be =
                        "Parse error on line " +
                        (Gt + 1) +
                        ": Unexpected " +
                        (Te == Xt
                          ? "end of input"
                          : "'" + (this.terminals_[Te] || Te) + "'")),
                    this.parseError(be, {
                      text: _t.match,
                      token: this.terminals_[Te] || Te,
                      line: _t.yylineno,
                      loc: xr,
                      expected: ye,
                    }));
                }
                if (hr[0] instanceof Array && hr.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      Se +
                      ", token: " +
                      Te,
                  );
                switch (hr[0]) {
                  case 1:
                    (bt.push(Te),
                      Lt.push(_t.yytext),
                      Z.push(_t.yylloc),
                      bt.push(hr[1]),
                      (Te = null),
                      Je
                        ? ((Te = Je), (Je = null))
                        : ((j = _t.yyleng),
                          (W = _t.yytext),
                          (Gt = _t.yylineno),
                          (xr = _t.yylloc),
                          Et > 0 && Et--));
                    break;
                  case 2:
                    if (
                      ((xe = this.productions_[hr[1]][1]),
                      ($e.$ = Lt[Lt.length - xe]),
                      ($e._$ = {
                        first_line: Z[Z.length - (xe || 1)].first_line,
                        last_line: Z[Z.length - 1].last_line,
                        first_column: Z[Z.length - (xe || 1)].first_column,
                        last_column: Z[Z.length - 1].last_column,
                      }),
                      Ze &&
                        ($e._$.range = [
                          Z[Z.length - (xe || 1)].range[0],
                          Z[Z.length - 1].range[1],
                        ]),
                      (Ee = this.performAction.apply(
                        $e,
                        [W, j, Gt, Qe.yy, hr[1], Lt, Z].concat(Ft),
                      )),
                      typeof Ee < "u")
                    )
                      return Ee;
                    (xe &&
                      ((bt = bt.slice(0, -1 * xe * 2)),
                      (Lt = Lt.slice(0, -1 * xe)),
                      (Z = Z.slice(0, -1 * xe))),
                      bt.push(this.productions_[hr[1]][0]),
                      Lt.push($e.$),
                      Z.push($e._$),
                      (fe = Mt[bt[bt.length - 2]][bt[bt.length - 1]]),
                      bt.push(fe));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          jt = (function () {
            var se = {
              EOF: 1,
              parseError: a(function (At, bt) {
                if (this.yy.parser) this.yy.parser.parseError(At, bt);
                else throw new Error(At);
              }, "parseError"),
              setInput: a(function (Nt, At) {
                return (
                  (this.yy = At || this.yy || {}),
                  (this._input = Nt),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var Nt = this._input[0];
                ((this.yytext += Nt),
                  this.yyleng++,
                  this.offset++,
                  (this.match += Nt),
                  (this.matched += Nt));
                var At = Nt.match(/(?:\r\n?|\n).*/g);
                return (
                  At
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  Nt
                );
              }, "input"),
              unput: a(function (Nt) {
                var At = Nt.length,
                  bt = Nt.split(/(?:\r\n?|\n)/g);
                ((this._input = Nt + this._input),
                  (this.yytext = this.yytext.substr(
                    0,
                    this.yytext.length - At,
                  )),
                  (this.offset -= At));
                var ct = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  bt.length - 1 && (this.yylineno -= bt.length - 1));
                var Lt = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: bt
                      ? (bt.length === ct.length
                          ? this.yylloc.first_column
                          : 0) +
                        ct[ct.length - bt.length].length -
                        bt[0].length
                      : this.yylloc.first_column - At,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [Lt[0], Lt[0] + this.yyleng - At]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (Nt) {
                this.unput(this.match.slice(Nt));
              }, "less"),
              pastInput: a(function () {
                var Nt = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (Nt.length > 20 ? "..." : "") +
                  Nt.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var Nt = this.match;
                return (
                  Nt.length < 20 &&
                    (Nt += this._input.substr(0, 20 - Nt.length)),
                  (Nt.substr(0, 20) + (Nt.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var Nt = this.pastInput(),
                  At = new Array(Nt.length + 1).join("-");
                return (
                  Nt +
                  this.upcomingInput() +
                  `
` +
                  At +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (Nt, At) {
                var bt, ct, Lt;
                if (
                  (this.options.backtrack_lexer &&
                    ((Lt = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (Lt.yylloc.range = this.yylloc.range.slice(0))),
                  (ct = Nt[0].match(/(?:\r\n?|\n).*/g)),
                  ct && (this.yylineno += ct.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: ct
                      ? ct[ct.length - 1].length -
                        ct[ct.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + Nt[0].length,
                  }),
                  (this.yytext += Nt[0]),
                  (this.match += Nt[0]),
                  (this.matches = Nt),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(Nt[0].length)),
                  (this.matched += Nt[0]),
                  (bt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    At,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  bt)
                )
                  return bt;
                if (this._backtrack) {
                  for (var Z in Lt) this[Z] = Lt[Z];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var Nt, At, bt, ct;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var Lt = this._currentRules(), Z = 0; Z < Lt.length; Z++)
                  if (
                    ((bt = this._input.match(this.rules[Lt[Z]])),
                    bt && (!At || bt[0].length > At[0].length))
                  ) {
                    if (((At = bt), (ct = Z), this.options.backtrack_lexer)) {
                      if (((Nt = this.test_match(bt, Lt[Z])), Nt !== !1))
                        return Nt;
                      if (this._backtrack) {
                        At = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return At
                  ? ((Nt = this.test_match(At, Lt[ct])), Nt !== !1 ? Nt : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var At = this.next();
                return At || this.lex();
              }, "lex"),
              begin: a(function (At) {
                this.conditionStack.push(At);
              }, "begin"),
              popState: a(function () {
                var At = this.conditionStack.length - 1;
                return At > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (At) {
                return (
                  (At = this.conditionStack.length - 1 - Math.abs(At || 0)),
                  At >= 0 ? this.conditionStack[At] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (At) {
                this.begin(At);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: {},
              performAction: a(function (At, bt, ct, Lt) {
                var Z = Lt;
                switch (ct) {
                  case 0:
                    return 6;
                  case 1:
                    return 7;
                  case 2:
                    return 8;
                  case 3:
                    return 9;
                  case 4:
                    return 22;
                  case 5:
                    return 23;
                  case 6:
                    return (this.begin("acc_title"), 24);
                    break;
                  case 7:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 8:
                    return (this.begin("acc_descr"), 26);
                    break;
                  case 9:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 10:
                    this.begin("acc_descr_multiline");
                    break;
                  case 11:
                    this.popState();
                    break;
                  case 12:
                    return "acc_descr_multiline_value";
                  case 13:
                    break;
                  case 14:
                    c;
                    break;
                  case 15:
                    return 12;
                  case 16:
                    break;
                  case 17:
                    return 11;
                  case 18:
                    return 15;
                  case 19:
                    return 16;
                  case 20:
                    return 17;
                  case 21:
                    return 18;
                  case 22:
                    return (this.begin("person_ext"), 45);
                    break;
                  case 23:
                    return (this.begin("person"), 44);
                    break;
                  case 24:
                    return (this.begin("system_ext_queue"), 51);
                    break;
                  case 25:
                    return (this.begin("system_ext_db"), 50);
                    break;
                  case 26:
                    return (this.begin("system_ext"), 49);
                    break;
                  case 27:
                    return (this.begin("system_queue"), 48);
                    break;
                  case 28:
                    return (this.begin("system_db"), 47);
                    break;
                  case 29:
                    return (this.begin("system"), 46);
                    break;
                  case 30:
                    return (this.begin("boundary"), 37);
                    break;
                  case 31:
                    return (this.begin("enterprise_boundary"), 34);
                    break;
                  case 32:
                    return (this.begin("system_boundary"), 36);
                    break;
                  case 33:
                    return (this.begin("container_ext_queue"), 57);
                    break;
                  case 34:
                    return (this.begin("container_ext_db"), 56);
                    break;
                  case 35:
                    return (this.begin("container_ext"), 55);
                    break;
                  case 36:
                    return (this.begin("container_queue"), 54);
                    break;
                  case 37:
                    return (this.begin("container_db"), 53);
                    break;
                  case 38:
                    return (this.begin("container"), 52);
                    break;
                  case 39:
                    return (this.begin("container_boundary"), 38);
                    break;
                  case 40:
                    return (this.begin("component_ext_queue"), 63);
                    break;
                  case 41:
                    return (this.begin("component_ext_db"), 62);
                    break;
                  case 42:
                    return (this.begin("component_ext"), 61);
                    break;
                  case 43:
                    return (this.begin("component_queue"), 60);
                    break;
                  case 44:
                    return (this.begin("component_db"), 59);
                    break;
                  case 45:
                    return (this.begin("component"), 58);
                    break;
                  case 46:
                    return (this.begin("node"), 39);
                    break;
                  case 47:
                    return (this.begin("node"), 39);
                    break;
                  case 48:
                    return (this.begin("node_l"), 40);
                    break;
                  case 49:
                    return (this.begin("node_r"), 41);
                    break;
                  case 50:
                    return (this.begin("rel"), 64);
                    break;
                  case 51:
                    return (this.begin("birel"), 65);
                    break;
                  case 52:
                    return (this.begin("rel_u"), 66);
                    break;
                  case 53:
                    return (this.begin("rel_u"), 66);
                    break;
                  case 54:
                    return (this.begin("rel_d"), 67);
                    break;
                  case 55:
                    return (this.begin("rel_d"), 67);
                    break;
                  case 56:
                    return (this.begin("rel_l"), 68);
                    break;
                  case 57:
                    return (this.begin("rel_l"), 68);
                    break;
                  case 58:
                    return (this.begin("rel_r"), 69);
                    break;
                  case 59:
                    return (this.begin("rel_r"), 69);
                    break;
                  case 60:
                    return (this.begin("rel_b"), 70);
                    break;
                  case 61:
                    return (this.begin("rel_index"), 71);
                    break;
                  case 62:
                    return (this.begin("update_el_style"), 72);
                    break;
                  case 63:
                    return (this.begin("update_rel_style"), 73);
                    break;
                  case 64:
                    return (this.begin("update_layout_config"), 74);
                    break;
                  case 65:
                    return "EOF_IN_STRUCT";
                  case 66:
                    return (this.begin("attribute"), "ATTRIBUTE_EMPTY");
                    break;
                  case 67:
                    this.begin("attribute");
                    break;
                  case 68:
                    (this.popState(), this.popState());
                    break;
                  case 69:
                    return 80;
                  case 70:
                    break;
                  case 71:
                    return 80;
                  case 72:
                    this.begin("string");
                    break;
                  case 73:
                    this.popState();
                    break;
                  case 74:
                    return "STR";
                  case 75:
                    this.begin("string_kv");
                    break;
                  case 76:
                    return (this.begin("string_kv_key"), "STR_KEY");
                    break;
                  case 77:
                    (this.popState(), this.begin("string_kv_value"));
                    break;
                  case 78:
                    return "STR_VALUE";
                  case 79:
                    (this.popState(), this.popState());
                    break;
                  case 80:
                    return "STR";
                  case 81:
                    return "LBRACE";
                  case 82:
                    return "RBRACE";
                  case 83:
                    return "SPACE";
                  case 84:
                    return "EOL";
                  case 85:
                    return 14;
                }
              }, "anonymous"),
              rules: [
                /^(?:.*direction\s+TB[^\n]*)/,
                /^(?:.*direction\s+BT[^\n]*)/,
                /^(?:.*direction\s+RL[^\n]*)/,
                /^(?:.*direction\s+LR[^\n]*)/,
                /^(?:title\s[^#\n;]+)/,
                /^(?:accDescription\s[^#\n;]+)/,
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/,
                /^(?:%%[^\n]*(\r?\n)*)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:C4Context\b)/,
                /^(?:C4Container\b)/,
                /^(?:C4Component\b)/,
                /^(?:C4Dynamic\b)/,
                /^(?:C4Deployment\b)/,
                /^(?:Person_Ext\b)/,
                /^(?:Person\b)/,
                /^(?:SystemQueue_Ext\b)/,
                /^(?:SystemDb_Ext\b)/,
                /^(?:System_Ext\b)/,
                /^(?:SystemQueue\b)/,
                /^(?:SystemDb\b)/,
                /^(?:System\b)/,
                /^(?:Boundary\b)/,
                /^(?:Enterprise_Boundary\b)/,
                /^(?:System_Boundary\b)/,
                /^(?:ContainerQueue_Ext\b)/,
                /^(?:ContainerDb_Ext\b)/,
                /^(?:Container_Ext\b)/,
                /^(?:ContainerQueue\b)/,
                /^(?:ContainerDb\b)/,
                /^(?:Container\b)/,
                /^(?:Container_Boundary\b)/,
                /^(?:ComponentQueue_Ext\b)/,
                /^(?:ComponentDb_Ext\b)/,
                /^(?:Component_Ext\b)/,
                /^(?:ComponentQueue\b)/,
                /^(?:ComponentDb\b)/,
                /^(?:Component\b)/,
                /^(?:Deployment_Node\b)/,
                /^(?:Node\b)/,
                /^(?:Node_L\b)/,
                /^(?:Node_R\b)/,
                /^(?:Rel\b)/,
                /^(?:BiRel\b)/,
                /^(?:Rel_Up\b)/,
                /^(?:Rel_U\b)/,
                /^(?:Rel_Down\b)/,
                /^(?:Rel_D\b)/,
                /^(?:Rel_Left\b)/,
                /^(?:Rel_L\b)/,
                /^(?:Rel_Right\b)/,
                /^(?:Rel_R\b)/,
                /^(?:Rel_Back\b)/,
                /^(?:RelIndex\b)/,
                /^(?:UpdateElementStyle\b)/,
                /^(?:UpdateRelStyle\b)/,
                /^(?:UpdateLayoutConfig\b)/,
                /^(?:$)/,
                /^(?:[(][ ]*[,])/,
                /^(?:[(])/,
                /^(?:[)])/,
                /^(?:,,)/,
                /^(?:,)/,
                /^(?:[ ]*["]["])/,
                /^(?:[ ]*["])/,
                /^(?:["])/,
                /^(?:[^"]*)/,
                /^(?:[ ]*[\$])/,
                /^(?:[^=]*)/,
                /^(?:[=][ ]*["])/,
                /^(?:[^"]+)/,
                /^(?:["])/,
                /^(?:[^,]+)/,
                /^(?:\{)/,
                /^(?:\})/,
                /^(?:[\s]+)/,
                /^(?:[\n\r]+)/,
                /^(?:$)/,
              ],
              conditions: {
                acc_descr_multiline: { rules: [11, 12], inclusive: !1 },
                acc_descr: { rules: [9], inclusive: !1 },
                acc_title: { rules: [7], inclusive: !1 },
                string_kv_value: { rules: [78, 79], inclusive: !1 },
                string_kv_key: { rules: [77], inclusive: !1 },
                string_kv: { rules: [76], inclusive: !1 },
                string: { rules: [73, 74], inclusive: !1 },
                attribute: {
                  rules: [68, 69, 70, 71, 72, 75, 80],
                  inclusive: !1,
                },
                update_layout_config: {
                  rules: [65, 66, 67, 68],
                  inclusive: !1,
                },
                update_rel_style: { rules: [65, 66, 67, 68], inclusive: !1 },
                update_el_style: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_b: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_r: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_l: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_d: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_u: { rules: [65, 66, 67, 68], inclusive: !1 },
                rel_bi: { rules: [], inclusive: !1 },
                rel: { rules: [65, 66, 67, 68], inclusive: !1 },
                node_r: { rules: [65, 66, 67, 68], inclusive: !1 },
                node_l: { rules: [65, 66, 67, 68], inclusive: !1 },
                node: { rules: [65, 66, 67, 68], inclusive: !1 },
                index: { rules: [], inclusive: !1 },
                rel_index: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_ext_queue: { rules: [], inclusive: !1 },
                component_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                component_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                component: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                container_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                container: { rules: [65, 66, 67, 68], inclusive: !1 },
                birel: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                enterprise_boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                boundary: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_ext_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_ext_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_queue: { rules: [65, 66, 67, 68], inclusive: !1 },
                system_db: { rules: [65, 66, 67, 68], inclusive: !1 },
                system: { rules: [65, 66, 67, 68], inclusive: !1 },
                person_ext: { rules: [65, 66, 67, 68], inclusive: !1 },
                person: { rules: [65, 66, 67, 68], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20,
                    21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,
                    36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50,
                    51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 81,
                    82, 83, 84, 85,
                  ],
                  inclusive: !0,
                },
              },
            };
            return se;
          })();
        lt.lexer = jt;
        function Me() {
          this.yy = {};
        }
        return (
          a(Me, "Parser"),
          (Me.prototype = lt),
          (lt.Parser = Me),
          new Me()
        );
      })();
      sg.parser = sg;
      v7 = sg;
    });
  var dut,
    put,
    Ar,
    Ql,
    On = x(() => {
      "use strict";
      Vt();
      ((dut = a(function (e, t) {
        for (let r of t) e.attr(r[0], r[1]);
      }, "d3Attrs")),
        (put = a(function (e, t, r) {
          let n = new Map();
          return (
            r
              ? (n.set("width", "100%"), n.set("style", `max-width: ${t}px;`))
              : (n.set("height", e), n.set("width", t)),
            n
          );
        }, "calculateSvgSizeAttrs")),
        (Ar = a(function (e, t, r, n) {
          let i = put(t, r, n);
          dut(e, i);
        }, "configureSvgSize")),
        (Ql = a(function (e, t, r, n) {
          let i = t.node().getBBox(),
            s = i.width,
            o = i.height;
          P.info(`SVG bounds: ${s}x${o}`, i);
          let l = 0,
            u = 0;
          (P.info(`Graph bounds: ${l}x${u}`, e),
            (l = s + r * 2),
            (u = o + r * 2),
            P.info(`Calculated bounds: ${l}x${u}`),
            Ar(t, u, l, n));
          let h = `${i.x - r} ${i.y - r} ${i.width + 2 * r} ${i.height + 2 * r}`;
          t.attr("viewBox", h);
        }, "setupGraphViewbox")));
    });
  var _x,
    mut,
    E7,
    A7,
    bw = x(() => {
      "use strict";
      Vt();
      ((_x = {}),
        (mut = a((e, t, r) => {
          let n = "";
          return (
            e in _x && _x[e]
              ? (n = _x[e](r))
              : P.warn(`No theme found for ${e}`),
            ` & {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
    fill: ${r.textColor}
  }
  @keyframes edge-animation-frame {
    from {
      stroke-dashoffset: 0;
    }
  }
  @keyframes dash {
    to {
      stroke-dashoffset: 0;
    }
  }
  & .edge-animation-slow {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 50s linear infinite;
    stroke-linecap: round;
  }
  & .edge-animation-fast {
    stroke-dasharray: 9,5 !important;
    stroke-dashoffset: 900;
    animation: dash 20s linear infinite;
    stroke-linecap: round;
  }
  /* Classes common for multiple diagrams */

  & .error-icon {
    fill: ${r.errorBkgColor};
  }
  & .error-text {
    fill: ${r.errorTextColor};
    stroke: ${r.errorTextColor};
  }

  & .edge-thickness-normal {
    stroke-width: 1px;
  }
  & .edge-thickness-thick {
    stroke-width: 3.5px
  }
  & .edge-pattern-solid {
    stroke-dasharray: 0;
  }
  & .edge-thickness-invisible {
    stroke-width: 0;
    fill: none;
  }
  & .edge-pattern-dashed{
    stroke-dasharray: 3;
  }
  .edge-pattern-dotted {
    stroke-dasharray: 2;
  }

  & .marker {
    fill: ${r.lineColor};
    stroke: ${r.lineColor};
  }
  & .marker.cross {
    stroke: ${r.lineColor};
  }

  & svg {
    font-family: ${r.fontFamily};
    font-size: ${r.fontSize};
  }
   & p {
    margin: 0
   }

  ${n}

  ${t}
`
          );
        }, "getStyles")),
        (E7 = a((e, t) => {
          t !== void 0 && (_x[e] = t);
        }, "addStylesForDiagram")),
        (A7 = mut));
    });
  var ag = {};
  Oe(ag, {
    clear: () => Ye,
    getAccDescription: () => rr,
    getAccTitle: () => tr,
    getDiagramTitle: () => nr,
    setAccDescription: () => er,
    setAccTitle: () => Xe,
    setDiagramTitle: () => lr,
  });
  var kw,
    Tw,
    Sw,
    _w,
    Ye,
    Xe,
    tr,
    er,
    rr,
    lr,
    nr,
    yn = x(() => {
      "use strict";
      Be();
      un();
      ((kw = ""),
        (Tw = ""),
        (Sw = ""),
        (_w = a((e) => Ie(e, ke()), "sanitizeText")),
        (Ye = a(() => {
          ((kw = ""), (Sw = ""), (Tw = ""));
        }, "clear")),
        (Xe = a((e) => {
          kw = _w(e).replace(/^\s+/g, "");
        }, "setAccTitle")),
        (tr = a(() => kw, "getAccTitle")),
        (er = a((e) => {
          Sw = _w(e).replace(
            /\n\s+/g,
            `
`,
          );
        }, "setAccDescription")),
        (rr = a(() => Sw, "getAccDescription")),
        (lr = a((e) => {
          Tw = _w(e);
        }, "setDiagramTitle")),
        (nr = a(() => Tw, "getDiagramTitle")));
    });
  var L7,
    gut,
    K,
    og,
    wx,
    lg,
    ww,
    yut,
    Cx,
    Su,
    cg,
    Cw,
    pe = x(() => {
      "use strict";
      Tu();
      Vt();
      un();
      Be();
      On();
      bw();
      yn();
      ((L7 = P),
        (gut = jm),
        (K = ke),
        (og = mx),
        (wx = Yl),
        (lg = a((e) => Ie(e, K()), "sanitizeText")),
        (ww = Ql),
        (yut = a(() => ag, "getCommonDb")),
        (Cx = {}),
        (Su = a((e, t, r) => {
          (Cx[e] &&
            L7.warn(`Diagram with id ${e} already registered. Overwriting.`),
            (Cx[e] = t),
            r && yw(e, r),
            E7(e, t.styles),
            t.injectUtils?.(L7, gut, K, lg, ww, yut(), () => {}));
        }, "registerDiagram")),
        (cg = a((e) => {
          if (e in Cx) return Cx[e];
          throw new Cw(e);
        }, "getDiagram")),
        (Cw = class extends Error {
          static {
            a(this, "DiagramNotFoundError");
          }
          constructor(t) {
            super(`Diagram ${t} not found.`);
          }
        }));
    });
  var Ca,
    Zl,
    Pi,
    _a,
    io,
    ug,
    vw,
    Ew,
    vx,
    Ex,
    R7,
    xut,
    but,
    kut,
    Tut,
    Sut,
    _ut,
    Cut,
    wut,
    vut,
    Eut,
    Aut,
    Lut,
    Rut,
    Dut,
    Nut,
    Iut,
    Mut,
    D7,
    Out,
    Put,
    N7,
    But,
    Fut,
    $ut,
    Gut,
    Jl,
    Vut,
    zut,
    Wut,
    Uut,
    jut,
    hg,
    Aw = x(() => {
      "use strict";
      pe();
      Be();
      yn();
      ((Ca = []),
        (Zl = [""]),
        (Pi = "global"),
        (_a = ""),
        (io = [
          {
            alias: "global",
            label: { text: "global" },
            type: { text: "global" },
            tags: null,
            link: null,
            parentBoundary: "",
          },
        ]),
        (ug = []),
        (vw = ""),
        (Ew = !1),
        (vx = 4),
        (Ex = 2),
        (xut = a(function () {
          return R7;
        }, "getC4Type")),
        (but = a(function (e) {
          R7 = Ie(e, K());
        }, "setC4Type")),
        (kut = a(function (e, t, r, n, i, s, o, l, u) {
          if (
            e == null ||
            t === void 0 ||
            t === null ||
            r === void 0 ||
            r === null ||
            n === void 0 ||
            n === null
          )
            return;
          let h = {},
            f = ug.find((d) => d.from === t && d.to === r);
          if (
            (f ? (h = f) : ug.push(h),
            (h.type = e),
            (h.from = t),
            (h.to = r),
            (h.label = { text: n }),
            i == null)
          )
            h.techn = { text: "" };
          else if (typeof i == "object") {
            let [d, p] = Object.entries(i)[0];
            h[d] = { text: p };
          } else h.techn = { text: i };
          if (s == null) h.descr = { text: "" };
          else if (typeof s == "object") {
            let [d, p] = Object.entries(s)[0];
            h[d] = { text: p };
          } else h.descr = { text: s };
          if (typeof o == "object") {
            let [d, p] = Object.entries(o)[0];
            h[d] = p;
          } else h.sprite = o;
          if (typeof l == "object") {
            let [d, p] = Object.entries(l)[0];
            h[d] = p;
          } else h.tags = l;
          if (typeof u == "object") {
            let [d, p] = Object.entries(u)[0];
            h[d] = p;
          } else h.link = u;
          h.wrap = Jl();
        }, "addRel")),
        (Tut = a(function (e, t, r, n, i, s, o) {
          if (t === null || r === null) return;
          let l = {},
            u = Ca.find((h) => h.alias === t);
          if (
            (u && t === u.alias ? (l = u) : ((l.alias = t), Ca.push(l)),
            r == null ? (l.label = { text: "" }) : (l.label = { text: r }),
            n == null)
          )
            l.descr = { text: "" };
          else if (typeof n == "object") {
            let [h, f] = Object.entries(n)[0];
            l[h] = { text: f };
          } else l.descr = { text: n };
          if (typeof i == "object") {
            let [h, f] = Object.entries(i)[0];
            l[h] = f;
          } else l.sprite = i;
          if (typeof s == "object") {
            let [h, f] = Object.entries(s)[0];
            l[h] = f;
          } else l.tags = s;
          if (typeof o == "object") {
            let [h, f] = Object.entries(o)[0];
            l[h] = f;
          } else l.link = o;
          ((l.typeC4Shape = { text: e }),
            (l.parentBoundary = Pi),
            (l.wrap = Jl()));
        }, "addPersonOrSystem")),
        (Sut = a(function (e, t, r, n, i, s, o, l) {
          if (t === null || r === null) return;
          let u = {},
            h = Ca.find((f) => f.alias === t);
          if (
            (h && t === h.alias ? (u = h) : ((u.alias = t), Ca.push(u)),
            r == null ? (u.label = { text: "" }) : (u.label = { text: r }),
            n == null)
          )
            u.techn = { text: "" };
          else if (typeof n == "object") {
            let [f, d] = Object.entries(n)[0];
            u[f] = { text: d };
          } else u.techn = { text: n };
          if (i == null) u.descr = { text: "" };
          else if (typeof i == "object") {
            let [f, d] = Object.entries(i)[0];
            u[f] = { text: d };
          } else u.descr = { text: i };
          if (typeof s == "object") {
            let [f, d] = Object.entries(s)[0];
            u[f] = d;
          } else u.sprite = s;
          if (typeof o == "object") {
            let [f, d] = Object.entries(o)[0];
            u[f] = d;
          } else u.tags = o;
          if (typeof l == "object") {
            let [f, d] = Object.entries(l)[0];
            u[f] = d;
          } else u.link = l;
          ((u.wrap = Jl()),
            (u.typeC4Shape = { text: e }),
            (u.parentBoundary = Pi));
        }, "addContainer")),
        (_ut = a(function (e, t, r, n, i, s, o, l) {
          if (t === null || r === null) return;
          let u = {},
            h = Ca.find((f) => f.alias === t);
          if (
            (h && t === h.alias ? (u = h) : ((u.alias = t), Ca.push(u)),
            r == null ? (u.label = { text: "" }) : (u.label = { text: r }),
            n == null)
          )
            u.techn = { text: "" };
          else if (typeof n == "object") {
            let [f, d] = Object.entries(n)[0];
            u[f] = { text: d };
          } else u.techn = { text: n };
          if (i == null) u.descr = { text: "" };
          else if (typeof i == "object") {
            let [f, d] = Object.entries(i)[0];
            u[f] = { text: d };
          } else u.descr = { text: i };
          if (typeof s == "object") {
            let [f, d] = Object.entries(s)[0];
            u[f] = d;
          } else u.sprite = s;
          if (typeof o == "object") {
            let [f, d] = Object.entries(o)[0];
            u[f] = d;
          } else u.tags = o;
          if (typeof l == "object") {
            let [f, d] = Object.entries(l)[0];
            u[f] = d;
          } else u.link = l;
          ((u.wrap = Jl()),
            (u.typeC4Shape = { text: e }),
            (u.parentBoundary = Pi));
        }, "addComponent")),
        (Cut = a(function (e, t, r, n, i) {
          if (e === null || t === null) return;
          let s = {},
            o = io.find((l) => l.alias === e);
          if (
            (o && e === o.alias ? (s = o) : ((s.alias = e), io.push(s)),
            t == null ? (s.label = { text: "" }) : (s.label = { text: t }),
            r == null)
          )
            s.type = { text: "system" };
          else if (typeof r == "object") {
            let [l, u] = Object.entries(r)[0];
            s[l] = { text: u };
          } else s.type = { text: r };
          if (typeof n == "object") {
            let [l, u] = Object.entries(n)[0];
            s[l] = u;
          } else s.tags = n;
          if (typeof i == "object") {
            let [l, u] = Object.entries(i)[0];
            s[l] = u;
          } else s.link = i;
          ((s.parentBoundary = Pi),
            (s.wrap = Jl()),
            (_a = Pi),
            (Pi = e),
            Zl.push(_a));
        }, "addPersonOrSystemBoundary")),
        (wut = a(function (e, t, r, n, i) {
          if (e === null || t === null) return;
          let s = {},
            o = io.find((l) => l.alias === e);
          if (
            (o && e === o.alias ? (s = o) : ((s.alias = e), io.push(s)),
            t == null ? (s.label = { text: "" }) : (s.label = { text: t }),
            r == null)
          )
            s.type = { text: "container" };
          else if (typeof r == "object") {
            let [l, u] = Object.entries(r)[0];
            s[l] = { text: u };
          } else s.type = { text: r };
          if (typeof n == "object") {
            let [l, u] = Object.entries(n)[0];
            s[l] = u;
          } else s.tags = n;
          if (typeof i == "object") {
            let [l, u] = Object.entries(i)[0];
            s[l] = u;
          } else s.link = i;
          ((s.parentBoundary = Pi),
            (s.wrap = Jl()),
            (_a = Pi),
            (Pi = e),
            Zl.push(_a));
        }, "addContainerBoundary")),
        (vut = a(function (e, t, r, n, i, s, o, l) {
          if (t === null || r === null) return;
          let u = {},
            h = io.find((f) => f.alias === t);
          if (
            (h && t === h.alias ? (u = h) : ((u.alias = t), io.push(u)),
            r == null ? (u.label = { text: "" }) : (u.label = { text: r }),
            n == null)
          )
            u.type = { text: "node" };
          else if (typeof n == "object") {
            let [f, d] = Object.entries(n)[0];
            u[f] = { text: d };
          } else u.type = { text: n };
          if (i == null) u.descr = { text: "" };
          else if (typeof i == "object") {
            let [f, d] = Object.entries(i)[0];
            u[f] = { text: d };
          } else u.descr = { text: i };
          if (typeof o == "object") {
            let [f, d] = Object.entries(o)[0];
            u[f] = d;
          } else u.tags = o;
          if (typeof l == "object") {
            let [f, d] = Object.entries(l)[0];
            u[f] = d;
          } else u.link = l;
          ((u.nodeType = e),
            (u.parentBoundary = Pi),
            (u.wrap = Jl()),
            (_a = Pi),
            (Pi = t),
            Zl.push(_a));
        }, "addDeploymentNode")),
        (Eut = a(function () {
          ((Pi = _a), Zl.pop(), (_a = Zl.pop()), Zl.push(_a));
        }, "popBoundaryParseStack")),
        (Aut = a(function (e, t, r, n, i, s, o, l, u, h, f) {
          let d = Ca.find((p) => p.alias === t);
          if (
            !(
              d === void 0 &&
              ((d = io.find((p) => p.alias === t)), d === void 0)
            )
          ) {
            if (r != null)
              if (typeof r == "object") {
                let [p, m] = Object.entries(r)[0];
                d[p] = m;
              } else d.bgColor = r;
            if (n != null)
              if (typeof n == "object") {
                let [p, m] = Object.entries(n)[0];
                d[p] = m;
              } else d.fontColor = n;
            if (i != null)
              if (typeof i == "object") {
                let [p, m] = Object.entries(i)[0];
                d[p] = m;
              } else d.borderColor = i;
            if (s != null)
              if (typeof s == "object") {
                let [p, m] = Object.entries(s)[0];
                d[p] = m;
              } else d.shadowing = s;
            if (o != null)
              if (typeof o == "object") {
                let [p, m] = Object.entries(o)[0];
                d[p] = m;
              } else d.shape = o;
            if (l != null)
              if (typeof l == "object") {
                let [p, m] = Object.entries(l)[0];
                d[p] = m;
              } else d.sprite = l;
            if (u != null)
              if (typeof u == "object") {
                let [p, m] = Object.entries(u)[0];
                d[p] = m;
              } else d.techn = u;
            if (h != null)
              if (typeof h == "object") {
                let [p, m] = Object.entries(h)[0];
                d[p] = m;
              } else d.legendText = h;
            if (f != null)
              if (typeof f == "object") {
                let [p, m] = Object.entries(f)[0];
                d[p] = m;
              } else d.legendSprite = f;
          }
        }, "updateElStyle")),
        (Lut = a(function (e, t, r, n, i, s, o) {
          let l = ug.find((u) => u.from === t && u.to === r);
          if (l !== void 0) {
            if (n != null)
              if (typeof n == "object") {
                let [u, h] = Object.entries(n)[0];
                l[u] = h;
              } else l.textColor = n;
            if (i != null)
              if (typeof i == "object") {
                let [u, h] = Object.entries(i)[0];
                l[u] = h;
              } else l.lineColor = i;
            if (s != null)
              if (typeof s == "object") {
                let [u, h] = Object.entries(s)[0];
                l[u] = parseInt(h);
              } else l.offsetX = parseInt(s);
            if (o != null)
              if (typeof o == "object") {
                let [u, h] = Object.entries(o)[0];
                l[u] = parseInt(h);
              } else l.offsetY = parseInt(o);
          }
        }, "updateRelStyle")),
        (Rut = a(function (e, t, r) {
          let n = vx,
            i = Ex;
          if (typeof t == "object") {
            let s = Object.values(t)[0];
            n = parseInt(s);
          } else n = parseInt(t);
          if (typeof r == "object") {
            let s = Object.values(r)[0];
            i = parseInt(s);
          } else i = parseInt(r);
          (n >= 1 && (vx = n), i >= 1 && (Ex = i));
        }, "updateLayoutConfig")),
        (Dut = a(function () {
          return vx;
        }, "getC4ShapeInRow")),
        (Nut = a(function () {
          return Ex;
        }, "getC4BoundaryInRow")),
        (Iut = a(function () {
          return Pi;
        }, "getCurrentBoundaryParse")),
        (Mut = a(function () {
          return _a;
        }, "getParentBoundaryParse")),
        (D7 = a(function (e) {
          return e == null ? Ca : Ca.filter((t) => t.parentBoundary === e);
        }, "getC4ShapeArray")),
        (Out = a(function (e) {
          return Ca.find((t) => t.alias === e);
        }, "getC4Shape")),
        (Put = a(function (e) {
          return Object.keys(D7(e));
        }, "getC4ShapeKeys")),
        (N7 = a(function (e) {
          return e == null ? io : io.filter((t) => t.parentBoundary === e);
        }, "getBoundaries")),
        (But = N7),
        (Fut = a(function () {
          return ug;
        }, "getRels")),
        ($ut = a(function () {
          return vw;
        }, "getTitle")),
        (Gut = a(function (e) {
          Ew = e;
        }, "setWrap")),
        (Jl = a(function () {
          return Ew;
        }, "autoWrap")),
        (Vut = a(function () {
          ((Ca = []),
            (io = [
              {
                alias: "global",
                label: { text: "global" },
                type: { text: "global" },
                tags: null,
                link: null,
                parentBoundary: "",
              },
            ]),
            (_a = ""),
            (Pi = "global"),
            (Zl = [""]),
            (ug = []),
            (Zl = [""]),
            (vw = ""),
            (Ew = !1),
            (vx = 4),
            (Ex = 2));
        }, "clear")),
        (zut = {
          SOLID: 0,
          DOTTED: 1,
          NOTE: 2,
          SOLID_CROSS: 3,
          DOTTED_CROSS: 4,
          SOLID_OPEN: 5,
          DOTTED_OPEN: 6,
          LOOP_START: 10,
          LOOP_END: 11,
          ALT_START: 12,
          ALT_ELSE: 13,
          ALT_END: 14,
          OPT_START: 15,
          OPT_END: 16,
          ACTIVE_START: 17,
          ACTIVE_END: 18,
          PAR_START: 19,
          PAR_AND: 20,
          PAR_END: 21,
          RECT_START: 22,
          RECT_END: 23,
          SOLID_POINT: 24,
          DOTTED_POINT: 25,
        }),
        (Wut = { FILLED: 0, OPEN: 1 }),
        (Uut = { LEFTOF: 0, RIGHTOF: 1, OVER: 2 }),
        (jut = a(function (e) {
          vw = Ie(e, K());
        }, "setTitle")),
        (hg = {
          addPersonOrSystem: Tut,
          addPersonOrSystemBoundary: Cut,
          addContainer: Sut,
          addContainerBoundary: wut,
          addComponent: _ut,
          addDeploymentNode: vut,
          popBoundaryParseStack: Eut,
          addRel: kut,
          updateElStyle: Aut,
          updateRelStyle: Lut,
          updateLayoutConfig: Rut,
          autoWrap: Jl,
          setWrap: Gut,
          getC4ShapeArray: D7,
          getC4Shape: Out,
          getC4ShapeKeys: Put,
          getBoundaries: N7,
          getBoundarys: But,
          getCurrentBoundaryParse: Iut,
          getParentBoundaryParse: Mut,
          getRels: Fut,
          getTitle: $ut,
          getC4Type: xut,
          getC4ShapeInRow: Dut,
          getC4BoundaryInRow: Nut,
          setAccTitle: Xe,
          getAccTitle: tr,
          getAccDescription: rr,
          setAccDescription: er,
          getConfig: a(() => K().c4, "getConfig"),
          clear: Vut,
          LINETYPE: zut,
          ARROWTYPE: Wut,
          PLACEMENT: Uut,
          setTitle: jut,
          setC4Type: but,
        }));
    });
  function _u(e, t) {
    return e == null || t == null
      ? NaN
      : e < t
        ? -1
        : e > t
          ? 1
          : e >= t
            ? 0
            : NaN;
  }
  var Lw = x(() => {
    "use strict";
    a(_u, "ascending");
  });
  function Rw(e, t) {
    return e == null || t == null
      ? NaN
      : t < e
        ? -1
        : t > e
          ? 1
          : t >= e
            ? 0
            : NaN;
  }
  var I7 = x(() => {
    "use strict";
    a(Rw, "descending");
  });
  function Cu(e) {
    let t, r, n;
    e.length !== 2
      ? ((t = _u),
        (r = a((l, u) => _u(e(l), u), "compare2")),
        (n = a((l, u) => e(l) - u, "delta")))
      : ((t = e === _u || e === Rw ? e : qut), (r = e), (n = e));
    function i(l, u, h = 0, f = l.length) {
      if (h < f) {
        if (t(u, u) !== 0) return f;
        do {
          let d = (h + f) >>> 1;
          r(l[d], u) < 0 ? (h = d + 1) : (f = d);
        } while (h < f);
      }
      return h;
    }
    a(i, "left");
    function s(l, u, h = 0, f = l.length) {
      if (h < f) {
        if (t(u, u) !== 0) return f;
        do {
          let d = (h + f) >>> 1;
          r(l[d], u) <= 0 ? (h = d + 1) : (f = d);
        } while (h < f);
      }
      return h;
    }
    a(s, "right");
    function o(l, u, h = 0, f = l.length) {
      let d = i(l, u, h, f - 1);
      return d > h && n(l[d - 1], u) > -n(l[d], u) ? d - 1 : d;
    }
    return (a(o, "center"), { left: i, center: o, right: s });
  }
  function qut() {
    return 0;
  }
  var Dw = x(() => {
    "use strict";
    Lw();
    I7();
    a(Cu, "bisector");
    a(qut, "zero");
  });
  function Nw(e) {
    return e === null ? NaN : +e;
  }
  var M7 = x(() => {
    "use strict";
    a(Nw, "number");
  });
  var O7,
    P7,
    Hut,
    Yut,
    Iw,
    B7 = x(() => {
      "use strict";
      Lw();
      Dw();
      M7();
      ((O7 = Cu(_u)),
        (P7 = O7.right),
        (Hut = O7.left),
        (Yut = Cu(Nw).center),
        (Iw = P7));
    });
  function F7({ _intern: e, _key: t }, r) {
    let n = t(r);
    return e.has(n) ? e.get(n) : r;
  }
  function Xut({ _intern: e, _key: t }, r) {
    let n = t(r);
    return e.has(n) ? e.get(n) : (e.set(n, r), r);
  }
  function Kut({ _intern: e, _key: t }, r) {
    let n = t(r);
    return (e.has(n) && ((r = e.get(n)), e.delete(n)), r);
  }
  function Qut(e) {
    return e !== null && typeof e == "object" ? e.valueOf() : e;
  }
  var mf,
    $7 = x(() => {
      "use strict";
      mf = class extends Map {
        static {
          a(this, "InternMap");
        }
        constructor(t, r = Qut) {
          if (
            (super(),
            Object.defineProperties(this, {
              _intern: { value: new Map() },
              _key: { value: r },
            }),
            t != null)
          )
            for (let [n, i] of t) this.set(n, i);
        }
        get(t) {
          return super.get(F7(this, t));
        }
        has(t) {
          return super.has(F7(this, t));
        }
        set(t, r) {
          return super.set(Xut(this, t), r);
        }
        delete(t) {
          return super.delete(Kut(this, t));
        }
      };
      a(F7, "intern_get");
      a(Xut, "intern_set");
      a(Kut, "intern_delete");
      a(Qut, "keyof");
    });
  function Ax(e, t, r) {
    let n = (t - e) / Math.max(0, r),
      i = Math.floor(Math.log10(n)),
      s = n / Math.pow(10, i),
      o = s >= Zut ? 10 : s >= Jut ? 5 : s >= tht ? 2 : 1,
      l,
      u,
      h;
    return (
      i < 0
        ? ((h = Math.pow(10, -i) / o),
          (l = Math.round(e * h)),
          (u = Math.round(t * h)),
          l / h < e && ++l,
          u / h > t && --u,
          (h = -h))
        : ((h = Math.pow(10, i) * o),
          (l = Math.round(e / h)),
          (u = Math.round(t / h)),
          l * h < e && ++l,
          u * h > t && --u),
      u < l && 0.5 <= r && r < 2 ? Ax(e, t, r * 2) : [l, u, h]
    );
  }
  function Lx(e, t, r) {
    if (((t = +t), (e = +e), (r = +r), !(r > 0))) return [];
    if (e === t) return [e];
    let n = t < e,
      [i, s, o] = n ? Ax(t, e, r) : Ax(e, t, r);
    if (!(s >= i)) return [];
    let l = s - i + 1,
      u = new Array(l);
    if (n)
      if (o < 0) for (let h = 0; h < l; ++h) u[h] = (s - h) / -o;
      else for (let h = 0; h < l; ++h) u[h] = (s - h) * o;
    else if (o < 0) for (let h = 0; h < l; ++h) u[h] = (i + h) / -o;
    else for (let h = 0; h < l; ++h) u[h] = (i + h) * o;
    return u;
  }
  function fg(e, t, r) {
    return ((t = +t), (e = +e), (r = +r), Ax(e, t, r)[2]);
  }
  function gf(e, t, r) {
    ((t = +t), (e = +e), (r = +r));
    let n = t < e,
      i = n ? fg(t, e, r) : fg(e, t, r);
    return (n ? -1 : 1) * (i < 0 ? 1 / -i : i);
  }
  var Zut,
    Jut,
    tht,
    G7 = x(() => {
      "use strict";
      ((Zut = Math.sqrt(50)), (Jut = Math.sqrt(10)), (tht = Math.sqrt(2)));
      a(Ax, "tickSpec");
      a(Lx, "ticks");
      a(fg, "tickIncrement");
      a(gf, "tickStep");
    });
  function Rx(e, t) {
    let r;
    if (t === void 0)
      for (let n of e)
        n != null && (r < n || (r === void 0 && n >= n)) && (r = n);
    else {
      let n = -1;
      for (let i of e)
        (i = t(i, ++n, e)) != null &&
          (r < i || (r === void 0 && i >= i)) &&
          (r = i);
    }
    return r;
  }
  var V7 = x(() => {
    "use strict";
    a(Rx, "max");
  });
  function Dx(e, t) {
    let r;
    if (t === void 0)
      for (let n of e)
        n != null && (r > n || (r === void 0 && n >= n)) && (r = n);
    else {
      let n = -1;
      for (let i of e)
        (i = t(i, ++n, e)) != null &&
          (r > i || (r === void 0 && i >= i)) &&
          (r = i);
    }
    return r;
  }
  var z7 = x(() => {
    "use strict";
    a(Dx, "min");
  });
  function Nx(e, t, r) {
    ((e = +e),
      (t = +t),
      (r =
        (i = arguments.length) < 2 ? ((t = e), (e = 0), 1) : i < 3 ? 1 : +r));
    for (
      var n = -1, i = Math.max(0, Math.ceil((t - e) / r)) | 0, s = new Array(i);
      ++n < i;

    )
      s[n] = e + n * r;
    return s;
  }
  var W7 = x(() => {
    "use strict";
    a(Nx, "range");
  });
  var tc = x(() => {
    "use strict";
    B7();
    Dw();
    V7();
    z7();
    W7();
    G7();
    $7();
  });
  function Mw(e) {
    return e;
  }
  var U7 = x(() => {
    "use strict";
    a(Mw, "default");
  });
  function eht(e) {
    return "translate(" + e + ",0)";
  }
  function rht(e) {
    return "translate(0," + e + ")";
  }
  function nht(e) {
    return (t) => +e(t);
  }
  function iht(e, t) {
    return (
      (t = Math.max(0, e.bandwidth() - t * 2) / 2),
      e.round() && (t = Math.round(t)),
      (r) => +e(r) + t
    );
  }
  function sht() {
    return !this.__axis;
  }
  function q7(e, t) {
    var r = [],
      n = null,
      i = null,
      s = 6,
      o = 6,
      l = 3,
      u = typeof window < "u" && window.devicePixelRatio > 1 ? 0 : 0.5,
      h = e === Mx || e === Ix ? -1 : 1,
      f = e === Ix || e === Ow ? "x" : "y",
      d = e === Mx || e === Pw ? eht : rht;
    function p(m) {
      var g = n ?? (t.ticks ? t.ticks.apply(t, r) : t.domain()),
        y = i ?? (t.tickFormat ? t.tickFormat.apply(t, r) : Mw),
        b = Math.max(s, 0) + l,
        k = t.range(),
        T = +k[0] + u,
        C = +k[k.length - 1] + u,
        L = (t.bandwidth ? iht : nht)(t.copy(), u),
        w = m.selection ? m.selection() : m,
        D = w.selectAll(".domain").data([null]),
        G = w.selectAll(".tick").data(g, t).order(),
        E = G.exit(),
        R = G.enter().append("g").attr("class", "tick"),
        F = G.select("line"),
        S = G.select("text");
      ((D = D.merge(
        D.enter()
          .insert("path", ".tick")
          .attr("class", "domain")
          .attr("stroke", "currentColor"),
      )),
        (G = G.merge(R)),
        (F = F.merge(
          R.append("line")
            .attr("stroke", "currentColor")
            .attr(f + "2", h * s),
        )),
        (S = S.merge(
          R.append("text")
            .attr("fill", "currentColor")
            .attr(f, h * b)
            .attr("dy", e === Mx ? "0em" : e === Pw ? "0.71em" : "0.32em"),
        )),
        m !== w &&
          ((D = D.transition(m)),
          (G = G.transition(m)),
          (F = F.transition(m)),
          (S = S.transition(m)),
          (E = E.transition(m)
            .attr("opacity", j7)
            .attr("transform", function (O) {
              return isFinite((O = L(O)))
                ? d(O + u)
                : this.getAttribute("transform");
            })),
          R.attr("opacity", j7).attr("transform", function (O) {
            var v = this.parentNode.__axis;
            return d((v && isFinite((v = v(O))) ? v : L(O)) + u);
          })),
        E.remove(),
        D.attr(
          "d",
          e === Ix || e === Ow
            ? o
              ? "M" + h * o + "," + T + "H" + u + "V" + C + "H" + h * o
              : "M" + u + "," + T + "V" + C
            : o
              ? "M" + T + "," + h * o + "V" + u + "H" + C + "V" + h * o
              : "M" + T + "," + u + "H" + C,
        ),
        G.attr("opacity", 1).attr("transform", function (O) {
          return d(L(O) + u);
        }),
        F.attr(f + "2", h * s),
        S.attr(f, h * b).text(y),
        w
          .filter(sht)
          .attr("fill", "none")
          .attr("font-size", 10)
          .attr("font-family", "sans-serif")
          .attr(
            "text-anchor",
            e === Ow ? "start" : e === Ix ? "end" : "middle",
          ),
        w.each(function () {
          this.__axis = L;
        }));
    }
    return (
      a(p, "axis"),
      (p.scale = function (m) {
        return arguments.length ? ((t = m), p) : t;
      }),
      (p.ticks = function () {
        return ((r = Array.from(arguments)), p);
      }),
      (p.tickArguments = function (m) {
        return arguments.length
          ? ((r = m == null ? [] : Array.from(m)), p)
          : r.slice();
      }),
      (p.tickValues = function (m) {
        return arguments.length
          ? ((n = m == null ? null : Array.from(m)), p)
          : n && n.slice();
      }),
      (p.tickFormat = function (m) {
        return arguments.length ? ((i = m), p) : i;
      }),
      (p.tickSize = function (m) {
        return arguments.length ? ((s = o = +m), p) : s;
      }),
      (p.tickSizeInner = function (m) {
        return arguments.length ? ((s = +m), p) : s;
      }),
      (p.tickSizeOuter = function (m) {
        return arguments.length ? ((o = +m), p) : o;
      }),
      (p.tickPadding = function (m) {
        return arguments.length ? ((l = +m), p) : l;
      }),
      (p.offset = function (m) {
        return arguments.length ? ((u = +m), p) : u;
      }),
      p
    );
  }
  function Bw(e) {
    return q7(Mx, e);
  }
  function Fw(e) {
    return q7(Pw, e);
  }
  var Mx,
    Ow,
    Pw,
    Ix,
    j7,
    H7 = x(() => {
      "use strict";
      U7();
      ((Mx = 1), (Ow = 2), (Pw = 3), (Ix = 4), (j7 = 1e-6));
      a(eht, "translateX");
      a(rht, "translateY");
      a(nht, "number");
      a(iht, "center");
      a(sht, "entering");
      a(q7, "axis");
      a(Bw, "axisTop");
      a(Fw, "axisBottom");
    });
  var Y7 = x(() => {
    "use strict";
    H7();
  });
  function K7() {
    for (var e = 0, t = arguments.length, r = {}, n; e < t; ++e) {
      if (!(n = arguments[e] + "") || n in r || /[\s.]/.test(n))
        throw new Error("illegal type: " + n);
      r[n] = [];
    }
    return new Ox(r);
  }
  function Ox(e) {
    this._ = e;
  }
  function oht(e, t) {
    return e
      .trim()
      .split(/^|\s+/)
      .map(function (r) {
        var n = "",
          i = r.indexOf(".");
        if (
          (i >= 0 && ((n = r.slice(i + 1)), (r = r.slice(0, i))),
          r && !t.hasOwnProperty(r))
        )
          throw new Error("unknown type: " + r);
        return { type: r, name: n };
      });
  }
  function lht(e, t) {
    for (var r = 0, n = e.length, i; r < n; ++r)
      if ((i = e[r]).name === t) return i.value;
  }
  function X7(e, t, r) {
    for (var n = 0, i = e.length; n < i; ++n)
      if (e[n].name === t) {
        ((e[n] = aht), (e = e.slice(0, n).concat(e.slice(n + 1))));
        break;
      }
    return (r != null && e.push({ name: t, value: r }), e);
  }
  var aht,
    $w,
    Q7 = x(() => {
      "use strict";
      aht = { value: a(() => {}, "value") };
      a(K7, "dispatch");
      a(Ox, "Dispatch");
      a(oht, "parseTypenames");
      Ox.prototype = K7.prototype = {
        constructor: Ox,
        on: a(function (e, t) {
          var r = this._,
            n = oht(e + "", r),
            i,
            s = -1,
            o = n.length;
          if (arguments.length < 2) {
            for (; ++s < o; )
              if ((i = (e = n[s]).type) && (i = lht(r[i], e.name))) return i;
            return;
          }
          if (t != null && typeof t != "function")
            throw new Error("invalid callback: " + t);
          for (; ++s < o; )
            if ((i = (e = n[s]).type)) r[i] = X7(r[i], e.name, t);
            else if (t == null) for (i in r) r[i] = X7(r[i], e.name, null);
          return this;
        }, "on"),
        copy: a(function () {
          var e = {},
            t = this._;
          for (var r in t) e[r] = t[r].slice();
          return new Ox(e);
        }, "copy"),
        call: a(function (e, t) {
          if ((i = arguments.length - 2) > 0)
            for (var r = new Array(i), n = 0, i, s; n < i; ++n)
              r[n] = arguments[n + 2];
          if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
          for (s = this._[e], n = 0, i = s.length; n < i; ++n)
            s[n].value.apply(t, r);
        }, "call"),
        apply: a(function (e, t, r) {
          if (!this._.hasOwnProperty(e)) throw new Error("unknown type: " + e);
          for (var n = this._[e], i = 0, s = n.length; i < s; ++i)
            n[i].value.apply(t, r);
        }, "apply"),
      };
      a(lht, "get");
      a(X7, "set");
      $w = K7;
    });
  var Gw = x(() => {
    "use strict";
    Q7();
  });
  var Px,
    Vw,
    zw = x(() => {
      "use strict";
      ((Px = "http://www.w3.org/1999/xhtml"),
        (Vw = {
          svg: "http://www.w3.org/2000/svg",
          xhtml: Px,
          xlink: "http://www.w3.org/1999/xlink",
          xml: "http://www.w3.org/XML/1998/namespace",
          xmlns: "http://www.w3.org/2000/xmlns/",
        }));
    });
  function so(e) {
    var t = (e += ""),
      r = t.indexOf(":");
    return (
      r >= 0 && (t = e.slice(0, r)) !== "xmlns" && (e = e.slice(r + 1)),
      Vw.hasOwnProperty(t) ? { space: Vw[t], local: e } : e
    );
  }
  var Bx = x(() => {
    "use strict";
    zw();
    a(so, "default");
  });
  function cht(e) {
    return function () {
      var t = this.ownerDocument,
        r = this.namespaceURI;
      return r === Px && t.documentElement.namespaceURI === Px
        ? t.createElement(e)
        : t.createElementNS(r, e);
    };
  }
  function uht(e) {
    return function () {
      return this.ownerDocument.createElementNS(e.space, e.local);
    };
  }
  function dg(e) {
    var t = so(e);
    return (t.local ? uht : cht)(t);
  }
  var Ww = x(() => {
    "use strict";
    Bx();
    zw();
    a(cht, "creatorInherit");
    a(uht, "creatorFixed");
    a(dg, "default");
  });
  function hht() {}
  function ec(e) {
    return e == null
      ? hht
      : function () {
          return this.querySelector(e);
        };
  }
  var Fx = x(() => {
    "use strict";
    a(hht, "none");
    a(ec, "default");
  });
  function Uw(e) {
    typeof e != "function" && (e = ec(e));
    for (
      var t = this._groups, r = t.length, n = new Array(r), i = 0;
      i < r;
      ++i
    )
      for (
        var s = t[i], o = s.length, l = (n[i] = new Array(o)), u, h, f = 0;
        f < o;
        ++f
      )
        (u = s[f]) &&
          (h = e.call(u, u.__data__, f, s)) &&
          ("__data__" in u && (h.__data__ = u.__data__), (l[f] = h));
    return new hn(n, this._parents);
  }
  var Z7 = x(() => {
    "use strict";
    wa();
    Fx();
    a(Uw, "default");
  });
  function jw(e) {
    return e == null ? [] : Array.isArray(e) ? e : Array.from(e);
  }
  var J7 = x(() => {
    "use strict";
    a(jw, "array");
  });
  function fht() {
    return [];
  }
  function yf(e) {
    return e == null
      ? fht
      : function () {
          return this.querySelectorAll(e);
        };
  }
  var qw = x(() => {
    "use strict";
    a(fht, "empty");
    a(yf, "default");
  });
  function dht(e) {
    return function () {
      return jw(e.apply(this, arguments));
    };
  }
  function Hw(e) {
    typeof e == "function" ? (e = dht(e)) : (e = yf(e));
    for (var t = this._groups, r = t.length, n = [], i = [], s = 0; s < r; ++s)
      for (var o = t[s], l = o.length, u, h = 0; h < l; ++h)
        (u = o[h]) && (n.push(e.call(u, u.__data__, h, o)), i.push(u));
    return new hn(n, i);
  }
  var tM = x(() => {
    "use strict";
    wa();
    J7();
    qw();
    a(dht, "arrayAll");
    a(Hw, "default");
  });
  function xf(e) {
    return function () {
      return this.matches(e);
    };
  }
  function $x(e) {
    return function (t) {
      return t.matches(e);
    };
  }
  var pg = x(() => {
    "use strict";
    a(xf, "default");
    a($x, "childMatcher");
  });
  function mht(e) {
    return function () {
      return pht.call(this.children, e);
    };
  }
  function ght() {
    return this.firstElementChild;
  }
  function Yw(e) {
    return this.select(
      e == null ? ght : mht(typeof e == "function" ? e : $x(e)),
    );
  }
  var pht,
    eM = x(() => {
      "use strict";
      pg();
      pht = Array.prototype.find;
      a(mht, "childFind");
      a(ght, "childFirst");
      a(Yw, "default");
    });
  function xht() {
    return Array.from(this.children);
  }
  function bht(e) {
    return function () {
      return yht.call(this.children, e);
    };
  }
  function Xw(e) {
    return this.selectAll(
      e == null ? xht : bht(typeof e == "function" ? e : $x(e)),
    );
  }
  var yht,
    rM = x(() => {
      "use strict";
      pg();
      yht = Array.prototype.filter;
      a(xht, "children");
      a(bht, "childrenFilter");
      a(Xw, "default");
    });
  function Kw(e) {
    typeof e != "function" && (e = xf(e));
    for (
      var t = this._groups, r = t.length, n = new Array(r), i = 0;
      i < r;
      ++i
    )
      for (var s = t[i], o = s.length, l = (n[i] = []), u, h = 0; h < o; ++h)
        (u = s[h]) && e.call(u, u.__data__, h, s) && l.push(u);
    return new hn(n, this._parents);
  }
  var nM = x(() => {
    "use strict";
    wa();
    pg();
    a(Kw, "default");
  });
  function mg(e) {
    return new Array(e.length);
  }
  var Qw = x(() => {
    "use strict";
    a(mg, "default");
  });
  function Zw() {
    return new hn(this._enter || this._groups.map(mg), this._parents);
  }
  function gg(e, t) {
    ((this.ownerDocument = e.ownerDocument),
      (this.namespaceURI = e.namespaceURI),
      (this._next = null),
      (this._parent = e),
      (this.__data__ = t));
  }
  var Jw = x(() => {
    "use strict";
    Qw();
    wa();
    a(Zw, "default");
    a(gg, "EnterNode");
    gg.prototype = {
      constructor: gg,
      appendChild: a(function (e) {
        return this._parent.insertBefore(e, this._next);
      }, "appendChild"),
      insertBefore: a(function (e, t) {
        return this._parent.insertBefore(e, t);
      }, "insertBefore"),
      querySelector: a(function (e) {
        return this._parent.querySelector(e);
      }, "querySelector"),
      querySelectorAll: a(function (e) {
        return this._parent.querySelectorAll(e);
      }, "querySelectorAll"),
    };
  });
  function tv(e) {
    return function () {
      return e;
    };
  }
  var iM = x(() => {
    "use strict";
    a(tv, "default");
  });
  function kht(e, t, r, n, i, s) {
    for (var o = 0, l, u = t.length, h = s.length; o < h; ++o)
      (l = t[o]) ? ((l.__data__ = s[o]), (n[o] = l)) : (r[o] = new gg(e, s[o]));
    for (; o < u; ++o) (l = t[o]) && (i[o] = l);
  }
  function Tht(e, t, r, n, i, s, o) {
    var l,
      u,
      h = new Map(),
      f = t.length,
      d = s.length,
      p = new Array(f),
      m;
    for (l = 0; l < f; ++l)
      (u = t[l]) &&
        ((p[l] = m = o.call(u, u.__data__, l, t) + ""),
        h.has(m) ? (i[l] = u) : h.set(m, u));
    for (l = 0; l < d; ++l)
      ((m = o.call(e, s[l], l, s) + ""),
        (u = h.get(m))
          ? ((n[l] = u), (u.__data__ = s[l]), h.delete(m))
          : (r[l] = new gg(e, s[l])));
    for (l = 0; l < f; ++l) (u = t[l]) && h.get(p[l]) === u && (i[l] = u);
  }
  function Sht(e) {
    return e.__data__;
  }
  function ev(e, t) {
    if (!arguments.length) return Array.from(this, Sht);
    var r = t ? Tht : kht,
      n = this._parents,
      i = this._groups;
    typeof e != "function" && (e = tv(e));
    for (
      var s = i.length,
        o = new Array(s),
        l = new Array(s),
        u = new Array(s),
        h = 0;
      h < s;
      ++h
    ) {
      var f = n[h],
        d = i[h],
        p = d.length,
        m = _ht(e.call(f, f && f.__data__, h, n)),
        g = m.length,
        y = (l[h] = new Array(g)),
        b = (o[h] = new Array(g)),
        k = (u[h] = new Array(p));
      r(f, d, y, b, k, m, t);
      for (var T = 0, C = 0, L, w; T < g; ++T)
        if ((L = y[T])) {
          for (T >= C && (C = T + 1); !(w = b[C]) && ++C < g; );
          L._next = w || null;
        }
    }
    return ((o = new hn(o, n)), (o._enter = l), (o._exit = u), o);
  }
  function _ht(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e);
  }
  var sM = x(() => {
    "use strict";
    wa();
    Jw();
    iM();
    a(kht, "bindIndex");
    a(Tht, "bindKey");
    a(Sht, "datum");
    a(ev, "default");
    a(_ht, "arraylike");
  });
  function rv() {
    return new hn(this._exit || this._groups.map(mg), this._parents);
  }
  var aM = x(() => {
    "use strict";
    Qw();
    wa();
    a(rv, "default");
  });
  function nv(e, t, r) {
    var n = this.enter(),
      i = this,
      s = this.exit();
    return (
      typeof e == "function"
        ? ((n = e(n)), n && (n = n.selection()))
        : (n = n.append(e + "")),
      t != null && ((i = t(i)), i && (i = i.selection())),
      r == null ? s.remove() : r(s),
      n && i ? n.merge(i).order() : i
    );
  }
  var oM = x(() => {
    "use strict";
    a(nv, "default");
  });
  function iv(e) {
    for (
      var t = e.selection ? e.selection() : e,
        r = this._groups,
        n = t._groups,
        i = r.length,
        s = n.length,
        o = Math.min(i, s),
        l = new Array(i),
        u = 0;
      u < o;
      ++u
    )
      for (
        var h = r[u],
          f = n[u],
          d = h.length,
          p = (l[u] = new Array(d)),
          m,
          g = 0;
        g < d;
        ++g
      )
        (m = h[g] || f[g]) && (p[g] = m);
    for (; u < i; ++u) l[u] = r[u];
    return new hn(l, this._parents);
  }
  var lM = x(() => {
    "use strict";
    wa();
    a(iv, "default");
  });
  function sv() {
    for (var e = this._groups, t = -1, r = e.length; ++t < r; )
      for (var n = e[t], i = n.length - 1, s = n[i], o; --i >= 0; )
        (o = n[i]) &&
          (s &&
            o.compareDocumentPosition(s) ^ 4 &&
            s.parentNode.insertBefore(o, s),
          (s = o));
    return this;
  }
  var cM = x(() => {
    "use strict";
    a(sv, "default");
  });
  function av(e) {
    e || (e = Cht);
    function t(d, p) {
      return d && p ? e(d.__data__, p.__data__) : !d - !p;
    }
    a(t, "compareNode");
    for (
      var r = this._groups, n = r.length, i = new Array(n), s = 0;
      s < n;
      ++s
    ) {
      for (
        var o = r[s], l = o.length, u = (i[s] = new Array(l)), h, f = 0;
        f < l;
        ++f
      )
        (h = o[f]) && (u[f] = h);
      u.sort(t);
    }
    return new hn(i, this._parents).order();
  }
  function Cht(e, t) {
    return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
  }
  var uM = x(() => {
    "use strict";
    wa();
    a(av, "default");
    a(Cht, "ascending");
  });
  function ov() {
    var e = arguments[0];
    return ((arguments[0] = this), e.apply(null, arguments), this);
  }
  var hM = x(() => {
    "use strict";
    a(ov, "default");
  });
  function lv() {
    return Array.from(this);
  }
  var fM = x(() => {
    "use strict";
    a(lv, "default");
  });
  function cv() {
    for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
      for (var n = e[t], i = 0, s = n.length; i < s; ++i) {
        var o = n[i];
        if (o) return o;
      }
    return null;
  }
  var dM = x(() => {
    "use strict";
    a(cv, "default");
  });
  function uv() {
    let e = 0;
    for (let t of this) ++e;
    return e;
  }
  var pM = x(() => {
    "use strict";
    a(uv, "default");
  });
  function hv() {
    return !this.node();
  }
  var mM = x(() => {
    "use strict";
    a(hv, "default");
  });
  function fv(e) {
    for (var t = this._groups, r = 0, n = t.length; r < n; ++r)
      for (var i = t[r], s = 0, o = i.length, l; s < o; ++s)
        (l = i[s]) && e.call(l, l.__data__, s, i);
    return this;
  }
  var gM = x(() => {
    "use strict";
    a(fv, "default");
  });
  function wht(e) {
    return function () {
      this.removeAttribute(e);
    };
  }
  function vht(e) {
    return function () {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function Eht(e, t) {
    return function () {
      this.setAttribute(e, t);
    };
  }
  function Aht(e, t) {
    return function () {
      this.setAttributeNS(e.space, e.local, t);
    };
  }
  function Lht(e, t) {
    return function () {
      var r = t.apply(this, arguments);
      r == null ? this.removeAttribute(e) : this.setAttribute(e, r);
    };
  }
  function Rht(e, t) {
    return function () {
      var r = t.apply(this, arguments);
      r == null
        ? this.removeAttributeNS(e.space, e.local)
        : this.setAttributeNS(e.space, e.local, r);
    };
  }
  function dv(e, t) {
    var r = so(e);
    if (arguments.length < 2) {
      var n = this.node();
      return r.local ? n.getAttributeNS(r.space, r.local) : n.getAttribute(r);
    }
    return this.each(
      (t == null
        ? r.local
          ? vht
          : wht
        : typeof t == "function"
          ? r.local
            ? Rht
            : Lht
          : r.local
            ? Aht
            : Eht)(r, t),
    );
  }
  var yM = x(() => {
    "use strict";
    Bx();
    a(wht, "attrRemove");
    a(vht, "attrRemoveNS");
    a(Eht, "attrConstant");
    a(Aht, "attrConstantNS");
    a(Lht, "attrFunction");
    a(Rht, "attrFunctionNS");
    a(dv, "default");
  });
  function yg(e) {
    return (
      (e.ownerDocument && e.ownerDocument.defaultView) ||
      (e.document && e) ||
      e.defaultView
    );
  }
  var pv = x(() => {
    "use strict";
    a(yg, "default");
  });
  function Dht(e) {
    return function () {
      this.style.removeProperty(e);
    };
  }
  function Nht(e, t, r) {
    return function () {
      this.style.setProperty(e, t, r);
    };
  }
  function Iht(e, t, r) {
    return function () {
      var n = t.apply(this, arguments);
      n == null
        ? this.style.removeProperty(e)
        : this.style.setProperty(e, n, r);
    };
  }
  function mv(e, t, r) {
    return arguments.length > 1
      ? this.each(
          (t == null ? Dht : typeof t == "function" ? Iht : Nht)(e, t, r ?? ""),
        )
      : rc(this.node(), e);
  }
  function rc(e, t) {
    return (
      e.style.getPropertyValue(t) ||
      yg(e).getComputedStyle(e, null).getPropertyValue(t)
    );
  }
  var gv = x(() => {
    "use strict";
    pv();
    a(Dht, "styleRemove");
    a(Nht, "styleConstant");
    a(Iht, "styleFunction");
    a(mv, "default");
    a(rc, "styleValue");
  });
  function Mht(e) {
    return function () {
      delete this[e];
    };
  }
  function Oht(e, t) {
    return function () {
      this[e] = t;
    };
  }
  function Pht(e, t) {
    return function () {
      var r = t.apply(this, arguments);
      r == null ? delete this[e] : (this[e] = r);
    };
  }
  function yv(e, t) {
    return arguments.length > 1
      ? this.each((t == null ? Mht : typeof t == "function" ? Pht : Oht)(e, t))
      : this.node()[e];
  }
  var xM = x(() => {
    "use strict";
    a(Mht, "propertyRemove");
    a(Oht, "propertyConstant");
    a(Pht, "propertyFunction");
    a(yv, "default");
  });
  function bM(e) {
    return e.trim().split(/^|\s+/);
  }
  function xv(e) {
    return e.classList || new kM(e);
  }
  function kM(e) {
    ((this._node = e), (this._names = bM(e.getAttribute("class") || "")));
  }
  function TM(e, t) {
    for (var r = xv(e), n = -1, i = t.length; ++n < i; ) r.add(t[n]);
  }
  function SM(e, t) {
    for (var r = xv(e), n = -1, i = t.length; ++n < i; ) r.remove(t[n]);
  }
  function Bht(e) {
    return function () {
      TM(this, e);
    };
  }
  function Fht(e) {
    return function () {
      SM(this, e);
    };
  }
  function $ht(e, t) {
    return function () {
      (t.apply(this, arguments) ? TM : SM)(this, e);
    };
  }
  function bv(e, t) {
    var r = bM(e + "");
    if (arguments.length < 2) {
      for (var n = xv(this.node()), i = -1, s = r.length; ++i < s; )
        if (!n.contains(r[i])) return !1;
      return !0;
    }
    return this.each((typeof t == "function" ? $ht : t ? Bht : Fht)(r, t));
  }
  var _M = x(() => {
    "use strict";
    a(bM, "classArray");
    a(xv, "classList");
    a(kM, "ClassList");
    kM.prototype = {
      add: a(function (e) {
        var t = this._names.indexOf(e);
        t < 0 &&
          (this._names.push(e),
          this._node.setAttribute("class", this._names.join(" ")));
      }, "add"),
      remove: a(function (e) {
        var t = this._names.indexOf(e);
        t >= 0 &&
          (this._names.splice(t, 1),
          this._node.setAttribute("class", this._names.join(" ")));
      }, "remove"),
      contains: a(function (e) {
        return this._names.indexOf(e) >= 0;
      }, "contains"),
    };
    a(TM, "classedAdd");
    a(SM, "classedRemove");
    a(Bht, "classedTrue");
    a(Fht, "classedFalse");
    a($ht, "classedFunction");
    a(bv, "default");
  });
  function Ght() {
    this.textContent = "";
  }
  function Vht(e) {
    return function () {
      this.textContent = e;
    };
  }
  function zht(e) {
    return function () {
      var t = e.apply(this, arguments);
      this.textContent = t ?? "";
    };
  }
  function kv(e) {
    return arguments.length
      ? this.each(e == null ? Ght : (typeof e == "function" ? zht : Vht)(e))
      : this.node().textContent;
  }
  var CM = x(() => {
    "use strict";
    a(Ght, "textRemove");
    a(Vht, "textConstant");
    a(zht, "textFunction");
    a(kv, "default");
  });
  function Wht() {
    this.innerHTML = "";
  }
  function Uht(e) {
    return function () {
      this.innerHTML = e;
    };
  }
  function jht(e) {
    return function () {
      var t = e.apply(this, arguments);
      this.innerHTML = t ?? "";
    };
  }
  function Tv(e) {
    return arguments.length
      ? this.each(e == null ? Wht : (typeof e == "function" ? jht : Uht)(e))
      : this.node().innerHTML;
  }
  var wM = x(() => {
    "use strict";
    a(Wht, "htmlRemove");
    a(Uht, "htmlConstant");
    a(jht, "htmlFunction");
    a(Tv, "default");
  });
  function qht() {
    this.nextSibling && this.parentNode.appendChild(this);
  }
  function Sv() {
    return this.each(qht);
  }
  var vM = x(() => {
    "use strict";
    a(qht, "raise");
    a(Sv, "default");
  });
  function Hht() {
    this.previousSibling &&
      this.parentNode.insertBefore(this, this.parentNode.firstChild);
  }
  function _v() {
    return this.each(Hht);
  }
  var EM = x(() => {
    "use strict";
    a(Hht, "lower");
    a(_v, "default");
  });
  function Cv(e) {
    var t = typeof e == "function" ? e : dg(e);
    return this.select(function () {
      return this.appendChild(t.apply(this, arguments));
    });
  }
  var AM = x(() => {
    "use strict";
    Ww();
    a(Cv, "default");
  });
  function Yht() {
    return null;
  }
  function wv(e, t) {
    var r = typeof e == "function" ? e : dg(e),
      n = t == null ? Yht : typeof t == "function" ? t : ec(t);
    return this.select(function () {
      return this.insertBefore(
        r.apply(this, arguments),
        n.apply(this, arguments) || null,
      );
    });
  }
  var LM = x(() => {
    "use strict";
    Ww();
    Fx();
    a(Yht, "constantNull");
    a(wv, "default");
  });
  function Xht() {
    var e = this.parentNode;
    e && e.removeChild(this);
  }
  function vv() {
    return this.each(Xht);
  }
  var RM = x(() => {
    "use strict";
    a(Xht, "remove");
    a(vv, "default");
  });
  function Kht() {
    var e = this.cloneNode(!1),
      t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function Qht() {
    var e = this.cloneNode(!0),
      t = this.parentNode;
    return t ? t.insertBefore(e, this.nextSibling) : e;
  }
  function Ev(e) {
    return this.select(e ? Qht : Kht);
  }
  var DM = x(() => {
    "use strict";
    a(Kht, "selection_cloneShallow");
    a(Qht, "selection_cloneDeep");
    a(Ev, "default");
  });
  function Av(e) {
    return arguments.length
      ? this.property("__data__", e)
      : this.node().__data__;
  }
  var NM = x(() => {
    "use strict";
    a(Av, "default");
  });
  function Zht(e) {
    return function (t) {
      e.call(this, t, this.__data__);
    };
  }
  function Jht(e) {
    return e
      .trim()
      .split(/^|\s+/)
      .map(function (t) {
        var r = "",
          n = t.indexOf(".");
        return (
          n >= 0 && ((r = t.slice(n + 1)), (t = t.slice(0, n))),
          { type: t, name: r }
        );
      });
  }
  function tft(e) {
    return function () {
      var t = this.__on;
      if (t) {
        for (var r = 0, n = -1, i = t.length, s; r < i; ++r)
          ((s = t[r]),
            (!e.type || s.type === e.type) && s.name === e.name
              ? this.removeEventListener(s.type, s.listener, s.options)
              : (t[++n] = s));
        ++n ? (t.length = n) : delete this.__on;
      }
    };
  }
  function eft(e, t, r) {
    return function () {
      var n = this.__on,
        i,
        s = Zht(t);
      if (n) {
        for (var o = 0, l = n.length; o < l; ++o)
          if ((i = n[o]).type === e.type && i.name === e.name) {
            (this.removeEventListener(i.type, i.listener, i.options),
              this.addEventListener(i.type, (i.listener = s), (i.options = r)),
              (i.value = t));
            return;
          }
      }
      (this.addEventListener(e.type, s, r),
        (i = { type: e.type, name: e.name, value: t, listener: s, options: r }),
        n ? n.push(i) : (this.__on = [i]));
    };
  }
  function Lv(e, t, r) {
    var n = Jht(e + ""),
      i,
      s = n.length,
      o;
    if (arguments.length < 2) {
      var l = this.node().__on;
      if (l) {
        for (var u = 0, h = l.length, f; u < h; ++u)
          for (i = 0, f = l[u]; i < s; ++i)
            if ((o = n[i]).type === f.type && o.name === f.name) return f.value;
      }
      return;
    }
    for (l = t ? eft : tft, i = 0; i < s; ++i) this.each(l(n[i], t, r));
    return this;
  }
  var IM = x(() => {
    "use strict";
    a(Zht, "contextListener");
    a(Jht, "parseTypenames");
    a(tft, "onRemove");
    a(eft, "onAdd");
    a(Lv, "default");
  });
  function MM(e, t, r) {
    var n = yg(e),
      i = n.CustomEvent;
    (typeof i == "function"
      ? (i = new i(t, r))
      : ((i = n.document.createEvent("Event")),
        r
          ? (i.initEvent(t, r.bubbles, r.cancelable), (i.detail = r.detail))
          : i.initEvent(t, !1, !1)),
      e.dispatchEvent(i));
  }
  function rft(e, t) {
    return function () {
      return MM(this, e, t);
    };
  }
  function nft(e, t) {
    return function () {
      return MM(this, e, t.apply(this, arguments));
    };
  }
  function Rv(e, t) {
    return this.each((typeof t == "function" ? nft : rft)(e, t));
  }
  var OM = x(() => {
    "use strict";
    pv();
    a(MM, "dispatchEvent");
    a(rft, "dispatchConstant");
    a(nft, "dispatchFunction");
    a(Rv, "default");
  });
  function* Dv() {
    for (var e = this._groups, t = 0, r = e.length; t < r; ++t)
      for (var n = e[t], i = 0, s = n.length, o; i < s; ++i)
        (o = n[i]) && (yield o);
  }
  var PM = x(() => {
    "use strict";
    a(Dv, "default");
  });
  function hn(e, t) {
    ((this._groups = e), (this._parents = t));
  }
  function BM() {
    return new hn([[document.documentElement]], Nv);
  }
  function ift() {
    return this;
  }
  var Nv,
    rl,
    wa = x(() => {
      "use strict";
      Z7();
      tM();
      eM();
      rM();
      nM();
      sM();
      Jw();
      aM();
      oM();
      lM();
      cM();
      uM();
      hM();
      fM();
      dM();
      pM();
      mM();
      gM();
      yM();
      gv();
      xM();
      _M();
      CM();
      wM();
      vM();
      EM();
      AM();
      LM();
      RM();
      DM();
      NM();
      IM();
      OM();
      PM();
      Nv = [null];
      a(hn, "Selection");
      a(BM, "selection");
      a(ift, "selection_selection");
      hn.prototype = BM.prototype = {
        constructor: hn,
        select: Uw,
        selectAll: Hw,
        selectChild: Yw,
        selectChildren: Xw,
        filter: Kw,
        data: ev,
        enter: Zw,
        exit: rv,
        join: nv,
        merge: iv,
        selection: ift,
        order: sv,
        sort: av,
        call: ov,
        nodes: lv,
        node: cv,
        size: uv,
        empty: hv,
        each: fv,
        attr: dv,
        style: mv,
        property: yv,
        classed: bv,
        text: kv,
        html: Tv,
        raise: Sv,
        lower: _v,
        append: Cv,
        insert: wv,
        remove: vv,
        clone: Ev,
        datum: Av,
        on: Lv,
        dispatch: Rv,
        [Symbol.iterator]: Dv,
      };
      rl = BM;
    });
  function xt(e) {
    return typeof e == "string"
      ? new hn([[document.querySelector(e)]], [document.documentElement])
      : new hn([[e]], Nv);
  }
  var FM = x(() => {
    "use strict";
    wa();
    a(xt, "default");
  });
  var va = x(() => {
    "use strict";
    pg();
    Bx();
    FM();
    wa();
    Fx();
    qw();
    gv();
  });
  var $M = x(() => {
    "use strict";
  });
  function nc(e, t, r) {
    ((e.prototype = t.prototype = r), (r.constructor = e));
  }
  function bf(e, t) {
    var r = Object.create(e.prototype);
    for (var n in t) r[n] = t[n];
    return r;
  }
  var Iv = x(() => {
    "use strict";
    a(nc, "default");
    a(bf, "extend");
  });
  function ic() {}
  function VM() {
    return this.rgb().formatHex();
  }
  function fft() {
    return this.rgb().formatHex8();
  }
  function dft() {
    return YM(this).formatHsl();
  }
  function zM() {
    return this.rgb().formatRgb();
  }
  function Aa(e) {
    var t, r;
    return (
      (e = (e + "").trim().toLowerCase()),
      (t = sft.exec(e))
        ? ((r = t[1].length),
          (t = parseInt(t[1], 16)),
          r === 6
            ? WM(t)
            : r === 3
              ? new Jn(
                  ((t >> 8) & 15) | ((t >> 4) & 240),
                  ((t >> 4) & 15) | (t & 240),
                  ((t & 15) << 4) | (t & 15),
                  1,
                )
              : r === 8
                ? Gx(
                    (t >> 24) & 255,
                    (t >> 16) & 255,
                    (t >> 8) & 255,
                    (t & 255) / 255,
                  )
                : r === 4
                  ? Gx(
                      ((t >> 12) & 15) | ((t >> 8) & 240),
                      ((t >> 8) & 15) | ((t >> 4) & 240),
                      ((t >> 4) & 15) | (t & 240),
                      (((t & 15) << 4) | (t & 15)) / 255,
                    )
                  : null)
        : (t = aft.exec(e))
          ? new Jn(t[1], t[2], t[3], 1)
          : (t = oft.exec(e))
            ? new Jn(
                (t[1] * 255) / 100,
                (t[2] * 255) / 100,
                (t[3] * 255) / 100,
                1,
              )
            : (t = lft.exec(e))
              ? Gx(t[1], t[2], t[3], t[4])
              : (t = cft.exec(e))
                ? Gx(
                    (t[1] * 255) / 100,
                    (t[2] * 255) / 100,
                    (t[3] * 255) / 100,
                    t[4],
                  )
                : (t = uft.exec(e))
                  ? qM(t[1], t[2] / 100, t[3] / 100, 1)
                  : (t = hft.exec(e))
                    ? qM(t[1], t[2] / 100, t[3] / 100, t[4])
                    : GM.hasOwnProperty(e)
                      ? WM(GM[e])
                      : e === "transparent"
                        ? new Jn(NaN, NaN, NaN, 0)
                        : null
    );
  }
  function WM(e) {
    return new Jn((e >> 16) & 255, (e >> 8) & 255, e & 255, 1);
  }
  function Gx(e, t, r, n) {
    return (n <= 0 && (e = t = r = NaN), new Jn(e, t, r, n));
  }
  function Ov(e) {
    return (
      e instanceof ic || (e = Aa(e)),
      e ? ((e = e.rgb()), new Jn(e.r, e.g, e.b, e.opacity)) : new Jn()
    );
  }
  function Tf(e, t, r, n) {
    return arguments.length === 1 ? Ov(e) : new Jn(e, t, r, n ?? 1);
  }
  function Jn(e, t, r, n) {
    ((this.r = +e), (this.g = +t), (this.b = +r), (this.opacity = +n));
  }
  function UM() {
    return `#${wu(this.r)}${wu(this.g)}${wu(this.b)}`;
  }
  function pft() {
    return `#${wu(this.r)}${wu(this.g)}${wu(this.b)}${wu((isNaN(this.opacity) ? 1 : this.opacity) * 255)}`;
  }
  function jM() {
    let e = Wx(this.opacity);
    return `${e === 1 ? "rgb(" : "rgba("}${vu(this.r)}, ${vu(this.g)}, ${vu(this.b)}${e === 1 ? ")" : `, ${e})`}`;
  }
  function Wx(e) {
    return isNaN(e) ? 1 : Math.max(0, Math.min(1, e));
  }
  function vu(e) {
    return Math.max(0, Math.min(255, Math.round(e) || 0));
  }
  function wu(e) {
    return ((e = vu(e)), (e < 16 ? "0" : "") + e.toString(16));
  }
  function qM(e, t, r, n) {
    return (
      n <= 0
        ? (e = t = r = NaN)
        : r <= 0 || r >= 1
          ? (e = t = NaN)
          : t <= 0 && (e = NaN),
      new Ea(e, t, r, n)
    );
  }
  function YM(e) {
    if (e instanceof Ea) return new Ea(e.h, e.s, e.l, e.opacity);
    if ((e instanceof ic || (e = Aa(e)), !e)) return new Ea();
    if (e instanceof Ea) return e;
    e = e.rgb();
    var t = e.r / 255,
      r = e.g / 255,
      n = e.b / 255,
      i = Math.min(t, r, n),
      s = Math.max(t, r, n),
      o = NaN,
      l = s - i,
      u = (s + i) / 2;
    return (
      l
        ? (t === s
            ? (o = (r - n) / l + (r < n) * 6)
            : r === s
              ? (o = (n - t) / l + 2)
              : (o = (t - r) / l + 4),
          (l /= u < 0.5 ? s + i : 2 - s - i),
          (o *= 60))
        : (l = u > 0 && u < 1 ? 0 : o),
      new Ea(o, l, u, e.opacity)
    );
  }
  function XM(e, t, r, n) {
    return arguments.length === 1 ? YM(e) : new Ea(e, t, r, n ?? 1);
  }
  function Ea(e, t, r, n) {
    ((this.h = +e), (this.s = +t), (this.l = +r), (this.opacity = +n));
  }
  function HM(e) {
    return ((e = (e || 0) % 360), e < 0 ? e + 360 : e);
  }
  function Vx(e) {
    return Math.max(0, Math.min(1, e || 0));
  }
  function Mv(e, t, r) {
    return (
      (e < 60
        ? t + ((r - t) * e) / 60
        : e < 180
          ? r
          : e < 240
            ? t + ((r - t) * (240 - e)) / 60
            : t) * 255
    );
  }
  var xg,
    zx,
    kf,
    bg,
    ao,
    sft,
    aft,
    oft,
    lft,
    cft,
    uft,
    hft,
    GM,
    Pv = x(() => {
      "use strict";
      Iv();
      a(ic, "Color");
      ((xg = 0.7),
        (zx = 1 / xg),
        (kf = "\\s*([+-]?\\d+)\\s*"),
        (bg = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*"),
        (ao = "\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*"),
        (sft = /^#([0-9a-f]{3,8})$/),
        (aft = new RegExp(`^rgb\\(${kf},${kf},${kf}\\)$`)),
        (oft = new RegExp(`^rgb\\(${ao},${ao},${ao}\\)$`)),
        (lft = new RegExp(`^rgba\\(${kf},${kf},${kf},${bg}\\)$`)),
        (cft = new RegExp(`^rgba\\(${ao},${ao},${ao},${bg}\\)$`)),
        (uft = new RegExp(`^hsl\\(${bg},${ao},${ao}\\)$`)),
        (hft = new RegExp(`^hsla\\(${bg},${ao},${ao},${bg}\\)$`)),
        (GM = {
          aliceblue: 15792383,
          antiquewhite: 16444375,
          aqua: 65535,
          aquamarine: 8388564,
          azure: 15794175,
          beige: 16119260,
          bisque: 16770244,
          black: 0,
          blanchedalmond: 16772045,
          blue: 255,
          blueviolet: 9055202,
          brown: 10824234,
          burlywood: 14596231,
          cadetblue: 6266528,
          chartreuse: 8388352,
          chocolate: 13789470,
          coral: 16744272,
          cornflowerblue: 6591981,
          cornsilk: 16775388,
          crimson: 14423100,
          cyan: 65535,
          darkblue: 139,
          darkcyan: 35723,
          darkgoldenrod: 12092939,
          darkgray: 11119017,
          darkgreen: 25600,
          darkgrey: 11119017,
          darkkhaki: 12433259,
          darkmagenta: 9109643,
          darkolivegreen: 5597999,
          darkorange: 16747520,
          darkorchid: 10040012,
          darkred: 9109504,
          darksalmon: 15308410,
          darkseagreen: 9419919,
          darkslateblue: 4734347,
          darkslategray: 3100495,
          darkslategrey: 3100495,
          darkturquoise: 52945,
          darkviolet: 9699539,
          deeppink: 16716947,
          deepskyblue: 49151,
          dimgray: 6908265,
          dimgrey: 6908265,
          dodgerblue: 2003199,
          firebrick: 11674146,
          floralwhite: 16775920,
          forestgreen: 2263842,
          fuchsia: 16711935,
          gainsboro: 14474460,
          ghostwhite: 16316671,
          gold: 16766720,
          goldenrod: 14329120,
          gray: 8421504,
          green: 32768,
          greenyellow: 11403055,
          grey: 8421504,
          honeydew: 15794160,
          hotpink: 16738740,
          indianred: 13458524,
          indigo: 4915330,
          ivory: 16777200,
          khaki: 15787660,
          lavender: 15132410,
          lavenderblush: 16773365,
          lawngreen: 8190976,
          lemonchiffon: 16775885,
          lightblue: 11393254,
          lightcoral: 15761536,
          lightcyan: 14745599,
          lightgoldenrodyellow: 16448210,
          lightgray: 13882323,
          lightgreen: 9498256,
          lightgrey: 13882323,
          lightpink: 16758465,
          lightsalmon: 16752762,
          lightseagreen: 2142890,
          lightskyblue: 8900346,
          lightslategray: 7833753,
          lightslategrey: 7833753,
          lightsteelblue: 11584734,
          lightyellow: 16777184,
          lime: 65280,
          limegreen: 3329330,
          linen: 16445670,
          magenta: 16711935,
          maroon: 8388608,
          mediumaquamarine: 6737322,
          mediumblue: 205,
          mediumorchid: 12211667,
          mediumpurple: 9662683,
          mediumseagreen: 3978097,
          mediumslateblue: 8087790,
          mediumspringgreen: 64154,
          mediumturquoise: 4772300,
          mediumvioletred: 13047173,
          midnightblue: 1644912,
          mintcream: 16121850,
          mistyrose: 16770273,
          moccasin: 16770229,
          navajowhite: 16768685,
          navy: 128,
          oldlace: 16643558,
          olive: 8421376,
          olivedrab: 7048739,
          orange: 16753920,
          orangered: 16729344,
          orchid: 14315734,
          palegoldenrod: 15657130,
          palegreen: 10025880,
          paleturquoise: 11529966,
          palevioletred: 14381203,
          papayawhip: 16773077,
          peachpuff: 16767673,
          peru: 13468991,
          pink: 16761035,
          plum: 14524637,
          powderblue: 11591910,
          purple: 8388736,
          rebeccapurple: 6697881,
          red: 16711680,
          rosybrown: 12357519,
          royalblue: 4286945,
          saddlebrown: 9127187,
          salmon: 16416882,
          sandybrown: 16032864,
          seagreen: 3050327,
          seashell: 16774638,
          sienna: 10506797,
          silver: 12632256,
          skyblue: 8900331,
          slateblue: 6970061,
          slategray: 7372944,
          slategrey: 7372944,
          snow: 16775930,
          springgreen: 65407,
          steelblue: 4620980,
          tan: 13808780,
          teal: 32896,
          thistle: 14204888,
          tomato: 16737095,
          turquoise: 4251856,
          violet: 15631086,
          wheat: 16113331,
          white: 16777215,
          whitesmoke: 16119285,
          yellow: 16776960,
          yellowgreen: 10145074,
        }));
      nc(ic, Aa, {
        copy(e) {
          return Object.assign(new this.constructor(), this, e);
        },
        displayable() {
          return this.rgb().displayable();
        },
        hex: VM,
        formatHex: VM,
        formatHex8: fft,
        formatHsl: dft,
        formatRgb: zM,
        toString: zM,
      });
      a(VM, "color_formatHex");
      a(fft, "color_formatHex8");
      a(dft, "color_formatHsl");
      a(zM, "color_formatRgb");
      a(Aa, "color");
      a(WM, "rgbn");
      a(Gx, "rgba");
      a(Ov, "rgbConvert");
      a(Tf, "rgb");
      a(Jn, "Rgb");
      nc(
        Jn,
        Tf,
        bf(ic, {
          brighter(e) {
            return (
              (e = e == null ? zx : Math.pow(zx, e)),
              new Jn(this.r * e, this.g * e, this.b * e, this.opacity)
            );
          },
          darker(e) {
            return (
              (e = e == null ? xg : Math.pow(xg, e)),
              new Jn(this.r * e, this.g * e, this.b * e, this.opacity)
            );
          },
          rgb() {
            return this;
          },
          clamp() {
            return new Jn(vu(this.r), vu(this.g), vu(this.b), Wx(this.opacity));
          },
          displayable() {
            return (
              -0.5 <= this.r &&
              this.r < 255.5 &&
              -0.5 <= this.g &&
              this.g < 255.5 &&
              -0.5 <= this.b &&
              this.b < 255.5 &&
              0 <= this.opacity &&
              this.opacity <= 1
            );
          },
          hex: UM,
          formatHex: UM,
          formatHex8: pft,
          formatRgb: jM,
          toString: jM,
        }),
      );
      a(UM, "rgb_formatHex");
      a(pft, "rgb_formatHex8");
      a(jM, "rgb_formatRgb");
      a(Wx, "clampa");
      a(vu, "clampi");
      a(wu, "hex");
      a(qM, "hsla");
      a(YM, "hslConvert");
      a(XM, "hsl");
      a(Ea, "Hsl");
      nc(
        Ea,
        XM,
        bf(ic, {
          brighter(e) {
            return (
              (e = e == null ? zx : Math.pow(zx, e)),
              new Ea(this.h, this.s, this.l * e, this.opacity)
            );
          },
          darker(e) {
            return (
              (e = e == null ? xg : Math.pow(xg, e)),
              new Ea(this.h, this.s, this.l * e, this.opacity)
            );
          },
          rgb() {
            var e = (this.h % 360) + (this.h < 0) * 360,
              t = isNaN(e) || isNaN(this.s) ? 0 : this.s,
              r = this.l,
              n = r + (r < 0.5 ? r : 1 - r) * t,
              i = 2 * r - n;
            return new Jn(
              Mv(e >= 240 ? e - 240 : e + 120, i, n),
              Mv(e, i, n),
              Mv(e < 120 ? e + 240 : e - 120, i, n),
              this.opacity,
            );
          },
          clamp() {
            return new Ea(HM(this.h), Vx(this.s), Vx(this.l), Wx(this.opacity));
          },
          displayable() {
            return (
              ((0 <= this.s && this.s <= 1) || isNaN(this.s)) &&
              0 <= this.l &&
              this.l <= 1 &&
              0 <= this.opacity &&
              this.opacity <= 1
            );
          },
          formatHsl() {
            let e = Wx(this.opacity);
            return `${e === 1 ? "hsl(" : "hsla("}${HM(this.h)}, ${Vx(this.s) * 100}%, ${Vx(this.l) * 100}%${e === 1 ? ")" : `, ${e})`}`;
          },
        }),
      );
      a(HM, "clamph");
      a(Vx, "clampt");
      a(Mv, "hsl2rgb");
    });
  var KM,
    QM,
    ZM = x(() => {
      "use strict";
      ((KM = Math.PI / 180), (QM = 180 / Math.PI));
    });
  function iO(e) {
    if (e instanceof oo) return new oo(e.l, e.a, e.b, e.opacity);
    if (e instanceof nl) return sO(e);
    e instanceof Jn || (e = Ov(e));
    var t = Gv(e.r),
      r = Gv(e.g),
      n = Gv(e.b),
      i = Bv((0.2225045 * t + 0.7168786 * r + 0.0606169 * n) / tO),
      s,
      o;
    return (
      t === r && r === n
        ? (s = o = i)
        : ((s = Bv((0.4360747 * t + 0.3850649 * r + 0.1430804 * n) / JM)),
          (o = Bv((0.0139322 * t + 0.0971045 * r + 0.7141733 * n) / eO))),
      new oo(116 * i - 16, 500 * (s - i), 200 * (i - o), e.opacity)
    );
  }
  function Vv(e, t, r, n) {
    return arguments.length === 1 ? iO(e) : new oo(e, t, r, n ?? 1);
  }
  function oo(e, t, r, n) {
    ((this.l = +e), (this.a = +t), (this.b = +r), (this.opacity = +n));
  }
  function Bv(e) {
    return e > mft ? Math.pow(e, 1 / 3) : e / nO + rO;
  }
  function Fv(e) {
    return e > Sf ? e * e * e : nO * (e - rO);
  }
  function $v(e) {
    return (
      255 * (e <= 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 1 / 2.4) - 0.055)
    );
  }
  function Gv(e) {
    return (e /= 255) <= 0.04045
      ? e / 12.92
      : Math.pow((e + 0.055) / 1.055, 2.4);
  }
  function gft(e) {
    if (e instanceof nl) return new nl(e.h, e.c, e.l, e.opacity);
    if ((e instanceof oo || (e = iO(e)), e.a === 0 && e.b === 0))
      return new nl(NaN, 0 < e.l && e.l < 100 ? 0 : NaN, e.l, e.opacity);
    var t = Math.atan2(e.b, e.a) * QM;
    return new nl(
      t < 0 ? t + 360 : t,
      Math.sqrt(e.a * e.a + e.b * e.b),
      e.l,
      e.opacity,
    );
  }
  function kg(e, t, r, n) {
    return arguments.length === 1 ? gft(e) : new nl(e, t, r, n ?? 1);
  }
  function nl(e, t, r, n) {
    ((this.h = +e), (this.c = +t), (this.l = +r), (this.opacity = +n));
  }
  function sO(e) {
    if (isNaN(e.h)) return new oo(e.l, 0, 0, e.opacity);
    var t = e.h * KM;
    return new oo(e.l, Math.cos(t) * e.c, Math.sin(t) * e.c, e.opacity);
  }
  var Ux,
    JM,
    tO,
    eO,
    rO,
    Sf,
    nO,
    mft,
    aO = x(() => {
      "use strict";
      Iv();
      Pv();
      ZM();
      ((Ux = 18),
        (JM = 0.96422),
        (tO = 1),
        (eO = 0.82521),
        (rO = 4 / 29),
        (Sf = 6 / 29),
        (nO = 3 * Sf * Sf),
        (mft = Sf * Sf * Sf));
      a(iO, "labConvert");
      a(Vv, "lab");
      a(oo, "Lab");
      nc(
        oo,
        Vv,
        bf(ic, {
          brighter(e) {
            return new oo(this.l + Ux * (e ?? 1), this.a, this.b, this.opacity);
          },
          darker(e) {
            return new oo(this.l - Ux * (e ?? 1), this.a, this.b, this.opacity);
          },
          rgb() {
            var e = (this.l + 16) / 116,
              t = isNaN(this.a) ? e : e + this.a / 500,
              r = isNaN(this.b) ? e : e - this.b / 200;
            return (
              (t = JM * Fv(t)),
              (e = tO * Fv(e)),
              (r = eO * Fv(r)),
              new Jn(
                $v(3.1338561 * t - 1.6168667 * e - 0.4906146 * r),
                $v(-0.9787684 * t + 1.9161415 * e + 0.033454 * r),
                $v(0.0719453 * t - 0.2289914 * e + 1.4052427 * r),
                this.opacity,
              )
            );
          },
        }),
      );
      a(Bv, "xyz2lab");
      a(Fv, "lab2xyz");
      a($v, "lrgb2rgb");
      a(Gv, "rgb2lrgb");
      a(gft, "hclConvert");
      a(kg, "hcl");
      a(nl, "Hcl");
      a(sO, "hcl2lab");
      nc(
        nl,
        kg,
        bf(ic, {
          brighter(e) {
            return new nl(this.h, this.c, this.l + Ux * (e ?? 1), this.opacity);
          },
          darker(e) {
            return new nl(this.h, this.c, this.l - Ux * (e ?? 1), this.opacity);
          },
          rgb() {
            return sO(this).rgb();
          },
        }),
      );
    });
  var _f = x(() => {
    "use strict";
    Pv();
    aO();
  });
  function zv(e, t, r, n, i) {
    var s = e * e,
      o = s * e;
    return (
      ((1 - 3 * e + 3 * s - o) * t +
        (4 - 6 * s + 3 * o) * r +
        (1 + 3 * e + 3 * s - 3 * o) * n +
        o * i) /
      6
    );
  }
  function Wv(e) {
    var t = e.length - 1;
    return function (r) {
      var n = r <= 0 ? (r = 0) : r >= 1 ? ((r = 1), t - 1) : Math.floor(r * t),
        i = e[n],
        s = e[n + 1],
        o = n > 0 ? e[n - 1] : 2 * i - s,
        l = n < t - 1 ? e[n + 2] : 2 * s - i;
      return zv((r - n / t) * t, o, i, s, l);
    };
  }
  var Uv = x(() => {
    "use strict";
    a(zv, "basis");
    a(Wv, "default");
  });
  function jv(e) {
    var t = e.length;
    return function (r) {
      var n = Math.floor(((r %= 1) < 0 ? ++r : r) * t),
        i = e[(n + t - 1) % t],
        s = e[n % t],
        o = e[(n + 1) % t],
        l = e[(n + 2) % t];
      return zv((r - n / t) * t, i, s, o, l);
    };
  }
  var oO = x(() => {
    "use strict";
    Uv();
    a(jv, "default");
  });
  var Cf,
    qv = x(() => {
      "use strict";
      Cf = a((e) => () => e, "default");
    });
  function lO(e, t) {
    return function (r) {
      return e + r * t;
    };
  }
  function yft(e, t, r) {
    return (
      (e = Math.pow(e, r)),
      (t = Math.pow(t, r) - e),
      (r = 1 / r),
      function (n) {
        return Math.pow(e + n * t, r);
      }
    );
  }
  function cO(e, t) {
    var r = t - e;
    return r
      ? lO(e, r > 180 || r < -180 ? r - 360 * Math.round(r / 360) : r)
      : Cf(isNaN(e) ? t : e);
  }
  function uO(e) {
    return (e = +e) == 1
      ? il
      : function (t, r) {
          return r - t ? yft(t, r, e) : Cf(isNaN(t) ? r : t);
        };
  }
  function il(e, t) {
    var r = t - e;
    return r ? lO(e, r) : Cf(isNaN(e) ? t : e);
  }
  var Hv = x(() => {
    "use strict";
    qv();
    a(lO, "linear");
    a(yft, "exponential");
    a(cO, "hue");
    a(uO, "gamma");
    a(il, "nogamma");
  });
  function hO(e) {
    return function (t) {
      var r = t.length,
        n = new Array(r),
        i = new Array(r),
        s = new Array(r),
        o,
        l;
      for (o = 0; o < r; ++o)
        ((l = Tf(t[o])),
          (n[o] = l.r || 0),
          (i[o] = l.g || 0),
          (s[o] = l.b || 0));
      return (
        (n = e(n)),
        (i = e(i)),
        (s = e(s)),
        (l.opacity = 1),
        function (u) {
          return ((l.r = n(u)), (l.g = i(u)), (l.b = s(u)), l + "");
        }
      );
    };
  }
  var Eu,
    xft,
    bft,
    Yv = x(() => {
      "use strict";
      _f();
      Uv();
      oO();
      Hv();
      Eu = a(function e(t) {
        var r = uO(t);
        function n(i, s) {
          var o = r((i = Tf(i)).r, (s = Tf(s)).r),
            l = r(i.g, s.g),
            u = r(i.b, s.b),
            h = il(i.opacity, s.opacity);
          return function (f) {
            return (
              (i.r = o(f)),
              (i.g = l(f)),
              (i.b = u(f)),
              (i.opacity = h(f)),
              i + ""
            );
          };
        }
        return (a(n, "rgb"), (n.gamma = e), n);
      }, "rgbGamma")(1);
      a(hO, "rgbSpline");
      ((xft = hO(Wv)), (bft = hO(jv)));
    });
  function Xv(e, t) {
    t || (t = []);
    var r = e ? Math.min(t.length, e.length) : 0,
      n = t.slice(),
      i;
    return function (s) {
      for (i = 0; i < r; ++i) n[i] = e[i] * (1 - s) + t[i] * s;
      return n;
    };
  }
  function fO(e) {
    return ArrayBuffer.isView(e) && !(e instanceof DataView);
  }
  var dO = x(() => {
    "use strict";
    a(Xv, "default");
    a(fO, "isNumberArray");
  });
  function pO(e, t) {
    var r = t ? t.length : 0,
      n = e ? Math.min(r, e.length) : 0,
      i = new Array(n),
      s = new Array(r),
      o;
    for (o = 0; o < n; ++o) i[o] = sc(e[o], t[o]);
    for (; o < r; ++o) s[o] = t[o];
    return function (l) {
      for (o = 0; o < n; ++o) s[o] = i[o](l);
      return s;
    };
  }
  var mO = x(() => {
    "use strict";
    jx();
    a(pO, "genericArray");
  });
  function Kv(e, t) {
    var r = new Date();
    return (
      (e = +e),
      (t = +t),
      function (n) {
        return (r.setTime(e * (1 - n) + t * n), r);
      }
    );
  }
  var gO = x(() => {
    "use strict";
    a(Kv, "default");
  });
  function zn(e, t) {
    return (
      (e = +e),
      (t = +t),
      function (r) {
        return e * (1 - r) + t * r;
      }
    );
  }
  var Tg = x(() => {
    "use strict";
    a(zn, "default");
  });
  function Qv(e, t) {
    var r = {},
      n = {},
      i;
    ((e === null || typeof e != "object") && (e = {}),
      (t === null || typeof t != "object") && (t = {}));
    for (i in t) i in e ? (r[i] = sc(e[i], t[i])) : (n[i] = t[i]);
    return function (s) {
      for (i in r) n[i] = r[i](s);
      return n;
    };
  }
  var yO = x(() => {
    "use strict";
    jx();
    a(Qv, "default");
  });
  function kft(e) {
    return function () {
      return e;
    };
  }
  function Tft(e) {
    return function (t) {
      return e(t) + "";
    };
  }
  function wf(e, t) {
    var r = (Jv.lastIndex = Zv.lastIndex = 0),
      n,
      i,
      s,
      o = -1,
      l = [],
      u = [];
    for (e = e + "", t = t + ""; (n = Jv.exec(e)) && (i = Zv.exec(t)); )
      ((s = i.index) > r &&
        ((s = t.slice(r, s)), l[o] ? (l[o] += s) : (l[++o] = s)),
        (n = n[0]) === (i = i[0])
          ? l[o]
            ? (l[o] += i)
            : (l[++o] = i)
          : ((l[++o] = null), u.push({ i: o, x: zn(n, i) })),
        (r = Zv.lastIndex));
    return (
      r < t.length && ((s = t.slice(r)), l[o] ? (l[o] += s) : (l[++o] = s)),
      l.length < 2
        ? u[0]
          ? Tft(u[0].x)
          : kft(t)
        : ((t = u.length),
          function (h) {
            for (var f = 0, d; f < t; ++f) l[(d = u[f]).i] = d.x(h);
            return l.join("");
          })
    );
  }
  var Jv,
    Zv,
    tE = x(() => {
      "use strict";
      Tg();
      ((Jv = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g),
        (Zv = new RegExp(Jv.source, "g")));
      a(kft, "zero");
      a(Tft, "one");
      a(wf, "default");
    });
  function sc(e, t) {
    var r = typeof t,
      n;
    return t == null || r === "boolean"
      ? Cf(t)
      : (r === "number"
          ? zn
          : r === "string"
            ? (n = Aa(t))
              ? ((t = n), Eu)
              : wf
            : t instanceof Aa
              ? Eu
              : t instanceof Date
                ? Kv
                : fO(t)
                  ? Xv
                  : Array.isArray(t)
                    ? pO
                    : (typeof t.valueOf != "function" &&
                          typeof t.toString != "function") ||
                        isNaN(t)
                      ? Qv
                      : zn)(e, t);
  }
  var jx = x(() => {
    "use strict";
    _f();
    Yv();
    mO();
    gO();
    Tg();
    yO();
    tE();
    qv();
    dO();
    a(sc, "default");
  });
  function qx(e, t) {
    return (
      (e = +e),
      (t = +t),
      function (r) {
        return Math.round(e * (1 - r) + t * r);
      }
    );
  }
  var xO = x(() => {
    "use strict";
    a(qx, "default");
  });
  function Yx(e, t, r, n, i, s) {
    var o, l, u;
    return (
      (o = Math.sqrt(e * e + t * t)) && ((e /= o), (t /= o)),
      (u = e * r + t * n) && ((r -= e * u), (n -= t * u)),
      (l = Math.sqrt(r * r + n * n)) && ((r /= l), (n /= l), (u /= l)),
      e * n < t * r && ((e = -e), (t = -t), (u = -u), (o = -o)),
      {
        translateX: i,
        translateY: s,
        rotate: Math.atan2(t, e) * bO,
        skewX: Math.atan(u) * bO,
        scaleX: o,
        scaleY: l,
      }
    );
  }
  var bO,
    Hx,
    kO = x(() => {
      "use strict";
      ((bO = 180 / Math.PI),
        (Hx = {
          translateX: 0,
          translateY: 0,
          rotate: 0,
          skewX: 0,
          scaleX: 1,
          scaleY: 1,
        }));
      a(Yx, "default");
    });
  function TO(e) {
    let t = new (typeof DOMMatrix == "function" ? DOMMatrix : WebKitCSSMatrix)(
      e + "",
    );
    return t.isIdentity ? Hx : Yx(t.a, t.b, t.c, t.d, t.e, t.f);
  }
  function SO(e) {
    return e == null
      ? Hx
      : (Xx ||
          (Xx = document.createElementNS("http://www.w3.org/2000/svg", "g")),
        Xx.setAttribute("transform", e),
        (e = Xx.transform.baseVal.consolidate())
          ? ((e = e.matrix), Yx(e.a, e.b, e.c, e.d, e.e, e.f))
          : Hx);
  }
  var Xx,
    _O = x(() => {
      "use strict";
      kO();
      a(TO, "parseCss");
      a(SO, "parseSvg");
    });
  function CO(e, t, r, n) {
    function i(h) {
      return h.length ? h.pop() + " " : "";
    }
    a(i, "pop");
    function s(h, f, d, p, m, g) {
      if (h !== d || f !== p) {
        var y = m.push("translate(", null, t, null, r);
        g.push({ i: y - 4, x: zn(h, d) }, { i: y - 2, x: zn(f, p) });
      } else (d || p) && m.push("translate(" + d + t + p + r);
    }
    a(s, "translate");
    function o(h, f, d, p) {
      h !== f
        ? (h - f > 180 ? (f += 360) : f - h > 180 && (h += 360),
          p.push({ i: d.push(i(d) + "rotate(", null, n) - 2, x: zn(h, f) }))
        : f && d.push(i(d) + "rotate(" + f + n);
    }
    a(o, "rotate");
    function l(h, f, d, p) {
      h !== f
        ? p.push({ i: d.push(i(d) + "skewX(", null, n) - 2, x: zn(h, f) })
        : f && d.push(i(d) + "skewX(" + f + n);
    }
    a(l, "skewX");
    function u(h, f, d, p, m, g) {
      if (h !== d || f !== p) {
        var y = m.push(i(m) + "scale(", null, ",", null, ")");
        g.push({ i: y - 4, x: zn(h, d) }, { i: y - 2, x: zn(f, p) });
      } else
        (d !== 1 || p !== 1) && m.push(i(m) + "scale(" + d + "," + p + ")");
    }
    return (
      a(u, "scale"),
      function (h, f) {
        var d = [],
          p = [];
        return (
          (h = e(h)),
          (f = e(f)),
          s(h.translateX, h.translateY, f.translateX, f.translateY, d, p),
          o(h.rotate, f.rotate, d, p),
          l(h.skewX, f.skewX, d, p),
          u(h.scaleX, h.scaleY, f.scaleX, f.scaleY, d, p),
          (h = f = null),
          function (m) {
            for (var g = -1, y = p.length, b; ++g < y; )
              d[(b = p[g]).i] = b.x(m);
            return d.join("");
          }
        );
      }
    );
  }
  var eE,
    rE,
    wO = x(() => {
      "use strict";
      Tg();
      _O();
      a(CO, "interpolateTransform");
      ((eE = CO(TO, "px, ", "px)", "deg)")), (rE = CO(SO, ", ", ")", ")")));
    });
  function vO(e) {
    return function (t, r) {
      var n = e((t = kg(t)).h, (r = kg(r)).h),
        i = il(t.c, r.c),
        s = il(t.l, r.l),
        o = il(t.opacity, r.opacity);
      return function (l) {
        return (
          (t.h = n(l)),
          (t.c = i(l)),
          (t.l = s(l)),
          (t.opacity = o(l)),
          t + ""
        );
      };
    };
  }
  var nE,
    Sft,
    EO = x(() => {
      "use strict";
      _f();
      Hv();
      a(vO, "hcl");
      ((nE = vO(cO)), (Sft = vO(il)));
    });
  var vf = x(() => {
    "use strict";
    jx();
    Tg();
    xO();
    tE();
    wO();
    Yv();
    EO();
  });
  function Eg() {
    return Au || (RO(_ft), (Au = wg.now() + Zx));
  }
  function _ft() {
    Au = 0;
  }
  function vg() {
    this._call = this._time = this._next = null;
  }
  function Jx(e, t, r) {
    var n = new vg();
    return (n.restart(e, t, r), n);
  }
  function DO() {
    (Eg(), ++Ef);
    for (var e = Kx, t; e; )
      ((t = Au - e._time) >= 0 && e._call.call(void 0, t), (e = e._next));
    --Ef;
  }
  function AO() {
    ((Au = (Qx = wg.now()) + Zx), (Ef = _g = 0));
    try {
      DO();
    } finally {
      ((Ef = 0), wft(), (Au = 0));
    }
  }
  function Cft() {
    var e = wg.now(),
      t = e - Qx;
    t > LO && ((Zx -= t), (Qx = e));
  }
  function wft() {
    for (var e, t = Kx, r, n = 1 / 0; t; )
      t._call
        ? (n > t._time && (n = t._time), (e = t), (t = t._next))
        : ((r = t._next), (t._next = null), (t = e ? (e._next = r) : (Kx = r)));
    ((Cg = e), iE(n));
  }
  function iE(e) {
    if (!Ef) {
      _g && (_g = clearTimeout(_g));
      var t = e - Au;
      t > 24
        ? (e < 1 / 0 && (_g = setTimeout(AO, e - wg.now() - Zx)),
          Sg && (Sg = clearInterval(Sg)))
        : (Sg || ((Qx = wg.now()), (Sg = setInterval(Cft, LO))),
          (Ef = 1),
          RO(AO));
    }
  }
  var Ef,
    _g,
    Sg,
    LO,
    Kx,
    Cg,
    Qx,
    Au,
    Zx,
    wg,
    RO,
    sE = x(() => {
      "use strict";
      ((Ef = 0),
        (_g = 0),
        (Sg = 0),
        (LO = 1e3),
        (Qx = 0),
        (Au = 0),
        (Zx = 0),
        (wg =
          typeof performance == "object" && performance.now
            ? performance
            : Date),
        (RO =
          typeof window == "object" && window.requestAnimationFrame
            ? window.requestAnimationFrame.bind(window)
            : function (e) {
                setTimeout(e, 17);
              }));
      a(Eg, "now");
      a(_ft, "clearNow");
      a(vg, "Timer");
      vg.prototype = Jx.prototype = {
        constructor: vg,
        restart: a(function (e, t, r) {
          if (typeof e != "function")
            throw new TypeError("callback is not a function");
          ((r = (r == null ? Eg() : +r) + (t == null ? 0 : +t)),
            !this._next &&
              Cg !== this &&
              (Cg ? (Cg._next = this) : (Kx = this), (Cg = this)),
            (this._call = e),
            (this._time = r),
            iE());
        }, "restart"),
        stop: a(function () {
          this._call && ((this._call = null), (this._time = 1 / 0), iE());
        }, "stop"),
      };
      a(Jx, "timer");
      a(DO, "timerFlush");
      a(AO, "wake");
      a(Cft, "poke");
      a(wft, "nap");
      a(iE, "sleep");
    });
  function Ag(e, t, r) {
    var n = new vg();
    return (
      (t = t == null ? 0 : +t),
      n.restart(
        (i) => {
          (n.stop(), e(i + t));
        },
        t,
        r,
      ),
      n
    );
  }
  var NO = x(() => {
    "use strict";
    sE();
    a(Ag, "default");
  });
  var t2 = x(() => {
    "use strict";
    sE();
    NO();
  });
  function sl(e, t, r, n, i, s) {
    var o = e.__transition;
    if (!o) e.__transition = {};
    else if (r in o) return;
    Aft(e, r, {
      name: t,
      index: n,
      group: i,
      on: vft,
      tween: Eft,
      time: s.time,
      delay: s.delay,
      duration: s.duration,
      ease: s.ease,
      timer: null,
      state: OO,
    });
  }
  function Rg(e, t) {
    var r = Pn(e, t);
    if (r.state > OO) throw new Error("too late; already scheduled");
    return r;
  }
  function ti(e, t) {
    var r = Pn(e, t);
    if (r.state > e2) throw new Error("too late; already running");
    return r;
  }
  function Pn(e, t) {
    var r = e.__transition;
    if (!r || !(r = r[t])) throw new Error("transition not found");
    return r;
  }
  function Aft(e, t, r) {
    var n = e.__transition,
      i;
    ((n[t] = r), (r.timer = Jx(s, 0, r.time)));
    function s(h) {
      ((r.state = IO),
        r.timer.restart(o, r.delay, r.time),
        r.delay <= h && o(h - r.delay));
    }
    a(s, "schedule");
    function o(h) {
      var f, d, p, m;
      if (r.state !== IO) return u();
      for (f in n)
        if (((m = n[f]), m.name === r.name)) {
          if (m.state === e2) return Ag(o);
          m.state === MO
            ? ((m.state = Lg),
              m.timer.stop(),
              m.on.call("interrupt", e, e.__data__, m.index, m.group),
              delete n[f])
            : +f < t &&
              ((m.state = Lg),
              m.timer.stop(),
              m.on.call("cancel", e, e.__data__, m.index, m.group),
              delete n[f]);
        }
      if (
        (Ag(function () {
          r.state === e2 &&
            ((r.state = MO), r.timer.restart(l, r.delay, r.time), l(h));
        }),
        (r.state = r2),
        r.on.call("start", e, e.__data__, r.index, r.group),
        r.state === r2)
      ) {
        for (
          r.state = e2, i = new Array((p = r.tween.length)), f = 0, d = -1;
          f < p;
          ++f
        )
          (m = r.tween[f].value.call(e, e.__data__, r.index, r.group)) &&
            (i[++d] = m);
        i.length = d + 1;
      }
    }
    a(o, "start");
    function l(h) {
      for (
        var f =
            h < r.duration
              ? r.ease.call(null, h / r.duration)
              : (r.timer.restart(u), (r.state = n2), 1),
          d = -1,
          p = i.length;
        ++d < p;

      )
        i[d].call(e, f);
      r.state === n2 &&
        (r.on.call("end", e, e.__data__, r.index, r.group), u());
    }
    a(l, "tick");
    function u() {
      ((r.state = Lg), r.timer.stop(), delete n[t]);
      for (var h in n) return;
      delete e.__transition;
    }
    a(u, "stop");
  }
  var vft,
    Eft,
    OO,
    IO,
    r2,
    e2,
    MO,
    n2,
    Lg,
    es = x(() => {
      "use strict";
      Gw();
      t2();
      ((vft = $w("start", "end", "cancel", "interrupt")),
        (Eft = []),
        (OO = 0),
        (IO = 1),
        (r2 = 2),
        (e2 = 3),
        (MO = 4),
        (n2 = 5),
        (Lg = 6));
      a(sl, "default");
      a(Rg, "init");
      a(ti, "set");
      a(Pn, "get");
      a(Aft, "create");
    });
  function Dg(e, t) {
    var r = e.__transition,
      n,
      i,
      s = !0,
      o;
    if (r) {
      t = t == null ? null : t + "";
      for (o in r) {
        if ((n = r[o]).name !== t) {
          s = !1;
          continue;
        }
        ((i = n.state > r2 && n.state < n2),
          (n.state = Lg),
          n.timer.stop(),
          n.on.call(
            i ? "interrupt" : "cancel",
            e,
            e.__data__,
            n.index,
            n.group,
          ),
          delete r[o]);
      }
      s && delete e.__transition;
    }
  }
  var PO = x(() => {
    "use strict";
    es();
    a(Dg, "default");
  });
  function aE(e) {
    return this.each(function () {
      Dg(this, e);
    });
  }
  var BO = x(() => {
    "use strict";
    PO();
    a(aE, "default");
  });
  function Lft(e, t) {
    var r, n;
    return function () {
      var i = ti(this, e),
        s = i.tween;
      if (s !== r) {
        n = r = s;
        for (var o = 0, l = n.length; o < l; ++o)
          if (n[o].name === t) {
            ((n = n.slice()), n.splice(o, 1));
            break;
          }
      }
      i.tween = n;
    };
  }
  function Rft(e, t, r) {
    var n, i;
    if (typeof r != "function") throw new Error();
    return function () {
      var s = ti(this, e),
        o = s.tween;
      if (o !== n) {
        i = (n = o).slice();
        for (var l = { name: t, value: r }, u = 0, h = i.length; u < h; ++u)
          if (i[u].name === t) {
            i[u] = l;
            break;
          }
        u === h && i.push(l);
      }
      s.tween = i;
    };
  }
  function oE(e, t) {
    var r = this._id;
    if (((e += ""), arguments.length < 2)) {
      for (var n = Pn(this.node(), r).tween, i = 0, s = n.length, o; i < s; ++i)
        if ((o = n[i]).name === e) return o.value;
      return null;
    }
    return this.each((t == null ? Lft : Rft)(r, e, t));
  }
  function Af(e, t, r) {
    var n = e._id;
    return (
      e.each(function () {
        var i = ti(this, n);
        (i.value || (i.value = {}))[t] = r.apply(this, arguments);
      }),
      function (i) {
        return Pn(i, n).value[t];
      }
    );
  }
  var Ng = x(() => {
    "use strict";
    es();
    a(Lft, "tweenRemove");
    a(Rft, "tweenFunction");
    a(oE, "default");
    a(Af, "tweenValue");
  });
  function Ig(e, t) {
    var r;
    return (
      typeof t == "number"
        ? zn
        : t instanceof Aa
          ? Eu
          : (r = Aa(t))
            ? ((t = r), Eu)
            : wf
    )(e, t);
  }
  var lE = x(() => {
    "use strict";
    _f();
    vf();
    a(Ig, "default");
  });
  function Dft(e) {
    return function () {
      this.removeAttribute(e);
    };
  }
  function Nft(e) {
    return function () {
      this.removeAttributeNS(e.space, e.local);
    };
  }
  function Ift(e, t, r) {
    var n,
      i = r + "",
      s;
    return function () {
      var o = this.getAttribute(e);
      return o === i ? null : o === n ? s : (s = t((n = o), r));
    };
  }
  function Mft(e, t, r) {
    var n,
      i = r + "",
      s;
    return function () {
      var o = this.getAttributeNS(e.space, e.local);
      return o === i ? null : o === n ? s : (s = t((n = o), r));
    };
  }
  function Oft(e, t, r) {
    var n, i, s;
    return function () {
      var o,
        l = r(this),
        u;
      return l == null
        ? void this.removeAttribute(e)
        : ((o = this.getAttribute(e)),
          (u = l + ""),
          o === u
            ? null
            : o === n && u === i
              ? s
              : ((i = u), (s = t((n = o), l))));
    };
  }
  function Pft(e, t, r) {
    var n, i, s;
    return function () {
      var o,
        l = r(this),
        u;
      return l == null
        ? void this.removeAttributeNS(e.space, e.local)
        : ((o = this.getAttributeNS(e.space, e.local)),
          (u = l + ""),
          o === u
            ? null
            : o === n && u === i
              ? s
              : ((i = u), (s = t((n = o), l))));
    };
  }
  function cE(e, t) {
    var r = so(e),
      n = r === "transform" ? rE : Ig;
    return this.attrTween(
      e,
      typeof t == "function"
        ? (r.local ? Pft : Oft)(r, n, Af(this, "attr." + e, t))
        : t == null
          ? (r.local ? Nft : Dft)(r)
          : (r.local ? Mft : Ift)(r, n, t),
    );
  }
  var FO = x(() => {
    "use strict";
    vf();
    va();
    Ng();
    lE();
    a(Dft, "attrRemove");
    a(Nft, "attrRemoveNS");
    a(Ift, "attrConstant");
    a(Mft, "attrConstantNS");
    a(Oft, "attrFunction");
    a(Pft, "attrFunctionNS");
    a(cE, "default");
  });
  function Bft(e, t) {
    return function (r) {
      this.setAttribute(e, t.call(this, r));
    };
  }
  function Fft(e, t) {
    return function (r) {
      this.setAttributeNS(e.space, e.local, t.call(this, r));
    };
  }
  function $ft(e, t) {
    var r, n;
    function i() {
      var s = t.apply(this, arguments);
      return (s !== n && (r = (n = s) && Fft(e, s)), r);
    }
    return (a(i, "tween"), (i._value = t), i);
  }
  function Gft(e, t) {
    var r, n;
    function i() {
      var s = t.apply(this, arguments);
      return (s !== n && (r = (n = s) && Bft(e, s)), r);
    }
    return (a(i, "tween"), (i._value = t), i);
  }
  function uE(e, t) {
    var r = "attr." + e;
    if (arguments.length < 2) return (r = this.tween(r)) && r._value;
    if (t == null) return this.tween(r, null);
    if (typeof t != "function") throw new Error();
    var n = so(e);
    return this.tween(r, (n.local ? $ft : Gft)(n, t));
  }
  var $O = x(() => {
    "use strict";
    va();
    a(Bft, "attrInterpolate");
    a(Fft, "attrInterpolateNS");
    a($ft, "attrTweenNS");
    a(Gft, "attrTween");
    a(uE, "default");
  });
  function Vft(e, t) {
    return function () {
      Rg(this, e).delay = +t.apply(this, arguments);
    };
  }
  function zft(e, t) {
    return (
      (t = +t),
      function () {
        Rg(this, e).delay = t;
      }
    );
  }
  function hE(e) {
    var t = this._id;
    return arguments.length
      ? this.each((typeof e == "function" ? Vft : zft)(t, e))
      : Pn(this.node(), t).delay;
  }
  var GO = x(() => {
    "use strict";
    es();
    a(Vft, "delayFunction");
    a(zft, "delayConstant");
    a(hE, "default");
  });
  function Wft(e, t) {
    return function () {
      ti(this, e).duration = +t.apply(this, arguments);
    };
  }
  function Uft(e, t) {
    return (
      (t = +t),
      function () {
        ti(this, e).duration = t;
      }
    );
  }
  function fE(e) {
    var t = this._id;
    return arguments.length
      ? this.each((typeof e == "function" ? Wft : Uft)(t, e))
      : Pn(this.node(), t).duration;
  }
  var VO = x(() => {
    "use strict";
    es();
    a(Wft, "durationFunction");
    a(Uft, "durationConstant");
    a(fE, "default");
  });
  function jft(e, t) {
    if (typeof t != "function") throw new Error();
    return function () {
      ti(this, e).ease = t;
    };
  }
  function dE(e) {
    var t = this._id;
    return arguments.length ? this.each(jft(t, e)) : Pn(this.node(), t).ease;
  }
  var zO = x(() => {
    "use strict";
    es();
    a(jft, "easeConstant");
    a(dE, "default");
  });
  function qft(e, t) {
    return function () {
      var r = t.apply(this, arguments);
      if (typeof r != "function") throw new Error();
      ti(this, e).ease = r;
    };
  }
  function pE(e) {
    if (typeof e != "function") throw new Error();
    return this.each(qft(this._id, e));
  }
  var WO = x(() => {
    "use strict";
    es();
    a(qft, "easeVarying");
    a(pE, "default");
  });
  function mE(e) {
    typeof e != "function" && (e = xf(e));
    for (
      var t = this._groups, r = t.length, n = new Array(r), i = 0;
      i < r;
      ++i
    )
      for (var s = t[i], o = s.length, l = (n[i] = []), u, h = 0; h < o; ++h)
        (u = s[h]) && e.call(u, u.__data__, h, s) && l.push(u);
    return new Bi(n, this._parents, this._name, this._id);
  }
  var UO = x(() => {
    "use strict";
    va();
    Lu();
    a(mE, "default");
  });
  function gE(e) {
    if (e._id !== this._id) throw new Error();
    for (
      var t = this._groups,
        r = e._groups,
        n = t.length,
        i = r.length,
        s = Math.min(n, i),
        o = new Array(n),
        l = 0;
      l < s;
      ++l
    )
      for (
        var u = t[l],
          h = r[l],
          f = u.length,
          d = (o[l] = new Array(f)),
          p,
          m = 0;
        m < f;
        ++m
      )
        (p = u[m] || h[m]) && (d[m] = p);
    for (; l < n; ++l) o[l] = t[l];
    return new Bi(o, this._parents, this._name, this._id);
  }
  var jO = x(() => {
    "use strict";
    Lu();
    a(gE, "default");
  });
  function Hft(e) {
    return (e + "")
      .trim()
      .split(/^|\s+/)
      .every(function (t) {
        var r = t.indexOf(".");
        return (r >= 0 && (t = t.slice(0, r)), !t || t === "start");
      });
  }
  function Yft(e, t, r) {
    var n,
      i,
      s = Hft(t) ? Rg : ti;
    return function () {
      var o = s(this, e),
        l = o.on;
      (l !== n && (i = (n = l).copy()).on(t, r), (o.on = i));
    };
  }
  function yE(e, t) {
    var r = this._id;
    return arguments.length < 2
      ? Pn(this.node(), r).on.on(e)
      : this.each(Yft(r, e, t));
  }
  var qO = x(() => {
    "use strict";
    es();
    a(Hft, "start");
    a(Yft, "onFunction");
    a(yE, "default");
  });
  function Xft(e) {
    return function () {
      var t = this.parentNode;
      for (var r in this.__transition) if (+r !== e) return;
      t && t.removeChild(this);
    };
  }
  function xE() {
    return this.on("end.remove", Xft(this._id));
  }
  var HO = x(() => {
    "use strict";
    a(Xft, "removeFunction");
    a(xE, "default");
  });
  function bE(e) {
    var t = this._name,
      r = this._id;
    typeof e != "function" && (e = ec(e));
    for (
      var n = this._groups, i = n.length, s = new Array(i), o = 0;
      o < i;
      ++o
    )
      for (
        var l = n[o], u = l.length, h = (s[o] = new Array(u)), f, d, p = 0;
        p < u;
        ++p
      )
        (f = l[p]) &&
          (d = e.call(f, f.__data__, p, l)) &&
          ("__data__" in f && (d.__data__ = f.__data__),
          (h[p] = d),
          sl(h[p], t, r, p, h, Pn(f, r)));
    return new Bi(s, this._parents, t, r);
  }
  var YO = x(() => {
    "use strict";
    va();
    Lu();
    es();
    a(bE, "default");
  });
  function kE(e) {
    var t = this._name,
      r = this._id;
    typeof e != "function" && (e = yf(e));
    for (var n = this._groups, i = n.length, s = [], o = [], l = 0; l < i; ++l)
      for (var u = n[l], h = u.length, f, d = 0; d < h; ++d)
        if ((f = u[d])) {
          for (
            var p = e.call(f, f.__data__, d, u),
              m,
              g = Pn(f, r),
              y = 0,
              b = p.length;
            y < b;
            ++y
          )
            (m = p[y]) && sl(m, t, r, y, p, g);
          (s.push(p), o.push(f));
        }
    return new Bi(s, o, t, r);
  }
  var XO = x(() => {
    "use strict";
    va();
    Lu();
    es();
    a(kE, "default");
  });
  function TE() {
    return new Kft(this._groups, this._parents);
  }
  var Kft,
    KO = x(() => {
      "use strict";
      va();
      Kft = rl.prototype.constructor;
      a(TE, "default");
    });
  function Qft(e, t) {
    var r, n, i;
    return function () {
      var s = rc(this, e),
        o = (this.style.removeProperty(e), rc(this, e));
      return s === o
        ? null
        : s === r && o === n
          ? i
          : (i = t((r = s), (n = o)));
    };
  }
  function QO(e) {
    return function () {
      this.style.removeProperty(e);
    };
  }
  function Zft(e, t, r) {
    var n,
      i = r + "",
      s;
    return function () {
      var o = rc(this, e);
      return o === i ? null : o === n ? s : (s = t((n = o), r));
    };
  }
  function Jft(e, t, r) {
    var n, i, s;
    return function () {
      var o = rc(this, e),
        l = r(this),
        u = l + "";
      return (
        l == null && (u = l = (this.style.removeProperty(e), rc(this, e))),
        o === u ? null : o === n && u === i ? s : ((i = u), (s = t((n = o), l)))
      );
    };
  }
  function tdt(e, t) {
    var r,
      n,
      i,
      s = "style." + t,
      o = "end." + s,
      l;
    return function () {
      var u = ti(this, e),
        h = u.on,
        f = u.value[s] == null ? l || (l = QO(t)) : void 0;
      ((h !== r || i !== f) && (n = (r = h).copy()).on(o, (i = f)), (u.on = n));
    };
  }
  function SE(e, t, r) {
    var n = (e += "") == "transform" ? eE : Ig;
    return t == null
      ? this.styleTween(e, Qft(e, n)).on("end.style." + e, QO(e))
      : typeof t == "function"
        ? this.styleTween(e, Jft(e, n, Af(this, "style." + e, t))).each(
            tdt(this._id, e),
          )
        : this.styleTween(e, Zft(e, n, t), r).on("end.style." + e, null);
  }
  var ZO = x(() => {
    "use strict";
    vf();
    va();
    es();
    Ng();
    lE();
    a(Qft, "styleNull");
    a(QO, "styleRemove");
    a(Zft, "styleConstant");
    a(Jft, "styleFunction");
    a(tdt, "styleMaybeRemove");
    a(SE, "default");
  });
  function edt(e, t, r) {
    return function (n) {
      this.style.setProperty(e, t.call(this, n), r);
    };
  }
  function rdt(e, t, r) {
    var n, i;
    function s() {
      var o = t.apply(this, arguments);
      return (o !== i && (n = (i = o) && edt(e, o, r)), n);
    }
    return (a(s, "tween"), (s._value = t), s);
  }
  function _E(e, t, r) {
    var n = "style." + (e += "");
    if (arguments.length < 2) return (n = this.tween(n)) && n._value;
    if (t == null) return this.tween(n, null);
    if (typeof t != "function") throw new Error();
    return this.tween(n, rdt(e, t, r ?? ""));
  }
  var JO = x(() => {
    "use strict";
    a(edt, "styleInterpolate");
    a(rdt, "styleTween");
    a(_E, "default");
  });
  function ndt(e) {
    return function () {
      this.textContent = e;
    };
  }
  function idt(e) {
    return function () {
      var t = e(this);
      this.textContent = t ?? "";
    };
  }
  function CE(e) {
    return this.tween(
      "text",
      typeof e == "function"
        ? idt(Af(this, "text", e))
        : ndt(e == null ? "" : e + ""),
    );
  }
  var tP = x(() => {
    "use strict";
    Ng();
    a(ndt, "textConstant");
    a(idt, "textFunction");
    a(CE, "default");
  });
  function sdt(e) {
    return function (t) {
      this.textContent = e.call(this, t);
    };
  }
  function adt(e) {
    var t, r;
    function n() {
      var i = e.apply(this, arguments);
      return (i !== r && (t = (r = i) && sdt(i)), t);
    }
    return (a(n, "tween"), (n._value = e), n);
  }
  function wE(e) {
    var t = "text";
    if (arguments.length < 1) return (t = this.tween(t)) && t._value;
    if (e == null) return this.tween(t, null);
    if (typeof e != "function") throw new Error();
    return this.tween(t, adt(e));
  }
  var eP = x(() => {
    "use strict";
    a(sdt, "textInterpolate");
    a(adt, "textTween");
    a(wE, "default");
  });
  function vE() {
    for (
      var e = this._name,
        t = this._id,
        r = i2(),
        n = this._groups,
        i = n.length,
        s = 0;
      s < i;
      ++s
    )
      for (var o = n[s], l = o.length, u, h = 0; h < l; ++h)
        if ((u = o[h])) {
          var f = Pn(u, t);
          sl(u, e, r, h, o, {
            time: f.time + f.delay + f.duration,
            delay: 0,
            duration: f.duration,
            ease: f.ease,
          });
        }
    return new Bi(n, this._parents, e, r);
  }
  var rP = x(() => {
    "use strict";
    Lu();
    es();
    a(vE, "default");
  });
  function EE() {
    var e,
      t,
      r = this,
      n = r._id,
      i = r.size();
    return new Promise(function (s, o) {
      var l = { value: o },
        u = {
          value: a(function () {
            --i === 0 && s();
          }, "value"),
        };
      (r.each(function () {
        var h = ti(this, n),
          f = h.on;
        (f !== e &&
          ((t = (e = f).copy()),
          t._.cancel.push(l),
          t._.interrupt.push(l),
          t._.end.push(u)),
          (h.on = t));
      }),
        i === 0 && s());
    });
  }
  var nP = x(() => {
    "use strict";
    es();
    a(EE, "default");
  });
  function Bi(e, t, r, n) {
    ((this._groups = e), (this._parents = t), (this._name = r), (this._id = n));
  }
  function iP(e) {
    return rl().transition(e);
  }
  function i2() {
    return ++odt;
  }
  var odt,
    al,
    Lu = x(() => {
      "use strict";
      va();
      FO();
      $O();
      GO();
      VO();
      zO();
      WO();
      UO();
      jO();
      qO();
      HO();
      YO();
      XO();
      KO();
      ZO();
      JO();
      tP();
      eP();
      rP();
      Ng();
      nP();
      odt = 0;
      a(Bi, "Transition");
      a(iP, "transition");
      a(i2, "newId");
      al = rl.prototype;
      Bi.prototype = iP.prototype = {
        constructor: Bi,
        select: bE,
        selectAll: kE,
        selectChild: al.selectChild,
        selectChildren: al.selectChildren,
        filter: mE,
        merge: gE,
        selection: TE,
        transition: vE,
        call: al.call,
        nodes: al.nodes,
        node: al.node,
        size: al.size,
        empty: al.empty,
        each: al.each,
        on: yE,
        attr: cE,
        attrTween: uE,
        style: SE,
        styleTween: _E,
        text: CE,
        textTween: wE,
        remove: xE,
        tween: oE,
        delay: hE,
        duration: fE,
        ease: dE,
        easeVarying: pE,
        end: EE,
        [Symbol.iterator]: al[Symbol.iterator],
      };
    });
  function s2(e) {
    return ((e *= 2) <= 1 ? e * e * e : (e -= 2) * e * e + 2) / 2;
  }
  var sP = x(() => {
    "use strict";
    a(s2, "cubicInOut");
  });
  var AE = x(() => {
    "use strict";
    sP();
  });
  function cdt(e, t) {
    for (var r; !(r = e.__transition) || !(r = r[t]); )
      if (!(e = e.parentNode)) throw new Error(`transition ${t} not found`);
    return r;
  }
  function LE(e) {
    var t, r;
    e instanceof Bi
      ? ((t = e._id), (e = e._name))
      : ((t = i2()), ((r = ldt).time = Eg()), (e = e == null ? null : e + ""));
    for (var n = this._groups, i = n.length, s = 0; s < i; ++s)
      for (var o = n[s], l = o.length, u, h = 0; h < l; ++h)
        (u = o[h]) && sl(u, e, t, h, o, r || cdt(u, t));
    return new Bi(n, this._parents, e, t);
  }
  var ldt,
    aP = x(() => {
      "use strict";
      Lu();
      es();
      AE();
      t2();
      ldt = { time: null, delay: 0, duration: 250, ease: s2 };
      a(cdt, "inherit");
      a(LE, "default");
    });
  var oP = x(() => {
    "use strict";
    va();
    BO();
    aP();
    rl.prototype.interrupt = aE;
    rl.prototype.transition = LE;
  });
  var a2 = x(() => {
    "use strict";
    oP();
  });
  var lP = x(() => {
    "use strict";
  });
  var cP = x(() => {
    "use strict";
  });
  var uP = x(() => {
    "use strict";
  });
  function hP(e) {
    return [+e[0], +e[1]];
  }
  function udt(e) {
    return [hP(e[0]), hP(e[1])];
  }
  function RE(e) {
    return { type: e };
  }
  var hqt,
    fqt,
    dqt,
    pqt,
    mqt,
    gqt,
    fP = x(() => {
      "use strict";
      a2();
      lP();
      cP();
      uP();
      ({ abs: hqt, max: fqt, min: dqt } = Math);
      a(hP, "number1");
      a(udt, "number2");
      ((pqt = {
        name: "x",
        handles: ["w", "e"].map(RE),
        input: a(function (e, t) {
          return e == null
            ? null
            : [
                [+e[0], t[0][1]],
                [+e[1], t[1][1]],
              ];
        }, "input"),
        output: a(function (e) {
          return e && [e[0][0], e[1][0]];
        }, "output"),
      }),
        (mqt = {
          name: "y",
          handles: ["n", "s"].map(RE),
          input: a(function (e, t) {
            return e == null
              ? null
              : [
                  [t[0][0], +e[0]],
                  [t[1][0], +e[1]],
                ];
          }, "input"),
          output: a(function (e) {
            return e && [e[0][1], e[1][1]];
          }, "output"),
        }),
        (gqt = {
          name: "xy",
          handles: ["n", "w", "e", "s", "nw", "ne", "sw", "se"].map(RE),
          input: a(function (e) {
            return e == null ? null : udt(e);
          }, "input"),
          output: a(function (e) {
            return e;
          }, "output"),
        }));
      a(RE, "type");
    });
  var dP = x(() => {
    "use strict";
    fP();
  });
  function pP(e) {
    this._ += e[0];
    for (let t = 1, r = e.length; t < r; ++t) this._ += arguments[t] + e[t];
  }
  function fdt(e) {
    let t = Math.floor(e);
    if (!(t >= 0)) throw new Error(`invalid digits: ${e}`);
    if (t > 15) return pP;
    let r = 10 ** t;
    return function (n) {
      this._ += n[0];
      for (let i = 1, s = n.length; i < s; ++i)
        this._ += Math.round(arguments[i] * r) / r + n[i];
    };
  }
  function mP() {
    return new Du();
  }
  var DE,
    NE,
    Ru,
    hdt,
    Du,
    gP = x(() => {
      "use strict";
      ((DE = Math.PI), (NE = 2 * DE), (Ru = 1e-6), (hdt = NE - Ru));
      a(pP, "append");
      a(fdt, "appendRound");
      Du = class {
        static {
          a(this, "Path");
        }
        constructor(t) {
          ((this._x0 = this._y0 = this._x1 = this._y1 = null),
            (this._ = ""),
            (this._append = t == null ? pP : fdt(t)));
        }
        moveTo(t, r) {
          this
            ._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +r)}`;
        }
        closePath() {
          this._x1 !== null &&
            ((this._x1 = this._x0), (this._y1 = this._y0), this._append`Z`);
        }
        lineTo(t, r) {
          this._append`L${(this._x1 = +t)},${(this._y1 = +r)}`;
        }
        quadraticCurveTo(t, r, n, i) {
          this._append`Q${+t},${+r},${(this._x1 = +n)},${(this._y1 = +i)}`;
        }
        bezierCurveTo(t, r, n, i, s, o) {
          this
            ._append`C${+t},${+r},${+n},${+i},${(this._x1 = +s)},${(this._y1 = +o)}`;
        }
        arcTo(t, r, n, i, s) {
          if (((t = +t), (r = +r), (n = +n), (i = +i), (s = +s), s < 0))
            throw new Error(`negative radius: ${s}`);
          let o = this._x1,
            l = this._y1,
            u = n - t,
            h = i - r,
            f = o - t,
            d = l - r,
            p = f * f + d * d;
          if (this._x1 === null)
            this._append`M${(this._x1 = t)},${(this._y1 = r)}`;
          else if (p > Ru)
            if (!(Math.abs(d * u - h * f) > Ru) || !s)
              this._append`L${(this._x1 = t)},${(this._y1 = r)}`;
            else {
              let m = n - o,
                g = i - l,
                y = u * u + h * h,
                b = m * m + g * g,
                k = Math.sqrt(y),
                T = Math.sqrt(p),
                C =
                  s * Math.tan((DE - Math.acos((y + p - b) / (2 * k * T))) / 2),
                L = C / T,
                w = C / k;
              (Math.abs(L - 1) > Ru && this._append`L${t + L * f},${r + L * d}`,
                this
                  ._append`A${s},${s},0,0,${+(d * m > f * g)},${(this._x1 = t + w * u)},${(this._y1 = r + w * h)}`);
            }
        }
        arc(t, r, n, i, s, o) {
          if (((t = +t), (r = +r), (n = +n), (o = !!o), n < 0))
            throw new Error(`negative radius: ${n}`);
          let l = n * Math.cos(i),
            u = n * Math.sin(i),
            h = t + l,
            f = r + u,
            d = 1 ^ o,
            p = o ? i - s : s - i;
          (this._x1 === null
            ? this._append`M${h},${f}`
            : (Math.abs(this._x1 - h) > Ru || Math.abs(this._y1 - f) > Ru) &&
              this._append`L${h},${f}`,
            n &&
              (p < 0 && (p = (p % NE) + NE),
              p > hdt
                ? this
                    ._append`A${n},${n},0,1,${d},${t - l},${r - u}A${n},${n},0,1,${d},${(this._x1 = h)},${(this._y1 = f)}`
                : p > Ru &&
                  this
                    ._append`A${n},${n},0,${+(p >= DE)},${d},${(this._x1 = t + n * Math.cos(s))},${(this._y1 = r + n * Math.sin(s))}`));
        }
        rect(t, r, n, i) {
          this
            ._append`M${(this._x0 = this._x1 = +t)},${(this._y0 = this._y1 = +r)}h${(n = +n)}v${+i}h${-n}Z`;
        }
        toString() {
          return this._;
        }
      };
      a(mP, "path");
      mP.prototype = Du.prototype;
    });
  var IE = x(() => {
    "use strict";
    gP();
  });
  var yP = x(() => {
    "use strict";
  });
  var xP = x(() => {
    "use strict";
  });
  var bP = x(() => {
    "use strict";
  });
  var kP = x(() => {
    "use strict";
  });
  var TP = x(() => {
    "use strict";
  });
  var SP = x(() => {
    "use strict";
  });
  var _P = x(() => {
    "use strict";
  });
  function ME(e) {
    return Math.abs((e = Math.round(e))) >= 1e21
      ? e.toLocaleString("en").replace(/,/g, "")
      : e.toString(10);
  }
  function Nu(e, t) {
    if (
      (r = (e = t ? e.toExponential(t - 1) : e.toExponential()).indexOf("e")) <
      0
    )
      return null;
    var r,
      n = e.slice(0, r);
    return [n.length > 1 ? n[0] + n.slice(2) : n, +e.slice(r + 1)];
  }
  var Mg = x(() => {
    "use strict";
    a(ME, "default");
    a(Nu, "formatDecimalParts");
  });
  function La(e) {
    return ((e = Nu(Math.abs(e))), e ? e[1] : NaN);
  }
  var Og = x(() => {
    "use strict";
    Mg();
    a(La, "default");
  });
  function OE(e, t) {
    return function (r, n) {
      for (
        var i = r.length, s = [], o = 0, l = e[0], u = 0;
        i > 0 &&
        l > 0 &&
        (u + l + 1 > n && (l = Math.max(1, n - u)),
        s.push(r.substring((i -= l), i + l)),
        !((u += l + 1) > n));

      )
        l = e[(o = (o + 1) % e.length)];
      return s.reverse().join(t);
    };
  }
  var CP = x(() => {
    "use strict";
    a(OE, "default");
  });
  function PE(e) {
    return function (t) {
      return t.replace(/[0-9]/g, function (r) {
        return e[+r];
      });
    };
  }
  var wP = x(() => {
    "use strict";
    a(PE, "default");
  });
  function ac(e) {
    if (!(t = ddt.exec(e))) throw new Error("invalid format: " + e);
    var t;
    return new o2({
      fill: t[1],
      align: t[2],
      sign: t[3],
      symbol: t[4],
      zero: t[5],
      width: t[6],
      comma: t[7],
      precision: t[8] && t[8].slice(1),
      trim: t[9],
      type: t[10],
    });
  }
  function o2(e) {
    ((this.fill = e.fill === void 0 ? " " : e.fill + ""),
      (this.align = e.align === void 0 ? ">" : e.align + ""),
      (this.sign = e.sign === void 0 ? "-" : e.sign + ""),
      (this.symbol = e.symbol === void 0 ? "" : e.symbol + ""),
      (this.zero = !!e.zero),
      (this.width = e.width === void 0 ? void 0 : +e.width),
      (this.comma = !!e.comma),
      (this.precision = e.precision === void 0 ? void 0 : +e.precision),
      (this.trim = !!e.trim),
      (this.type = e.type === void 0 ? "" : e.type + ""));
  }
  var ddt,
    BE = x(() => {
      "use strict";
      ddt =
        /^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;
      a(ac, "formatSpecifier");
      ac.prototype = o2.prototype;
      a(o2, "FormatSpecifier");
      o2.prototype.toString = function () {
        return (
          this.fill +
          this.align +
          this.sign +
          this.symbol +
          (this.zero ? "0" : "") +
          (this.width === void 0 ? "" : Math.max(1, this.width | 0)) +
          (this.comma ? "," : "") +
          (this.precision === void 0
            ? ""
            : "." + Math.max(0, this.precision | 0)) +
          (this.trim ? "~" : "") +
          this.type
        );
      };
    });
  function FE(e) {
    t: for (var t = e.length, r = 1, n = -1, i; r < t; ++r)
      switch (e[r]) {
        case ".":
          n = i = r;
          break;
        case "0":
          (n === 0 && (n = r), (i = r));
          break;
        default:
          if (!+e[r]) break t;
          n > 0 && (n = 0);
          break;
      }
    return n > 0 ? e.slice(0, n) + e.slice(i + 1) : e;
  }
  var vP = x(() => {
    "use strict";
    a(FE, "default");
  });
  function GE(e, t) {
    var r = Nu(e, t);
    if (!r) return e + "";
    var n = r[0],
      i = r[1],
      s = i - ($E = Math.max(-8, Math.min(8, Math.floor(i / 3))) * 3) + 1,
      o = n.length;
    return s === o
      ? n
      : s > o
        ? n + new Array(s - o + 1).join("0")
        : s > 0
          ? n.slice(0, s) + "." + n.slice(s)
          : "0." +
            new Array(1 - s).join("0") +
            Nu(e, Math.max(0, t + s - 1))[0];
  }
  var $E,
    VE = x(() => {
      "use strict";
      Mg();
      a(GE, "default");
    });
  function l2(e, t) {
    var r = Nu(e, t);
    if (!r) return e + "";
    var n = r[0],
      i = r[1];
    return i < 0
      ? "0." + new Array(-i).join("0") + n
      : n.length > i + 1
        ? n.slice(0, i + 1) + "." + n.slice(i + 1)
        : n + new Array(i - n.length + 2).join("0");
  }
  var EP = x(() => {
    "use strict";
    Mg();
    a(l2, "default");
  });
  var zE,
    AP = x(() => {
      "use strict";
      Mg();
      VE();
      EP();
      zE = {
        "%": a((e, t) => (e * 100).toFixed(t), "%"),
        b: a((e) => Math.round(e).toString(2), "b"),
        c: a((e) => e + "", "c"),
        d: ME,
        e: a((e, t) => e.toExponential(t), "e"),
        f: a((e, t) => e.toFixed(t), "f"),
        g: a((e, t) => e.toPrecision(t), "g"),
        o: a((e) => Math.round(e).toString(8), "o"),
        p: a((e, t) => l2(e * 100, t), "p"),
        r: l2,
        s: GE,
        X: a((e) => Math.round(e).toString(16).toUpperCase(), "X"),
        x: a((e) => Math.round(e).toString(16), "x"),
      };
    });
  function c2(e) {
    return e;
  }
  var LP = x(() => {
    "use strict";
    a(c2, "default");
  });
  function WE(e) {
    var t =
        e.grouping === void 0 || e.thousands === void 0
          ? c2
          : OE(RP.call(e.grouping, Number), e.thousands + ""),
      r = e.currency === void 0 ? "" : e.currency[0] + "",
      n = e.currency === void 0 ? "" : e.currency[1] + "",
      i = e.decimal === void 0 ? "." : e.decimal + "",
      s = e.numerals === void 0 ? c2 : PE(RP.call(e.numerals, String)),
      o = e.percent === void 0 ? "%" : e.percent + "",
      l = e.minus === void 0 ? "\u2212" : e.minus + "",
      u = e.nan === void 0 ? "NaN" : e.nan + "";
    function h(d) {
      d = ac(d);
      var p = d.fill,
        m = d.align,
        g = d.sign,
        y = d.symbol,
        b = d.zero,
        k = d.width,
        T = d.comma,
        C = d.precision,
        L = d.trim,
        w = d.type;
      (w === "n"
        ? ((T = !0), (w = "g"))
        : zE[w] || (C === void 0 && (C = 12), (L = !0), (w = "g")),
        (b || (p === "0" && m === "=")) && ((b = !0), (p = "0"), (m = "=")));
      var D =
          y === "$"
            ? r
            : y === "#" && /[boxX]/.test(w)
              ? "0" + w.toLowerCase()
              : "",
        G = y === "$" ? n : /[%p]/.test(w) ? o : "",
        E = zE[w],
        R = /[defgprs%]/.test(w);
      C =
        C === void 0
          ? 6
          : /[gprs]/.test(w)
            ? Math.max(1, Math.min(21, C))
            : Math.max(0, Math.min(20, C));
      function F(S) {
        var O = D,
          v = G,
          _,
          A,
          N;
        if (w === "c") ((v = E(S) + v), (S = ""));
        else {
          S = +S;
          var B = S < 0 || 1 / S < 0;
          if (
            ((S = isNaN(S) ? u : E(Math.abs(S), C)),
            L && (S = FE(S)),
            B && +S == 0 && g !== "+" && (B = !1),
            (O =
              (B ? (g === "(" ? g : l) : g === "-" || g === "(" ? "" : g) + O),
            (v =
              (w === "s" ? DP[8 + $E / 3] : "") +
              v +
              (B && g === "(" ? ")" : "")),
            R)
          ) {
            for (_ = -1, A = S.length; ++_ < A; )
              if (((N = S.charCodeAt(_)), 48 > N || N > 57)) {
                ((v = (N === 46 ? i + S.slice(_ + 1) : S.slice(_)) + v),
                  (S = S.slice(0, _)));
                break;
              }
          }
        }
        T && !b && (S = t(S, 1 / 0));
        var M = O.length + S.length + v.length,
          I = M < k ? new Array(k - M + 1).join(p) : "";
        switch (
          (T &&
            b &&
            ((S = t(I + S, I.length ? k - v.length : 1 / 0)), (I = "")),
          m)
        ) {
          case "<":
            S = O + S + v + I;
            break;
          case "=":
            S = O + I + S + v;
            break;
          case "^":
            S = I.slice(0, (M = I.length >> 1)) + O + S + v + I.slice(M);
            break;
          default:
            S = I + O + S + v;
            break;
        }
        return s(S);
      }
      return (
        a(F, "format"),
        (F.toString = function () {
          return d + "";
        }),
        F
      );
    }
    a(h, "newFormat");
    function f(d, p) {
      var m = h(((d = ac(d)), (d.type = "f"), d)),
        g = Math.max(-8, Math.min(8, Math.floor(La(p) / 3))) * 3,
        y = Math.pow(10, -g),
        b = DP[8 + g / 3];
      return function (k) {
        return m(y * k) + b;
      };
    }
    return (a(f, "formatPrefix"), { format: h, formatPrefix: f });
  }
  var RP,
    DP,
    NP = x(() => {
      "use strict";
      Og();
      CP();
      wP();
      BE();
      vP();
      AP();
      VE();
      LP();
      ((RP = Array.prototype.map),
        (DP = [
          "y",
          "z",
          "a",
          "f",
          "p",
          "n",
          "\xB5",
          "m",
          "",
          "k",
          "M",
          "G",
          "T",
          "P",
          "E",
          "Z",
          "Y",
        ]));
      a(WE, "default");
    });
  function UE(e) {
    return ((u2 = WE(e)), (lo = u2.format), (h2 = u2.formatPrefix), u2);
  }
  var u2,
    lo,
    h2,
    IP = x(() => {
      "use strict";
      NP();
      UE({ thousands: ",", grouping: [3], currency: ["$", ""] });
      a(UE, "defaultLocale");
    });
  function f2(e) {
    return Math.max(0, -La(Math.abs(e)));
  }
  var MP = x(() => {
    "use strict";
    Og();
    a(f2, "default");
  });
  function d2(e, t) {
    return Math.max(
      0,
      Math.max(-8, Math.min(8, Math.floor(La(t) / 3))) * 3 - La(Math.abs(e)),
    );
  }
  var OP = x(() => {
    "use strict";
    Og();
    a(d2, "default");
  });
  function p2(e, t) {
    return (
      (e = Math.abs(e)),
      (t = Math.abs(t) - e),
      Math.max(0, La(t) - La(e)) + 1
    );
  }
  var PP = x(() => {
    "use strict";
    Og();
    a(p2, "default");
  });
  var jE = x(() => {
    "use strict";
    IP();
    BE();
    MP();
    OP();
    PP();
  });
  var BP = x(() => {
    "use strict";
  });
  function pdt(e) {
    var t = 0,
      r = e.children,
      n = r && r.length;
    if (!n) t = 1;
    else for (; --n >= 0; ) t += r[n].value;
    e.value = t;
  }
  function qE() {
    return this.eachAfter(pdt);
  }
  var FP = x(() => {
    "use strict";
    a(pdt, "count");
    a(qE, "default");
  });
  function HE(e, t) {
    let r = -1;
    for (let n of this) e.call(t, n, ++r, this);
    return this;
  }
  var $P = x(() => {
    "use strict";
    a(HE, "default");
  });
  function YE(e, t) {
    for (var r = this, n = [r], i, s, o = -1; (r = n.pop()); )
      if ((e.call(t, r, ++o, this), (i = r.children)))
        for (s = i.length - 1; s >= 0; --s) n.push(i[s]);
    return this;
  }
  var GP = x(() => {
    "use strict";
    a(YE, "default");
  });
  function XE(e, t) {
    for (var r = this, n = [r], i = [], s, o, l, u = -1; (r = n.pop()); )
      if ((i.push(r), (s = r.children)))
        for (o = 0, l = s.length; o < l; ++o) n.push(s[o]);
    for (; (r = i.pop()); ) e.call(t, r, ++u, this);
    return this;
  }
  var VP = x(() => {
    "use strict";
    a(XE, "default");
  });
  function KE(e, t) {
    let r = -1;
    for (let n of this) if (e.call(t, n, ++r, this)) return n;
  }
  var zP = x(() => {
    "use strict";
    a(KE, "default");
  });
  function QE(e) {
    return this.eachAfter(function (t) {
      for (
        var r = +e(t.data) || 0, n = t.children, i = n && n.length;
        --i >= 0;

      )
        r += n[i].value;
      t.value = r;
    });
  }
  var WP = x(() => {
    "use strict";
    a(QE, "default");
  });
  function ZE(e) {
    return this.eachBefore(function (t) {
      t.children && t.children.sort(e);
    });
  }
  var UP = x(() => {
    "use strict";
    a(ZE, "default");
  });
  function JE(e) {
    for (var t = this, r = mdt(t, e), n = [t]; t !== r; )
      ((t = t.parent), n.push(t));
    for (var i = n.length; e !== r; ) (n.splice(i, 0, e), (e = e.parent));
    return n;
  }
  function mdt(e, t) {
    if (e === t) return e;
    var r = e.ancestors(),
      n = t.ancestors(),
      i = null;
    for (e = r.pop(), t = n.pop(); e === t; )
      ((i = e), (e = r.pop()), (t = n.pop()));
    return i;
  }
  var jP = x(() => {
    "use strict";
    a(JE, "default");
    a(mdt, "leastCommonAncestor");
  });
  function t3() {
    for (var e = this, t = [e]; (e = e.parent); ) t.push(e);
    return t;
  }
  var qP = x(() => {
    "use strict";
    a(t3, "default");
  });
  function e3() {
    return Array.from(this);
  }
  var HP = x(() => {
    "use strict";
    a(e3, "default");
  });
  function r3() {
    var e = [];
    return (
      this.eachBefore(function (t) {
        t.children || e.push(t);
      }),
      e
    );
  }
  var YP = x(() => {
    "use strict";
    a(r3, "default");
  });
  function n3() {
    var e = this,
      t = [];
    return (
      e.each(function (r) {
        r !== e && t.push({ source: r.parent, target: r });
      }),
      t
    );
  }
  var XP = x(() => {
    "use strict";
    a(n3, "default");
  });
  function* i3() {
    var e = this,
      t,
      r = [e],
      n,
      i,
      s;
    do
      for (t = r.reverse(), r = []; (e = t.pop()); )
        if ((yield e, (n = e.children)))
          for (i = 0, s = n.length; i < s; ++i) r.push(n[i]);
    while (r.length);
  }
  var KP = x(() => {
    "use strict";
    a(i3, "default");
  });
  function Lf(e, t) {
    e instanceof Map
      ? ((e = [void 0, e]), t === void 0 && (t = xdt))
      : t === void 0 && (t = ydt);
    for (var r = new Pg(e), n, i = [r], s, o, l, u; (n = i.pop()); )
      if ((o = t(n.data)) && (u = (o = Array.from(o)).length))
        for (n.children = o, l = u - 1; l >= 0; --l)
          (i.push((s = o[l] = new Pg(o[l]))),
            (s.parent = n),
            (s.depth = n.depth + 1));
    return r.eachBefore(kdt);
  }
  function gdt() {
    return Lf(this).eachBefore(bdt);
  }
  function ydt(e) {
    return e.children;
  }
  function xdt(e) {
    return Array.isArray(e) ? e[1] : null;
  }
  function bdt(e) {
    (e.data.value !== void 0 && (e.value = e.data.value),
      (e.data = e.data.data));
  }
  function kdt(e) {
    var t = 0;
    do e.height = t;
    while ((e = e.parent) && e.height < ++t);
  }
  function Pg(e) {
    ((this.data = e), (this.depth = this.height = 0), (this.parent = null));
  }
  var QP = x(() => {
    "use strict";
    FP();
    $P();
    GP();
    VP();
    zP();
    WP();
    UP();
    jP();
    qP();
    HP();
    YP();
    XP();
    KP();
    a(Lf, "hierarchy");
    a(gdt, "node_copy");
    a(ydt, "objectChildren");
    a(xdt, "mapChildren");
    a(bdt, "copyData");
    a(kdt, "computeHeight");
    a(Pg, "Node");
    Pg.prototype = Lf.prototype = {
      constructor: Pg,
      count: qE,
      each: HE,
      eachAfter: XE,
      eachBefore: YE,
      find: KE,
      sum: QE,
      sort: ZE,
      path: JE,
      ancestors: t3,
      descendants: e3,
      leaves: r3,
      links: n3,
      copy: gdt,
      [Symbol.iterator]: i3,
    };
  });
  function ZP(e) {
    if (typeof e != "function") throw new Error();
    return e;
  }
  var JP = x(() => {
    "use strict";
    a(ZP, "required");
  });
  function Rf() {
    return 0;
  }
  function Iu(e) {
    return function () {
      return e;
    };
  }
  var t9 = x(() => {
    "use strict";
    a(Rf, "constantZero");
    a(Iu, "default");
  });
  function s3(e) {
    ((e.x0 = Math.round(e.x0)),
      (e.y0 = Math.round(e.y0)),
      (e.x1 = Math.round(e.x1)),
      (e.y1 = Math.round(e.y1)));
  }
  var e9 = x(() => {
    "use strict";
    a(s3, "default");
  });
  function a3(e, t, r, n, i) {
    for (
      var s = e.children,
        o,
        l = -1,
        u = s.length,
        h = e.value && (n - t) / e.value;
      ++l < u;

    )
      ((o = s[l]),
        (o.y0 = r),
        (o.y1 = i),
        (o.x0 = t),
        (o.x1 = t += o.value * h));
  }
  var r9 = x(() => {
    "use strict";
    a(a3, "default");
  });
  function o3(e, t, r, n, i) {
    for (
      var s = e.children,
        o,
        l = -1,
        u = s.length,
        h = e.value && (i - r) / e.value;
      ++l < u;

    )
      ((o = s[l]),
        (o.x0 = t),
        (o.x1 = n),
        (o.y0 = r),
        (o.y1 = r += o.value * h));
  }
  var n9 = x(() => {
    "use strict";
    a(o3, "default");
  });
  function Sdt(e, t, r, n, i, s) {
    for (
      var o = [],
        l = t.children,
        u,
        h,
        f = 0,
        d = 0,
        p = l.length,
        m,
        g,
        y = t.value,
        b,
        k,
        T,
        C,
        L,
        w,
        D;
      f < p;

    ) {
      ((m = i - r), (g = s - n));
      do b = l[d++].value;
      while (!b && d < p);
      for (
        k = T = b,
          w = Math.max(g / m, m / g) / (y * e),
          D = b * b * w,
          L = Math.max(T / D, D / k);
        d < p;
        ++d
      ) {
        if (
          ((b += h = l[d].value),
          h < k && (k = h),
          h > T && (T = h),
          (D = b * b * w),
          (C = Math.max(T / D, D / k)),
          C > L)
        ) {
          b -= h;
          break;
        }
        L = C;
      }
      (o.push((u = { value: b, dice: m < g, children: l.slice(f, d) })),
        u.dice
          ? a3(u, r, n, i, y ? (n += (g * b) / y) : s)
          : o3(u, r, n, y ? (r += (m * b) / y) : i, s),
        (y -= b),
        (f = d));
    }
    return o;
  }
  var Tdt,
    i9,
    s9 = x(() => {
      "use strict";
      r9();
      n9();
      Tdt = (1 + Math.sqrt(5)) / 2;
      a(Sdt, "squarifyRatio");
      i9 = a(function e(t) {
        function r(n, i, s, o, l) {
          Sdt(t, n, i, s, o, l);
        }
        return (
          a(r, "squarify"),
          (r.ratio = function (n) {
            return e((n = +n) > 1 ? n : 1);
          }),
          r
        );
      }, "custom")(Tdt);
    });
  function m2() {
    var e = i9,
      t = !1,
      r = 1,
      n = 1,
      i = [0],
      s = Rf,
      o = Rf,
      l = Rf,
      u = Rf,
      h = Rf;
    function f(p) {
      return (
        (p.x0 = p.y0 = 0),
        (p.x1 = r),
        (p.y1 = n),
        p.eachBefore(d),
        (i = [0]),
        t && p.eachBefore(s3),
        p
      );
    }
    a(f, "treemap");
    function d(p) {
      var m = i[p.depth],
        g = p.x0 + m,
        y = p.y0 + m,
        b = p.x1 - m,
        k = p.y1 - m;
      (b < g && (g = b = (g + b) / 2),
        k < y && (y = k = (y + k) / 2),
        (p.x0 = g),
        (p.y0 = y),
        (p.x1 = b),
        (p.y1 = k),
        p.children &&
          ((m = i[p.depth + 1] = s(p) / 2),
          (g += h(p) - m),
          (y += o(p) - m),
          (b -= l(p) - m),
          (k -= u(p) - m),
          b < g && (g = b = (g + b) / 2),
          k < y && (y = k = (y + k) / 2),
          e(p, g, y, b, k)));
    }
    return (
      a(d, "positionNode"),
      (f.round = function (p) {
        return arguments.length ? ((t = !!p), f) : t;
      }),
      (f.size = function (p) {
        return arguments.length ? ((r = +p[0]), (n = +p[1]), f) : [r, n];
      }),
      (f.tile = function (p) {
        return arguments.length ? ((e = ZP(p)), f) : e;
      }),
      (f.padding = function (p) {
        return arguments.length
          ? f.paddingInner(p).paddingOuter(p)
          : f.paddingInner();
      }),
      (f.paddingInner = function (p) {
        return arguments.length
          ? ((s = typeof p == "function" ? p : Iu(+p)), f)
          : s;
      }),
      (f.paddingOuter = function (p) {
        return arguments.length
          ? f.paddingTop(p).paddingRight(p).paddingBottom(p).paddingLeft(p)
          : f.paddingTop();
      }),
      (f.paddingTop = function (p) {
        return arguments.length
          ? ((o = typeof p == "function" ? p : Iu(+p)), f)
          : o;
      }),
      (f.paddingRight = function (p) {
        return arguments.length
          ? ((l = typeof p == "function" ? p : Iu(+p)), f)
          : l;
      }),
      (f.paddingBottom = function (p) {
        return arguments.length
          ? ((u = typeof p == "function" ? p : Iu(+p)), f)
          : u;
      }),
      (f.paddingLeft = function (p) {
        return arguments.length
          ? ((h = typeof p == "function" ? p : Iu(+p)), f)
          : h;
      }),
      f
    );
  }
  var a9 = x(() => {
    "use strict";
    e9();
    s9();
    JP();
    t9();
    a(m2, "default");
  });
  var o9 = x(() => {
    "use strict";
    QP();
    a9();
  });
  var l9 = x(() => {
    "use strict";
  });
  var c9 = x(() => {
    "use strict";
  });
  function oc(e, t) {
    switch (arguments.length) {
      case 0:
        break;
      case 1:
        this.range(e);
        break;
      default:
        this.range(t).domain(e);
        break;
    }
    return this;
  }
  var Bg = x(() => {
    "use strict";
    a(oc, "initRange");
  });
  function _s() {
    var e = new mf(),
      t = [],
      r = [],
      n = l3;
    function i(s) {
      let o = e.get(s);
      if (o === void 0) {
        if (n !== l3) return n;
        e.set(s, (o = t.push(s) - 1));
      }
      return r[o % r.length];
    }
    return (
      a(i, "scale"),
      (i.domain = function (s) {
        if (!arguments.length) return t.slice();
        ((t = []), (e = new mf()));
        for (let o of s) e.has(o) || e.set(o, t.push(o) - 1);
        return i;
      }),
      (i.range = function (s) {
        return arguments.length ? ((r = Array.from(s)), i) : r.slice();
      }),
      (i.unknown = function (s) {
        return arguments.length ? ((n = s), i) : n;
      }),
      (i.copy = function () {
        return _s(t, r).unknown(n);
      }),
      oc.apply(i, arguments),
      i
    );
  }
  var l3,
    c3 = x(() => {
      "use strict";
      tc();
      Bg();
      l3 = Symbol("implicit");
      a(_s, "ordinal");
    });
  function Df() {
    var e = _s().unknown(void 0),
      t = e.domain,
      r = e.range,
      n = 0,
      i = 1,
      s,
      o,
      l = !1,
      u = 0,
      h = 0,
      f = 0.5;
    delete e.unknown;
    function d() {
      var p = t().length,
        m = i < n,
        g = m ? i : n,
        y = m ? n : i;
      ((s = (y - g) / Math.max(1, p - u + h * 2)),
        l && (s = Math.floor(s)),
        (g += (y - g - s * (p - u)) * f),
        (o = s * (1 - u)),
        l && ((g = Math.round(g)), (o = Math.round(o))));
      var b = Nx(p).map(function (k) {
        return g + s * k;
      });
      return r(m ? b.reverse() : b);
    }
    return (
      a(d, "rescale"),
      (e.domain = function (p) {
        return arguments.length ? (t(p), d()) : t();
      }),
      (e.range = function (p) {
        return arguments.length
          ? (([n, i] = p), (n = +n), (i = +i), d())
          : [n, i];
      }),
      (e.rangeRound = function (p) {
        return (([n, i] = p), (n = +n), (i = +i), (l = !0), d());
      }),
      (e.bandwidth = function () {
        return o;
      }),
      (e.step = function () {
        return s;
      }),
      (e.round = function (p) {
        return arguments.length ? ((l = !!p), d()) : l;
      }),
      (e.padding = function (p) {
        return arguments.length ? ((u = Math.min(1, (h = +p))), d()) : u;
      }),
      (e.paddingInner = function (p) {
        return arguments.length ? ((u = Math.min(1, p)), d()) : u;
      }),
      (e.paddingOuter = function (p) {
        return arguments.length ? ((h = +p), d()) : h;
      }),
      (e.align = function (p) {
        return arguments.length ? ((f = Math.max(0, Math.min(1, p))), d()) : f;
      }),
      (e.copy = function () {
        return Df(t(), [n, i])
          .round(l)
          .paddingInner(u)
          .paddingOuter(h)
          .align(f);
      }),
      oc.apply(d(), arguments)
    );
  }
  var u9 = x(() => {
    "use strict";
    tc();
    Bg();
    c3();
    a(Df, "band");
  });
  function u3(e) {
    return function () {
      return e;
    };
  }
  var h9 = x(() => {
    "use strict";
    a(u3, "constants");
  });
  function h3(e) {
    return +e;
  }
  var f9 = x(() => {
    "use strict";
    a(h3, "number");
  });
  function Nf(e) {
    return e;
  }
  function f3(e, t) {
    return (t -= e = +e)
      ? function (r) {
          return (r - e) / t;
        }
      : u3(isNaN(t) ? NaN : 0.5);
  }
  function _dt(e, t) {
    var r;
    return (
      e > t && ((r = e), (e = t), (t = r)),
      function (n) {
        return Math.max(e, Math.min(t, n));
      }
    );
  }
  function Cdt(e, t, r) {
    var n = e[0],
      i = e[1],
      s = t[0],
      o = t[1];
    return (
      i < n ? ((n = f3(i, n)), (s = r(o, s))) : ((n = f3(n, i)), (s = r(s, o))),
      function (l) {
        return s(n(l));
      }
    );
  }
  function wdt(e, t, r) {
    var n = Math.min(e.length, t.length) - 1,
      i = new Array(n),
      s = new Array(n),
      o = -1;
    for (
      e[n] < e[0] && ((e = e.slice().reverse()), (t = t.slice().reverse()));
      ++o < n;

    )
      ((i[o] = f3(e[o], e[o + 1])), (s[o] = r(t[o], t[o + 1])));
    return function (l) {
      var u = Iw(e, l, 1, n) - 1;
      return s[u](i[u](l));
    };
  }
  function g2(e, t) {
    return t
      .domain(e.domain())
      .range(e.range())
      .interpolate(e.interpolate())
      .clamp(e.clamp())
      .unknown(e.unknown());
  }
  function vdt() {
    var e = d9,
      t = d9,
      r = sc,
      n,
      i,
      s,
      o = Nf,
      l,
      u,
      h;
    function f() {
      var p = Math.min(e.length, t.length);
      return (
        o !== Nf && (o = _dt(e[0], e[p - 1])),
        (l = p > 2 ? wdt : Cdt),
        (u = h = null),
        d
      );
    }
    a(f, "rescale");
    function d(p) {
      return p == null || isNaN((p = +p))
        ? s
        : (u || (u = l(e.map(n), t, r)))(n(o(p)));
    }
    return (
      a(d, "scale"),
      (d.invert = function (p) {
        return o(i((h || (h = l(t, e.map(n), zn)))(p)));
      }),
      (d.domain = function (p) {
        return arguments.length ? ((e = Array.from(p, h3)), f()) : e.slice();
      }),
      (d.range = function (p) {
        return arguments.length ? ((t = Array.from(p)), f()) : t.slice();
      }),
      (d.rangeRound = function (p) {
        return ((t = Array.from(p)), (r = qx), f());
      }),
      (d.clamp = function (p) {
        return arguments.length ? ((o = p ? !0 : Nf), f()) : o !== Nf;
      }),
      (d.interpolate = function (p) {
        return arguments.length ? ((r = p), f()) : r;
      }),
      (d.unknown = function (p) {
        return arguments.length ? ((s = p), d) : s;
      }),
      function (p, m) {
        return ((n = p), (i = m), f());
      }
    );
  }
  function Fg() {
    return vdt()(Nf, Nf);
  }
  var d9,
    d3 = x(() => {
      "use strict";
      tc();
      vf();
      h9();
      f9();
      d9 = [0, 1];
      a(Nf, "identity");
      a(f3, "normalize");
      a(_dt, "clamper");
      a(Cdt, "bimap");
      a(wdt, "polymap");
      a(g2, "copy");
      a(vdt, "transformer");
      a(Fg, "continuous");
    });
  function p3(e, t, r, n) {
    var i = gf(e, t, r),
      s;
    switch (((n = ac(n ?? ",f")), n.type)) {
      case "s": {
        var o = Math.max(Math.abs(e), Math.abs(t));
        return (
          n.precision == null && !isNaN((s = d2(i, o))) && (n.precision = s),
          h2(n, o)
        );
      }
      case "":
      case "e":
      case "g":
      case "p":
      case "r": {
        n.precision == null &&
          !isNaN((s = p2(i, Math.max(Math.abs(e), Math.abs(t))))) &&
          (n.precision = s - (n.type === "e"));
        break;
      }
      case "f":
      case "%": {
        n.precision == null &&
          !isNaN((s = f2(i))) &&
          (n.precision = s - (n.type === "%") * 2);
        break;
      }
    }
    return lo(n);
  }
  var p9 = x(() => {
    "use strict";
    tc();
    jE();
    a(p3, "tickFormat");
  });
  function Edt(e) {
    var t = e.domain;
    return (
      (e.ticks = function (r) {
        var n = t();
        return Lx(n[0], n[n.length - 1], r ?? 10);
      }),
      (e.tickFormat = function (r, n) {
        var i = t();
        return p3(i[0], i[i.length - 1], r ?? 10, n);
      }),
      (e.nice = function (r) {
        r == null && (r = 10);
        var n = t(),
          i = 0,
          s = n.length - 1,
          o = n[i],
          l = n[s],
          u,
          h,
          f = 10;
        for (
          l < o && ((h = o), (o = l), (l = h), (h = i), (i = s), (s = h));
          f-- > 0;

        ) {
          if (((h = fg(o, l, r)), h === u))
            return ((n[i] = o), (n[s] = l), t(n));
          if (h > 0) ((o = Math.floor(o / h) * h), (l = Math.ceil(l / h) * h));
          else if (h < 0)
            ((o = Math.ceil(o * h) / h), (l = Math.floor(l * h) / h));
          else break;
          u = h;
        }
        return e;
      }),
      e
    );
  }
  function Ra() {
    var e = Fg();
    return (
      (e.copy = function () {
        return g2(e, Ra());
      }),
      oc.apply(e, arguments),
      Edt(e)
    );
  }
  var m9 = x(() => {
    "use strict";
    tc();
    d3();
    Bg();
    p9();
    a(Edt, "linearish");
    a(Ra, "linear");
  });
  function m3(e, t) {
    e = e.slice();
    var r = 0,
      n = e.length - 1,
      i = e[r],
      s = e[n],
      o;
    return (
      s < i && ((o = r), (r = n), (n = o), (o = i), (i = s), (s = o)),
      (e[r] = t.floor(i)),
      (e[n] = t.ceil(s)),
      e
    );
  }
  var g9 = x(() => {
    "use strict";
    a(m3, "nice");
  });
  function Dr(e, t, r, n) {
    function i(s) {
      return (e((s = arguments.length === 0 ? new Date() : new Date(+s))), s);
    }
    return (
      a(i, "interval"),
      (i.floor = (s) => (e((s = new Date(+s))), s)),
      (i.ceil = (s) => (e((s = new Date(s - 1))), t(s, 1), e(s), s)),
      (i.round = (s) => {
        let o = i(s),
          l = i.ceil(s);
        return s - o < l - s ? o : l;
      }),
      (i.offset = (s, o) => (
        t((s = new Date(+s)), o == null ? 1 : Math.floor(o)),
        s
      )),
      (i.range = (s, o, l) => {
        let u = [];
        if (
          ((s = i.ceil(s)),
          (l = l == null ? 1 : Math.floor(l)),
          !(s < o) || !(l > 0))
        )
          return u;
        let h;
        do (u.push((h = new Date(+s))), t(s, l), e(s));
        while (h < s && s < o);
        return u;
      }),
      (i.filter = (s) =>
        Dr(
          (o) => {
            if (o >= o) for (; e(o), !s(o); ) o.setTime(o - 1);
          },
          (o, l) => {
            if (o >= o)
              if (l < 0) for (; ++l <= 0; ) for (; t(o, -1), !s(o); );
              else for (; --l >= 0; ) for (; t(o, 1), !s(o); );
          },
        )),
      r &&
        ((i.count = (s, o) => (
          g3.setTime(+s),
          y3.setTime(+o),
          e(g3),
          e(y3),
          Math.floor(r(g3, y3))
        )),
        (i.every = (s) => (
          (s = Math.floor(s)),
          !isFinite(s) || !(s > 0)
            ? null
            : s > 1
              ? i.filter(
                  n ? (o) => n(o) % s === 0 : (o) => i.count(0, o) % s === 0,
                )
              : i
        ))),
      i
    );
  }
  var g3,
    y3,
    ol = x(() => {
      "use strict";
      ((g3 = new Date()), (y3 = new Date()));
      a(Dr, "timeInterval");
    });
  var co,
    y9,
    x3 = x(() => {
      "use strict";
      ol();
      co = Dr(
        () => {},
        (e, t) => {
          e.setTime(+e + t);
        },
        (e, t) => t - e,
      );
      co.every = (e) => (
        (e = Math.floor(e)),
        !isFinite(e) || !(e > 0)
          ? null
          : e > 1
            ? Dr(
                (t) => {
                  t.setTime(Math.floor(t / e) * e);
                },
                (t, r) => {
                  t.setTime(+t + r * e);
                },
                (t, r) => (r - t) / e,
              )
            : co
      );
      y9 = co.range;
    });
  var Cs,
    x9,
    b3 = x(() => {
      "use strict";
      ol();
      ((Cs = Dr(
        (e) => {
          e.setTime(e - e.getMilliseconds());
        },
        (e, t) => {
          e.setTime(+e + t * 1e3);
        },
        (e, t) => (t - e) / 1e3,
        (e) => e.getUTCSeconds(),
      )),
        (x9 = Cs.range));
    });
  var ll,
    Adt,
    y2,
    Ldt,
    k3 = x(() => {
      "use strict";
      ol();
      ((ll = Dr(
        (e) => {
          e.setTime(e - e.getMilliseconds() - e.getSeconds() * 1e3);
        },
        (e, t) => {
          e.setTime(+e + t * 6e4);
        },
        (e, t) => (t - e) / 6e4,
        (e) => e.getMinutes(),
      )),
        (Adt = ll.range),
        (y2 = Dr(
          (e) => {
            e.setUTCSeconds(0, 0);
          },
          (e, t) => {
            e.setTime(+e + t * 6e4);
          },
          (e, t) => (t - e) / 6e4,
          (e) => e.getUTCMinutes(),
        )),
        (Ldt = y2.range));
    });
  var cl,
    Rdt,
    x2,
    Ddt,
    T3 = x(() => {
      "use strict";
      ol();
      ((cl = Dr(
        (e) => {
          e.setTime(
            e -
              e.getMilliseconds() -
              e.getSeconds() * 1e3 -
              e.getMinutes() * 6e4,
          );
        },
        (e, t) => {
          e.setTime(+e + t * 36e5);
        },
        (e, t) => (t - e) / 36e5,
        (e) => e.getHours(),
      )),
        (Rdt = cl.range),
        (x2 = Dr(
          (e) => {
            e.setUTCMinutes(0, 0, 0);
          },
          (e, t) => {
            e.setTime(+e + t * 36e5);
          },
          (e, t) => (t - e) / 36e5,
          (e) => e.getUTCHours(),
        )),
        (Ddt = x2.range));
    });
  var Hs,
    Ndt,
    Gg,
    Idt,
    b2,
    Mdt,
    S3 = x(() => {
      "use strict";
      ol();
      ((Hs = Dr(
        (e) => e.setHours(0, 0, 0, 0),
        (e, t) => e.setDate(e.getDate() + t),
        (e, t) =>
          (t - e - (t.getTimezoneOffset() - e.getTimezoneOffset()) * 6e4) /
          864e5,
        (e) => e.getDate() - 1,
      )),
        (Ndt = Hs.range),
        (Gg = Dr(
          (e) => {
            e.setUTCHours(0, 0, 0, 0);
          },
          (e, t) => {
            e.setUTCDate(e.getUTCDate() + t);
          },
          (e, t) => (t - e) / 864e5,
          (e) => e.getUTCDate() - 1,
        )),
        (Idt = Gg.range),
        (b2 = Dr(
          (e) => {
            e.setUTCHours(0, 0, 0, 0);
          },
          (e, t) => {
            e.setUTCDate(e.getUTCDate() + t);
          },
          (e, t) => (t - e) / 864e5,
          (e) => Math.floor(e / 864e5),
        )),
        (Mdt = b2.range));
    });
  function Pu(e) {
    return Dr(
      (t) => {
        (t.setDate(t.getDate() - ((t.getDay() + 7 - e) % 7)),
          t.setHours(0, 0, 0, 0));
      },
      (t, r) => {
        t.setDate(t.getDate() + r * 7);
      },
      (t, r) =>
        (r - t - (r.getTimezoneOffset() - t.getTimezoneOffset()) * 6e4) /
        6048e5,
    );
  }
  function Bu(e) {
    return Dr(
      (t) => {
        (t.setUTCDate(t.getUTCDate() - ((t.getUTCDay() + 7 - e) % 7)),
          t.setUTCHours(0, 0, 0, 0));
      },
      (t, r) => {
        t.setUTCDate(t.getUTCDate() + r * 7);
      },
      (t, r) => (r - t) / 6048e5,
    );
  }
  var Da,
    lc,
    k2,
    T2,
    ho,
    S2,
    _2,
    k9,
    Odt,
    Pdt,
    Bdt,
    Fdt,
    $dt,
    Gdt,
    Fu,
    If,
    T9,
    S9,
    cc,
    _9,
    C9,
    w9,
    Vdt,
    zdt,
    Wdt,
    Udt,
    jdt,
    qdt,
    _3 = x(() => {
      "use strict";
      ol();
      a(Pu, "timeWeekday");
      ((Da = Pu(0)),
        (lc = Pu(1)),
        (k2 = Pu(2)),
        (T2 = Pu(3)),
        (ho = Pu(4)),
        (S2 = Pu(5)),
        (_2 = Pu(6)),
        (k9 = Da.range),
        (Odt = lc.range),
        (Pdt = k2.range),
        (Bdt = T2.range),
        (Fdt = ho.range),
        ($dt = S2.range),
        (Gdt = _2.range));
      a(Bu, "utcWeekday");
      ((Fu = Bu(0)),
        (If = Bu(1)),
        (T9 = Bu(2)),
        (S9 = Bu(3)),
        (cc = Bu(4)),
        (_9 = Bu(5)),
        (C9 = Bu(6)),
        (w9 = Fu.range),
        (Vdt = If.range),
        (zdt = T9.range),
        (Wdt = S9.range),
        (Udt = cc.range),
        (jdt = _9.range),
        (qdt = C9.range));
    });
  var ul,
    Hdt,
    C2,
    Ydt,
    C3 = x(() => {
      "use strict";
      ol();
      ((ul = Dr(
        (e) => {
          (e.setDate(1), e.setHours(0, 0, 0, 0));
        },
        (e, t) => {
          e.setMonth(e.getMonth() + t);
        },
        (e, t) =>
          t.getMonth() -
          e.getMonth() +
          (t.getFullYear() - e.getFullYear()) * 12,
        (e) => e.getMonth(),
      )),
        (Hdt = ul.range),
        (C2 = Dr(
          (e) => {
            (e.setUTCDate(1), e.setUTCHours(0, 0, 0, 0));
          },
          (e, t) => {
            e.setUTCMonth(e.getUTCMonth() + t);
          },
          (e, t) =>
            t.getUTCMonth() -
            e.getUTCMonth() +
            (t.getUTCFullYear() - e.getUTCFullYear()) * 12,
          (e) => e.getUTCMonth(),
        )),
        (Ydt = C2.range));
    });
  var ws,
    Xdt,
    Na,
    Kdt,
    w3 = x(() => {
      "use strict";
      ol();
      ws = Dr(
        (e) => {
          (e.setMonth(0, 1), e.setHours(0, 0, 0, 0));
        },
        (e, t) => {
          e.setFullYear(e.getFullYear() + t);
        },
        (e, t) => t.getFullYear() - e.getFullYear(),
        (e) => e.getFullYear(),
      );
      ws.every = (e) =>
        !isFinite((e = Math.floor(e))) || !(e > 0)
          ? null
          : Dr(
              (t) => {
                (t.setFullYear(Math.floor(t.getFullYear() / e) * e),
                  t.setMonth(0, 1),
                  t.setHours(0, 0, 0, 0));
              },
              (t, r) => {
                t.setFullYear(t.getFullYear() + r * e);
              },
            );
      ((Xdt = ws.range),
        (Na = Dr(
          (e) => {
            (e.setUTCMonth(0, 1), e.setUTCHours(0, 0, 0, 0));
          },
          (e, t) => {
            e.setUTCFullYear(e.getUTCFullYear() + t);
          },
          (e, t) => t.getUTCFullYear() - e.getUTCFullYear(),
          (e) => e.getUTCFullYear(),
        )));
      Na.every = (e) =>
        !isFinite((e = Math.floor(e))) || !(e > 0)
          ? null
          : Dr(
              (t) => {
                (t.setUTCFullYear(Math.floor(t.getUTCFullYear() / e) * e),
                  t.setUTCMonth(0, 1),
                  t.setUTCHours(0, 0, 0, 0));
              },
              (t, r) => {
                t.setUTCFullYear(t.getUTCFullYear() + r * e);
              },
            );
      Kdt = Na.range;
    });
  function E9(e, t, r, n, i, s) {
    let o = [
      [Cs, 1, 1e3],
      [Cs, 5, 5 * 1e3],
      [Cs, 15, 15 * 1e3],
      [Cs, 30, 30 * 1e3],
      [s, 1, 6e4],
      [s, 5, 5 * 6e4],
      [s, 15, 15 * 6e4],
      [s, 30, 30 * 6e4],
      [i, 1, 36e5],
      [i, 3, 3 * 36e5],
      [i, 6, 6 * 36e5],
      [i, 12, 12 * 36e5],
      [n, 1, 864e5],
      [n, 2, 2 * 864e5],
      [r, 1, 6048e5],
      [t, 1, 2592e6],
      [t, 3, 3 * 2592e6],
      [e, 1, 31536e6],
    ];
    function l(h, f, d) {
      let p = f < h;
      p && ([h, f] = [f, h]);
      let m = d && typeof d.range == "function" ? d : u(h, f, d),
        g = m ? m.range(h, +f + 1) : [];
      return p ? g.reverse() : g;
    }
    a(l, "ticks");
    function u(h, f, d) {
      let p = Math.abs(f - h) / d,
        m = Cu(([, , b]) => b).right(o, p);
      if (m === o.length) return e.every(gf(h / 31536e6, f / 31536e6, d));
      if (m === 0) return co.every(Math.max(gf(h, f, d), 1));
      let [g, y] = o[p / o[m - 1][2] < o[m][2] / p ? m - 1 : m];
      return g.every(y);
    }
    return (a(u, "tickInterval"), [l, u]);
  }
  var Zdt,
    Jdt,
    v3,
    E3,
    A9 = x(() => {
      "use strict";
      tc();
      x3();
      b3();
      k3();
      T3();
      S3();
      _3();
      C3();
      w3();
      a(E9, "ticker");
      (([Zdt, Jdt] = E9(Na, C2, Fu, b2, x2, y2)),
        ([v3, E3] = E9(ws, ul, Da, Hs, cl, ll)));
    });
  var w2 = x(() => {
    "use strict";
    x3();
    b3();
    k3();
    T3();
    S3();
    _3();
    C3();
    w3();
    A9();
  });
  function A3(e) {
    if (0 <= e.y && e.y < 100) {
      var t = new Date(-1, e.m, e.d, e.H, e.M, e.S, e.L);
      return (t.setFullYear(e.y), t);
    }
    return new Date(e.y, e.m, e.d, e.H, e.M, e.S, e.L);
  }
  function L3(e) {
    if (0 <= e.y && e.y < 100) {
      var t = new Date(Date.UTC(-1, e.m, e.d, e.H, e.M, e.S, e.L));
      return (t.setUTCFullYear(e.y), t);
    }
    return new Date(Date.UTC(e.y, e.m, e.d, e.H, e.M, e.S, e.L));
  }
  function Vg(e, t, r) {
    return { y: e, m: t, d: r, H: 0, M: 0, S: 0, L: 0 };
  }
  function R3(e) {
    var t = e.dateTime,
      r = e.date,
      n = e.time,
      i = e.periods,
      s = e.days,
      o = e.shortDays,
      l = e.months,
      u = e.shortMonths,
      h = zg(i),
      f = Wg(i),
      d = zg(s),
      p = Wg(s),
      m = zg(o),
      g = Wg(o),
      y = zg(l),
      b = Wg(l),
      k = zg(u),
      T = Wg(u),
      C = {
        a: B,
        A: M,
        b: I,
        B: V,
        c: null,
        d: M9,
        e: M9,
        f: Spt,
        g: Npt,
        G: Mpt,
        H: bpt,
        I: kpt,
        j: Tpt,
        L: $9,
        m: _pt,
        M: Cpt,
        p: $,
        q,
        Q: B9,
        s: F9,
        S: wpt,
        u: vpt,
        U: Ept,
        V: Apt,
        w: Lpt,
        W: Rpt,
        x: null,
        X: null,
        y: Dpt,
        Y: Ipt,
        Z: Opt,
        "%": P9,
      },
      L = {
        a: tt,
        A: ht,
        b: H,
        B: kt,
        c: null,
        d: O9,
        e: O9,
        f: $pt,
        g: Xpt,
        G: Qpt,
        H: Ppt,
        I: Bpt,
        j: Fpt,
        L: V9,
        m: Gpt,
        M: Vpt,
        p: ft,
        q: yt,
        Q: B9,
        s: F9,
        S: zpt,
        u: Wpt,
        U: Upt,
        V: jpt,
        w: qpt,
        W: Hpt,
        x: null,
        X: null,
        y: Ypt,
        Y: Kpt,
        Z: Zpt,
        "%": P9,
      },
      w = {
        a: F,
        A: S,
        b: O,
        B: v,
        c: _,
        d: N9,
        e: N9,
        f: mpt,
        g: D9,
        G: R9,
        H: I9,
        I: I9,
        j: hpt,
        L: ppt,
        m: upt,
        M: fpt,
        p: R,
        q: cpt,
        Q: ypt,
        s: xpt,
        S: dpt,
        u: ipt,
        U: spt,
        V: apt,
        w: npt,
        W: opt,
        x: A,
        X: N,
        y: D9,
        Y: R9,
        Z: lpt,
        "%": gpt,
      };
    ((C.x = D(r, C)),
      (C.X = D(n, C)),
      (C.c = D(t, C)),
      (L.x = D(r, L)),
      (L.X = D(n, L)),
      (L.c = D(t, L)));
    function D(ot, dt) {
      return function (nt) {
        var Q = [],
          et = -1,
          X = 0,
          st = ot.length,
          U,
          gt,
          z;
        for (nt instanceof Date || (nt = new Date(+nt)); ++et < st; )
          ot.charCodeAt(et) === 37 &&
            (Q.push(ot.slice(X, et)),
            (gt = L9[(U = ot.charAt(++et))]) != null
              ? (U = ot.charAt(++et))
              : (gt = U === "e" ? " " : "0"),
            (z = dt[U]) && (U = z(nt, gt)),
            Q.push(U),
            (X = et + 1));
        return (Q.push(ot.slice(X, et)), Q.join(""));
      };
    }
    a(D, "newFormat");
    function G(ot, dt) {
      return function (nt) {
        var Q = Vg(1900, void 0, 1),
          et = E(Q, ot, (nt += ""), 0),
          X,
          st;
        if (et != nt.length) return null;
        if ("Q" in Q) return new Date(Q.Q);
        if ("s" in Q) return new Date(Q.s * 1e3 + ("L" in Q ? Q.L : 0));
        if (
          (dt && !("Z" in Q) && (Q.Z = 0),
          "p" in Q && (Q.H = (Q.H % 12) + Q.p * 12),
          Q.m === void 0 && (Q.m = "q" in Q ? Q.q : 0),
          "V" in Q)
        ) {
          if (Q.V < 1 || Q.V > 53) return null;
          ("w" in Q || (Q.w = 1),
            "Z" in Q
              ? ((X = L3(Vg(Q.y, 0, 1))),
                (st = X.getUTCDay()),
                (X = st > 4 || st === 0 ? If.ceil(X) : If(X)),
                (X = Gg.offset(X, (Q.V - 1) * 7)),
                (Q.y = X.getUTCFullYear()),
                (Q.m = X.getUTCMonth()),
                (Q.d = X.getUTCDate() + ((Q.w + 6) % 7)))
              : ((X = A3(Vg(Q.y, 0, 1))),
                (st = X.getDay()),
                (X = st > 4 || st === 0 ? lc.ceil(X) : lc(X)),
                (X = Hs.offset(X, (Q.V - 1) * 7)),
                (Q.y = X.getFullYear()),
                (Q.m = X.getMonth()),
                (Q.d = X.getDate() + ((Q.w + 6) % 7))));
        } else
          ("W" in Q || "U" in Q) &&
            ("w" in Q || (Q.w = "u" in Q ? Q.u % 7 : "W" in Q ? 1 : 0),
            (st =
              "Z" in Q
                ? L3(Vg(Q.y, 0, 1)).getUTCDay()
                : A3(Vg(Q.y, 0, 1)).getDay()),
            (Q.m = 0),
            (Q.d =
              "W" in Q
                ? ((Q.w + 6) % 7) + Q.W * 7 - ((st + 5) % 7)
                : Q.w + Q.U * 7 - ((st + 6) % 7)));
        return "Z" in Q
          ? ((Q.H += (Q.Z / 100) | 0), (Q.M += Q.Z % 100), L3(Q))
          : A3(Q);
      };
    }
    a(G, "newParse");
    function E(ot, dt, nt, Q) {
      for (var et = 0, X = dt.length, st = nt.length, U, gt; et < X; ) {
        if (Q >= st) return -1;
        if (((U = dt.charCodeAt(et++)), U === 37)) {
          if (
            ((U = dt.charAt(et++)),
            (gt = w[U in L9 ? dt.charAt(et++) : U]),
            !gt || (Q = gt(ot, nt, Q)) < 0)
          )
            return -1;
        } else if (U != nt.charCodeAt(Q++)) return -1;
      }
      return Q;
    }
    a(E, "parseSpecifier");
    function R(ot, dt, nt) {
      var Q = h.exec(dt.slice(nt));
      return Q ? ((ot.p = f.get(Q[0].toLowerCase())), nt + Q[0].length) : -1;
    }
    a(R, "parsePeriod");
    function F(ot, dt, nt) {
      var Q = m.exec(dt.slice(nt));
      return Q ? ((ot.w = g.get(Q[0].toLowerCase())), nt + Q[0].length) : -1;
    }
    a(F, "parseShortWeekday");
    function S(ot, dt, nt) {
      var Q = d.exec(dt.slice(nt));
      return Q ? ((ot.w = p.get(Q[0].toLowerCase())), nt + Q[0].length) : -1;
    }
    a(S, "parseWeekday");
    function O(ot, dt, nt) {
      var Q = k.exec(dt.slice(nt));
      return Q ? ((ot.m = T.get(Q[0].toLowerCase())), nt + Q[0].length) : -1;
    }
    a(O, "parseShortMonth");
    function v(ot, dt, nt) {
      var Q = y.exec(dt.slice(nt));
      return Q ? ((ot.m = b.get(Q[0].toLowerCase())), nt + Q[0].length) : -1;
    }
    a(v, "parseMonth");
    function _(ot, dt, nt) {
      return E(ot, t, dt, nt);
    }
    a(_, "parseLocaleDateTime");
    function A(ot, dt, nt) {
      return E(ot, r, dt, nt);
    }
    a(A, "parseLocaleDate");
    function N(ot, dt, nt) {
      return E(ot, n, dt, nt);
    }
    a(N, "parseLocaleTime");
    function B(ot) {
      return o[ot.getDay()];
    }
    a(B, "formatShortWeekday");
    function M(ot) {
      return s[ot.getDay()];
    }
    a(M, "formatWeekday");
    function I(ot) {
      return u[ot.getMonth()];
    }
    a(I, "formatShortMonth");
    function V(ot) {
      return l[ot.getMonth()];
    }
    a(V, "formatMonth");
    function $(ot) {
      return i[+(ot.getHours() >= 12)];
    }
    a($, "formatPeriod");
    function q(ot) {
      return 1 + ~~(ot.getMonth() / 3);
    }
    a(q, "formatQuarter");
    function tt(ot) {
      return o[ot.getUTCDay()];
    }
    a(tt, "formatUTCShortWeekday");
    function ht(ot) {
      return s[ot.getUTCDay()];
    }
    a(ht, "formatUTCWeekday");
    function H(ot) {
      return u[ot.getUTCMonth()];
    }
    a(H, "formatUTCShortMonth");
    function kt(ot) {
      return l[ot.getUTCMonth()];
    }
    a(kt, "formatUTCMonth");
    function ft(ot) {
      return i[+(ot.getUTCHours() >= 12)];
    }
    a(ft, "formatUTCPeriod");
    function yt(ot) {
      return 1 + ~~(ot.getUTCMonth() / 3);
    }
    return (
      a(yt, "formatUTCQuarter"),
      {
        format: a(function (ot) {
          var dt = D((ot += ""), C);
          return (
            (dt.toString = function () {
              return ot;
            }),
            dt
          );
        }, "format"),
        parse: a(function (ot) {
          var dt = G((ot += ""), !1);
          return (
            (dt.toString = function () {
              return ot;
            }),
            dt
          );
        }, "parse"),
        utcFormat: a(function (ot) {
          var dt = D((ot += ""), L);
          return (
            (dt.toString = function () {
              return ot;
            }),
            dt
          );
        }, "utcFormat"),
        utcParse: a(function (ot) {
          var dt = G((ot += ""), !0);
          return (
            (dt.toString = function () {
              return ot;
            }),
            dt
          );
        }, "utcParse"),
      }
    );
  }
  function fr(e, t, r) {
    var n = e < 0 ? "-" : "",
      i = (n ? -e : e) + "",
      s = i.length;
    return n + (s < r ? new Array(r - s + 1).join(t) + i : i);
  }
  function rpt(e) {
    return e.replace(ept, "\\$&");
  }
  function zg(e) {
    return new RegExp("^(?:" + e.map(rpt).join("|") + ")", "i");
  }
  function Wg(e) {
    return new Map(e.map((t, r) => [t.toLowerCase(), r]));
  }
  function npt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 1));
    return n ? ((e.w = +n[0]), r + n[0].length) : -1;
  }
  function ipt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 1));
    return n ? ((e.u = +n[0]), r + n[0].length) : -1;
  }
  function spt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.U = +n[0]), r + n[0].length) : -1;
  }
  function apt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.V = +n[0]), r + n[0].length) : -1;
  }
  function opt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.W = +n[0]), r + n[0].length) : -1;
  }
  function R9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 4));
    return n ? ((e.y = +n[0]), r + n[0].length) : -1;
  }
  function D9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n
      ? ((e.y = +n[0] + (+n[0] > 68 ? 1900 : 2e3)), r + n[0].length)
      : -1;
  }
  function lpt(e, t, r) {
    var n = /^(Z)|([+-]\d\d)(?::?(\d\d))?/.exec(t.slice(r, r + 6));
    return n
      ? ((e.Z = n[1] ? 0 : -(n[2] + (n[3] || "00"))), r + n[0].length)
      : -1;
  }
  function cpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 1));
    return n ? ((e.q = n[0] * 3 - 3), r + n[0].length) : -1;
  }
  function upt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.m = n[0] - 1), r + n[0].length) : -1;
  }
  function N9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.d = +n[0]), r + n[0].length) : -1;
  }
  function hpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 3));
    return n ? ((e.m = 0), (e.d = +n[0]), r + n[0].length) : -1;
  }
  function I9(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.H = +n[0]), r + n[0].length) : -1;
  }
  function fpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.M = +n[0]), r + n[0].length) : -1;
  }
  function dpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 2));
    return n ? ((e.S = +n[0]), r + n[0].length) : -1;
  }
  function ppt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 3));
    return n ? ((e.L = +n[0]), r + n[0].length) : -1;
  }
  function mpt(e, t, r) {
    var n = Wn.exec(t.slice(r, r + 6));
    return n ? ((e.L = Math.floor(n[0] / 1e3)), r + n[0].length) : -1;
  }
  function gpt(e, t, r) {
    var n = tpt.exec(t.slice(r, r + 1));
    return n ? r + n[0].length : -1;
  }
  function ypt(e, t, r) {
    var n = Wn.exec(t.slice(r));
    return n ? ((e.Q = +n[0]), r + n[0].length) : -1;
  }
  function xpt(e, t, r) {
    var n = Wn.exec(t.slice(r));
    return n ? ((e.s = +n[0]), r + n[0].length) : -1;
  }
  function M9(e, t) {
    return fr(e.getDate(), t, 2);
  }
  function bpt(e, t) {
    return fr(e.getHours(), t, 2);
  }
  function kpt(e, t) {
    return fr(e.getHours() % 12 || 12, t, 2);
  }
  function Tpt(e, t) {
    return fr(1 + Hs.count(ws(e), e), t, 3);
  }
  function $9(e, t) {
    return fr(e.getMilliseconds(), t, 3);
  }
  function Spt(e, t) {
    return $9(e, t) + "000";
  }
  function _pt(e, t) {
    return fr(e.getMonth() + 1, t, 2);
  }
  function Cpt(e, t) {
    return fr(e.getMinutes(), t, 2);
  }
  function wpt(e, t) {
    return fr(e.getSeconds(), t, 2);
  }
  function vpt(e) {
    var t = e.getDay();
    return t === 0 ? 7 : t;
  }
  function Ept(e, t) {
    return fr(Da.count(ws(e) - 1, e), t, 2);
  }
  function G9(e) {
    var t = e.getDay();
    return t >= 4 || t === 0 ? ho(e) : ho.ceil(e);
  }
  function Apt(e, t) {
    return ((e = G9(e)), fr(ho.count(ws(e), e) + (ws(e).getDay() === 4), t, 2));
  }
  function Lpt(e) {
    return e.getDay();
  }
  function Rpt(e, t) {
    return fr(lc.count(ws(e) - 1, e), t, 2);
  }
  function Dpt(e, t) {
    return fr(e.getFullYear() % 100, t, 2);
  }
  function Npt(e, t) {
    return ((e = G9(e)), fr(e.getFullYear() % 100, t, 2));
  }
  function Ipt(e, t) {
    return fr(e.getFullYear() % 1e4, t, 4);
  }
  function Mpt(e, t) {
    var r = e.getDay();
    return (
      (e = r >= 4 || r === 0 ? ho(e) : ho.ceil(e)),
      fr(e.getFullYear() % 1e4, t, 4)
    );
  }
  function Opt(e) {
    var t = e.getTimezoneOffset();
    return (
      (t > 0 ? "-" : ((t *= -1), "+")) +
      fr((t / 60) | 0, "0", 2) +
      fr(t % 60, "0", 2)
    );
  }
  function O9(e, t) {
    return fr(e.getUTCDate(), t, 2);
  }
  function Ppt(e, t) {
    return fr(e.getUTCHours(), t, 2);
  }
  function Bpt(e, t) {
    return fr(e.getUTCHours() % 12 || 12, t, 2);
  }
  function Fpt(e, t) {
    return fr(1 + Gg.count(Na(e), e), t, 3);
  }
  function V9(e, t) {
    return fr(e.getUTCMilliseconds(), t, 3);
  }
  function $pt(e, t) {
    return V9(e, t) + "000";
  }
  function Gpt(e, t) {
    return fr(e.getUTCMonth() + 1, t, 2);
  }
  function Vpt(e, t) {
    return fr(e.getUTCMinutes(), t, 2);
  }
  function zpt(e, t) {
    return fr(e.getUTCSeconds(), t, 2);
  }
  function Wpt(e) {
    var t = e.getUTCDay();
    return t === 0 ? 7 : t;
  }
  function Upt(e, t) {
    return fr(Fu.count(Na(e) - 1, e), t, 2);
  }
  function z9(e) {
    var t = e.getUTCDay();
    return t >= 4 || t === 0 ? cc(e) : cc.ceil(e);
  }
  function jpt(e, t) {
    return (
      (e = z9(e)),
      fr(cc.count(Na(e), e) + (Na(e).getUTCDay() === 4), t, 2)
    );
  }
  function qpt(e) {
    return e.getUTCDay();
  }
  function Hpt(e, t) {
    return fr(If.count(Na(e) - 1, e), t, 2);
  }
  function Ypt(e, t) {
    return fr(e.getUTCFullYear() % 100, t, 2);
  }
  function Xpt(e, t) {
    return ((e = z9(e)), fr(e.getUTCFullYear() % 100, t, 2));
  }
  function Kpt(e, t) {
    return fr(e.getUTCFullYear() % 1e4, t, 4);
  }
  function Qpt(e, t) {
    var r = e.getUTCDay();
    return (
      (e = r >= 4 || r === 0 ? cc(e) : cc.ceil(e)),
      fr(e.getUTCFullYear() % 1e4, t, 4)
    );
  }
  function Zpt() {
    return "+0000";
  }
  function P9() {
    return "%";
  }
  function B9(e) {
    return +e;
  }
  function F9(e) {
    return Math.floor(+e / 1e3);
  }
  var L9,
    Wn,
    tpt,
    ept,
    W9 = x(() => {
      "use strict";
      w2();
      a(A3, "localDate");
      a(L3, "utcDate");
      a(Vg, "newDate");
      a(R3, "formatLocale");
      ((L9 = { "-": "", _: " ", 0: "0" }),
        (Wn = /^\s*\d+/),
        (tpt = /^%/),
        (ept = /[\\^$*+?|[\]().{}]/g));
      a(fr, "pad");
      a(rpt, "requote");
      a(zg, "formatRe");
      a(Wg, "formatLookup");
      a(npt, "parseWeekdayNumberSunday");
      a(ipt, "parseWeekdayNumberMonday");
      a(spt, "parseWeekNumberSunday");
      a(apt, "parseWeekNumberISO");
      a(opt, "parseWeekNumberMonday");
      a(R9, "parseFullYear");
      a(D9, "parseYear");
      a(lpt, "parseZone");
      a(cpt, "parseQuarter");
      a(upt, "parseMonthNumber");
      a(N9, "parseDayOfMonth");
      a(hpt, "parseDayOfYear");
      a(I9, "parseHour24");
      a(fpt, "parseMinutes");
      a(dpt, "parseSeconds");
      a(ppt, "parseMilliseconds");
      a(mpt, "parseMicroseconds");
      a(gpt, "parseLiteralPercent");
      a(ypt, "parseUnixTimestamp");
      a(xpt, "parseUnixTimestampSeconds");
      a(M9, "formatDayOfMonth");
      a(bpt, "formatHour24");
      a(kpt, "formatHour12");
      a(Tpt, "formatDayOfYear");
      a($9, "formatMilliseconds");
      a(Spt, "formatMicroseconds");
      a(_pt, "formatMonthNumber");
      a(Cpt, "formatMinutes");
      a(wpt, "formatSeconds");
      a(vpt, "formatWeekdayNumberMonday");
      a(Ept, "formatWeekNumberSunday");
      a(G9, "dISO");
      a(Apt, "formatWeekNumberISO");
      a(Lpt, "formatWeekdayNumberSunday");
      a(Rpt, "formatWeekNumberMonday");
      a(Dpt, "formatYear");
      a(Npt, "formatYearISO");
      a(Ipt, "formatFullYear");
      a(Mpt, "formatFullYearISO");
      a(Opt, "formatZone");
      a(O9, "formatUTCDayOfMonth");
      a(Ppt, "formatUTCHour24");
      a(Bpt, "formatUTCHour12");
      a(Fpt, "formatUTCDayOfYear");
      a(V9, "formatUTCMilliseconds");
      a($pt, "formatUTCMicroseconds");
      a(Gpt, "formatUTCMonthNumber");
      a(Vpt, "formatUTCMinutes");
      a(zpt, "formatUTCSeconds");
      a(Wpt, "formatUTCWeekdayNumberMonday");
      a(Upt, "formatUTCWeekNumberSunday");
      a(z9, "UTCdISO");
      a(jpt, "formatUTCWeekNumberISO");
      a(qpt, "formatUTCWeekdayNumberSunday");
      a(Hpt, "formatUTCWeekNumberMonday");
      a(Ypt, "formatUTCYear");
      a(Xpt, "formatUTCYearISO");
      a(Kpt, "formatUTCFullYear");
      a(Qpt, "formatUTCFullYearISO");
      a(Zpt, "formatUTCZone");
      a(P9, "formatLiteralPercent");
      a(B9, "formatUnixTimestamp");
      a(F9, "formatUnixTimestampSeconds");
    });
  function D3(e) {
    return (
      (Mf = R3(e)),
      ($u = Mf.format),
      (U9 = Mf.parse),
      (j9 = Mf.utcFormat),
      (q9 = Mf.utcParse),
      Mf
    );
  }
  var Mf,
    $u,
    U9,
    j9,
    q9,
    H9 = x(() => {
      "use strict";
      W9();
      D3({
        dateTime: "%x, %X",
        date: "%-m/%-d/%Y",
        time: "%-I:%M:%S %p",
        periods: ["AM", "PM"],
        days: [
          "Sunday",
          "Monday",
          "Tuesday",
          "Wednesday",
          "Thursday",
          "Friday",
          "Saturday",
        ],
        shortDays: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
        months: [
          "January",
          "February",
          "March",
          "April",
          "May",
          "June",
          "July",
          "August",
          "September",
          "October",
          "November",
          "December",
        ],
        shortMonths: [
          "Jan",
          "Feb",
          "Mar",
          "Apr",
          "May",
          "Jun",
          "Jul",
          "Aug",
          "Sep",
          "Oct",
          "Nov",
          "Dec",
        ],
      });
      a(D3, "defaultLocale");
    });
  var N3 = x(() => {
    "use strict";
    H9();
  });
  function Jpt(e) {
    return new Date(e);
  }
  function tmt(e) {
    return e instanceof Date ? +e : +new Date(+e);
  }
  function Y9(e, t, r, n, i, s, o, l, u, h) {
    var f = Fg(),
      d = f.invert,
      p = f.domain,
      m = h(".%L"),
      g = h(":%S"),
      y = h("%I:%M"),
      b = h("%I %p"),
      k = h("%a %d"),
      T = h("%b %d"),
      C = h("%B"),
      L = h("%Y");
    function w(D) {
      return (
        u(D) < D
          ? m
          : l(D) < D
            ? g
            : o(D) < D
              ? y
              : s(D) < D
                ? b
                : n(D) < D
                  ? i(D) < D
                    ? k
                    : T
                  : r(D) < D
                    ? C
                    : L
      )(D);
    }
    return (
      a(w, "tickFormat"),
      (f.invert = function (D) {
        return new Date(d(D));
      }),
      (f.domain = function (D) {
        return arguments.length ? p(Array.from(D, tmt)) : p().map(Jpt);
      }),
      (f.ticks = function (D) {
        var G = p();
        return e(G[0], G[G.length - 1], D ?? 10);
      }),
      (f.tickFormat = function (D, G) {
        return G == null ? w : h(G);
      }),
      (f.nice = function (D) {
        var G = p();
        return (
          (!D || typeof D.range != "function") &&
            (D = t(G[0], G[G.length - 1], D ?? 10)),
          D ? p(m3(G, D)) : f
        );
      }),
      (f.copy = function () {
        return g2(f, Y9(e, t, r, n, i, s, o, l, u, h));
      }),
      f
    );
  }
  function v2() {
    return oc.apply(
      Y9(v3, E3, ws, ul, Da, Hs, cl, ll, Cs, $u).domain([
        new Date(2e3, 0, 1),
        new Date(2e3, 0, 2),
      ]),
      arguments,
    );
  }
  var X9 = x(() => {
    "use strict";
    w2();
    N3();
    d3();
    Bg();
    g9();
    a(Jpt, "date");
    a(tmt, "number");
    a(Y9, "calendar");
    a(v2, "time");
  });
  var K9 = x(() => {
    "use strict";
    u9();
    m9();
    c3();
    X9();
  });
  function I3(e) {
    for (var t = (e.length / 6) | 0, r = new Array(t), n = 0; n < t; )
      r[n] = "#" + e.slice(n * 6, ++n * 6);
    return r;
  }
  var Q9 = x(() => {
    "use strict";
    a(I3, "default");
  });
  var M3,
    Z9 = x(() => {
      "use strict";
      Q9();
      M3 = I3("4e79a7f28e2ce1575976b7b259a14fedc949af7aa1ff9da79c755fbab0ab");
    });
  var J9 = x(() => {
    "use strict";
    Z9();
  });
  function qr(e) {
    return a(function () {
      return e;
    }, "constant");
  }
  var E2 = x(() => {
    "use strict";
    a(qr, "default");
  });
  function eB(e) {
    return e > 1 ? 0 : e < -1 ? Of : Math.acos(e);
  }
  function P3(e) {
    return e >= 1 ? Ug : e <= -1 ? -Ug : Math.asin(e);
  }
  var O3,
    ei,
    uc,
    tB,
    A2,
    Ia,
    Gu,
    Un,
    Of,
    Ug,
    Pf,
    L2 = x(() => {
      "use strict";
      ((O3 = Math.abs),
        (ei = Math.atan2),
        (uc = Math.cos),
        (tB = Math.max),
        (A2 = Math.min),
        (Ia = Math.sin),
        (Gu = Math.sqrt),
        (Un = 1e-12),
        (Of = Math.PI),
        (Ug = Of / 2),
        (Pf = 2 * Of));
      a(eB, "acos");
      a(P3, "asin");
    });
  function R2(e) {
    let t = 3;
    return (
      (e.digits = function (r) {
        if (!arguments.length) return t;
        if (r == null) t = null;
        else {
          let n = Math.floor(r);
          if (!(n >= 0)) throw new RangeError(`invalid digits: ${r}`);
          t = n;
        }
        return e;
      }),
      () => new Du(t)
    );
  }
  var B3 = x(() => {
    "use strict";
    IE();
    a(R2, "withPath");
  });
  function emt(e) {
    return e.innerRadius;
  }
  function rmt(e) {
    return e.outerRadius;
  }
  function nmt(e) {
    return e.startAngle;
  }
  function imt(e) {
    return e.endAngle;
  }
  function smt(e) {
    return e && e.padAngle;
  }
  function amt(e, t, r, n, i, s, o, l) {
    var u = r - e,
      h = n - t,
      f = o - i,
      d = l - s,
      p = d * u - f * h;
    if (!(p * p < Un))
      return ((p = (f * (t - s) - d * (e - i)) / p), [e + p * u, t + p * h]);
  }
  function D2(e, t, r, n, i, s, o) {
    var l = e - r,
      u = t - n,
      h = (o ? s : -s) / Gu(l * l + u * u),
      f = h * u,
      d = -h * l,
      p = e + f,
      m = t + d,
      g = r + f,
      y = n + d,
      b = (p + g) / 2,
      k = (m + y) / 2,
      T = g - p,
      C = y - m,
      L = T * T + C * C,
      w = i - s,
      D = p * y - g * m,
      G = (C < 0 ? -1 : 1) * Gu(tB(0, w * w * L - D * D)),
      E = (D * C - T * G) / L,
      R = (-D * T - C * G) / L,
      F = (D * C + T * G) / L,
      S = (-D * T + C * G) / L,
      O = E - b,
      v = R - k,
      _ = F - b,
      A = S - k;
    return (
      O * O + v * v > _ * _ + A * A && ((E = F), (R = S)),
      {
        cx: E,
        cy: R,
        x01: -f,
        y01: -d,
        x11: E * (i / w - 1),
        y11: R * (i / w - 1),
      }
    );
  }
  function Ma() {
    var e = emt,
      t = rmt,
      r = qr(0),
      n = null,
      i = nmt,
      s = imt,
      o = smt,
      l = null,
      u = R2(h);
    function h() {
      var f,
        d,
        p = +e.apply(this, arguments),
        m = +t.apply(this, arguments),
        g = i.apply(this, arguments) - Ug,
        y = s.apply(this, arguments) - Ug,
        b = O3(y - g),
        k = y > g;
      if ((l || (l = f = u()), m < p && ((d = m), (m = p), (p = d)), !(m > Un)))
        l.moveTo(0, 0);
      else if (b > Pf - Un)
        (l.moveTo(m * uc(g), m * Ia(g)),
          l.arc(0, 0, m, g, y, !k),
          p > Un && (l.moveTo(p * uc(y), p * Ia(y)), l.arc(0, 0, p, y, g, k)));
      else {
        var T = g,
          C = y,
          L = g,
          w = y,
          D = b,
          G = b,
          E = o.apply(this, arguments) / 2,
          R = E > Un && (n ? +n.apply(this, arguments) : Gu(p * p + m * m)),
          F = A2(O3(m - p) / 2, +r.apply(this, arguments)),
          S = F,
          O = F,
          v,
          _;
        if (R > Un) {
          var A = P3((R / p) * Ia(E)),
            N = P3((R / m) * Ia(E));
          ((D -= A * 2) > Un
            ? ((A *= k ? 1 : -1), (L += A), (w -= A))
            : ((D = 0), (L = w = (g + y) / 2)),
            (G -= N * 2) > Un
              ? ((N *= k ? 1 : -1), (T += N), (C -= N))
              : ((G = 0), (T = C = (g + y) / 2)));
        }
        var B = m * uc(T),
          M = m * Ia(T),
          I = p * uc(w),
          V = p * Ia(w);
        if (F > Un) {
          var $ = m * uc(C),
            q = m * Ia(C),
            tt = p * uc(L),
            ht = p * Ia(L),
            H;
          if (b < Of)
            if ((H = amt(B, M, tt, ht, $, q, I, V))) {
              var kt = B - H[0],
                ft = M - H[1],
                yt = $ - H[0],
                ot = q - H[1],
                dt =
                  1 /
                  Ia(
                    eB(
                      (kt * yt + ft * ot) /
                        (Gu(kt * kt + ft * ft) * Gu(yt * yt + ot * ot)),
                    ) / 2,
                  ),
                nt = Gu(H[0] * H[0] + H[1] * H[1]);
              ((S = A2(F, (p - nt) / (dt - 1))),
                (O = A2(F, (m - nt) / (dt + 1))));
            } else S = O = 0;
        }
        (G > Un
          ? O > Un
            ? ((v = D2(tt, ht, B, M, m, O, k)),
              (_ = D2($, q, I, V, m, O, k)),
              l.moveTo(v.cx + v.x01, v.cy + v.y01),
              O < F
                ? l.arc(v.cx, v.cy, O, ei(v.y01, v.x01), ei(_.y01, _.x01), !k)
                : (l.arc(v.cx, v.cy, O, ei(v.y01, v.x01), ei(v.y11, v.x11), !k),
                  l.arc(
                    0,
                    0,
                    m,
                    ei(v.cy + v.y11, v.cx + v.x11),
                    ei(_.cy + _.y11, _.cx + _.x11),
                    !k,
                  ),
                  l.arc(_.cx, _.cy, O, ei(_.y11, _.x11), ei(_.y01, _.x01), !k)))
            : (l.moveTo(B, M), l.arc(0, 0, m, T, C, !k))
          : l.moveTo(B, M),
          !(p > Un) || !(D > Un)
            ? l.lineTo(I, V)
            : S > Un
              ? ((v = D2(I, V, $, q, p, -S, k)),
                (_ = D2(B, M, tt, ht, p, -S, k)),
                l.lineTo(v.cx + v.x01, v.cy + v.y01),
                S < F
                  ? l.arc(v.cx, v.cy, S, ei(v.y01, v.x01), ei(_.y01, _.x01), !k)
                  : (l.arc(
                      v.cx,
                      v.cy,
                      S,
                      ei(v.y01, v.x01),
                      ei(v.y11, v.x11),
                      !k,
                    ),
                    l.arc(
                      0,
                      0,
                      p,
                      ei(v.cy + v.y11, v.cx + v.x11),
                      ei(_.cy + _.y11, _.cx + _.x11),
                      k,
                    ),
                    l.arc(
                      _.cx,
                      _.cy,
                      S,
                      ei(_.y11, _.x11),
                      ei(_.y01, _.x01),
                      !k,
                    )))
              : l.arc(0, 0, p, w, L, k));
      }
      if ((l.closePath(), f)) return ((l = null), f + "" || null);
    }
    return (
      a(h, "arc"),
      (h.centroid = function () {
        var f = (+e.apply(this, arguments) + +t.apply(this, arguments)) / 2,
          d =
            (+i.apply(this, arguments) + +s.apply(this, arguments)) / 2 -
            Of / 2;
        return [uc(d) * f, Ia(d) * f];
      }),
      (h.innerRadius = function (f) {
        return arguments.length
          ? ((e = typeof f == "function" ? f : qr(+f)), h)
          : e;
      }),
      (h.outerRadius = function (f) {
        return arguments.length
          ? ((t = typeof f == "function" ? f : qr(+f)), h)
          : t;
      }),
      (h.cornerRadius = function (f) {
        return arguments.length
          ? ((r = typeof f == "function" ? f : qr(+f)), h)
          : r;
      }),
      (h.padRadius = function (f) {
        return arguments.length
          ? ((n = f == null ? null : typeof f == "function" ? f : qr(+f)), h)
          : n;
      }),
      (h.startAngle = function (f) {
        return arguments.length
          ? ((i = typeof f == "function" ? f : qr(+f)), h)
          : i;
      }),
      (h.endAngle = function (f) {
        return arguments.length
          ? ((s = typeof f == "function" ? f : qr(+f)), h)
          : s;
      }),
      (h.padAngle = function (f) {
        return arguments.length
          ? ((o = typeof f == "function" ? f : qr(+f)), h)
          : o;
      }),
      (h.context = function (f) {
        return arguments.length ? ((l = f ?? null), h) : l;
      }),
      h
    );
  }
  var rB = x(() => {
    "use strict";
    E2();
    L2();
    B3();
    a(emt, "arcInnerRadius");
    a(rmt, "arcOuterRadius");
    a(nmt, "arcStartAngle");
    a(imt, "arcEndAngle");
    a(smt, "arcPadAngle");
    a(amt, "intersect");
    a(D2, "cornerTangents");
    a(Ma, "default");
  });
  function jg(e) {
    return typeof e == "object" && "length" in e ? e : Array.from(e);
  }
  var tQt,
    F3 = x(() => {
      "use strict";
      tQt = Array.prototype.slice;
      a(jg, "default");
    });
  function nB(e) {
    this._context = e;
  }
  function hl(e) {
    return new nB(e);
  }
  var $3 = x(() => {
    "use strict";
    a(nB, "Linear");
    nB.prototype = {
      areaStart: a(function () {
        this._line = 0;
      }, "areaStart"),
      areaEnd: a(function () {
        this._line = NaN;
      }, "areaEnd"),
      lineStart: a(function () {
        this._point = 0;
      }, "lineStart"),
      lineEnd: a(function () {
        ((this._line || (this._line !== 0 && this._point === 1)) &&
          this._context.closePath(),
          (this._line = 1 - this._line));
      }, "lineEnd"),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ((this._point = 1),
              this._line
                ? this._context.lineTo(e, t)
                : this._context.moveTo(e, t));
            break;
          case 1:
            this._point = 2;
          default:
            this._context.lineTo(e, t);
            break;
        }
      }, "point"),
    };
    a(hl, "default");
  });
  function iB(e) {
    return e[0];
  }
  function sB(e) {
    return e[1];
  }
  var aB = x(() => {
    "use strict";
    a(iB, "x");
    a(sB, "y");
  });
  function Oa(e, t) {
    var r = qr(!0),
      n = null,
      i = hl,
      s = null,
      o = R2(l);
    ((e = typeof e == "function" ? e : e === void 0 ? iB : qr(e)),
      (t = typeof t == "function" ? t : t === void 0 ? sB : qr(t)));
    function l(u) {
      var h,
        f = (u = jg(u)).length,
        d,
        p = !1,
        m;
      for (n == null && (s = i((m = o()))), h = 0; h <= f; ++h)
        (!(h < f && r((d = u[h]), h, u)) === p &&
          ((p = !p) ? s.lineStart() : s.lineEnd()),
          p && s.point(+e(d, h, u), +t(d, h, u)));
      if (m) return ((s = null), m + "" || null);
    }
    return (
      a(l, "line"),
      (l.x = function (u) {
        return arguments.length
          ? ((e = typeof u == "function" ? u : qr(+u)), l)
          : e;
      }),
      (l.y = function (u) {
        return arguments.length
          ? ((t = typeof u == "function" ? u : qr(+u)), l)
          : t;
      }),
      (l.defined = function (u) {
        return arguments.length
          ? ((r = typeof u == "function" ? u : qr(!!u)), l)
          : r;
      }),
      (l.curve = function (u) {
        return arguments.length ? ((i = u), n != null && (s = i(n)), l) : i;
      }),
      (l.context = function (u) {
        return arguments.length
          ? (u == null ? (n = s = null) : (s = i((n = u))), l)
          : n;
      }),
      l
    );
  }
  var oB = x(() => {
    "use strict";
    F3();
    E2();
    $3();
    B3();
    aB();
    a(Oa, "default");
  });
  function G3(e, t) {
    return t < e ? -1 : t > e ? 1 : t >= e ? 0 : NaN;
  }
  var lB = x(() => {
    "use strict";
    a(G3, "default");
  });
  function V3(e) {
    return e;
  }
  var cB = x(() => {
    "use strict";
    a(V3, "default");
  });
  function N2() {
    var e = V3,
      t = G3,
      r = null,
      n = qr(0),
      i = qr(Pf),
      s = qr(0);
    function o(l) {
      var u,
        h = (l = jg(l)).length,
        f,
        d,
        p = 0,
        m = new Array(h),
        g = new Array(h),
        y = +n.apply(this, arguments),
        b = Math.min(Pf, Math.max(-Pf, i.apply(this, arguments) - y)),
        k,
        T = Math.min(Math.abs(b) / h, s.apply(this, arguments)),
        C = T * (b < 0 ? -1 : 1),
        L;
      for (u = 0; u < h; ++u)
        (L = g[(m[u] = u)] = +e(l[u], u, l)) > 0 && (p += L);
      for (
        t != null
          ? m.sort(function (w, D) {
              return t(g[w], g[D]);
            })
          : r != null &&
            m.sort(function (w, D) {
              return r(l[w], l[D]);
            }),
          u = 0,
          d = p ? (b - h * C) / p : 0;
        u < h;
        ++u, y = k
      )
        ((f = m[u]),
          (L = g[f]),
          (k = y + (L > 0 ? L * d : 0) + C),
          (g[f] = {
            data: l[f],
            index: u,
            value: L,
            startAngle: y,
            endAngle: k,
            padAngle: T,
          }));
      return g;
    }
    return (
      a(o, "pie"),
      (o.value = function (l) {
        return arguments.length
          ? ((e = typeof l == "function" ? l : qr(+l)), o)
          : e;
      }),
      (o.sortValues = function (l) {
        return arguments.length ? ((t = l), (r = null), o) : t;
      }),
      (o.sort = function (l) {
        return arguments.length ? ((r = l), (t = null), o) : r;
      }),
      (o.startAngle = function (l) {
        return arguments.length
          ? ((n = typeof l == "function" ? l : qr(+l)), o)
          : n;
      }),
      (o.endAngle = function (l) {
        return arguments.length
          ? ((i = typeof l == "function" ? l : qr(+l)), o)
          : i;
      }),
      (o.padAngle = function (l) {
        return arguments.length
          ? ((s = typeof l == "function" ? l : qr(+l)), o)
          : s;
      }),
      o
    );
  }
  var uB = x(() => {
    "use strict";
    F3();
    E2();
    lB();
    cB();
    L2();
    a(N2, "default");
  });
  function qg(e) {
    return new I2(e, !0);
  }
  function Hg(e) {
    return new I2(e, !1);
  }
  var I2,
    hB = x(() => {
      "use strict";
      I2 = class {
        static {
          a(this, "Bump");
        }
        constructor(t, r) {
          ((this._context = t), (this._x = r));
        }
        areaStart() {
          this._line = 0;
        }
        areaEnd() {
          this._line = NaN;
        }
        lineStart() {
          this._point = 0;
        }
        lineEnd() {
          ((this._line || (this._line !== 0 && this._point === 1)) &&
            this._context.closePath(),
            (this._line = 1 - this._line));
        }
        point(t, r) {
          switch (((t = +t), (r = +r), this._point)) {
            case 0: {
              ((this._point = 1),
                this._line
                  ? this._context.lineTo(t, r)
                  : this._context.moveTo(t, r));
              break;
            }
            case 1:
              this._point = 2;
            default: {
              this._x
                ? this._context.bezierCurveTo(
                    (this._x0 = (this._x0 + t) / 2),
                    this._y0,
                    this._x0,
                    r,
                    t,
                    r,
                  )
                : this._context.bezierCurveTo(
                    this._x0,
                    (this._y0 = (this._y0 + r) / 2),
                    t,
                    this._y0,
                    t,
                    r,
                  );
              break;
            }
          }
          ((this._x0 = t), (this._y0 = r));
        }
      };
      a(qg, "bumpX");
      a(Hg, "bumpY");
    });
  function vs() {}
  var Yg = x(() => {
    "use strict";
    a(vs, "default");
  });
  function Bf(e, t, r) {
    e._context.bezierCurveTo(
      (2 * e._x0 + e._x1) / 3,
      (2 * e._y0 + e._y1) / 3,
      (e._x0 + 2 * e._x1) / 3,
      (e._y0 + 2 * e._y1) / 3,
      (e._x0 + 4 * e._x1 + t) / 6,
      (e._y0 + 4 * e._y1 + r) / 6,
    );
  }
  function Xg(e) {
    this._context = e;
  }
  function Ys(e) {
    return new Xg(e);
  }
  var Kg = x(() => {
    "use strict";
    a(Bf, "point");
    a(Xg, "Basis");
    Xg.prototype = {
      areaStart: a(function () {
        this._line = 0;
      }, "areaStart"),
      areaEnd: a(function () {
        this._line = NaN;
      }, "areaEnd"),
      lineStart: a(function () {
        ((this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0));
      }, "lineStart"),
      lineEnd: a(function () {
        switch (this._point) {
          case 3:
            Bf(this, this._x1, this._y1);
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
        }
        ((this._line || (this._line !== 0 && this._point === 1)) &&
          this._context.closePath(),
          (this._line = 1 - this._line));
      }, "lineEnd"),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ((this._point = 1),
              this._line
                ? this._context.lineTo(e, t)
                : this._context.moveTo(e, t));
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            ((this._point = 3),
              this._context.lineTo(
                (5 * this._x0 + this._x1) / 6,
                (5 * this._y0 + this._y1) / 6,
              ));
          default:
            Bf(this, e, t);
            break;
        }
        ((this._x0 = this._x1),
          (this._x1 = e),
          (this._y0 = this._y1),
          (this._y1 = t));
      }, "point"),
    };
    a(Ys, "default");
  });
  function fB(e) {
    this._context = e;
  }
  function M2(e) {
    return new fB(e);
  }
  var dB = x(() => {
    "use strict";
    Yg();
    Kg();
    a(fB, "BasisClosed");
    fB.prototype = {
      areaStart: vs,
      areaEnd: vs,
      lineStart: a(function () {
        ((this._x0 =
          this._x1 =
          this._x2 =
          this._x3 =
          this._x4 =
          this._y0 =
          this._y1 =
          this._y2 =
          this._y3 =
          this._y4 =
            NaN),
          (this._point = 0));
      }, "lineStart"),
      lineEnd: a(function () {
        switch (this._point) {
          case 1: {
            (this._context.moveTo(this._x2, this._y2),
              this._context.closePath());
            break;
          }
          case 2: {
            (this._context.moveTo(
              (this._x2 + 2 * this._x3) / 3,
              (this._y2 + 2 * this._y3) / 3,
            ),
              this._context.lineTo(
                (this._x3 + 2 * this._x2) / 3,
                (this._y3 + 2 * this._y2) / 3,
              ),
              this._context.closePath());
            break;
          }
          case 3: {
            (this.point(this._x2, this._y2),
              this.point(this._x3, this._y3),
              this.point(this._x4, this._y4));
            break;
          }
        }
      }, "lineEnd"),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ((this._point = 1), (this._x2 = e), (this._y2 = t));
            break;
          case 1:
            ((this._point = 2), (this._x3 = e), (this._y3 = t));
            break;
          case 2:
            ((this._point = 3),
              (this._x4 = e),
              (this._y4 = t),
              this._context.moveTo(
                (this._x0 + 4 * this._x1 + e) / 6,
                (this._y0 + 4 * this._y1 + t) / 6,
              ));
            break;
          default:
            Bf(this, e, t);
            break;
        }
        ((this._x0 = this._x1),
          (this._x1 = e),
          (this._y0 = this._y1),
          (this._y1 = t));
      }, "point"),
    };
    a(M2, "default");
  });
  function pB(e) {
    this._context = e;
  }
  function O2(e) {
    return new pB(e);
  }
  var mB = x(() => {
    "use strict";
    Kg();
    a(pB, "BasisOpen");
    pB.prototype = {
      areaStart: a(function () {
        this._line = 0;
      }, "areaStart"),
      areaEnd: a(function () {
        this._line = NaN;
      }, "areaEnd"),
      lineStart: a(function () {
        ((this._x0 = this._x1 = this._y0 = this._y1 = NaN), (this._point = 0));
      }, "lineStart"),
      lineEnd: a(function () {
        ((this._line || (this._line !== 0 && this._point === 3)) &&
          this._context.closePath(),
          (this._line = 1 - this._line));
      }, "lineEnd"),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            this._point = 1;
            break;
          case 1:
            this._point = 2;
            break;
          case 2:
            this._point = 3;
            var r = (this._x0 + 4 * this._x1 + e) / 6,
              n = (this._y0 + 4 * this._y1 + t) / 6;
            this._line
              ? this._context.lineTo(r, n)
              : this._context.moveTo(r, n);
            break;
          case 3:
            this._point = 4;
          default:
            Bf(this, e, t);
            break;
        }
        ((this._x0 = this._x1),
          (this._x1 = e),
          (this._y0 = this._y1),
          (this._y1 = t));
      }, "point"),
    };
    a(O2, "default");
  });
  function gB(e, t) {
    ((this._basis = new Xg(e)), (this._beta = t));
  }
  var z3,
    yB = x(() => {
      "use strict";
      Kg();
      a(gB, "Bundle");
      gB.prototype = {
        lineStart: a(function () {
          ((this._x = []), (this._y = []), this._basis.lineStart());
        }, "lineStart"),
        lineEnd: a(function () {
          var e = this._x,
            t = this._y,
            r = e.length - 1;
          if (r > 0)
            for (
              var n = e[0], i = t[0], s = e[r] - n, o = t[r] - i, l = -1, u;
              ++l <= r;

            )
              ((u = l / r),
                this._basis.point(
                  this._beta * e[l] + (1 - this._beta) * (n + u * s),
                  this._beta * t[l] + (1 - this._beta) * (i + u * o),
                ));
          ((this._x = this._y = null), this._basis.lineEnd());
        }, "lineEnd"),
        point: a(function (e, t) {
          (this._x.push(+e), this._y.push(+t));
        }, "point"),
      };
      z3 = a(function e(t) {
        function r(n) {
          return t === 1 ? new Xg(n) : new gB(n, t);
        }
        return (
          a(r, "bundle"),
          (r.beta = function (n) {
            return e(+n);
          }),
          r
        );
      }, "custom")(0.85);
    });
  function Ff(e, t, r) {
    e._context.bezierCurveTo(
      e._x1 + e._k * (e._x2 - e._x0),
      e._y1 + e._k * (e._y2 - e._y0),
      e._x2 + e._k * (e._x1 - t),
      e._y2 + e._k * (e._y1 - r),
      e._x2,
      e._y2,
    );
  }
  function P2(e, t) {
    ((this._context = e), (this._k = (1 - t) / 6));
  }
  var Qg,
    Zg = x(() => {
      "use strict";
      a(Ff, "point");
      a(P2, "Cardinal");
      P2.prototype = {
        areaStart: a(function () {
          this._line = 0;
        }, "areaStart"),
        areaEnd: a(function () {
          this._line = NaN;
        }, "areaEnd"),
        lineStart: a(function () {
          ((this._x0 =
            this._x1 =
            this._x2 =
            this._y0 =
            this._y1 =
            this._y2 =
              NaN),
            (this._point = 0));
        }, "lineStart"),
        lineEnd: a(function () {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              Ff(this, this._x1, this._y1);
              break;
          }
          ((this._line || (this._line !== 0 && this._point === 1)) &&
            this._context.closePath(),
            (this._line = 1 - this._line));
        }, "lineEnd"),
        point: a(function (e, t) {
          switch (((e = +e), (t = +t), this._point)) {
            case 0:
              ((this._point = 1),
                this._line
                  ? this._context.lineTo(e, t)
                  : this._context.moveTo(e, t));
              break;
            case 1:
              ((this._point = 2), (this._x1 = e), (this._y1 = t));
              break;
            case 2:
              this._point = 3;
            default:
              Ff(this, e, t);
              break;
          }
          ((this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t));
        }, "point"),
      };
      Qg = a(function e(t) {
        function r(n) {
          return new P2(n, t);
        }
        return (
          a(r, "cardinal"),
          (r.tension = function (n) {
            return e(+n);
          }),
          r
        );
      }, "custom")(0);
    });
  function B2(e, t) {
    ((this._context = e), (this._k = (1 - t) / 6));
  }
  var W3,
    U3 = x(() => {
      "use strict";
      Yg();
      Zg();
      a(B2, "CardinalClosed");
      B2.prototype = {
        areaStart: vs,
        areaEnd: vs,
        lineStart: a(function () {
          ((this._x0 =
            this._x1 =
            this._x2 =
            this._x3 =
            this._x4 =
            this._x5 =
            this._y0 =
            this._y1 =
            this._y2 =
            this._y3 =
            this._y4 =
            this._y5 =
              NaN),
            (this._point = 0));
        }, "lineStart"),
        lineEnd: a(function () {
          switch (this._point) {
            case 1: {
              (this._context.moveTo(this._x3, this._y3),
                this._context.closePath());
              break;
            }
            case 2: {
              (this._context.lineTo(this._x3, this._y3),
                this._context.closePath());
              break;
            }
            case 3: {
              (this.point(this._x3, this._y3),
                this.point(this._x4, this._y4),
                this.point(this._x5, this._y5));
              break;
            }
          }
        }, "lineEnd"),
        point: a(function (e, t) {
          switch (((e = +e), (t = +t), this._point)) {
            case 0:
              ((this._point = 1), (this._x3 = e), (this._y3 = t));
              break;
            case 1:
              ((this._point = 2),
                this._context.moveTo((this._x4 = e), (this._y4 = t)));
              break;
            case 2:
              ((this._point = 3), (this._x5 = e), (this._y5 = t));
              break;
            default:
              Ff(this, e, t);
              break;
          }
          ((this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t));
        }, "point"),
      };
      W3 = a(function e(t) {
        function r(n) {
          return new B2(n, t);
        }
        return (
          a(r, "cardinal"),
          (r.tension = function (n) {
            return e(+n);
          }),
          r
        );
      }, "custom")(0);
    });
  function F2(e, t) {
    ((this._context = e), (this._k = (1 - t) / 6));
  }
  var j3,
    q3 = x(() => {
      "use strict";
      Zg();
      a(F2, "CardinalOpen");
      F2.prototype = {
        areaStart: a(function () {
          this._line = 0;
        }, "areaStart"),
        areaEnd: a(function () {
          this._line = NaN;
        }, "areaEnd"),
        lineStart: a(function () {
          ((this._x0 =
            this._x1 =
            this._x2 =
            this._y0 =
            this._y1 =
            this._y2 =
              NaN),
            (this._point = 0));
        }, "lineStart"),
        lineEnd: a(function () {
          ((this._line || (this._line !== 0 && this._point === 3)) &&
            this._context.closePath(),
            (this._line = 1 - this._line));
        }, "lineEnd"),
        point: a(function (e, t) {
          switch (((e = +e), (t = +t), this._point)) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              ((this._point = 3),
                this._line
                  ? this._context.lineTo(this._x2, this._y2)
                  : this._context.moveTo(this._x2, this._y2));
              break;
            case 3:
              this._point = 4;
            default:
              Ff(this, e, t);
              break;
          }
          ((this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t));
        }, "point"),
      };
      j3 = a(function e(t) {
        function r(n) {
          return new F2(n, t);
        }
        return (
          a(r, "cardinal"),
          (r.tension = function (n) {
            return e(+n);
          }),
          r
        );
      }, "custom")(0);
    });
  function Jg(e, t, r) {
    var n = e._x1,
      i = e._y1,
      s = e._x2,
      o = e._y2;
    if (e._l01_a > Un) {
      var l = 2 * e._l01_2a + 3 * e._l01_a * e._l12_a + e._l12_2a,
        u = 3 * e._l01_a * (e._l01_a + e._l12_a);
      ((n = (n * l - e._x0 * e._l12_2a + e._x2 * e._l01_2a) / u),
        (i = (i * l - e._y0 * e._l12_2a + e._y2 * e._l01_2a) / u));
    }
    if (e._l23_a > Un) {
      var h = 2 * e._l23_2a + 3 * e._l23_a * e._l12_a + e._l12_2a,
        f = 3 * e._l23_a * (e._l23_a + e._l12_a);
      ((s = (s * h + e._x1 * e._l23_2a - t * e._l12_2a) / f),
        (o = (o * h + e._y1 * e._l23_2a - r * e._l12_2a) / f));
    }
    e._context.bezierCurveTo(n, i, s, o, e._x2, e._y2);
  }
  function xB(e, t) {
    ((this._context = e), (this._alpha = t));
  }
  var t0,
    $2 = x(() => {
      "use strict";
      L2();
      Zg();
      a(Jg, "point");
      a(xB, "CatmullRom");
      xB.prototype = {
        areaStart: a(function () {
          this._line = 0;
        }, "areaStart"),
        areaEnd: a(function () {
          this._line = NaN;
        }, "areaEnd"),
        lineStart: a(function () {
          ((this._x0 =
            this._x1 =
            this._x2 =
            this._y0 =
            this._y1 =
            this._y2 =
              NaN),
            (this._l01_a =
              this._l12_a =
              this._l23_a =
              this._l01_2a =
              this._l12_2a =
              this._l23_2a =
              this._point =
                0));
        }, "lineStart"),
        lineEnd: a(function () {
          switch (this._point) {
            case 2:
              this._context.lineTo(this._x2, this._y2);
              break;
            case 3:
              this.point(this._x2, this._y2);
              break;
          }
          ((this._line || (this._line !== 0 && this._point === 1)) &&
            this._context.closePath(),
            (this._line = 1 - this._line));
        }, "lineEnd"),
        point: a(function (e, t) {
          if (((e = +e), (t = +t), this._point)) {
            var r = this._x2 - e,
              n = this._y2 - t;
            this._l23_a = Math.sqrt(
              (this._l23_2a = Math.pow(r * r + n * n, this._alpha)),
            );
          }
          switch (this._point) {
            case 0:
              ((this._point = 1),
                this._line
                  ? this._context.lineTo(e, t)
                  : this._context.moveTo(e, t));
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              this._point = 3;
            default:
              Jg(this, e, t);
              break;
          }
          ((this._l01_a = this._l12_a),
            (this._l12_a = this._l23_a),
            (this._l01_2a = this._l12_2a),
            (this._l12_2a = this._l23_2a),
            (this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t));
        }, "point"),
      };
      t0 = a(function e(t) {
        function r(n) {
          return t ? new xB(n, t) : new P2(n, 0);
        }
        return (
          a(r, "catmullRom"),
          (r.alpha = function (n) {
            return e(+n);
          }),
          r
        );
      }, "custom")(0.5);
    });
  function bB(e, t) {
    ((this._context = e), (this._alpha = t));
  }
  var H3,
    kB = x(() => {
      "use strict";
      U3();
      Yg();
      $2();
      a(bB, "CatmullRomClosed");
      bB.prototype = {
        areaStart: vs,
        areaEnd: vs,
        lineStart: a(function () {
          ((this._x0 =
            this._x1 =
            this._x2 =
            this._x3 =
            this._x4 =
            this._x5 =
            this._y0 =
            this._y1 =
            this._y2 =
            this._y3 =
            this._y4 =
            this._y5 =
              NaN),
            (this._l01_a =
              this._l12_a =
              this._l23_a =
              this._l01_2a =
              this._l12_2a =
              this._l23_2a =
              this._point =
                0));
        }, "lineStart"),
        lineEnd: a(function () {
          switch (this._point) {
            case 1: {
              (this._context.moveTo(this._x3, this._y3),
                this._context.closePath());
              break;
            }
            case 2: {
              (this._context.lineTo(this._x3, this._y3),
                this._context.closePath());
              break;
            }
            case 3: {
              (this.point(this._x3, this._y3),
                this.point(this._x4, this._y4),
                this.point(this._x5, this._y5));
              break;
            }
          }
        }, "lineEnd"),
        point: a(function (e, t) {
          if (((e = +e), (t = +t), this._point)) {
            var r = this._x2 - e,
              n = this._y2 - t;
            this._l23_a = Math.sqrt(
              (this._l23_2a = Math.pow(r * r + n * n, this._alpha)),
            );
          }
          switch (this._point) {
            case 0:
              ((this._point = 1), (this._x3 = e), (this._y3 = t));
              break;
            case 1:
              ((this._point = 2),
                this._context.moveTo((this._x4 = e), (this._y4 = t)));
              break;
            case 2:
              ((this._point = 3), (this._x5 = e), (this._y5 = t));
              break;
            default:
              Jg(this, e, t);
              break;
          }
          ((this._l01_a = this._l12_a),
            (this._l12_a = this._l23_a),
            (this._l01_2a = this._l12_2a),
            (this._l12_2a = this._l23_2a),
            (this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t));
        }, "point"),
      };
      H3 = a(function e(t) {
        function r(n) {
          return t ? new bB(n, t) : new B2(n, 0);
        }
        return (
          a(r, "catmullRom"),
          (r.alpha = function (n) {
            return e(+n);
          }),
          r
        );
      }, "custom")(0.5);
    });
  function TB(e, t) {
    ((this._context = e), (this._alpha = t));
  }
  var Y3,
    SB = x(() => {
      "use strict";
      q3();
      $2();
      a(TB, "CatmullRomOpen");
      TB.prototype = {
        areaStart: a(function () {
          this._line = 0;
        }, "areaStart"),
        areaEnd: a(function () {
          this._line = NaN;
        }, "areaEnd"),
        lineStart: a(function () {
          ((this._x0 =
            this._x1 =
            this._x2 =
            this._y0 =
            this._y1 =
            this._y2 =
              NaN),
            (this._l01_a =
              this._l12_a =
              this._l23_a =
              this._l01_2a =
              this._l12_2a =
              this._l23_2a =
              this._point =
                0));
        }, "lineStart"),
        lineEnd: a(function () {
          ((this._line || (this._line !== 0 && this._point === 3)) &&
            this._context.closePath(),
            (this._line = 1 - this._line));
        }, "lineEnd"),
        point: a(function (e, t) {
          if (((e = +e), (t = +t), this._point)) {
            var r = this._x2 - e,
              n = this._y2 - t;
            this._l23_a = Math.sqrt(
              (this._l23_2a = Math.pow(r * r + n * n, this._alpha)),
            );
          }
          switch (this._point) {
            case 0:
              this._point = 1;
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              ((this._point = 3),
                this._line
                  ? this._context.lineTo(this._x2, this._y2)
                  : this._context.moveTo(this._x2, this._y2));
              break;
            case 3:
              this._point = 4;
            default:
              Jg(this, e, t);
              break;
          }
          ((this._l01_a = this._l12_a),
            (this._l12_a = this._l23_a),
            (this._l01_2a = this._l12_2a),
            (this._l12_2a = this._l23_2a),
            (this._x0 = this._x1),
            (this._x1 = this._x2),
            (this._x2 = e),
            (this._y0 = this._y1),
            (this._y1 = this._y2),
            (this._y2 = t));
        }, "point"),
      };
      Y3 = a(function e(t) {
        function r(n) {
          return t ? new TB(n, t) : new F2(n, 0);
        }
        return (
          a(r, "catmullRom"),
          (r.alpha = function (n) {
            return e(+n);
          }),
          r
        );
      }, "custom")(0.5);
    });
  function _B(e) {
    this._context = e;
  }
  function G2(e) {
    return new _B(e);
  }
  var CB = x(() => {
    "use strict";
    Yg();
    a(_B, "LinearClosed");
    _B.prototype = {
      areaStart: vs,
      areaEnd: vs,
      lineStart: a(function () {
        this._point = 0;
      }, "lineStart"),
      lineEnd: a(function () {
        this._point && this._context.closePath();
      }, "lineEnd"),
      point: a(function (e, t) {
        ((e = +e),
          (t = +t),
          this._point
            ? this._context.lineTo(e, t)
            : ((this._point = 1), this._context.moveTo(e, t)));
      }, "point"),
    };
    a(G2, "default");
  });
  function wB(e) {
    return e < 0 ? -1 : 1;
  }
  function vB(e, t, r) {
    var n = e._x1 - e._x0,
      i = t - e._x1,
      s = (e._y1 - e._y0) / (n || (i < 0 && -0)),
      o = (r - e._y1) / (i || (n < 0 && -0)),
      l = (s * i + o * n) / (n + i);
    return (
      (wB(s) + wB(o)) * Math.min(Math.abs(s), Math.abs(o), 0.5 * Math.abs(l)) ||
      0
    );
  }
  function EB(e, t) {
    var r = e._x1 - e._x0;
    return r ? ((3 * (e._y1 - e._y0)) / r - t) / 2 : t;
  }
  function X3(e, t, r) {
    var n = e._x0,
      i = e._y0,
      s = e._x1,
      o = e._y1,
      l = (s - n) / 3;
    e._context.bezierCurveTo(n + l, i + l * t, s - l, o - l * r, s, o);
  }
  function V2(e) {
    this._context = e;
  }
  function AB(e) {
    this._context = new LB(e);
  }
  function LB(e) {
    this._context = e;
  }
  function e0(e) {
    return new V2(e);
  }
  function r0(e) {
    return new AB(e);
  }
  var RB = x(() => {
    "use strict";
    a(wB, "sign");
    a(vB, "slope3");
    a(EB, "slope2");
    a(X3, "point");
    a(V2, "MonotoneX");
    V2.prototype = {
      areaStart: a(function () {
        this._line = 0;
      }, "areaStart"),
      areaEnd: a(function () {
        this._line = NaN;
      }, "areaEnd"),
      lineStart: a(function () {
        ((this._x0 = this._x1 = this._y0 = this._y1 = this._t0 = NaN),
          (this._point = 0));
      }, "lineStart"),
      lineEnd: a(function () {
        switch (this._point) {
          case 2:
            this._context.lineTo(this._x1, this._y1);
            break;
          case 3:
            X3(this, this._t0, EB(this, this._t0));
            break;
        }
        ((this._line || (this._line !== 0 && this._point === 1)) &&
          this._context.closePath(),
          (this._line = 1 - this._line));
      }, "lineEnd"),
      point: a(function (e, t) {
        var r = NaN;
        if (((e = +e), (t = +t), !(e === this._x1 && t === this._y1))) {
          switch (this._point) {
            case 0:
              ((this._point = 1),
                this._line
                  ? this._context.lineTo(e, t)
                  : this._context.moveTo(e, t));
              break;
            case 1:
              this._point = 2;
              break;
            case 2:
              ((this._point = 3), X3(this, EB(this, (r = vB(this, e, t))), r));
              break;
            default:
              X3(this, this._t0, (r = vB(this, e, t)));
              break;
          }
          ((this._x0 = this._x1),
            (this._x1 = e),
            (this._y0 = this._y1),
            (this._y1 = t),
            (this._t0 = r));
        }
      }, "point"),
    };
    a(AB, "MonotoneY");
    (AB.prototype = Object.create(V2.prototype)).point = function (e, t) {
      V2.prototype.point.call(this, t, e);
    };
    a(LB, "ReflectContext");
    LB.prototype = {
      moveTo: a(function (e, t) {
        this._context.moveTo(t, e);
      }, "moveTo"),
      closePath: a(function () {
        this._context.closePath();
      }, "closePath"),
      lineTo: a(function (e, t) {
        this._context.lineTo(t, e);
      }, "lineTo"),
      bezierCurveTo: a(function (e, t, r, n, i, s) {
        this._context.bezierCurveTo(t, e, n, r, s, i);
      }, "bezierCurveTo"),
    };
    a(e0, "monotoneX");
    a(r0, "monotoneY");
  });
  function NB(e) {
    this._context = e;
  }
  function DB(e) {
    var t,
      r = e.length - 1,
      n,
      i = new Array(r),
      s = new Array(r),
      o = new Array(r);
    for (i[0] = 0, s[0] = 2, o[0] = e[0] + 2 * e[1], t = 1; t < r - 1; ++t)
      ((i[t] = 1), (s[t] = 4), (o[t] = 4 * e[t] + 2 * e[t + 1]));
    for (
      i[r - 1] = 2, s[r - 1] = 7, o[r - 1] = 8 * e[r - 1] + e[r], t = 1;
      t < r;
      ++t
    )
      ((n = i[t] / s[t - 1]), (s[t] -= n), (o[t] -= n * o[t - 1]));
    for (i[r - 1] = o[r - 1] / s[r - 1], t = r - 2; t >= 0; --t)
      i[t] = (o[t] - i[t + 1]) / s[t];
    for (s[r - 1] = (e[r] + i[r - 1]) / 2, t = 0; t < r - 1; ++t)
      s[t] = 2 * e[t + 1] - i[t + 1];
    return [i, s];
  }
  function $f(e) {
    return new NB(e);
  }
  var IB = x(() => {
    "use strict";
    a(NB, "Natural");
    NB.prototype = {
      areaStart: a(function () {
        this._line = 0;
      }, "areaStart"),
      areaEnd: a(function () {
        this._line = NaN;
      }, "areaEnd"),
      lineStart: a(function () {
        ((this._x = []), (this._y = []));
      }, "lineStart"),
      lineEnd: a(function () {
        var e = this._x,
          t = this._y,
          r = e.length;
        if (r)
          if (
            (this._line
              ? this._context.lineTo(e[0], t[0])
              : this._context.moveTo(e[0], t[0]),
            r === 2)
          )
            this._context.lineTo(e[1], t[1]);
          else
            for (var n = DB(e), i = DB(t), s = 0, o = 1; o < r; ++s, ++o)
              this._context.bezierCurveTo(
                n[0][s],
                i[0][s],
                n[1][s],
                i[1][s],
                e[o],
                t[o],
              );
        ((this._line || (this._line !== 0 && r === 1)) &&
          this._context.closePath(),
          (this._line = 1 - this._line),
          (this._x = this._y = null));
      }, "lineEnd"),
      point: a(function (e, t) {
        (this._x.push(+e), this._y.push(+t));
      }, "point"),
    };
    a(DB, "controlPoints");
    a($f, "default");
  });
  function z2(e, t) {
    ((this._context = e), (this._t = t));
  }
  function Gf(e) {
    return new z2(e, 0.5);
  }
  function n0(e) {
    return new z2(e, 0);
  }
  function i0(e) {
    return new z2(e, 1);
  }
  var MB = x(() => {
    "use strict";
    a(z2, "Step");
    z2.prototype = {
      areaStart: a(function () {
        this._line = 0;
      }, "areaStart"),
      areaEnd: a(function () {
        this._line = NaN;
      }, "areaEnd"),
      lineStart: a(function () {
        ((this._x = this._y = NaN), (this._point = 0));
      }, "lineStart"),
      lineEnd: a(function () {
        (0 < this._t &&
          this._t < 1 &&
          this._point === 2 &&
          this._context.lineTo(this._x, this._y),
          (this._line || (this._line !== 0 && this._point === 1)) &&
            this._context.closePath(),
          this._line >= 0 &&
            ((this._t = 1 - this._t), (this._line = 1 - this._line)));
      }, "lineEnd"),
      point: a(function (e, t) {
        switch (((e = +e), (t = +t), this._point)) {
          case 0:
            ((this._point = 1),
              this._line
                ? this._context.lineTo(e, t)
                : this._context.moveTo(e, t));
            break;
          case 1:
            this._point = 2;
          default: {
            if (this._t <= 0)
              (this._context.lineTo(this._x, t), this._context.lineTo(e, t));
            else {
              var r = this._x * (1 - this._t) + e * this._t;
              (this._context.lineTo(r, this._y), this._context.lineTo(r, t));
            }
            break;
          }
        }
        ((this._x = e), (this._y = t));
      }, "point"),
    };
    a(Gf, "default");
    a(n0, "stepBefore");
    a(i0, "stepAfter");
  });
  var OB = x(() => {
    "use strict";
    rB();
    oB();
    uB();
    dB();
    mB();
    Kg();
    hB();
    yB();
    U3();
    q3();
    Zg();
    kB();
    SB();
    $2();
    CB();
    $3();
    RB();
    IB();
    MB();
  });
  var PB = x(() => {
    "use strict";
  });
  var BB = x(() => {
    "use strict";
  });
  function hc(e, t, r) {
    ((this.k = e), (this.x = t), (this.y = r));
  }
  function Q3(e) {
    for (; !e.__zoom; ) if (!(e = e.parentNode)) return K3;
    return e.__zoom;
  }
  var K3,
    Z3 = x(() => {
      "use strict";
      a(hc, "Transform");
      hc.prototype = {
        constructor: hc,
        scale: a(function (e) {
          return e === 1 ? this : new hc(this.k * e, this.x, this.y);
        }, "scale"),
        translate: a(function (e, t) {
          return (e === 0) & (t === 0)
            ? this
            : new hc(this.k, this.x + this.k * e, this.y + this.k * t);
        }, "translate"),
        apply: a(function (e) {
          return [e[0] * this.k + this.x, e[1] * this.k + this.y];
        }, "apply"),
        applyX: a(function (e) {
          return e * this.k + this.x;
        }, "applyX"),
        applyY: a(function (e) {
          return e * this.k + this.y;
        }, "applyY"),
        invert: a(function (e) {
          return [(e[0] - this.x) / this.k, (e[1] - this.y) / this.k];
        }, "invert"),
        invertX: a(function (e) {
          return (e - this.x) / this.k;
        }, "invertX"),
        invertY: a(function (e) {
          return (e - this.y) / this.k;
        }, "invertY"),
        rescaleX: a(function (e) {
          return e
            .copy()
            .domain(e.range().map(this.invertX, this).map(e.invert, e));
        }, "rescaleX"),
        rescaleY: a(function (e) {
          return e
            .copy()
            .domain(e.range().map(this.invertY, this).map(e.invert, e));
        }, "rescaleY"),
        toString: a(function () {
          return (
            "translate(" + this.x + "," + this.y + ") scale(" + this.k + ")"
          );
        }, "toString"),
      };
      K3 = new hc(1, 0, 0);
      Q3.prototype = hc.prototype;
      a(Q3, "transform");
    });
  var FB = x(() => {
    "use strict";
  });
  var $B = x(() => {
    "use strict";
    a2();
    PB();
    BB();
    Z3();
    FB();
  });
  var GB = x(() => {
    "use strict";
    $B();
    Z3();
  });
  var Ge = x(() => {
    "use strict";
    tc();
    Y7();
    dP();
    yP();
    _f();
    xP();
    bP();
    Gw();
    $M();
    kP();
    AE();
    TP();
    _P();
    jE();
    BP();
    o9();
    vf();
    IE();
    l9();
    SP();
    c9();
    K9();
    J9();
    va();
    OB();
    w2();
    N3();
    t2();
    a2();
    GB();
  });
  var VB = to((jn) => {
    "use strict";
    Object.defineProperty(jn, "__esModule", { value: !0 });
    jn.BLANK_URL =
      jn.relativeFirstCharacters =
      jn.whitespaceEscapeCharsRegex =
      jn.urlSchemeRegex =
      jn.ctrlCharactersRegex =
      jn.htmlCtrlEntityRegex =
      jn.htmlEntitiesRegex =
      jn.invalidProtocolRegex =
        void 0;
    jn.invalidProtocolRegex = /^([^\w]*)(javascript|data|vbscript)/im;
    jn.htmlEntitiesRegex = /&#(\w+)(^\w|;)?/g;
    jn.htmlCtrlEntityRegex = /&(newline|tab);/gi;
    jn.ctrlCharactersRegex =
      /[\u0000-\u001F\u007F-\u009F\u2000-\u200D\uFEFF]/gim;
    jn.urlSchemeRegex = /^.+(:|&colon;)/gim;
    jn.whitespaceEscapeCharsRegex = /(\\|%5[cC])((%(6[eE]|72|74))|[nrt])/g;
    jn.relativeFirstCharacters = [".", "/"];
    jn.BLANK_URL = "about:blank";
  });
  var Vf = to((W2) => {
    "use strict";
    Object.defineProperty(W2, "__esModule", { value: !0 });
    W2.sanitizeUrl = void 0;
    var mi = VB();
    function omt(e) {
      return mi.relativeFirstCharacters.indexOf(e[0]) > -1;
    }
    a(omt, "isRelativeUrlWithoutProtocol");
    function lmt(e) {
      var t = e.replace(mi.ctrlCharactersRegex, "");
      return t.replace(mi.htmlEntitiesRegex, function (r, n) {
        return String.fromCharCode(n);
      });
    }
    a(lmt, "decodeHtmlCharacters");
    function cmt(e) {
      return URL.canParse(e);
    }
    a(cmt, "isValidUrl");
    function zB(e) {
      try {
        return decodeURIComponent(e);
      } catch {
        return e;
      }
    }
    a(zB, "decodeURI");
    function umt(e) {
      if (!e) return mi.BLANK_URL;
      var t,
        r = zB(e.trim());
      do
        ((r = lmt(r)
          .replace(mi.htmlCtrlEntityRegex, "")
          .replace(mi.ctrlCharactersRegex, "")
          .replace(mi.whitespaceEscapeCharsRegex, "")
          .trim()),
          (r = zB(r)),
          (t =
            r.match(mi.ctrlCharactersRegex) ||
            r.match(mi.htmlEntitiesRegex) ||
            r.match(mi.htmlCtrlEntityRegex) ||
            r.match(mi.whitespaceEscapeCharsRegex)));
      while (t && t.length > 0);
      var n = r;
      if (!n) return mi.BLANK_URL;
      if (omt(n)) return n;
      var i = n.trimStart(),
        s = i.match(mi.urlSchemeRegex);
      if (!s) return n;
      var o = s[0].toLowerCase().trim();
      if (mi.invalidProtocolRegex.test(o)) return mi.BLANK_URL;
      var l = i.replace(/\\/g, "/");
      if (o === "mailto:" || o.includes("://")) return l;
      if (o === "http:" || o === "https:") {
        if (!cmt(l)) return mi.BLANK_URL;
        var u = new URL(l);
        return (
          (u.protocol = u.protocol.toLowerCase()),
          (u.hostname = u.hostname.toLowerCase()),
          u.toString()
        );
      }
      return l;
    }
    a(umt, "sanitizeUrl");
    W2.sanitizeUrl = umt;
  });
  var J3,
    Vu,
    U2,
    WB,
    j2,
    q2,
    ri,
    s0,
    a0 = x(() => {
      "use strict";
      J3 = Ts(Vf(), 1);
      Be();
      ((Vu = a((e, t) => {
        let r = e.append("rect");
        if (
          (r.attr("x", t.x),
          r.attr("y", t.y),
          r.attr("fill", t.fill),
          r.attr("stroke", t.stroke),
          r.attr("width", t.width),
          r.attr("height", t.height),
          t.name && r.attr("name", t.name),
          t.rx && r.attr("rx", t.rx),
          t.ry && r.attr("ry", t.ry),
          t.attrs !== void 0)
        )
          for (let n in t.attrs) r.attr(n, t.attrs[n]);
        return (t.class && r.attr("class", t.class), r);
      }, "drawRect")),
        (U2 = a((e, t) => {
          let r = {
            x: t.startx,
            y: t.starty,
            width: t.stopx - t.startx,
            height: t.stopy - t.starty,
            fill: t.fill,
            stroke: t.stroke,
            class: "rect",
          };
          Vu(e, r).lower();
        }, "drawBackgroundRect")),
        (WB = a((e, t) => {
          let r = t.text.replace(ff, " "),
            n = e.append("text");
          (n.attr("x", t.x),
            n.attr("y", t.y),
            n.attr("class", "legend"),
            n.style("text-anchor", t.anchor),
            t.class && n.attr("class", t.class));
          let i = n.append("tspan");
          return (i.attr("x", t.x + t.textMargin * 2), i.text(r), n);
        }, "drawText")),
        (j2 = a((e, t, r, n) => {
          let i = e.append("image");
          (i.attr("x", t), i.attr("y", r));
          let s = (0, J3.sanitizeUrl)(n);
          i.attr("xlink:href", s);
        }, "drawImage")),
        (q2 = a((e, t, r, n) => {
          let i = e.append("use");
          (i.attr("x", t), i.attr("y", r));
          let s = (0, J3.sanitizeUrl)(n);
          i.attr("xlink:href", `#${s}`);
        }, "drawEmbeddedImage")),
        (ri = a(
          () => ({
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            fill: "#EDF2AE",
            stroke: "#666",
            anchor: "start",
            rx: 0,
            ry: 0,
          }),
          "getNoteRect",
        )),
        (s0 = a(
          () => ({
            x: 0,
            y: 0,
            width: 100,
            height: 100,
            "text-anchor": "start",
            style: "#666",
            textMargin: 0,
            rx: 0,
            ry: 0,
            tspan: !0,
          }),
          "getTextObj",
        )));
    });
  var UB,
    t4,
    jB,
    hmt,
    fmt,
    dmt,
    pmt,
    mmt,
    gmt,
    ymt,
    xmt,
    bmt,
    kmt,
    Tmt,
    Smt,
    fl,
    Pa,
    qB = x(() => {
      "use strict";
      Be();
      a0();
      ((UB = Ts(Vf(), 1)),
        (t4 = a(function (e, t) {
          return Vu(e, t);
        }, "drawRect")),
        (jB = a(function (e, t, r, n, i, s) {
          let o = e.append("image");
          (o.attr("width", t),
            o.attr("height", r),
            o.attr("x", n),
            o.attr("y", i));
          let l = s.startsWith("data:image/png;base64")
            ? s
            : (0, UB.sanitizeUrl)(s);
          o.attr("xlink:href", l);
        }, "drawImage")),
        (hmt = a((e, t, r) => {
          let n = e.append("g"),
            i = 0;
          for (let s of t) {
            let o = s.textColor ? s.textColor : "#444444",
              l = s.lineColor ? s.lineColor : "#444444",
              u = s.offsetX ? parseInt(s.offsetX) : 0,
              h = s.offsetY ? parseInt(s.offsetY) : 0,
              f = "";
            if (i === 0) {
              let p = n.append("line");
              (p.attr("x1", s.startPoint.x),
                p.attr("y1", s.startPoint.y),
                p.attr("x2", s.endPoint.x),
                p.attr("y2", s.endPoint.y),
                p.attr("stroke-width", "1"),
                p.attr("stroke", l),
                p.style("fill", "none"),
                s.type !== "rel_b" &&
                  p.attr("marker-end", "url(" + f + "#arrowhead)"),
                (s.type === "birel" || s.type === "rel_b") &&
                  p.attr("marker-start", "url(" + f + "#arrowend)"),
                (i = -1));
            } else {
              let p = n.append("path");
              (p
                .attr("fill", "none")
                .attr("stroke-width", "1")
                .attr("stroke", l)
                .attr(
                  "d",
                  "Mstartx,starty Qcontrolx,controly stopx,stopy "
                    .replaceAll("startx", s.startPoint.x)
                    .replaceAll("starty", s.startPoint.y)
                    .replaceAll(
                      "controlx",
                      s.startPoint.x +
                        (s.endPoint.x - s.startPoint.x) / 2 -
                        (s.endPoint.x - s.startPoint.x) / 4,
                    )
                    .replaceAll(
                      "controly",
                      s.startPoint.y + (s.endPoint.y - s.startPoint.y) / 2,
                    )
                    .replaceAll("stopx", s.endPoint.x)
                    .replaceAll("stopy", s.endPoint.y),
                ),
                s.type !== "rel_b" &&
                  p.attr("marker-end", "url(" + f + "#arrowhead)"),
                (s.type === "birel" || s.type === "rel_b") &&
                  p.attr("marker-start", "url(" + f + "#arrowend)"));
            }
            let d = r.messageFont();
            (fl(r)(
              s.label.text,
              n,
              Math.min(s.startPoint.x, s.endPoint.x) +
                Math.abs(s.endPoint.x - s.startPoint.x) / 2 +
                u,
              Math.min(s.startPoint.y, s.endPoint.y) +
                Math.abs(s.endPoint.y - s.startPoint.y) / 2 +
                h,
              s.label.width,
              s.label.height,
              { fill: o },
              d,
            ),
              s.techn &&
                s.techn.text !== "" &&
                ((d = r.messageFont()),
                fl(r)(
                  "[" + s.techn.text + "]",
                  n,
                  Math.min(s.startPoint.x, s.endPoint.x) +
                    Math.abs(s.endPoint.x - s.startPoint.x) / 2 +
                    u,
                  Math.min(s.startPoint.y, s.endPoint.y) +
                    Math.abs(s.endPoint.y - s.startPoint.y) / 2 +
                    r.messageFontSize +
                    5 +
                    h,
                  Math.max(s.label.width, s.techn.width),
                  s.techn.height,
                  { fill: o, "font-style": "italic" },
                  d,
                )));
          }
        }, "drawRels")),
        (fmt = a(function (e, t, r) {
          let n = e.append("g"),
            i = t.bgColor ? t.bgColor : "none",
            s = t.borderColor ? t.borderColor : "#444444",
            o = t.fontColor ? t.fontColor : "black",
            l = { "stroke-width": 1, "stroke-dasharray": "7.0,7.0" };
          t.nodeType && (l = { "stroke-width": 1 });
          let u = {
            x: t.x,
            y: t.y,
            fill: i,
            stroke: s,
            width: t.width,
            height: t.height,
            rx: 2.5,
            ry: 2.5,
            attrs: l,
          };
          t4(n, u);
          let h = r.boundaryFont();
          ((h.fontWeight = "bold"),
            (h.fontSize = h.fontSize + 2),
            (h.fontColor = o),
            fl(r)(
              t.label.text,
              n,
              t.x,
              t.y + t.label.Y,
              t.width,
              t.height,
              { fill: "#444444" },
              h,
            ),
            t.type &&
              t.type.text !== "" &&
              ((h = r.boundaryFont()),
              (h.fontColor = o),
              fl(r)(
                t.type.text,
                n,
                t.x,
                t.y + t.type.Y,
                t.width,
                t.height,
                { fill: "#444444" },
                h,
              )),
            t.descr &&
              t.descr.text !== "" &&
              ((h = r.boundaryFont()),
              (h.fontSize = h.fontSize - 2),
              (h.fontColor = o),
              fl(r)(
                t.descr.text,
                n,
                t.x,
                t.y + t.descr.Y,
                t.width,
                t.height,
                { fill: "#444444" },
                h,
              )));
        }, "drawBoundary")),
        (dmt = a(function (e, t, r) {
          let n = t.bgColor ? t.bgColor : r[t.typeC4Shape.text + "_bg_color"],
            i = t.borderColor
              ? t.borderColor
              : r[t.typeC4Shape.text + "_border_color"],
            s = t.fontColor ? t.fontColor : "#FFFFFF",
            o =
              "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
          switch (t.typeC4Shape.text) {
            case "person":
              o =
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAACD0lEQVR4Xu2YoU4EMRCGT+4j8Ai8AhaH4QHgAUjQuFMECUgMIUgwJAgMhgQsAYUiJCiQIBBY+EITsjfTdme6V24v4c8vyGbb+ZjOtN0bNcvjQXmkH83WvYBWto6PLm6v7p7uH1/w2fXD+PBycX1Pv2l3IdDm/vn7x+dXQiAubRzoURa7gRZWd0iGRIiJbOnhnfYBQZNJjNbuyY2eJG8fkDE3bbG4ep6MHUAsgYxmE3nVs6VsBWJSGccsOlFPmLIViMzLOB7pCVO2AtHJMohH7Fh6zqitQK7m0rJvAVYgGcEpe//PLdDz65sM4pF9N7ICcXDKIB5Nv6j7tD0NoSdM2QrU9Gg0ewE1LqBhHR3BBdvj2vapnidjHxD/q6vd7Pvhr31AwcY8eXMTXAKECZZJFXuEq27aLgQK5uLMohCenGGuGewOxSjBvYBqeG6B+Nqiblggdjnc+ZXDy+FNFpFzw76O3UBAROuXh6FoiAcf5g9eTvUgzy0nWg6I8cXHRUpg5bOVBCo+KDpFajOf23GgPme7RSQ+lacIENUgJ6gg1k6HjgOlqnLqip4tEuhv0hNEMXUD0clyXE3p6pZA0S2nnvTlXwLJEZWlb7cTQH1+USgTN4VhAenm/wea1OCAOmqo6fE1WCb9WSKBah+rbUWPWAmE2Rvk0ApiB45eOyNAzU8xcTvj8KvkKEoOaIYeHNA3ZuygAvFMUO0AAAAASUVORK5CYII=";
              break;
            case "external_person":
              o =
                "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAIAAADYYG7QAAAB6ElEQVR4Xu2YLY+EMBCG9+dWr0aj0Wg0Go1Go0+j8Xdv2uTCvv1gpt0ebHKPuhDaeW4605Z9mJvx4AdXUyTUdd08z+u6flmWZRnHsWkafk9DptAwDPu+f0eAYtu2PEaGWuj5fCIZrBAC2eLBAnRCsEkkxmeaJp7iDJ2QMDdHsLg8SxKFEJaAo8lAXnmuOFIhTMpxxKATebo4UiFknuNo4OniSIXQyRxEA3YsnjGCVEjVXD7yLUAqxBGUyPv/Y4W2beMgGuS7kVQIBycH0fD+oi5pezQETxdHKmQKGk1eQEYldK+jw5GxPfZ9z7Mk0Qnhf1W1m3w//EUn5BDmSZsbR44QQLBEqrBHqOrmSKaQAxdnLArCrxZcM7A7ZKs4ioRq8LFC+NpC3WCBJsvpVw5edm9iEXFuyNfxXAgSwfrFQ1c0iNda8AdejvUgnktOtJQQxmcfFzGglc5WVCj7oDgFqU18boeFSs52CUh8LE8BIVQDT1ABrB0HtgSEYlX5doJnCwv9TXocKCaKbnwhdDKPq4lf3SwU3HLq4V/+WYhHVMa/3b4IlfyikAduCkcBc7mQ3/z/Qq/cTuikhkzB12Ae/mcJC9U+Vo8Ej1gWAtgbeGgFsAMHr50BIWOLCbezvhpBFUdY6EJuJ/QDW0XoMX60zZ0AAAAASUVORK5CYII=";
              break;
          }
          let l = e.append("g");
          l.attr("class", "person-man");
          let u = ri();
          switch (t.typeC4Shape.text) {
            case "person":
            case "external_person":
            case "system":
            case "external_system":
            case "container":
            case "external_container":
            case "component":
            case "external_component":
              ((u.x = t.x),
                (u.y = t.y),
                (u.fill = n),
                (u.width = t.width),
                (u.height = t.height),
                (u.stroke = i),
                (u.rx = 2.5),
                (u.ry = 2.5),
                (u.attrs = { "stroke-width": 0.5 }),
                t4(l, u));
              break;
            case "system_db":
            case "external_system_db":
            case "container_db":
            case "external_container_db":
            case "component_db":
            case "external_component_db":
              (l
                .append("path")
                .attr("fill", n)
                .attr("stroke-width", "0.5")
                .attr("stroke", i)
                .attr(
                  "d",
                  "Mstartx,startyc0,-10 half,-10 half,-10c0,0 half,0 half,10l0,heightc0,10 -half,10 -half,10c0,0 -half,0 -half,-10l0,-height"
                    .replaceAll("startx", t.x)
                    .replaceAll("starty", t.y)
                    .replaceAll("half", t.width / 2)
                    .replaceAll("height", t.height),
                ),
                l
                  .append("path")
                  .attr("fill", "none")
                  .attr("stroke-width", "0.5")
                  .attr("stroke", i)
                  .attr(
                    "d",
                    "Mstartx,startyc0,10 half,10 half,10c0,0 half,0 half,-10"
                      .replaceAll("startx", t.x)
                      .replaceAll("starty", t.y)
                      .replaceAll("half", t.width / 2),
                  ));
              break;
            case "system_queue":
            case "external_system_queue":
            case "container_queue":
            case "external_container_queue":
            case "component_queue":
            case "external_component_queue":
              (l
                .append("path")
                .attr("fill", n)
                .attr("stroke-width", "0.5")
                .attr("stroke", i)
                .attr(
                  "d",
                  "Mstartx,startylwidth,0c5,0 5,half 5,halfc0,0 0,half -5,halfl-width,0c-5,0 -5,-half -5,-halfc0,0 0,-half 5,-half"
                    .replaceAll("startx", t.x)
                    .replaceAll("starty", t.y)
                    .replaceAll("width", t.width)
                    .replaceAll("half", t.height / 2),
                ),
                l
                  .append("path")
                  .attr("fill", "none")
                  .attr("stroke-width", "0.5")
                  .attr("stroke", i)
                  .attr(
                    "d",
                    "Mstartx,startyc-5,0 -5,half -5,halfc0,half 5,half 5,half"
                      .replaceAll("startx", t.x + t.width)
                      .replaceAll("starty", t.y)
                      .replaceAll("half", t.height / 2),
                  ));
              break;
          }
          let h = Smt(r, t.typeC4Shape.text);
          switch (
            (l
              .append("text")
              .attr("fill", s)
              .attr("font-family", h.fontFamily)
              .attr("font-size", h.fontSize - 2)
              .attr("font-style", "italic")
              .attr("lengthAdjust", "spacing")
              .attr("textLength", t.typeC4Shape.width)
              .attr("x", t.x + t.width / 2 - t.typeC4Shape.width / 2)
              .attr("y", t.y + t.typeC4Shape.Y)
              .text("<<" + t.typeC4Shape.text + ">>"),
            t.typeC4Shape.text)
          ) {
            case "person":
            case "external_person":
              jB(l, 48, 48, t.x + t.width / 2 - 24, t.y + t.image.Y, o);
              break;
          }
          let f = r[t.typeC4Shape.text + "Font"]();
          return (
            (f.fontWeight = "bold"),
            (f.fontSize = f.fontSize + 2),
            (f.fontColor = s),
            fl(r)(
              t.label.text,
              l,
              t.x,
              t.y + t.label.Y,
              t.width,
              t.height,
              { fill: s },
              f,
            ),
            (f = r[t.typeC4Shape.text + "Font"]()),
            (f.fontColor = s),
            t.techn && t.techn?.text !== ""
              ? fl(r)(
                  t.techn.text,
                  l,
                  t.x,
                  t.y + t.techn.Y,
                  t.width,
                  t.height,
                  { fill: s, "font-style": "italic" },
                  f,
                )
              : t.type &&
                t.type.text !== "" &&
                fl(r)(
                  t.type.text,
                  l,
                  t.x,
                  t.y + t.type.Y,
                  t.width,
                  t.height,
                  { fill: s, "font-style": "italic" },
                  f,
                ),
            t.descr &&
              t.descr.text !== "" &&
              ((f = r.personFont()),
              (f.fontColor = s),
              fl(r)(
                t.descr.text,
                l,
                t.x,
                t.y + t.descr.Y,
                t.width,
                t.height,
                { fill: s },
                f,
              )),
            t.height
          );
        }, "drawC4Shape")),
        (pmt = a(function (e) {
          e.append("defs")
            .append("symbol")
            .attr("id", "database")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .append("path")
            .attr("transform", "scale(.5)")
            .attr(
              "d",
              "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z",
            );
        }, "insertDatabaseIcon")),
        (mmt = a(function (e) {
          e.append("defs")
            .append("symbol")
            .attr("id", "computer")
            .attr("width", "24")
            .attr("height", "24")
            .append("path")
            .attr("transform", "scale(.5)")
            .attr(
              "d",
              "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z",
            );
        }, "insertComputerIcon")),
        (gmt = a(function (e) {
          e.append("defs")
            .append("symbol")
            .attr("id", "clock")
            .attr("width", "24")
            .attr("height", "24")
            .append("path")
            .attr("transform", "scale(.5)")
            .attr(
              "d",
              "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z",
            );
        }, "insertClockIcon")),
        (ymt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 9)
            .attr("refY", 5)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z");
        }, "insertArrowHead")),
        (xmt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "arrowend")
            .attr("refX", 1)
            .attr("refY", 5)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 10 0 L 0 5 L 10 10 z");
        }, "insertArrowEnd")),
        (bmt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "filled-head")
            .attr("refX", 18)
            .attr("refY", 7)
            .attr("markerWidth", 20)
            .attr("markerHeight", 28)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
        }, "insertArrowFilledHead")),
        (kmt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "sequencenumber")
            .attr("refX", 15)
            .attr("refY", 15)
            .attr("markerWidth", 60)
            .attr("markerHeight", 40)
            .attr("orient", "auto")
            .append("circle")
            .attr("cx", 15)
            .attr("cy", 15)
            .attr("r", 6);
        }, "insertDynamicNumber")),
        (Tmt = a(function (e) {
          let r = e
            .append("defs")
            .append("marker")
            .attr("id", "crosshead")
            .attr("markerWidth", 15)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .attr("refX", 16)
            .attr("refY", 4);
          (r
            .append("path")
            .attr("fill", "black")
            .attr("stroke", "#000000")
            .style("stroke-dasharray", "0, 0")
            .attr("stroke-width", "1px")
            .attr("d", "M 9,2 V 6 L16,4 Z"),
            r
              .append("path")
              .attr("fill", "none")
              .attr("stroke", "#000000")
              .style("stroke-dasharray", "0, 0")
              .attr("stroke-width", "1px")
              .attr("d", "M 0,1 L 6,7 M 6,1 L 0,7"));
        }, "insertArrowCrossHead")),
        (Smt = a(
          (e, t) => ({
            fontFamily: e[t + "FontFamily"],
            fontSize: e[t + "FontSize"],
            fontWeight: e[t + "FontWeight"],
          }),
          "getC4ShapeFont",
        )),
        (fl = (function () {
          function e(i, s, o, l, u, h, f) {
            let d = s
              .append("text")
              .attr("x", o + u / 2)
              .attr("y", l + h / 2 + 5)
              .style("text-anchor", "middle")
              .text(i);
            n(d, f);
          }
          a(e, "byText");
          function t(i, s, o, l, u, h, f, d) {
            let { fontSize: p, fontFamily: m, fontWeight: g } = d,
              y = i.split(Rt.lineBreakRegex);
            for (let b = 0; b < y.length; b++) {
              let k = b * p - (p * (y.length - 1)) / 2,
                T = s
                  .append("text")
                  .attr("x", o + u / 2)
                  .attr("y", l)
                  .style("text-anchor", "middle")
                  .attr("dominant-baseline", "middle")
                  .style("font-size", p)
                  .style("font-weight", g)
                  .style("font-family", m);
              (T.append("tspan")
                .attr("dy", k)
                .text(y[b])
                .attr("alignment-baseline", "mathematical"),
                n(T, f));
            }
          }
          a(t, "byTspan");
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append("switch"),
              g = p
                .append("foreignObject")
                .attr("x", o)
                .attr("y", l)
                .attr("width", u)
                .attr("height", h)
                .append("xhtml:div")
                .style("display", "table")
                .style("height", "100%")
                .style("width", "100%");
            (g
              .append("div")
              .style("display", "table-cell")
              .style("text-align", "center")
              .style("vertical-align", "middle")
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f));
          }
          a(r, "byFo");
          function n(i, s) {
            for (let o in s) s.hasOwnProperty(o) && i.attr(o, s[o]);
          }
          return (
            a(n, "_setTextAttrs"),
            function (i) {
              return i.textPlacement === "fo"
                ? r
                : i.textPlacement === "old"
                  ? e
                  : t;
            }
          );
        })()),
        (Pa = {
          drawRect: t4,
          drawBoundary: fmt,
          drawC4Shape: dmt,
          drawRels: hmt,
          drawImage: jB,
          insertArrowHead: ymt,
          insertArrowEnd: xmt,
          insertArrowFilledHead: bmt,
          insertDynamicNumber: kmt,
          insertArrowCrossHead: Tmt,
          insertDatabaseIcon: pmt,
          insertComputerIcon: mmt,
          insertClockIcon: gmt,
        }));
    });
  var _mt,
    Y2,
    e4 = x(() => {
      "use strict";
      ((_mt =
        typeof global == "object" &&
        global &&
        global.Object === Object &&
        global),
        (Y2 = _mt));
    });
  var Cmt,
    wmt,
    fn,
    Xs = x(() => {
      "use strict";
      e4();
      ((Cmt =
        typeof self == "object" && self && self.Object === Object && self),
        (wmt = Y2 || Cmt || Function("return this")()),
        (fn = wmt));
    });
  var vmt,
    qn,
    zu = x(() => {
      "use strict";
      Xs();
      ((vmt = fn.Symbol), (qn = vmt));
    });
  function Lmt(e) {
    var t = Emt.call(e, o0),
      r = e[o0];
    try {
      e[o0] = void 0;
      var n = !0;
    } catch {}
    var i = Amt.call(e);
    return (n && (t ? (e[o0] = r) : delete e[o0]), i);
  }
  var HB,
    Emt,
    Amt,
    o0,
    YB,
    XB = x(() => {
      "use strict";
      zu();
      ((HB = Object.prototype),
        (Emt = HB.hasOwnProperty),
        (Amt = HB.toString),
        (o0 = qn ? qn.toStringTag : void 0));
      a(Lmt, "getRawTag");
      YB = Lmt;
    });
  function Nmt(e) {
    return Dmt.call(e);
  }
  var Rmt,
    Dmt,
    KB,
    QB = x(() => {
      "use strict";
      ((Rmt = Object.prototype), (Dmt = Rmt.toString));
      a(Nmt, "objectToString");
      KB = Nmt;
    });
  function Omt(e) {
    return e == null
      ? e === void 0
        ? Mmt
        : Imt
      : ZB && ZB in Object(e)
        ? YB(e)
        : KB(e);
  }
  var Imt,
    Mmt,
    ZB,
    ni,
    dl = x(() => {
      "use strict";
      zu();
      XB();
      QB();
      ((Imt = "[object Null]"),
        (Mmt = "[object Undefined]"),
        (ZB = qn ? qn.toStringTag : void 0));
      a(Omt, "baseGetTag");
      ni = Omt;
    });
  function Pmt(e) {
    var t = typeof e;
    return e != null && (t == "object" || t == "function");
  }
  var Nr,
    Es = x(() => {
      "use strict";
      a(Pmt, "isObject");
      Nr = Pmt;
    });
  function Vmt(e) {
    if (!Nr(e)) return !1;
    var t = ni(e);
    return t == Fmt || t == $mt || t == Bmt || t == Gmt;
  }
  var Bmt,
    Fmt,
    $mt,
    Gmt,
    vn,
    l0 = x(() => {
      "use strict";
      dl();
      Es();
      ((Bmt = "[object AsyncFunction]"),
        (Fmt = "[object Function]"),
        ($mt = "[object GeneratorFunction]"),
        (Gmt = "[object Proxy]"));
      a(Vmt, "isFunction");
      vn = Vmt;
    });
  var zmt,
    X2,
    JB = x(() => {
      "use strict";
      Xs();
      ((zmt = fn["__core-js_shared__"]), (X2 = zmt));
    });
  function Wmt(e) {
    return !!tF && tF in e;
  }
  var tF,
    eF,
    rF = x(() => {
      "use strict";
      JB();
      tF = (function () {
        var e = /[^.]+$/.exec((X2 && X2.keys && X2.keys.IE_PROTO) || "");
        return e ? "Symbol(src)_1." + e : "";
      })();
      a(Wmt, "isMasked");
      eF = Wmt;
    });
  function qmt(e) {
    if (e != null) {
      try {
        return jmt.call(e);
      } catch {}
      try {
        return e + "";
      } catch {}
    }
    return "";
  }
  var Umt,
    jmt,
    pl,
    r4 = x(() => {
      "use strict";
      ((Umt = Function.prototype), (jmt = Umt.toString));
      a(qmt, "toSource");
      pl = qmt;
    });
  function tgt(e) {
    if (!Nr(e) || eF(e)) return !1;
    var t = vn(e) ? Jmt : Ymt;
    return t.test(pl(e));
  }
  var Hmt,
    Ymt,
    Xmt,
    Kmt,
    Qmt,
    Zmt,
    Jmt,
    nF,
    iF = x(() => {
      "use strict";
      l0();
      rF();
      Es();
      r4();
      ((Hmt = /[\\^$.*+?()[\]{}|]/g),
        (Ymt = /^\[object .+?Constructor\]$/),
        (Xmt = Function.prototype),
        (Kmt = Object.prototype),
        (Qmt = Xmt.toString),
        (Zmt = Kmt.hasOwnProperty),
        (Jmt = RegExp(
          "^" +
            Qmt.call(Zmt)
              .replace(Hmt, "\\$&")
              .replace(
                /hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,
                "$1.*?",
              ) +
            "$",
        )));
      a(tgt, "baseIsNative");
      nF = tgt;
    });
  function egt(e, t) {
    return e?.[t];
  }
  var sF,
    aF = x(() => {
      "use strict";
      a(egt, "getValue");
      sF = egt;
    });
  function rgt(e, t) {
    var r = sF(e, t);
    return nF(r) ? r : void 0;
  }
  var rs,
    fc = x(() => {
      "use strict";
      iF();
      aF();
      a(rgt, "getNative");
      rs = rgt;
    });
  var ngt,
    ml,
    c0 = x(() => {
      "use strict";
      fc();
      ((ngt = rs(Object, "create")), (ml = ngt));
    });
  function igt() {
    ((this.__data__ = ml ? ml(null) : {}), (this.size = 0));
  }
  var oF,
    lF = x(() => {
      "use strict";
      c0();
      a(igt, "hashClear");
      oF = igt;
    });
  function sgt(e) {
    var t = this.has(e) && delete this.__data__[e];
    return ((this.size -= t ? 1 : 0), t);
  }
  var cF,
    uF = x(() => {
      "use strict";
      a(sgt, "hashDelete");
      cF = sgt;
    });
  function cgt(e) {
    var t = this.__data__;
    if (ml) {
      var r = t[e];
      return r === agt ? void 0 : r;
    }
    return lgt.call(t, e) ? t[e] : void 0;
  }
  var agt,
    ogt,
    lgt,
    hF,
    fF = x(() => {
      "use strict";
      c0();
      ((agt = "__lodash_hash_undefined__"),
        (ogt = Object.prototype),
        (lgt = ogt.hasOwnProperty));
      a(cgt, "hashGet");
      hF = cgt;
    });
  function fgt(e) {
    var t = this.__data__;
    return ml ? t[e] !== void 0 : hgt.call(t, e);
  }
  var ugt,
    hgt,
    dF,
    pF = x(() => {
      "use strict";
      c0();
      ((ugt = Object.prototype), (hgt = ugt.hasOwnProperty));
      a(fgt, "hashHas");
      dF = fgt;
    });
  function pgt(e, t) {
    var r = this.__data__;
    return (
      (this.size += this.has(e) ? 0 : 1),
      (r[e] = ml && t === void 0 ? dgt : t),
      this
    );
  }
  var dgt,
    mF,
    gF = x(() => {
      "use strict";
      c0();
      dgt = "__lodash_hash_undefined__";
      a(pgt, "hashSet");
      mF = pgt;
    });
  function zf(e) {
    var t = -1,
      r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  var n4,
    yF = x(() => {
      "use strict";
      lF();
      uF();
      fF();
      pF();
      gF();
      a(zf, "Hash");
      zf.prototype.clear = oF;
      zf.prototype.delete = cF;
      zf.prototype.get = hF;
      zf.prototype.has = dF;
      zf.prototype.set = mF;
      n4 = zf;
    });
  function mgt() {
    ((this.__data__ = []), (this.size = 0));
  }
  var xF,
    bF = x(() => {
      "use strict";
      a(mgt, "listCacheClear");
      xF = mgt;
    });
  function ggt(e, t) {
    return e === t || (e !== e && t !== t);
  }
  var Ks,
    Wu = x(() => {
      "use strict";
      a(ggt, "eq");
      Ks = ggt;
    });
  function ygt(e, t) {
    for (var r = e.length; r--; ) if (Ks(e[r][0], t)) return r;
    return -1;
  }
  var dc,
    u0 = x(() => {
      "use strict";
      Wu();
      a(ygt, "assocIndexOf");
      dc = ygt;
    });
  function kgt(e) {
    var t = this.__data__,
      r = dc(t, e);
    if (r < 0) return !1;
    var n = t.length - 1;
    return (r == n ? t.pop() : bgt.call(t, r, 1), --this.size, !0);
  }
  var xgt,
    bgt,
    kF,
    TF = x(() => {
      "use strict";
      u0();
      ((xgt = Array.prototype), (bgt = xgt.splice));
      a(kgt, "listCacheDelete");
      kF = kgt;
    });
  function Tgt(e) {
    var t = this.__data__,
      r = dc(t, e);
    return r < 0 ? void 0 : t[r][1];
  }
  var SF,
    _F = x(() => {
      "use strict";
      u0();
      a(Tgt, "listCacheGet");
      SF = Tgt;
    });
  function Sgt(e) {
    return dc(this.__data__, e) > -1;
  }
  var CF,
    wF = x(() => {
      "use strict";
      u0();
      a(Sgt, "listCacheHas");
      CF = Sgt;
    });
  function _gt(e, t) {
    var r = this.__data__,
      n = dc(r, e);
    return (n < 0 ? (++this.size, r.push([e, t])) : (r[n][1] = t), this);
  }
  var vF,
    EF = x(() => {
      "use strict";
      u0();
      a(_gt, "listCacheSet");
      vF = _gt;
    });
  function Wf(e) {
    var t = -1,
      r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  var pc,
    h0 = x(() => {
      "use strict";
      bF();
      TF();
      _F();
      wF();
      EF();
      a(Wf, "ListCache");
      Wf.prototype.clear = xF;
      Wf.prototype.delete = kF;
      Wf.prototype.get = SF;
      Wf.prototype.has = CF;
      Wf.prototype.set = vF;
      pc = Wf;
    });
  var Cgt,
    mc,
    K2 = x(() => {
      "use strict";
      fc();
      Xs();
      ((Cgt = rs(fn, "Map")), (mc = Cgt));
    });
  function wgt() {
    ((this.size = 0),
      (this.__data__ = {
        hash: new n4(),
        map: new (mc || pc)(),
        string: new n4(),
      }));
  }
  var AF,
    LF = x(() => {
      "use strict";
      yF();
      h0();
      K2();
      a(wgt, "mapCacheClear");
      AF = wgt;
    });
  function vgt(e) {
    var t = typeof e;
    return t == "string" || t == "number" || t == "symbol" || t == "boolean"
      ? e !== "__proto__"
      : e === null;
  }
  var RF,
    DF = x(() => {
      "use strict";
      a(vgt, "isKeyable");
      RF = vgt;
    });
  function Egt(e, t) {
    var r = e.__data__;
    return RF(t) ? r[typeof t == "string" ? "string" : "hash"] : r.map;
  }
  var gc,
    f0 = x(() => {
      "use strict";
      DF();
      a(Egt, "getMapData");
      gc = Egt;
    });
  function Agt(e) {
    var t = gc(this, e).delete(e);
    return ((this.size -= t ? 1 : 0), t);
  }
  var NF,
    IF = x(() => {
      "use strict";
      f0();
      a(Agt, "mapCacheDelete");
      NF = Agt;
    });
  function Lgt(e) {
    return gc(this, e).get(e);
  }
  var MF,
    OF = x(() => {
      "use strict";
      f0();
      a(Lgt, "mapCacheGet");
      MF = Lgt;
    });
  function Rgt(e) {
    return gc(this, e).has(e);
  }
  var PF,
    BF = x(() => {
      "use strict";
      f0();
      a(Rgt, "mapCacheHas");
      PF = Rgt;
    });
  function Dgt(e, t) {
    var r = gc(this, e),
      n = r.size;
    return (r.set(e, t), (this.size += r.size == n ? 0 : 1), this);
  }
  var FF,
    $F = x(() => {
      "use strict";
      f0();
      a(Dgt, "mapCacheSet");
      FF = Dgt;
    });
  function Uf(e) {
    var t = -1,
      r = e == null ? 0 : e.length;
    for (this.clear(); ++t < r; ) {
      var n = e[t];
      this.set(n[0], n[1]);
    }
  }
  var Uu,
    Q2 = x(() => {
      "use strict";
      LF();
      IF();
      OF();
      BF();
      $F();
      a(Uf, "MapCache");
      Uf.prototype.clear = AF;
      Uf.prototype.delete = NF;
      Uf.prototype.get = MF;
      Uf.prototype.has = PF;
      Uf.prototype.set = FF;
      Uu = Uf;
    });
  function i4(e, t) {
    if (typeof e != "function" || (t != null && typeof t != "function"))
      throw new TypeError(Ngt);
    var r = a(function () {
      var n = arguments,
        i = t ? t.apply(this, n) : n[0],
        s = r.cache;
      if (s.has(i)) return s.get(i);
      var o = e.apply(this, n);
      return ((r.cache = s.set(i, o) || s), o);
    }, "memoized");
    return ((r.cache = new (i4.Cache || Uu)()), r);
  }
  var Ngt,
    jf,
    s4 = x(() => {
      "use strict";
      Q2();
      Ngt = "Expected a function";
      a(i4, "memoize");
      i4.Cache = Uu;
      jf = i4;
    });
  function Igt() {
    ((this.__data__ = new pc()), (this.size = 0));
  }
  var GF,
    VF = x(() => {
      "use strict";
      h0();
      a(Igt, "stackClear");
      GF = Igt;
    });
  function Mgt(e) {
    var t = this.__data__,
      r = t.delete(e);
    return ((this.size = t.size), r);
  }
  var zF,
    WF = x(() => {
      "use strict";
      a(Mgt, "stackDelete");
      zF = Mgt;
    });
  function Ogt(e) {
    return this.__data__.get(e);
  }
  var UF,
    jF = x(() => {
      "use strict";
      a(Ogt, "stackGet");
      UF = Ogt;
    });
  function Pgt(e) {
    return this.__data__.has(e);
  }
  var qF,
    HF = x(() => {
      "use strict";
      a(Pgt, "stackHas");
      qF = Pgt;
    });
  function Fgt(e, t) {
    var r = this.__data__;
    if (r instanceof pc) {
      var n = r.__data__;
      if (!mc || n.length < Bgt - 1)
        return (n.push([e, t]), (this.size = ++r.size), this);
      r = this.__data__ = new Uu(n);
    }
    return (r.set(e, t), (this.size = r.size), this);
  }
  var Bgt,
    YF,
    XF = x(() => {
      "use strict";
      h0();
      K2();
      Q2();
      Bgt = 200;
      a(Fgt, "stackSet");
      YF = Fgt;
    });
  function qf(e) {
    var t = (this.__data__ = new pc(e));
    this.size = t.size;
  }
  var fo,
    d0 = x(() => {
      "use strict";
      h0();
      VF();
      WF();
      jF();
      HF();
      XF();
      a(qf, "Stack");
      qf.prototype.clear = GF;
      qf.prototype.delete = zF;
      qf.prototype.get = UF;
      qf.prototype.has = qF;
      qf.prototype.set = YF;
      fo = qf;
    });
  var $gt,
    Hf,
    a4 = x(() => {
      "use strict";
      fc();
      (($gt = (function () {
        try {
          var e = rs(Object, "defineProperty");
          return (e({}, "", {}), e);
        } catch {}
      })()),
        (Hf = $gt));
    });
  function Ggt(e, t, r) {
    t == "__proto__" && Hf
      ? Hf(e, t, { configurable: !0, enumerable: !0, value: r, writable: !0 })
      : (e[t] = r);
  }
  var po,
    Yf = x(() => {
      "use strict";
      a4();
      a(Ggt, "baseAssignValue");
      po = Ggt;
    });
  function Vgt(e, t, r) {
    ((r !== void 0 && !Ks(e[t], r)) || (r === void 0 && !(t in e))) &&
      po(e, t, r);
  }
  var p0,
    o4 = x(() => {
      "use strict";
      Yf();
      Wu();
      a(Vgt, "assignMergeValue");
      p0 = Vgt;
    });
  function zgt(e) {
    return function (t, r, n) {
      for (var i = -1, s = Object(t), o = n(t), l = o.length; l--; ) {
        var u = o[e ? l : ++i];
        if (r(s[u], u, s) === !1) break;
      }
      return t;
    };
  }
  var KF,
    QF = x(() => {
      "use strict";
      a(zgt, "createBaseFor");
      KF = zgt;
    });
  var Wgt,
    Xf,
    Z2 = x(() => {
      "use strict";
      QF();
      ((Wgt = KF()), (Xf = Wgt));
    });
  function jgt(e, t) {
    if (t) return e.slice();
    var r = e.length,
      n = t$ ? t$(r) : new e.constructor(r);
    return (e.copy(n), n);
  }
  var e$,
    ZF,
    Ugt,
    JF,
    t$,
    J2,
    l4 = x(() => {
      "use strict";
      Xs();
      ((e$ =
        typeof exports == "object" && exports && !exports.nodeType && exports),
        (ZF =
          e$ &&
          typeof module == "object" &&
          module &&
          !module.nodeType &&
          module),
        (Ugt = ZF && ZF.exports === e$),
        (JF = Ugt ? fn.Buffer : void 0),
        (t$ = JF ? JF.allocUnsafe : void 0));
      a(jgt, "cloneBuffer");
      J2 = jgt;
    });
  var qgt,
    Kf,
    c4 = x(() => {
      "use strict";
      Xs();
      ((qgt = fn.Uint8Array), (Kf = qgt));
    });
  function Hgt(e) {
    var t = new e.constructor(e.byteLength);
    return (new Kf(t).set(new Kf(e)), t);
  }
  var Qf,
    tb = x(() => {
      "use strict";
      c4();
      a(Hgt, "cloneArrayBuffer");
      Qf = Hgt;
    });
  function Ygt(e, t) {
    var r = t ? Qf(e.buffer) : e.buffer;
    return new e.constructor(r, e.byteOffset, e.length);
  }
  var eb,
    u4 = x(() => {
      "use strict";
      tb();
      a(Ygt, "cloneTypedArray");
      eb = Ygt;
    });
  function Xgt(e, t) {
    var r = -1,
      n = e.length;
    for (t || (t = Array(n)); ++r < n; ) t[r] = e[r];
    return t;
  }
  var rb,
    h4 = x(() => {
      "use strict";
      a(Xgt, "copyArray");
      rb = Xgt;
    });
  var r$,
    Kgt,
    n$,
    i$ = x(() => {
      "use strict";
      Es();
      ((r$ = Object.create),
        (Kgt = (function () {
          function e() {}
          return (
            a(e, "object"),
            function (t) {
              if (!Nr(t)) return {};
              if (r$) return r$(t);
              e.prototype = t;
              var r = new e();
              return ((e.prototype = void 0), r);
            }
          );
        })()),
        (n$ = Kgt));
    });
  function Qgt(e, t) {
    return function (r) {
      return e(t(r));
    };
  }
  var nb,
    f4 = x(() => {
      "use strict";
      a(Qgt, "overArg");
      nb = Qgt;
    });
  var Zgt,
    Zf,
    ib = x(() => {
      "use strict";
      f4();
      ((Zgt = nb(Object.getPrototypeOf, Object)), (Zf = Zgt));
    });
  function t0t(e) {
    var t = e && e.constructor,
      r = (typeof t == "function" && t.prototype) || Jgt;
    return e === r;
  }
  var Jgt,
    mo,
    Jf = x(() => {
      "use strict";
      Jgt = Object.prototype;
      a(t0t, "isPrototype");
      mo = t0t;
    });
  function e0t(e) {
    return typeof e.constructor == "function" && !mo(e) ? n$(Zf(e)) : {};
  }
  var sb,
    d4 = x(() => {
      "use strict";
      i$();
      ib();
      Jf();
      a(e0t, "initCloneObject");
      sb = e0t;
    });
  function r0t(e) {
    return e != null && typeof e == "object";
  }
  var an,
    Qs = x(() => {
      "use strict";
      a(r0t, "isObjectLike");
      an = r0t;
    });
  function i0t(e) {
    return an(e) && ni(e) == n0t;
  }
  var n0t,
    p4,
    s$ = x(() => {
      "use strict";
      dl();
      Qs();
      n0t = "[object Arguments]";
      a(i0t, "baseIsArguments");
      p4 = i0t;
    });
  var a$,
    s0t,
    a0t,
    o0t,
    Ba,
    td = x(() => {
      "use strict";
      s$();
      Qs();
      ((a$ = Object.prototype),
        (s0t = a$.hasOwnProperty),
        (a0t = a$.propertyIsEnumerable),
        (o0t = p4(
          (function () {
            return arguments;
          })(),
        )
          ? p4
          : function (e) {
              return an(e) && s0t.call(e, "callee") && !a0t.call(e, "callee");
            }),
        (Ba = o0t));
    });
  var l0t,
    Jt,
    Kr = x(() => {
      "use strict";
      ((l0t = Array.isArray), (Jt = l0t));
    });
  function u0t(e) {
    return typeof e == "number" && e > -1 && e % 1 == 0 && e <= c0t;
  }
  var c0t,
    ed,
    ab = x(() => {
      "use strict";
      c0t = 9007199254740991;
      a(u0t, "isLength");
      ed = u0t;
    });
  function h0t(e) {
    return e != null && ed(e.length) && !vn(e);
  }
  var dn,
    Zs = x(() => {
      "use strict";
      l0();
      ab();
      a(h0t, "isArrayLike");
      dn = h0t;
    });
  function f0t(e) {
    return an(e) && dn(e);
  }
  var ju,
    ob = x(() => {
      "use strict";
      Zs();
      Qs();
      a(f0t, "isArrayLikeObject");
      ju = f0t;
    });
  function d0t() {
    return !1;
  }
  var o$,
    l$ = x(() => {
      "use strict";
      a(d0t, "stubFalse");
      o$ = d0t;
    });
  var h$,
    c$,
    p0t,
    u$,
    m0t,
    g0t,
    Fa,
    rd = x(() => {
      "use strict";
      Xs();
      l$();
      ((h$ =
        typeof exports == "object" && exports && !exports.nodeType && exports),
        (c$ =
          h$ &&
          typeof module == "object" &&
          module &&
          !module.nodeType &&
          module),
        (p0t = c$ && c$.exports === h$),
        (u$ = p0t ? fn.Buffer : void 0),
        (m0t = u$ ? u$.isBuffer : void 0),
        (g0t = m0t || o$),
        (Fa = g0t));
    });
  function S0t(e) {
    if (!an(e) || ni(e) != y0t) return !1;
    var t = Zf(e);
    if (t === null) return !0;
    var r = k0t.call(t, "constructor") && t.constructor;
    return typeof r == "function" && r instanceof r && f$.call(r) == T0t;
  }
  var y0t,
    x0t,
    b0t,
    f$,
    k0t,
    T0t,
    d$,
    p$ = x(() => {
      "use strict";
      dl();
      ib();
      Qs();
      ((y0t = "[object Object]"),
        (x0t = Function.prototype),
        (b0t = Object.prototype),
        (f$ = x0t.toString),
        (k0t = b0t.hasOwnProperty),
        (T0t = f$.call(Object)));
      a(S0t, "isPlainObject");
      d$ = S0t;
    });
  function H0t(e) {
    return an(e) && ed(e.length) && !!Hr[ni(e)];
  }
  var _0t,
    C0t,
    w0t,
    v0t,
    E0t,
    A0t,
    L0t,
    R0t,
    D0t,
    N0t,
    I0t,
    M0t,
    O0t,
    P0t,
    B0t,
    F0t,
    $0t,
    G0t,
    V0t,
    z0t,
    W0t,
    U0t,
    j0t,
    q0t,
    Hr,
    m$,
    g$ = x(() => {
      "use strict";
      dl();
      ab();
      Qs();
      ((_0t = "[object Arguments]"),
        (C0t = "[object Array]"),
        (w0t = "[object Boolean]"),
        (v0t = "[object Date]"),
        (E0t = "[object Error]"),
        (A0t = "[object Function]"),
        (L0t = "[object Map]"),
        (R0t = "[object Number]"),
        (D0t = "[object Object]"),
        (N0t = "[object RegExp]"),
        (I0t = "[object Set]"),
        (M0t = "[object String]"),
        (O0t = "[object WeakMap]"),
        (P0t = "[object ArrayBuffer]"),
        (B0t = "[object DataView]"),
        (F0t = "[object Float32Array]"),
        ($0t = "[object Float64Array]"),
        (G0t = "[object Int8Array]"),
        (V0t = "[object Int16Array]"),
        (z0t = "[object Int32Array]"),
        (W0t = "[object Uint8Array]"),
        (U0t = "[object Uint8ClampedArray]"),
        (j0t = "[object Uint16Array]"),
        (q0t = "[object Uint32Array]"),
        (Hr = {}));
      Hr[F0t] =
        Hr[$0t] =
        Hr[G0t] =
        Hr[V0t] =
        Hr[z0t] =
        Hr[W0t] =
        Hr[U0t] =
        Hr[j0t] =
        Hr[q0t] =
          !0;
      Hr[_0t] =
        Hr[C0t] =
        Hr[P0t] =
        Hr[w0t] =
        Hr[B0t] =
        Hr[v0t] =
        Hr[E0t] =
        Hr[A0t] =
        Hr[L0t] =
        Hr[R0t] =
        Hr[D0t] =
        Hr[N0t] =
        Hr[I0t] =
        Hr[M0t] =
        Hr[O0t] =
          !1;
      a(H0t, "baseIsTypedArray");
      m$ = H0t;
    });
  function Y0t(e) {
    return function (t) {
      return e(t);
    };
  }
  var Js,
    qu = x(() => {
      "use strict";
      a(Y0t, "baseUnary");
      Js = Y0t;
    });
  var y$,
    m0,
    X0t,
    m4,
    K0t,
    ta,
    g0 = x(() => {
      "use strict";
      e4();
      ((y$ =
        typeof exports == "object" && exports && !exports.nodeType && exports),
        (m0 =
          y$ &&
          typeof module == "object" &&
          module &&
          !module.nodeType &&
          module),
        (X0t = m0 && m0.exports === y$),
        (m4 = X0t && Y2.process),
        (K0t = (function () {
          try {
            var e = m0 && m0.require && m0.require("util").types;
            return e || (m4 && m4.binding && m4.binding("util"));
          } catch {}
        })()),
        (ta = K0t));
    });
  var x$,
    Q0t,
    yc,
    y0 = x(() => {
      "use strict";
      g$();
      qu();
      g0();
      ((x$ = ta && ta.isTypedArray), (Q0t = x$ ? Js(x$) : m$), (yc = Q0t));
    });
  function Z0t(e, t) {
    if (!(t === "constructor" && typeof e[t] == "function") && t != "__proto__")
      return e[t];
  }
  var x0,
    g4 = x(() => {
      "use strict";
      a(Z0t, "safeGet");
      x0 = Z0t;
    });
  function e1t(e, t, r) {
    var n = e[t];
    (!(t1t.call(e, t) && Ks(n, r)) || (r === void 0 && !(t in e))) &&
      po(e, t, r);
  }
  var J0t,
    t1t,
    go,
    nd = x(() => {
      "use strict";
      Yf();
      Wu();
      ((J0t = Object.prototype), (t1t = J0t.hasOwnProperty));
      a(e1t, "assignValue");
      go = e1t;
    });
  function r1t(e, t, r, n) {
    var i = !r;
    r || (r = {});
    for (var s = -1, o = t.length; ++s < o; ) {
      var l = t[s],
        u = n ? n(r[l], e[l], l, r, e) : void 0;
      (u === void 0 && (u = e[l]), i ? po(r, l, u) : go(r, l, u));
    }
    return r;
  }
  var ea,
    Hu = x(() => {
      "use strict";
      nd();
      Yf();
      a(r1t, "copyObject");
      ea = r1t;
    });
  function n1t(e, t) {
    for (var r = -1, n = Array(e); ++r < e; ) n[r] = t(r);
    return n;
  }
  var b$,
    k$ = x(() => {
      "use strict";
      a(n1t, "baseTimes");
      b$ = n1t;
    });
  function a1t(e, t) {
    var r = typeof e;
    return (
      (t = t ?? i1t),
      !!t &&
        (r == "number" || (r != "symbol" && s1t.test(e))) &&
        e > -1 &&
        e % 1 == 0 &&
        e < t
    );
  }
  var i1t,
    s1t,
    xc,
    b0 = x(() => {
      "use strict";
      ((i1t = 9007199254740991), (s1t = /^(?:0|[1-9]\d*)$/));
      a(a1t, "isIndex");
      xc = a1t;
    });
  function c1t(e, t) {
    var r = Jt(e),
      n = !r && Ba(e),
      i = !r && !n && Fa(e),
      s = !r && !n && !i && yc(e),
      o = r || n || i || s,
      l = o ? b$(e.length, String) : [],
      u = l.length;
    for (var h in e)
      (t || l1t.call(e, h)) &&
        !(
          o &&
          (h == "length" ||
            (i && (h == "offset" || h == "parent")) ||
            (s && (h == "buffer" || h == "byteLength" || h == "byteOffset")) ||
            xc(h, u))
        ) &&
        l.push(h);
    return l;
  }
  var o1t,
    l1t,
    lb,
    y4 = x(() => {
      "use strict";
      k$();
      td();
      Kr();
      rd();
      b0();
      y0();
      ((o1t = Object.prototype), (l1t = o1t.hasOwnProperty));
      a(c1t, "arrayLikeKeys");
      lb = c1t;
    });
  function u1t(e) {
    var t = [];
    if (e != null) for (var r in Object(e)) t.push(r);
    return t;
  }
  var T$,
    S$ = x(() => {
      "use strict";
      a(u1t, "nativeKeysIn");
      T$ = u1t;
    });
  function d1t(e) {
    if (!Nr(e)) return T$(e);
    var t = mo(e),
      r = [];
    for (var n in e)
      (n == "constructor" && (t || !f1t.call(e, n))) || r.push(n);
    return r;
  }
  var h1t,
    f1t,
    _$,
    C$ = x(() => {
      "use strict";
      Es();
      Jf();
      S$();
      ((h1t = Object.prototype), (f1t = h1t.hasOwnProperty));
      a(d1t, "baseKeysIn");
      _$ = d1t;
    });
  function p1t(e) {
    return dn(e) ? lb(e, !0) : _$(e);
  }
  var ns,
    bc = x(() => {
      "use strict";
      y4();
      C$();
      Zs();
      a(p1t, "keysIn");
      ns = p1t;
    });
  function m1t(e) {
    return ea(e, ns(e));
  }
  var w$,
    v$ = x(() => {
      "use strict";
      Hu();
      bc();
      a(m1t, "toPlainObject");
      w$ = m1t;
    });
  function g1t(e, t, r, n, i, s, o) {
    var l = x0(e, r),
      u = x0(t, r),
      h = o.get(u);
    if (h) {
      p0(e, r, h);
      return;
    }
    var f = s ? s(l, u, r + "", e, t, o) : void 0,
      d = f === void 0;
    if (d) {
      var p = Jt(u),
        m = !p && Fa(u),
        g = !p && !m && yc(u);
      ((f = u),
        p || m || g
          ? Jt(l)
            ? (f = l)
            : ju(l)
              ? (f = rb(l))
              : m
                ? ((d = !1), (f = J2(u, !0)))
                : g
                  ? ((d = !1), (f = eb(u, !0)))
                  : (f = [])
          : d$(u) || Ba(u)
            ? ((f = l), Ba(l) ? (f = w$(l)) : (!Nr(l) || vn(l)) && (f = sb(u)))
            : (d = !1));
    }
    (d && (o.set(u, f), i(f, u, n, s, o), o.delete(u)), p0(e, r, f));
  }
  var E$,
    A$ = x(() => {
      "use strict";
      o4();
      l4();
      u4();
      h4();
      d4();
      td();
      Kr();
      ob();
      rd();
      l0();
      Es();
      p$();
      y0();
      g4();
      v$();
      a(g1t, "baseMergeDeep");
      E$ = g1t;
    });
  function L$(e, t, r, n, i) {
    e !== t &&
      Xf(
        t,
        function (s, o) {
          if ((i || (i = new fo()), Nr(s))) E$(e, t, o, r, L$, n, i);
          else {
            var l = n ? n(x0(e, o), s, o + "", e, t, i) : void 0;
            (l === void 0 && (l = s), p0(e, o, l));
          }
        },
        ns,
      );
  }
  var R$,
    D$ = x(() => {
      "use strict";
      d0();
      o4();
      Z2();
      A$();
      Es();
      bc();
      g4();
      a(L$, "baseMerge");
      R$ = L$;
    });
  function y1t(e) {
    return e;
  }
  var Hn,
    gl = x(() => {
      "use strict";
      a(y1t, "identity");
      Hn = y1t;
    });
  function x1t(e, t, r) {
    switch (r.length) {
      case 0:
        return e.call(t);
      case 1:
        return e.call(t, r[0]);
      case 2:
        return e.call(t, r[0], r[1]);
      case 3:
        return e.call(t, r[0], r[1], r[2]);
    }
    return e.apply(t, r);
  }
  var N$,
    I$ = x(() => {
      "use strict";
      a(x1t, "apply");
      N$ = x1t;
    });
  function b1t(e, t, r) {
    return (
      (t = M$(t === void 0 ? e.length - 1 : t, 0)),
      function () {
        for (
          var n = arguments, i = -1, s = M$(n.length - t, 0), o = Array(s);
          ++i < s;

        )
          o[i] = n[t + i];
        i = -1;
        for (var l = Array(t + 1); ++i < t; ) l[i] = n[i];
        return ((l[t] = r(o)), N$(e, this, l));
      }
    );
  }
  var M$,
    cb,
    x4 = x(() => {
      "use strict";
      I$();
      M$ = Math.max;
      a(b1t, "overRest");
      cb = b1t;
    });
  function k1t(e) {
    return function () {
      return e;
    };
  }
  var is,
    b4 = x(() => {
      "use strict";
      a(k1t, "constant");
      is = k1t;
    });
  var T1t,
    O$,
    P$ = x(() => {
      "use strict";
      b4();
      a4();
      gl();
      ((T1t = Hf
        ? function (e, t) {
            return Hf(e, "toString", {
              configurable: !0,
              enumerable: !1,
              value: is(t),
              writable: !0,
            });
          }
        : Hn),
        (O$ = T1t));
    });
  function w1t(e) {
    var t = 0,
      r = 0;
    return function () {
      var n = C1t(),
        i = _1t - (n - r);
      if (((r = n), i > 0)) {
        if (++t >= S1t) return arguments[0];
      } else t = 0;
      return e.apply(void 0, arguments);
    };
  }
  var S1t,
    _1t,
    C1t,
    B$,
    F$ = x(() => {
      "use strict";
      ((S1t = 800), (_1t = 16), (C1t = Date.now));
      a(w1t, "shortOut");
      B$ = w1t;
    });
  var v1t,
    ub,
    k4 = x(() => {
      "use strict";
      P$();
      F$();
      ((v1t = B$(O$)), (ub = v1t));
    });
  function E1t(e, t) {
    return ub(cb(e, t, Hn), e + "");
  }
  var yo,
    id = x(() => {
      "use strict";
      gl();
      x4();
      k4();
      a(E1t, "baseRest");
      yo = E1t;
    });
  function A1t(e, t, r) {
    if (!Nr(r)) return !1;
    var n = typeof t;
    return (n == "number" ? dn(r) && xc(t, r.length) : n == "string" && t in r)
      ? Ks(r[t], e)
      : !1;
  }
  var As,
    Yu = x(() => {
      "use strict";
      Wu();
      Zs();
      b0();
      Es();
      a(A1t, "isIterateeCall");
      As = A1t;
    });
  function L1t(e) {
    return yo(function (t, r) {
      var n = -1,
        i = r.length,
        s = i > 1 ? r[i - 1] : void 0,
        o = i > 2 ? r[2] : void 0;
      for (
        s = e.length > 3 && typeof s == "function" ? (i--, s) : void 0,
          o && As(r[0], r[1], o) && ((s = i < 3 ? void 0 : s), (i = 1)),
          t = Object(t);
        ++n < i;

      ) {
        var l = r[n];
        l && e(t, l, n, s);
      }
      return t;
    });
  }
  var hb,
    T4 = x(() => {
      "use strict";
      id();
      Yu();
      a(L1t, "createAssigner");
      hb = L1t;
    });
  var R1t,
    kc,
    S4 = x(() => {
      "use strict";
      D$();
      T4();
      ((R1t = hb(function (e, t, r) {
        R$(e, t, r);
      })),
        (kc = R1t));
    });
  function w4(e, t) {
    if (!e) return t;
    let r = `curve${e.charAt(0).toUpperCase() + e.slice(1)}`;
    return D1t[r] ?? t;
  }
  function O1t(e, t) {
    let r = e.trim();
    if (r) return t.securityLevel !== "loose" ? (0, V$.sanitizeUrl)(r) : r;
  }
  function U$(e, t) {
    return !e || !t
      ? 0
      : Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
  }
  function B1t(e) {
    let t,
      r = 0;
    e.forEach((i) => {
      ((r += U$(i, t)), (t = i));
    });
    let n = r / 2;
    return v4(e, n);
  }
  function F1t(e) {
    return e.length === 1 ? e[0] : B1t(e);
  }
  function G1t(e, t, r) {
    let n = structuredClone(r);
    (P.info("our points", n),
      t !== "start_left" && t !== "start_right" && n.reverse());
    let i = 25 + e,
      s = v4(n, i),
      o = 10 + e * 0.5,
      l = Math.atan2(n[0].y - s.y, n[0].x - s.x),
      u = { x: 0, y: 0 };
    return (
      t === "start_left"
        ? ((u.x = Math.sin(l + Math.PI) * o + (n[0].x + s.x) / 2),
          (u.y = -Math.cos(l + Math.PI) * o + (n[0].y + s.y) / 2))
        : t === "end_right"
          ? ((u.x = Math.sin(l - Math.PI) * o + (n[0].x + s.x) / 2 - 5),
            (u.y = -Math.cos(l - Math.PI) * o + (n[0].y + s.y) / 2 - 5))
          : t === "end_left"
            ? ((u.x = Math.sin(l) * o + (n[0].x + s.x) / 2 - 5),
              (u.y = -Math.cos(l) * o + (n[0].y + s.y) / 2 - 5))
            : ((u.x = Math.sin(l) * o + (n[0].x + s.x) / 2),
              (u.y = -Math.cos(l) * o + (n[0].y + s.y) / 2)),
      u
    );
  }
  function E4(e) {
    let t = "",
      r = "";
    for (let n of e)
      n !== void 0 &&
        (n.startsWith("color:") || n.startsWith("text-align:")
          ? (r = r + n + ";")
          : (t = t + n + ";"));
    return { style: t, labelStyle: r };
  }
  function V1t(e) {
    let t = "",
      r = "0123456789abcdef",
      n = r.length;
    for (let i = 0; i < e; i++) t += r.charAt(Math.floor(Math.random() * n));
    return t;
  }
  function db(e, t) {
    return D4(e, t).height;
  }
  function Yn(e, t) {
    return D4(e, t).width;
  }
  function N4(e) {
    return "str" in e;
  }
  function on(e, t) {
    return kc({}, e, t);
  }
  function Ir(e) {
    return e ?? null;
  }
  function H1t(e, t) {
    let r = Math.round(e.x),
      n = Math.round(e.y),
      i = t.replace(/(\d+\.\d+)/g, (s) => Math.round(parseFloat(s)).toString());
    return i.includes(r.toString()) || i.includes(n.toString());
  }
  var V$,
    C4,
    D1t,
    N1t,
    I1t,
    z$,
    W$,
    M1t,
    P1t,
    $$,
    v4,
    $1t,
    G$,
    A4,
    L4,
    z1t,
    W1t,
    R4,
    U1t,
    D4,
    _4,
    fb,
    j1t,
    q1t,
    xo,
    le,
    j$,
    Xn,
    Tc,
    _e = x(() => {
      "use strict";
      V$ = Ts(Vf(), 1);
      Ge();
      Be();
      ew();
      Vt();
      Tu();
      of();
      s4();
      S4();
      Tx();
      ((C4 = "\u200B"),
        (D1t = {
          curveBasis: Ys,
          curveBasisClosed: M2,
          curveBasisOpen: O2,
          curveBumpX: qg,
          curveBumpY: Hg,
          curveBundle: z3,
          curveCardinalClosed: W3,
          curveCardinalOpen: j3,
          curveCardinal: Qg,
          curveCatmullRomClosed: H3,
          curveCatmullRomOpen: Y3,
          curveCatmullRom: t0,
          curveLinear: hl,
          curveLinearClosed: G2,
          curveMonotoneX: e0,
          curveMonotoneY: r0,
          curveNatural: $f,
          curveStep: Gf,
          curveStepAfter: i0,
          curveStepBefore: n0,
        }),
        (N1t =
          /\s*(?:(\w+)(?=:):|(\w+))\s*(?:(\w+)|((?:(?!}%{2}).|\r?\n)*))?\s*(?:}%{2})?/gi),
        (I1t = a(function (e, t) {
          let r = z$(e, /(?:init\b)|(?:initialize\b)/),
            n = {};
          if (Array.isArray(r)) {
            let o = r.map((l) => l.args);
            (cf(o), (n = Xr(n, [...o])));
          } else n = r.args;
          if (!n) return;
          let i = pf(e, t),
            s = "config";
          return (
            n[s] !== void 0 &&
              (i === "flowchart-v2" && (i = "flowchart"),
              (n[i] = n[s]),
              delete n[s]),
            n
          );
        }, "detectInit")),
        (z$ = a(function (e, t = null) {
          try {
            let r = new RegExp(
              `[%]{2}(?![{]${N1t.source})(?=[}][%]{2}).*
`,
              "ig",
            );
            ((e = e.trim().replace(r, "").replace(/'/gm, '"')),
              P.debug(
                `Detecting diagram directive${t !== null ? " type:" + t : ""} based on the text:${e}`,
              ));
            let n,
              i = [];
            for (; (n = ku.exec(e)) !== null; )
              if (
                (n.index === ku.lastIndex && ku.lastIndex++,
                (n && !t) || (t && n[1]?.match(t)) || (t && n[2]?.match(t)))
              ) {
                let s = n[1] ? n[1] : n[2],
                  o = n[3]
                    ? n[3].trim()
                    : n[4]
                      ? JSON.parse(n[4].trim())
                      : null;
                i.push({ type: s, args: o });
              }
            return i.length === 0
              ? { type: e, args: null }
              : i.length === 1
                ? i[0]
                : i;
          } catch (r) {
            return (
              P.error(
                `ERROR: ${r.message} - Unable to parse directive type: '${t}' based on the text: '${e}'`,
              ),
              { type: void 0, args: null }
            );
          }
        }, "detectDirective")),
        (W$ = a(function (e) {
          return e.replace(ku, "");
        }, "removeDirectives")),
        (M1t = a(function (e, t) {
          for (let [r, n] of t.entries()) if (n.match(e)) return r;
          return -1;
        }, "isSubstringInArray")));
      a(w4, "interpolateToCurve");
      a(O1t, "formatUrl");
      P1t = a((e, ...t) => {
        let r = e.split("."),
          n = r.length - 1,
          i = r[n],
          s = window;
        for (let o = 0; o < n; o++)
          if (((s = s[r[o]]), !s)) {
            P.error(`Function name: ${e} not found in window`);
            return;
          }
        s[i](...t);
      }, "runFunc");
      a(U$, "distance");
      a(B1t, "traverseEdge");
      a(F1t, "calcLabelPosition");
      (($$ = a((e, t = 2) => {
        let r = Math.pow(10, t);
        return Math.round(e * r) / r;
      }, "roundNumber")),
        (v4 = a((e, t) => {
          let r,
            n = t;
          for (let i of e) {
            if (r) {
              let s = U$(i, r);
              if (s === 0) return r;
              if (s < n) n -= s;
              else {
                let o = n / s;
                if (o <= 0) return r;
                if (o >= 1) return { x: i.x, y: i.y };
                if (o > 0 && o < 1)
                  return {
                    x: $$((1 - o) * r.x + o * i.x, 5),
                    y: $$((1 - o) * r.y + o * i.y, 5),
                  };
              }
            }
            r = i;
          }
          throw new Error(
            "Could not find a suitable point for the given distance",
          );
        }, "calculatePoint")),
        ($1t = a((e, t, r) => {
          (P.info(`our points ${JSON.stringify(t)}`),
            t[0] !== r && (t = t.reverse()));
          let i = v4(t, 25),
            s = e ? 10 : 5,
            o = Math.atan2(t[0].y - i.y, t[0].x - i.x),
            l = { x: 0, y: 0 };
          return (
            (l.x = Math.sin(o) * s + (t[0].x + i.x) / 2),
            (l.y = -Math.cos(o) * s + (t[0].y + i.y) / 2),
            l
          );
        }, "calcCardinalityPosition")));
      a(G1t, "calcTerminalLabelPosition");
      a(E4, "getStylesFromArray");
      ((G$ = 0),
        (A4 = a(
          () => (
            G$++,
            "id-" + Math.random().toString(36).substr(2, 12) + "-" + G$
          ),
          "generateId",
        )));
      a(V1t, "makeRandomHex");
      ((L4 = a((e) => V1t(e.length), "random")),
        (z1t = a(function () {
          return {
            x: 0,
            y: 0,
            fill: void 0,
            anchor: "start",
            style: "#666",
            width: 100,
            height: 100,
            textMargin: 0,
            rx: 0,
            ry: 0,
            valign: void 0,
            text: "",
          };
        }, "getTextObj")),
        (W1t = a(function (e, t) {
          let r = t.text.replace(Rt.lineBreakRegex, " "),
            [, n] = xo(t.fontSize),
            i = e.append("text");
          (i.attr("x", t.x),
            i.attr("y", t.y),
            i.style("text-anchor", t.anchor),
            i.style("font-family", t.fontFamily),
            i.style("font-size", n),
            i.style("font-weight", t.fontWeight),
            i.attr("fill", t.fill),
            t.class !== void 0 && i.attr("class", t.class));
          let s = i.append("tspan");
          return (
            s.attr("x", t.x + t.textMargin * 2),
            s.attr("fill", t.fill),
            s.text(r),
            i
          );
        }, "drawSimpleText")),
        (R4 = jf(
          (e, t, r) => {
            if (
              !e ||
              ((r = Object.assign(
                {
                  fontSize: 12,
                  fontWeight: 400,
                  fontFamily: "Arial",
                  joinWith: "<br/>",
                },
                r,
              )),
              Rt.lineBreakRegex.test(e))
            )
              return e;
            let n = e.split(" ").filter(Boolean),
              i = [],
              s = "";
            return (
              n.forEach((o, l) => {
                let u = Yn(`${o} `, r),
                  h = Yn(s, r);
                if (u > t) {
                  let { hyphenatedStrings: p, remainingWord: m } = U1t(
                    o,
                    t,
                    "-",
                    r,
                  );
                  (i.push(s, ...p), (s = m));
                } else
                  h + u >= t
                    ? (i.push(s), (s = o))
                    : (s = [s, o].filter(Boolean).join(" "));
                l + 1 === n.length && i.push(s);
              }),
              i.filter((o) => o !== "").join(r.joinWith)
            );
          },
          (e, t, r) =>
            `${e}${t}${r.fontSize}${r.fontWeight}${r.fontFamily}${r.joinWith}`,
        )),
        (U1t = jf(
          (e, t, r = "-", n) => {
            n = Object.assign(
              { fontSize: 12, fontWeight: 400, fontFamily: "Arial", margin: 0 },
              n,
            );
            let i = [...e],
              s = [],
              o = "";
            return (
              i.forEach((l, u) => {
                let h = `${o}${l}`;
                if (Yn(h, n) >= t) {
                  let d = u + 1,
                    p = i.length === d,
                    m = `${h}${r}`;
                  (s.push(p ? h : m), (o = ""));
                } else o = h;
              }),
              { hyphenatedStrings: s, remainingWord: o }
            );
          },
          (e, t, r = "-", n) =>
            `${e}${t}${r}${n.fontSize}${n.fontWeight}${n.fontFamily}`,
        )));
      a(db, "calculateTextHeight");
      a(Yn, "calculateTextWidth");
      ((D4 = jf(
        (e, t) => {
          let {
            fontSize: r = 12,
            fontFamily: n = "Arial",
            fontWeight: i = 400,
          } = t;
          if (!e) return { width: 0, height: 0 };
          let [, s] = xo(r),
            o = ["sans-serif", n],
            l = e.split(Rt.lineBreakRegex),
            u = [],
            h = xt("body");
          if (!h.remove) return { width: 0, height: 0, lineHeight: 0 };
          let f = h.append("svg");
          for (let p of o) {
            let m = 0,
              g = { width: 0, height: 0, lineHeight: 0 };
            for (let y of l) {
              let b = z1t();
              b.text = y || C4;
              let k = W1t(f, b)
                  .style("font-size", s)
                  .style("font-weight", i)
                  .style("font-family", p),
                T = (k._groups || k)[0][0].getBBox();
              if (T.width === 0 && T.height === 0)
                throw new Error("svg element not in render tree");
              ((g.width = Math.round(Math.max(g.width, T.width))),
                (m = Math.round(T.height)),
                (g.height += m),
                (g.lineHeight = Math.round(Math.max(g.lineHeight, m))));
            }
            u.push(g);
          }
          f.remove();
          let d =
            isNaN(u[1].height) ||
            isNaN(u[1].width) ||
            isNaN(u[1].lineHeight) ||
            (u[0].height > u[1].height &&
              u[0].width > u[1].width &&
              u[0].lineHeight > u[1].lineHeight)
              ? 0
              : 1;
          return u[d];
        },
        (e, t) => `${e}${t.fontSize}${t.fontWeight}${t.fontFamily}`,
      )),
        (_4 = class {
          constructor(t = !1, r) {
            this.count = 0;
            ((this.count = r ? r.length : 0),
              (this.next = t ? () => this.count++ : () => Date.now()));
          }
          static {
            a(this, "InitIDGenerator");
          }
        }),
        (j1t = a(function (e) {
          return (
            (fb = fb || document.createElement("div")),
            (e = escape(e)
              .replace(/%26/g, "&")
              .replace(/%23/g, "#")
              .replace(/%3B/g, ";")),
            (fb.innerHTML = e),
            unescape(fb.textContent)
          );
        }, "entityDecode")));
      a(N4, "isDetailedError");
      ((q1t = a((e, t, r, n) => {
        if (!n) return;
        let i = e.node()?.getBBox();
        i &&
          e
            .append("text")
            .text(n)
            .attr("text-anchor", "middle")
            .attr("x", i.x + i.width / 2)
            .attr("y", -r)
            .attr("class", t);
      }, "insertTitle")),
        (xo = a((e) => {
          if (typeof e == "number") return [e, e + "px"];
          let t = parseInt(e ?? "", 10);
          return Number.isNaN(t)
            ? [void 0, void 0]
            : e === String(t)
              ? [t, e + "px"]
              : [t, e];
        }, "parseFontSize")));
      a(on, "cleanAndMerge");
      ((le = {
        assignWithDepth: Xr,
        wrapLabel: R4,
        calculateTextHeight: db,
        calculateTextWidth: Yn,
        calculateTextDimensions: D4,
        cleanAndMerge: on,
        detectInit: I1t,
        detectDirective: z$,
        isSubstringInArray: M1t,
        interpolateToCurve: w4,
        calcLabelPosition: F1t,
        calcCardinalityPosition: $1t,
        calcTerminalLabelPosition: G1t,
        formatUrl: O1t,
        getStylesFromArray: E4,
        generateId: A4,
        random: L4,
        runFunc: P1t,
        entityDecode: j1t,
        insertTitle: q1t,
        isLabelCoordinateInPath: H1t,
        parseFontSize: xo,
        InitIDGenerator: _4,
      }),
        (j$ = a(function (e) {
          let t = e;
          return (
            (t = t.replace(/style.*:\S*#.*;/g, function (r) {
              return r.substring(0, r.length - 1);
            })),
            (t = t.replace(/classDef.*:\S*#.*;/g, function (r) {
              return r.substring(0, r.length - 1);
            })),
            (t = t.replace(/#\w+;/g, function (r) {
              let n = r.substring(1, r.length - 1);
              return /^\+?\d+$/.test(n)
                ? "\uFB02\xB0\xB0" + n + "\xB6\xDF"
                : "\uFB02\xB0" + n + "\xB6\xDF";
            })),
            t
          );
        }, "encodeEntities")),
        (Xn = a(function (e) {
          return e
            .replace(/ﬂ°°/g, "&#")
            .replace(/ﬂ°/g, "&")
            .replace(/¶ß/g, ";");
        }, "decodeEntities")),
        (Tc = a(
          (e, t, { counter: r = 0, prefix: n, suffix: i }, s) =>
            s || `${n ? `${n}_` : ""}${e}_${t}_${r}${i ? `_${i}` : ""}`,
          "getEdgeId",
        )));
      a(Ir, "handleUndefinedAttr");
      a(H1t, "isLabelCoordinateInPath");
    });
  function $a(e, t, r, n, i) {
    if (!t[e].width)
      if (r)
        ((t[e].text = R4(t[e].text, i, n)),
          (t[e].textLines = t[e].text.split(Rt.lineBreakRegex).length),
          (t[e].width = i),
          (t[e].height = db(t[e].text, n)));
      else {
        let s = t[e].text.split(Rt.lineBreakRegex);
        t[e].textLines = s.length;
        let o = 0;
        ((t[e].height = 0), (t[e].width = 0));
        for (let l of s)
          ((t[e].width = Math.max(Yn(l, n), t[e].width)),
            (o = db(l, n)),
            (t[e].height = t[e].height + o));
      }
  }
  function K$(e, t, r, n, i) {
    let s = new yb(i);
    s.data.widthLimit = r.data.widthLimit / Math.min(I4, n.length);
    for (let [o, l] of n.entries()) {
      let u = 0;
      ((l.image = { width: 0, height: 0, Y: 0 }),
        l.sprite &&
          ((l.image.width = 48),
          (l.image.height = 48),
          (l.image.Y = u),
          (u = l.image.Y + l.image.height)));
      let h = l.wrap && ue.wrap,
        f = pb(ue);
      if (
        ((f.fontSize = f.fontSize + 2),
        (f.fontWeight = "bold"),
        $a("label", l, h, f, s.data.widthLimit),
        (l.label.Y = u + 8),
        (u = l.label.Y + l.label.height),
        l.type && l.type.text !== "")
      ) {
        l.type.text = "[" + l.type.text + "]";
        let g = pb(ue);
        ($a("type", l, h, g, s.data.widthLimit),
          (l.type.Y = u + 5),
          (u = l.type.Y + l.type.height));
      }
      if (l.descr && l.descr.text !== "") {
        let g = pb(ue);
        ((g.fontSize = g.fontSize - 2),
          $a("descr", l, h, g, s.data.widthLimit),
          (l.descr.Y = u + 20),
          (u = l.descr.Y + l.descr.height));
      }
      if (o == 0 || o % I4 === 0) {
        let g = r.data.startx + ue.diagramMarginX,
          y = r.data.stopy + ue.diagramMarginY + u;
        s.setData(g, g, y, y);
      } else {
        let g =
            s.data.stopx !== s.data.startx
              ? s.data.stopx + ue.diagramMarginX
              : s.data.startx,
          y = s.data.starty;
        s.setData(g, g, y, y);
      }
      s.name = l.alias;
      let d = i.db.getC4ShapeArray(l.alias),
        p = i.db.getC4ShapeKeys(l.alias);
      (p.length > 0 && X$(s, e, d, p), (t = l.alias));
      let m = i.db.getBoundaries(t);
      (m.length > 0 && K$(e, t, s, m, i),
        l.alias !== "global" && Y$(e, l, s),
        (r.data.stopy = Math.max(
          s.data.stopy + ue.c4ShapeMargin,
          r.data.stopy,
        )),
        (r.data.stopx = Math.max(
          s.data.stopx + ue.c4ShapeMargin,
          r.data.stopx,
        )),
        (mb = Math.max(mb, r.data.stopx)),
        (gb = Math.max(gb, r.data.stopy)));
    }
  }
  var mb,
    gb,
    H$,
    I4,
    ue,
    yb,
    M4,
    k0,
    pb,
    Y1t,
    Y$,
    X$,
    ss,
    q$,
    X1t,
    K1t,
    Q1t,
    O4,
    Q$ = x(() => {
      "use strict";
      Ge();
      qB();
      Vt();
      xw();
      Be();
      Aw();
      pe();
      of();
      _e();
      On();
      ((mb = 0), (gb = 0), (H$ = 4), (I4 = 2));
      sg.yy = hg;
      ((ue = {}),
        (yb = class {
          static {
            a(this, "Bounds");
          }
          constructor(t) {
            ((this.name = ""),
              (this.data = {}),
              (this.data.startx = void 0),
              (this.data.stopx = void 0),
              (this.data.starty = void 0),
              (this.data.stopy = void 0),
              (this.data.widthLimit = void 0),
              (this.nextData = {}),
              (this.nextData.startx = void 0),
              (this.nextData.stopx = void 0),
              (this.nextData.starty = void 0),
              (this.nextData.stopy = void 0),
              (this.nextData.cnt = 0),
              M4(t.db.getConfig()));
          }
          setData(t, r, n, i) {
            ((this.nextData.startx = this.data.startx = t),
              (this.nextData.stopx = this.data.stopx = r),
              (this.nextData.starty = this.data.starty = n),
              (this.nextData.stopy = this.data.stopy = i));
          }
          updateVal(t, r, n, i) {
            t[r] === void 0 ? (t[r] = n) : (t[r] = i(n, t[r]));
          }
          insert(t) {
            this.nextData.cnt = this.nextData.cnt + 1;
            let r =
                this.nextData.startx === this.nextData.stopx
                  ? this.nextData.stopx + t.margin
                  : this.nextData.stopx + t.margin * 2,
              n = r + t.width,
              i = this.nextData.starty + t.margin * 2,
              s = i + t.height;
            ((r >= this.data.widthLimit ||
              n >= this.data.widthLimit ||
              this.nextData.cnt > H$) &&
              ((r = this.nextData.startx + t.margin + ue.nextLinePaddingX),
              (i = this.nextData.stopy + t.margin * 2),
              (this.nextData.stopx = n = r + t.width),
              (this.nextData.starty = this.nextData.stopy),
              (this.nextData.stopy = s = i + t.height),
              (this.nextData.cnt = 1)),
              (t.x = r),
              (t.y = i),
              this.updateVal(this.data, "startx", r, Math.min),
              this.updateVal(this.data, "starty", i, Math.min),
              this.updateVal(this.data, "stopx", n, Math.max),
              this.updateVal(this.data, "stopy", s, Math.max),
              this.updateVal(this.nextData, "startx", r, Math.min),
              this.updateVal(this.nextData, "starty", i, Math.min),
              this.updateVal(this.nextData, "stopx", n, Math.max),
              this.updateVal(this.nextData, "stopy", s, Math.max));
          }
          init(t) {
            ((this.name = ""),
              (this.data = {
                startx: void 0,
                stopx: void 0,
                starty: void 0,
                stopy: void 0,
                widthLimit: void 0,
              }),
              (this.nextData = {
                startx: void 0,
                stopx: void 0,
                starty: void 0,
                stopy: void 0,
                cnt: 0,
              }),
              M4(t.db.getConfig()));
          }
          bumpLastMargin(t) {
            ((this.data.stopx += t), (this.data.stopy += t));
          }
        }),
        (M4 = a(function (e) {
          (Xr(ue, e),
            e.fontFamily &&
              (ue.personFontFamily =
                ue.systemFontFamily =
                ue.messageFontFamily =
                  e.fontFamily),
            e.fontSize &&
              (ue.personFontSize =
                ue.systemFontSize =
                ue.messageFontSize =
                  e.fontSize),
            e.fontWeight &&
              (ue.personFontWeight =
                ue.systemFontWeight =
                ue.messageFontWeight =
                  e.fontWeight));
        }, "setConf")),
        (k0 = a(
          (e, t) => ({
            fontFamily: e[t + "FontFamily"],
            fontSize: e[t + "FontSize"],
            fontWeight: e[t + "FontWeight"],
          }),
          "c4ShapeFont",
        )),
        (pb = a(
          (e) => ({
            fontFamily: e.boundaryFontFamily,
            fontSize: e.boundaryFontSize,
            fontWeight: e.boundaryFontWeight,
          }),
          "boundaryFont",
        )),
        (Y1t = a(
          (e) => ({
            fontFamily: e.messageFontFamily,
            fontSize: e.messageFontSize,
            fontWeight: e.messageFontWeight,
          }),
          "messageFont",
        )));
      a($a, "calcC4ShapeTextWH");
      ((Y$ = a(function (e, t, r) {
        ((t.x = r.data.startx),
          (t.y = r.data.starty),
          (t.width = r.data.stopx - r.data.startx),
          (t.height = r.data.stopy - r.data.starty),
          (t.label.y = ue.c4ShapeMargin - 35));
        let n = t.wrap && ue.wrap,
          i = pb(ue);
        ((i.fontSize = i.fontSize + 2), (i.fontWeight = "bold"));
        let s = Yn(t.label.text, i);
        ($a("label", t, n, i, s), Pa.drawBoundary(e, t, ue));
      }, "drawBoundary")),
        (X$ = a(function (e, t, r, n) {
          let i = 0;
          for (let s of n) {
            i = 0;
            let o = r[s],
              l = k0(ue, o.typeC4Shape.text);
            switch (
              ((l.fontSize = l.fontSize - 2),
              (o.typeC4Shape.width = Yn(
                "\xAB" + o.typeC4Shape.text + "\xBB",
                l,
              )),
              (o.typeC4Shape.height = l.fontSize + 2),
              (o.typeC4Shape.Y = ue.c4ShapePadding),
              (i = o.typeC4Shape.Y + o.typeC4Shape.height - 4),
              (o.image = { width: 0, height: 0, Y: 0 }),
              o.typeC4Shape.text)
            ) {
              case "person":
              case "external_person":
                ((o.image.width = 48),
                  (o.image.height = 48),
                  (o.image.Y = i),
                  (i = o.image.Y + o.image.height));
                break;
            }
            o.sprite &&
              ((o.image.width = 48),
              (o.image.height = 48),
              (o.image.Y = i),
              (i = o.image.Y + o.image.height));
            let u = o.wrap && ue.wrap,
              h = ue.width - ue.c4ShapePadding * 2,
              f = k0(ue, o.typeC4Shape.text);
            if (
              ((f.fontSize = f.fontSize + 2),
              (f.fontWeight = "bold"),
              $a("label", o, u, f, h),
              (o.label.Y = i + 8),
              (i = o.label.Y + o.label.height),
              o.type && o.type.text !== "")
            ) {
              o.type.text = "[" + o.type.text + "]";
              let m = k0(ue, o.typeC4Shape.text);
              ($a("type", o, u, m, h),
                (o.type.Y = i + 5),
                (i = o.type.Y + o.type.height));
            } else if (o.techn && o.techn.text !== "") {
              o.techn.text = "[" + o.techn.text + "]";
              let m = k0(ue, o.techn.text);
              ($a("techn", o, u, m, h),
                (o.techn.Y = i + 5),
                (i = o.techn.Y + o.techn.height));
            }
            let d = i,
              p = o.label.width;
            if (o.descr && o.descr.text !== "") {
              let m = k0(ue, o.typeC4Shape.text);
              ($a("descr", o, u, m, h),
                (o.descr.Y = i + 20),
                (i = o.descr.Y + o.descr.height),
                (p = Math.max(o.label.width, o.descr.width)),
                (d = i - o.descr.textLines * 5));
            }
            ((p = p + ue.c4ShapePadding),
              (o.width = Math.max(o.width || ue.width, p, ue.width)),
              (o.height = Math.max(o.height || ue.height, d, ue.height)),
              (o.margin = o.margin || ue.c4ShapeMargin),
              e.insert(o),
              Pa.drawC4Shape(t, o, ue));
          }
          e.bumpLastMargin(ue.c4ShapeMargin);
        }, "drawC4ShapeArray")),
        (ss = class {
          static {
            a(this, "Point");
          }
          constructor(t, r) {
            ((this.x = t), (this.y = r));
          }
        }),
        (q$ = a(function (e, t) {
          let r = e.x,
            n = e.y,
            i = t.x,
            s = t.y,
            o = r + e.width / 2,
            l = n + e.height / 2,
            u = Math.abs(r - i),
            h = Math.abs(n - s),
            f = h / u,
            d = e.height / e.width,
            p = null;
          return (
            n == s && r < i
              ? (p = new ss(r + e.width, l))
              : n == s && r > i
                ? (p = new ss(r, l))
                : r == i && n < s
                  ? (p = new ss(o, n + e.height))
                  : r == i && n > s && (p = new ss(o, n)),
            r > i && n < s
              ? d >= f
                ? (p = new ss(r, l + (f * e.width) / 2))
                : (p = new ss(o - ((u / h) * e.height) / 2, n + e.height))
              : r < i && n < s
                ? d >= f
                  ? (p = new ss(r + e.width, l + (f * e.width) / 2))
                  : (p = new ss(o + ((u / h) * e.height) / 2, n + e.height))
                : r < i && n > s
                  ? d >= f
                    ? (p = new ss(r + e.width, l - (f * e.width) / 2))
                    : (p = new ss(o + ((e.height / 2) * u) / h, n))
                  : r > i &&
                    n > s &&
                    (d >= f
                      ? (p = new ss(r, l - (e.width / 2) * f))
                      : (p = new ss(o - ((e.height / 2) * u) / h, n))),
            p
          );
        }, "getIntersectPoint")),
        (X1t = a(function (e, t) {
          let r = { x: 0, y: 0 };
          ((r.x = t.x + t.width / 2), (r.y = t.y + t.height / 2));
          let n = q$(e, r);
          ((r.x = e.x + e.width / 2), (r.y = e.y + e.height / 2));
          let i = q$(t, r);
          return { startPoint: n, endPoint: i };
        }, "getIntersectPoints")),
        (K1t = a(function (e, t, r, n) {
          let i = 0;
          for (let s of t) {
            i = i + 1;
            let o = s.wrap && ue.wrap,
              l = Y1t(ue);
            n.db.getC4Type() === "C4Dynamic" &&
              (s.label.text = i + ": " + s.label.text);
            let h = Yn(s.label.text, l);
            ($a("label", s, o, l, h),
              s.techn &&
                s.techn.text !== "" &&
                ((h = Yn(s.techn.text, l)), $a("techn", s, o, l, h)),
              s.descr &&
                s.descr.text !== "" &&
                ((h = Yn(s.descr.text, l)), $a("descr", s, o, l, h)));
            let f = r(s.from),
              d = r(s.to),
              p = X1t(f, d);
            ((s.startPoint = p.startPoint), (s.endPoint = p.endPoint));
          }
          Pa.drawRels(e, t, ue);
        }, "drawRels")));
      a(K$, "drawInsideBoundary");
      ((Q1t = a(function (e, t, r, n) {
        ue = K().c4;
        let i = K().securityLevel,
          s;
        i === "sandbox" && (s = xt("#i" + t));
        let o =
            i === "sandbox"
              ? xt(s.nodes()[0].contentDocument.body)
              : xt("body"),
          l = n.db;
        (n.db.setWrap(ue.wrap),
          (H$ = l.getC4ShapeInRow()),
          (I4 = l.getC4BoundaryInRow()),
          P.debug(`C:${JSON.stringify(ue, null, 2)}`));
        let u = i === "sandbox" ? o.select(`[id="${t}"]`) : xt(`[id="${t}"]`);
        (Pa.insertComputerIcon(u),
          Pa.insertDatabaseIcon(u),
          Pa.insertClockIcon(u));
        let h = new yb(n);
        (h.setData(
          ue.diagramMarginX,
          ue.diagramMarginX,
          ue.diagramMarginY,
          ue.diagramMarginY,
        ),
          (h.data.widthLimit = screen.availWidth),
          (mb = ue.diagramMarginX),
          (gb = ue.diagramMarginY));
        let f = n.db.getTitle(),
          d = n.db.getBoundaries("");
        (K$(u, "", h, d, n),
          Pa.insertArrowHead(u),
          Pa.insertArrowEnd(u),
          Pa.insertArrowCrossHead(u),
          Pa.insertArrowFilledHead(u),
          K1t(u, n.db.getRels(), n.db.getC4Shape, n),
          (h.data.stopx = mb),
          (h.data.stopy = gb));
        let p = h.data,
          g = p.stopy - p.starty + 2 * ue.diagramMarginY,
          b = p.stopx - p.startx + 2 * ue.diagramMarginX;
        (f &&
          u
            .append("text")
            .text(f)
            .attr("x", (p.stopx - p.startx) / 2 - 4 * ue.diagramMarginX)
            .attr("y", p.starty + ue.diagramMarginY),
          Ar(u, g, b, ue.useMaxWidth));
        let k = f ? 60 : 0;
        (u.attr(
          "viewBox",
          p.startx -
            ue.diagramMarginX +
            " -" +
            (ue.diagramMarginY + k) +
            " " +
            b +
            " " +
            (g + k),
        ),
          P.debug("models:", p));
      }, "draw")),
        (O4 = {
          drawPersonOrSystemArray: X$,
          drawBoundary: Y$,
          setConf: M4,
          draw: Q1t,
        }));
    });
  var Z1t,
    Z$,
    J$ = x(() => {
      "use strict";
      ((Z1t = a(
        (e) => `.person {
    stroke: ${e.personBorder};
    fill: ${e.personBkg};
  }
`,
        "getStyles",
      )),
        (Z$ = Z1t));
    });
  var tG = {};
  Oe(tG, { diagram: () => J1t });
  var J1t,
    eG = x(() => {
      "use strict";
      xw();
      Aw();
      Q$();
      J$();
      J1t = {
        parser: v7,
        db: hg,
        renderer: O4,
        styles: Z$,
        init: a(({ c4: e, wrap: t }) => {
          (O4.setConf(e), hg.setWrap(t));
        }, "init"),
      };
    });
  function bG(e) {
    return typeof e > "u" || e === null;
  }
  function nyt(e) {
    return typeof e == "object" && e !== null;
  }
  function iyt(e) {
    return Array.isArray(e) ? e : bG(e) ? [] : [e];
  }
  function syt(e, t) {
    var r, n, i, s;
    if (t)
      for (s = Object.keys(t), r = 0, n = s.length; r < n; r += 1)
        ((i = s[r]), (e[i] = t[i]));
    return e;
  }
  function ayt(e, t) {
    var r = "",
      n;
    for (n = 0; n < t; n += 1) r += e;
    return r;
  }
  function oyt(e) {
    return e === 0 && Number.NEGATIVE_INFINITY === 1 / e;
  }
  function kG(e, t) {
    var r = "",
      n = e.reason || "(unknown reason)";
    return e.mark
      ? (e.mark.name && (r += 'in "' + e.mark.name + '" '),
        (r += "(" + (e.mark.line + 1) + ":" + (e.mark.column + 1) + ")"),
        !t &&
          e.mark.snippet &&
          (r +=
            `

` + e.mark.snippet),
        n + " " + r)
      : n;
  }
  function S0(e, t) {
    (Error.call(this),
      (this.name = "YAMLException"),
      (this.reason = e),
      (this.mark = t),
      (this.message = kG(this, !1)),
      Error.captureStackTrace
        ? Error.captureStackTrace(this, this.constructor)
        : (this.stack = new Error().stack || ""));
  }
  function P4(e, t, r, n, i) {
    var s = "",
      o = "",
      l = Math.floor(i / 2) - 1;
    return (
      n - t > l && ((s = " ... "), (t = n - l + s.length)),
      r - n > l && ((o = " ..."), (r = n + l - o.length)),
      {
        str: s + e.slice(t, r).replace(/\t/g, "\u2192") + o,
        pos: n - t + s.length,
      }
    );
  }
  function B4(e, t) {
    return Bn.repeat(" ", t - e.length) + e;
  }
  function pyt(e, t) {
    if (((t = Object.create(t || null)), !e.buffer)) return null;
    (t.maxLength || (t.maxLength = 79),
      typeof t.indent != "number" && (t.indent = 1),
      typeof t.linesBefore != "number" && (t.linesBefore = 3),
      typeof t.linesAfter != "number" && (t.linesAfter = 2));
    for (
      var r = /\r?\n|\r|\0/g, n = [0], i = [], s, o = -1;
      (s = r.exec(e.buffer));

    )
      (i.push(s.index),
        n.push(s.index + s[0].length),
        e.position <= s.index && o < 0 && (o = n.length - 2));
    o < 0 && (o = n.length - 1);
    var l = "",
      u,
      h,
      f = Math.min(e.line + t.linesAfter, i.length).toString().length,
      d = t.maxLength - (t.indent + f + 3);
    for (u = 1; u <= t.linesBefore && !(o - u < 0); u++)
      ((h = P4(
        e.buffer,
        n[o - u],
        i[o - u],
        e.position - (n[o] - n[o - u]),
        d,
      )),
        (l =
          Bn.repeat(" ", t.indent) +
          B4((e.line - u + 1).toString(), f) +
          " | " +
          h.str +
          `
` +
          l));
    for (
      h = P4(e.buffer, n[o], i[o], e.position, d),
        l +=
          Bn.repeat(" ", t.indent) +
          B4((e.line + 1).toString(), f) +
          " | " +
          h.str +
          `
`,
        l +=
          Bn.repeat("-", t.indent + f + 3 + h.pos) +
          `^
`,
        u = 1;
      u <= t.linesAfter && !(o + u >= i.length);
      u++
    )
      ((h = P4(
        e.buffer,
        n[o + u],
        i[o + u],
        e.position - (n[o] - n[o + u]),
        d,
      )),
        (l +=
          Bn.repeat(" ", t.indent) +
          B4((e.line + u + 1).toString(), f) +
          " | " +
          h.str +
          `
`));
    return l.replace(/\n$/, "");
  }
  function xyt(e) {
    var t = {};
    return (
      e !== null &&
        Object.keys(e).forEach(function (r) {
          e[r].forEach(function (n) {
            t[String(n)] = r;
          });
        }),
      t
    );
  }
  function byt(e, t) {
    if (
      ((t = t || {}),
      Object.keys(t).forEach(function (r) {
        if (gyt.indexOf(r) === -1)
          throw new as(
            'Unknown option "' +
              r +
              '" is met in definition of "' +
              e +
              '" YAML type.',
          );
      }),
      (this.options = t),
      (this.tag = e),
      (this.kind = t.kind || null),
      (this.resolve =
        t.resolve ||
        function () {
          return !0;
        }),
      (this.construct =
        t.construct ||
        function (r) {
          return r;
        }),
      (this.instanceOf = t.instanceOf || null),
      (this.predicate = t.predicate || null),
      (this.represent = t.represent || null),
      (this.representName = t.representName || null),
      (this.defaultStyle = t.defaultStyle || null),
      (this.multi = t.multi || !1),
      (this.styleAliases = xyt(t.styleAliases || null)),
      yyt.indexOf(this.kind) === -1)
    )
      throw new as(
        'Unknown kind "' +
          this.kind +
          '" is specified for "' +
          e +
          '" YAML type.',
      );
  }
  function iG(e, t) {
    var r = [];
    return (
      e[t].forEach(function (n) {
        var i = r.length;
        (r.forEach(function (s, o) {
          s.tag === n.tag &&
            s.kind === n.kind &&
            s.multi === n.multi &&
            (i = o);
        }),
          (r[i] = n));
      }),
      r
    );
  }
  function kyt() {
    var e = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {},
        multi: { scalar: [], sequence: [], mapping: [], fallback: [] },
      },
      t,
      r;
    function n(i) {
      i.multi
        ? (e.multi[i.kind].push(i), e.multi.fallback.push(i))
        : (e[i.kind][i.tag] = e.fallback[i.tag] = i);
    }
    for (a(n, "collectType"), t = 0, r = arguments.length; t < r; t += 1)
      arguments[t].forEach(n);
    return e;
  }
  function $4(e) {
    return this.extend(e);
  }
  function vyt(e) {
    if (e === null) return !0;
    var t = e.length;
    return (
      (t === 1 && e === "~") ||
      (t === 4 && (e === "null" || e === "Null" || e === "NULL"))
    );
  }
  function Eyt() {
    return null;
  }
  function Ayt(e) {
    return e === null;
  }
  function Ryt(e) {
    if (e === null) return !1;
    var t = e.length;
    return (
      (t === 4 && (e === "true" || e === "True" || e === "TRUE")) ||
      (t === 5 && (e === "false" || e === "False" || e === "FALSE"))
    );
  }
  function Dyt(e) {
    return e === "true" || e === "True" || e === "TRUE";
  }
  function Nyt(e) {
    return Object.prototype.toString.call(e) === "[object Boolean]";
  }
  function Myt(e) {
    return (
      (48 <= e && e <= 57) || (65 <= e && e <= 70) || (97 <= e && e <= 102)
    );
  }
  function Oyt(e) {
    return 48 <= e && e <= 55;
  }
  function Pyt(e) {
    return 48 <= e && e <= 57;
  }
  function Byt(e) {
    if (e === null) return !1;
    var t = e.length,
      r = 0,
      n = !1,
      i;
    if (!t) return !1;
    if (((i = e[r]), (i === "-" || i === "+") && (i = e[++r]), i === "0")) {
      if (r + 1 === t) return !0;
      if (((i = e[++r]), i === "b")) {
        for (r++; r < t; r++)
          if (((i = e[r]), i !== "_")) {
            if (i !== "0" && i !== "1") return !1;
            n = !0;
          }
        return n && i !== "_";
      }
      if (i === "x") {
        for (r++; r < t; r++)
          if (((i = e[r]), i !== "_")) {
            if (!Myt(e.charCodeAt(r))) return !1;
            n = !0;
          }
        return n && i !== "_";
      }
      if (i === "o") {
        for (r++; r < t; r++)
          if (((i = e[r]), i !== "_")) {
            if (!Oyt(e.charCodeAt(r))) return !1;
            n = !0;
          }
        return n && i !== "_";
      }
    }
    if (i === "_") return !1;
    for (; r < t; r++)
      if (((i = e[r]), i !== "_")) {
        if (!Pyt(e.charCodeAt(r))) return !1;
        n = !0;
      }
    return !(!n || i === "_");
  }
  function Fyt(e) {
    var t = e,
      r = 1,
      n;
    if (
      (t.indexOf("_") !== -1 && (t = t.replace(/_/g, "")),
      (n = t[0]),
      (n === "-" || n === "+") &&
        (n === "-" && (r = -1), (t = t.slice(1)), (n = t[0])),
      t === "0")
    )
      return 0;
    if (n === "0") {
      if (t[1] === "b") return r * parseInt(t.slice(2), 2);
      if (t[1] === "x") return r * parseInt(t.slice(2), 16);
      if (t[1] === "o") return r * parseInt(t.slice(2), 8);
    }
    return r * parseInt(t, 10);
  }
  function $yt(e) {
    return (
      Object.prototype.toString.call(e) === "[object Number]" &&
      e % 1 === 0 &&
      !Bn.isNegativeZero(e)
    );
  }
  function zyt(e) {
    return !(e === null || !Vyt.test(e) || e[e.length - 1] === "_");
  }
  function Wyt(e) {
    var t, r;
    return (
      (t = e.replace(/_/g, "").toLowerCase()),
      (r = t[0] === "-" ? -1 : 1),
      "+-".indexOf(t[0]) >= 0 && (t = t.slice(1)),
      t === ".inf"
        ? r === 1
          ? Number.POSITIVE_INFINITY
          : Number.NEGATIVE_INFINITY
        : t === ".nan"
          ? NaN
          : r * parseFloat(t, 10)
    );
  }
  function jyt(e, t) {
    var r;
    if (isNaN(e))
      switch (t) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === e)
      switch (t) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === e)
      switch (t) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (Bn.isNegativeZero(e)) return "-0.0";
    return ((r = e.toString(10)), Uyt.test(r) ? r.replace("e", ".e") : r);
  }
  function qyt(e) {
    return (
      Object.prototype.toString.call(e) === "[object Number]" &&
      (e % 1 !== 0 || Bn.isNegativeZero(e))
    );
  }
  function Xyt(e) {
    return e === null ? !1 : SG.exec(e) !== null || _G.exec(e) !== null;
  }
  function Kyt(e) {
    var t,
      r,
      n,
      i,
      s,
      o,
      l,
      u = 0,
      h = null,
      f,
      d,
      p;
    if (((t = SG.exec(e)), t === null && (t = _G.exec(e)), t === null))
      throw new Error("Date resolve error");
    if (((r = +t[1]), (n = +t[2] - 1), (i = +t[3]), !t[4]))
      return new Date(Date.UTC(r, n, i));
    if (((s = +t[4]), (o = +t[5]), (l = +t[6]), t[7])) {
      for (u = t[7].slice(0, 3); u.length < 3; ) u += "0";
      u = +u;
    }
    return (
      t[9] &&
        ((f = +t[10]),
        (d = +(t[11] || 0)),
        (h = (f * 60 + d) * 6e4),
        t[9] === "-" && (h = -h)),
      (p = new Date(Date.UTC(r, n, i, s, o, l, u))),
      h && p.setTime(p.getTime() - h),
      p
    );
  }
  function Qyt(e) {
    return e.toISOString();
  }
  function Jyt(e) {
    return e === "<<" || e === null;
  }
  function ext(e) {
    if (e === null) return !1;
    var t,
      r,
      n = 0,
      i = e.length,
      s = U4;
    for (r = 0; r < i; r++)
      if (((t = s.indexOf(e.charAt(r))), !(t > 64))) {
        if (t < 0) return !1;
        n += 6;
      }
    return n % 8 === 0;
  }
  function rxt(e) {
    var t,
      r,
      n = e.replace(/[\r\n=]/g, ""),
      i = n.length,
      s = U4,
      o = 0,
      l = [];
    for (t = 0; t < i; t++)
      (t % 4 === 0 &&
        t &&
        (l.push((o >> 16) & 255), l.push((o >> 8) & 255), l.push(o & 255)),
        (o = (o << 6) | s.indexOf(n.charAt(t))));
    return (
      (r = (i % 4) * 6),
      r === 0
        ? (l.push((o >> 16) & 255), l.push((o >> 8) & 255), l.push(o & 255))
        : r === 18
          ? (l.push((o >> 10) & 255), l.push((o >> 2) & 255))
          : r === 12 && l.push((o >> 4) & 255),
      new Uint8Array(l)
    );
  }
  function nxt(e) {
    var t = "",
      r = 0,
      n,
      i,
      s = e.length,
      o = U4;
    for (n = 0; n < s; n++)
      (n % 3 === 0 &&
        n &&
        ((t += o[(r >> 18) & 63]),
        (t += o[(r >> 12) & 63]),
        (t += o[(r >> 6) & 63]),
        (t += o[r & 63])),
        (r = (r << 8) + e[n]));
    return (
      (i = s % 3),
      i === 0
        ? ((t += o[(r >> 18) & 63]),
          (t += o[(r >> 12) & 63]),
          (t += o[(r >> 6) & 63]),
          (t += o[r & 63]))
        : i === 2
          ? ((t += o[(r >> 10) & 63]),
            (t += o[(r >> 4) & 63]),
            (t += o[(r << 2) & 63]),
            (t += o[64]))
          : i === 1 &&
            ((t += o[(r >> 2) & 63]),
            (t += o[(r << 4) & 63]),
            (t += o[64]),
            (t += o[64])),
      t
    );
  }
  function ixt(e) {
    return Object.prototype.toString.call(e) === "[object Uint8Array]";
  }
  function lxt(e) {
    if (e === null) return !0;
    var t = [],
      r,
      n,
      i,
      s,
      o,
      l = e;
    for (r = 0, n = l.length; r < n; r += 1) {
      if (((i = l[r]), (o = !1), oxt.call(i) !== "[object Object]")) return !1;
      for (s in i)
        if (axt.call(i, s))
          if (!o) o = !0;
          else return !1;
      if (!o) return !1;
      if (t.indexOf(s) === -1) t.push(s);
      else return !1;
    }
    return !0;
  }
  function cxt(e) {
    return e !== null ? e : [];
  }
  function fxt(e) {
    if (e === null) return !0;
    var t,
      r,
      n,
      i,
      s,
      o = e;
    for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1) {
      if (
        ((n = o[t]),
        hxt.call(n) !== "[object Object]" ||
          ((i = Object.keys(n)), i.length !== 1))
      )
        return !1;
      s[t] = [i[0], n[i[0]]];
    }
    return !0;
  }
  function dxt(e) {
    if (e === null) return [];
    var t,
      r,
      n,
      i,
      s,
      o = e;
    for (s = new Array(o.length), t = 0, r = o.length; t < r; t += 1)
      ((n = o[t]), (i = Object.keys(n)), (s[t] = [i[0], n[i[0]]]));
    return s;
  }
  function gxt(e) {
    if (e === null) return !0;
    var t,
      r = e;
    for (t in r) if (mxt.call(r, t) && r[t] !== null) return !1;
    return !0;
  }
  function yxt(e) {
    return e !== null ? e : {};
  }
  function aG(e) {
    return Object.prototype.toString.call(e);
  }
  function bo(e) {
    return e === 10 || e === 13;
  }
  function Ku(e) {
    return e === 9 || e === 32;
  }
  function os(e) {
    return e === 9 || e === 32 || e === 10 || e === 13;
  }
  function ad(e) {
    return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
  }
  function _xt(e) {
    var t;
    return 48 <= e && e <= 57
      ? e - 48
      : ((t = e | 32), 97 <= t && t <= 102 ? t - 97 + 10 : -1);
  }
  function Cxt(e) {
    return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
  }
  function wxt(e) {
    return 48 <= e && e <= 57 ? e - 48 : -1;
  }
  function oG(e) {
    return e === 48
      ? "\0"
      : e === 97
        ? "\x07"
        : e === 98
          ? "\b"
          : e === 116 || e === 9
            ? "	"
            : e === 110
              ? `
`
              : e === 118
                ? "\v"
                : e === 102
                  ? "\f"
                  : e === 114
                    ? "\r"
                    : e === 101
                      ? "\x1B"
                      : e === 32
                        ? " "
                        : e === 34
                          ? '"'
                          : e === 47
                            ? "/"
                            : e === 92
                              ? "\\"
                              : e === 78
                                ? "\x85"
                                : e === 95
                                  ? "\xA0"
                                  : e === 76
                                    ? "\u2028"
                                    : e === 80
                                      ? "\u2029"
                                      : "";
  }
  function vxt(e) {
    return e <= 65535
      ? String.fromCharCode(e)
      : String.fromCharCode(
          ((e - 65536) >> 10) + 55296,
          ((e - 65536) & 1023) + 56320,
        );
  }
  function Ext(e, t) {
    ((this.input = e),
      (this.filename = t.filename || null),
      (this.schema = t.schema || CG),
      (this.onWarning = t.onWarning || null),
      (this.legacy = t.legacy || !1),
      (this.json = t.json || !1),
      (this.listener = t.listener || null),
      (this.implicitTypes = this.schema.compiledImplicit),
      (this.typeMap = this.schema.compiledTypeMap),
      (this.length = e.length),
      (this.position = 0),
      (this.line = 0),
      (this.lineStart = 0),
      (this.lineIndent = 0),
      (this.firstTabInLine = -1),
      (this.documents = []));
  }
  function DG(e, t) {
    var r = {
      name: e.filename,
      buffer: e.input.slice(0, -1),
      position: e.position,
      line: e.line,
      column: e.position - e.lineStart,
    };
    return ((r.snippet = myt(r)), new as(t, r));
  }
  function me(e, t) {
    throw DG(e, t);
  }
  function kb(e, t) {
    e.onWarning && e.onWarning.call(null, DG(e, t));
  }
  function Sc(e, t, r, n) {
    var i, s, o, l;
    if (t < r) {
      if (((l = e.input.slice(t, r)), n))
        for (i = 0, s = l.length; i < s; i += 1)
          ((o = l.charCodeAt(i)),
            o === 9 ||
              (32 <= o && o <= 1114111) ||
              me(e, "expected valid JSON character"));
      else kxt.test(l) && me(e, "the stream contains non-printable characters");
      e.result += l;
    }
  }
  function cG(e, t, r, n) {
    var i, s, o, l;
    for (
      Bn.isObject(r) ||
        me(
          e,
          "cannot merge mappings; the provided source object is unacceptable",
        ),
        i = Object.keys(r),
        o = 0,
        l = i.length;
      o < l;
      o += 1
    )
      ((s = i[o]), _c.call(t, s) || ((t[s] = r[s]), (n[s] = !0)));
  }
  function od(e, t, r, n, i, s, o, l, u) {
    var h, f;
    if (Array.isArray(i))
      for (
        i = Array.prototype.slice.call(i), h = 0, f = i.length;
        h < f;
        h += 1
      )
        (Array.isArray(i[h]) &&
          me(e, "nested arrays are not supported inside keys"),
          typeof i == "object" &&
            aG(i[h]) === "[object Object]" &&
            (i[h] = "[object Object]"));
    if (
      (typeof i == "object" &&
        aG(i) === "[object Object]" &&
        (i = "[object Object]"),
      (i = String(i)),
      t === null && (t = {}),
      n === "tag:yaml.org,2002:merge")
    )
      if (Array.isArray(s))
        for (h = 0, f = s.length; h < f; h += 1) cG(e, t, s[h], r);
      else cG(e, t, s, r);
    else
      (!e.json &&
        !_c.call(r, i) &&
        _c.call(t, i) &&
        ((e.line = o || e.line),
        (e.lineStart = l || e.lineStart),
        (e.position = u || e.position),
        me(e, "duplicated mapping key")),
        i === "__proto__"
          ? Object.defineProperty(t, i, {
              configurable: !0,
              enumerable: !0,
              writable: !0,
              value: s,
            })
          : (t[i] = s),
        delete r[i]);
    return t;
  }
  function j4(e) {
    var t;
    ((t = e.input.charCodeAt(e.position)),
      t === 10
        ? e.position++
        : t === 13
          ? (e.position++,
            e.input.charCodeAt(e.position) === 10 && e.position++)
          : me(e, "a line break is expected"),
      (e.line += 1),
      (e.lineStart = e.position),
      (e.firstTabInLine = -1));
  }
  function En(e, t, r) {
    for (var n = 0, i = e.input.charCodeAt(e.position); i !== 0; ) {
      for (; Ku(i); )
        (i === 9 && e.firstTabInLine === -1 && (e.firstTabInLine = e.position),
          (i = e.input.charCodeAt(++e.position)));
      if (t && i === 35)
        do i = e.input.charCodeAt(++e.position);
        while (i !== 10 && i !== 13 && i !== 0);
      if (bo(i))
        for (
          j4(e), i = e.input.charCodeAt(e.position), n++, e.lineIndent = 0;
          i === 32;

        )
          (e.lineIndent++, (i = e.input.charCodeAt(++e.position)));
      else break;
    }
    return (
      r !== -1 && n !== 0 && e.lineIndent < r && kb(e, "deficient indentation"),
      n
    );
  }
  function _b(e) {
    var t = e.position,
      r;
    return (
      (r = e.input.charCodeAt(t)),
      !!(
        (r === 45 || r === 46) &&
        r === e.input.charCodeAt(t + 1) &&
        r === e.input.charCodeAt(t + 2) &&
        ((t += 3), (r = e.input.charCodeAt(t)), r === 0 || os(r))
      )
    );
  }
  function q4(e, t) {
    t === 1
      ? (e.result += " ")
      : t > 1 &&
        (e.result += Bn.repeat(
          `
`,
          t - 1,
        ));
  }
  function Axt(e, t, r) {
    var n,
      i,
      s,
      o,
      l,
      u,
      h,
      f,
      d = e.kind,
      p = e.result,
      m;
    if (
      ((m = e.input.charCodeAt(e.position)),
      os(m) ||
        ad(m) ||
        m === 35 ||
        m === 38 ||
        m === 42 ||
        m === 33 ||
        m === 124 ||
        m === 62 ||
        m === 39 ||
        m === 34 ||
        m === 37 ||
        m === 64 ||
        m === 96 ||
        ((m === 63 || m === 45) &&
          ((i = e.input.charCodeAt(e.position + 1)), os(i) || (r && ad(i)))))
    )
      return !1;
    for (
      e.kind = "scalar", e.result = "", s = o = e.position, l = !1;
      m !== 0;

    ) {
      if (m === 58) {
        if (((i = e.input.charCodeAt(e.position + 1)), os(i) || (r && ad(i))))
          break;
      } else if (m === 35) {
        if (((n = e.input.charCodeAt(e.position - 1)), os(n))) break;
      } else {
        if ((e.position === e.lineStart && _b(e)) || (r && ad(m))) break;
        if (bo(m))
          if (
            ((u = e.line),
            (h = e.lineStart),
            (f = e.lineIndent),
            En(e, !1, -1),
            e.lineIndent >= t)
          ) {
            ((l = !0), (m = e.input.charCodeAt(e.position)));
            continue;
          } else {
            ((e.position = o),
              (e.line = u),
              (e.lineStart = h),
              (e.lineIndent = f));
            break;
          }
      }
      (l &&
        (Sc(e, s, o, !1), q4(e, e.line - u), (s = o = e.position), (l = !1)),
        Ku(m) || (o = e.position + 1),
        (m = e.input.charCodeAt(++e.position)));
    }
    return (
      Sc(e, s, o, !1),
      e.result ? !0 : ((e.kind = d), (e.result = p), !1)
    );
  }
  function Lxt(e, t) {
    var r, n, i;
    if (((r = e.input.charCodeAt(e.position)), r !== 39)) return !1;
    for (
      e.kind = "scalar", e.result = "", e.position++, n = i = e.position;
      (r = e.input.charCodeAt(e.position)) !== 0;

    )
      if (r === 39)
        if (
          (Sc(e, n, e.position, !0),
          (r = e.input.charCodeAt(++e.position)),
          r === 39)
        )
          ((n = e.position), e.position++, (i = e.position));
        else return !0;
      else
        bo(r)
          ? (Sc(e, n, i, !0), q4(e, En(e, !1, t)), (n = i = e.position))
          : e.position === e.lineStart && _b(e)
            ? me(
                e,
                "unexpected end of the document within a single quoted scalar",
              )
            : (e.position++, (i = e.position));
    me(e, "unexpected end of the stream within a single quoted scalar");
  }
  function Rxt(e, t) {
    var r, n, i, s, o, l;
    if (((l = e.input.charCodeAt(e.position)), l !== 34)) return !1;
    for (
      e.kind = "scalar", e.result = "", e.position++, r = n = e.position;
      (l = e.input.charCodeAt(e.position)) !== 0;

    ) {
      if (l === 34) return (Sc(e, r, e.position, !0), e.position++, !0);
      if (l === 92) {
        if (
          (Sc(e, r, e.position, !0),
          (l = e.input.charCodeAt(++e.position)),
          bo(l))
        )
          En(e, !1, t);
        else if (l < 256 && LG[l]) ((e.result += RG[l]), e.position++);
        else if ((o = Cxt(l)) > 0) {
          for (i = o, s = 0; i > 0; i--)
            ((l = e.input.charCodeAt(++e.position)),
              (o = _xt(l)) >= 0
                ? (s = (s << 4) + o)
                : me(e, "expected hexadecimal character"));
          ((e.result += vxt(s)), e.position++);
        } else me(e, "unknown escape sequence");
        r = n = e.position;
      } else
        bo(l)
          ? (Sc(e, r, n, !0), q4(e, En(e, !1, t)), (r = n = e.position))
          : e.position === e.lineStart && _b(e)
            ? me(
                e,
                "unexpected end of the document within a double quoted scalar",
              )
            : (e.position++, (n = e.position));
    }
    me(e, "unexpected end of the stream within a double quoted scalar");
  }
  function Dxt(e, t) {
    var r = !0,
      n,
      i,
      s,
      o = e.tag,
      l,
      u = e.anchor,
      h,
      f,
      d,
      p,
      m,
      g = Object.create(null),
      y,
      b,
      k,
      T;
    if (((T = e.input.charCodeAt(e.position)), T === 91))
      ((f = 93), (m = !1), (l = []));
    else if (T === 123) ((f = 125), (m = !0), (l = {}));
    else return !1;
    for (
      e.anchor !== null && (e.anchorMap[e.anchor] = l),
        T = e.input.charCodeAt(++e.position);
      T !== 0;

    ) {
      if ((En(e, !0, t), (T = e.input.charCodeAt(e.position)), T === f))
        return (
          e.position++,
          (e.tag = o),
          (e.anchor = u),
          (e.kind = m ? "mapping" : "sequence"),
          (e.result = l),
          !0
        );
      (r
        ? T === 44 && me(e, "expected the node content, but found ','")
        : me(e, "missed comma between flow collection entries"),
        (b = y = k = null),
        (d = p = !1),
        T === 63 &&
          ((h = e.input.charCodeAt(e.position + 1)),
          os(h) && ((d = p = !0), e.position++, En(e, !0, t))),
        (n = e.line),
        (i = e.lineStart),
        (s = e.position),
        ld(e, t, xb, !1, !0),
        (b = e.tag),
        (y = e.result),
        En(e, !0, t),
        (T = e.input.charCodeAt(e.position)),
        (p || e.line === n) &&
          T === 58 &&
          ((d = !0),
          (T = e.input.charCodeAt(++e.position)),
          En(e, !0, t),
          ld(e, t, xb, !1, !0),
          (k = e.result)),
        m
          ? od(e, l, g, b, y, k, n, i, s)
          : d
            ? l.push(od(e, null, g, b, y, k, n, i, s))
            : l.push(y),
        En(e, !0, t),
        (T = e.input.charCodeAt(e.position)),
        T === 44
          ? ((r = !0), (T = e.input.charCodeAt(++e.position)))
          : (r = !1));
    }
    me(e, "unexpected end of the stream within a flow collection");
  }
  function Nxt(e, t) {
    var r,
      n,
      i = F4,
      s = !1,
      o = !1,
      l = t,
      u = 0,
      h = !1,
      f,
      d;
    if (((d = e.input.charCodeAt(e.position)), d === 124)) n = !1;
    else if (d === 62) n = !0;
    else return !1;
    for (e.kind = "scalar", e.result = ""; d !== 0; )
      if (((d = e.input.charCodeAt(++e.position)), d === 43 || d === 45))
        F4 === i
          ? (i = d === 43 ? sG : bxt)
          : me(e, "repeat of a chomping mode identifier");
      else if ((f = wxt(d)) >= 0)
        f === 0
          ? me(
              e,
              "bad explicit indentation width of a block scalar; it cannot be less than one",
            )
          : o
            ? me(e, "repeat of an indentation width identifier")
            : ((l = t + f - 1), (o = !0));
      else break;
    if (Ku(d)) {
      do d = e.input.charCodeAt(++e.position);
      while (Ku(d));
      if (d === 35)
        do d = e.input.charCodeAt(++e.position);
        while (!bo(d) && d !== 0);
    }
    for (; d !== 0; ) {
      for (
        j4(e), e.lineIndent = 0, d = e.input.charCodeAt(e.position);
        (!o || e.lineIndent < l) && d === 32;

      )
        (e.lineIndent++, (d = e.input.charCodeAt(++e.position)));
      if ((!o && e.lineIndent > l && (l = e.lineIndent), bo(d))) {
        u++;
        continue;
      }
      if (e.lineIndent < l) {
        i === sG
          ? (e.result += Bn.repeat(
              `
`,
              s ? 1 + u : u,
            ))
          : i === F4 &&
            s &&
            (e.result += `
`);
        break;
      }
      for (
        n
          ? Ku(d)
            ? ((h = !0),
              (e.result += Bn.repeat(
                `
`,
                s ? 1 + u : u,
              )))
            : h
              ? ((h = !1),
                (e.result += Bn.repeat(
                  `
`,
                  u + 1,
                )))
              : u === 0
                ? s && (e.result += " ")
                : (e.result += Bn.repeat(
                    `
`,
                    u,
                  ))
          : (e.result += Bn.repeat(
              `
`,
              s ? 1 + u : u,
            )),
          s = !0,
          o = !0,
          u = 0,
          r = e.position;
        !bo(d) && d !== 0;

      )
        d = e.input.charCodeAt(++e.position);
      Sc(e, r, e.position, !1);
    }
    return !0;
  }
  function uG(e, t) {
    var r,
      n = e.tag,
      i = e.anchor,
      s = [],
      o,
      l = !1,
      u;
    if (e.firstTabInLine !== -1) return !1;
    for (
      e.anchor !== null && (e.anchorMap[e.anchor] = s),
        u = e.input.charCodeAt(e.position);
      u !== 0 &&
      (e.firstTabInLine !== -1 &&
        ((e.position = e.firstTabInLine),
        me(e, "tab characters must not be used in indentation")),
      !(u !== 45 || ((o = e.input.charCodeAt(e.position + 1)), !os(o))));

    ) {
      if (((l = !0), e.position++, En(e, !0, -1) && e.lineIndent <= t)) {
        (s.push(null), (u = e.input.charCodeAt(e.position)));
        continue;
      }
      if (
        ((r = e.line),
        ld(e, t, vG, !1, !0),
        s.push(e.result),
        En(e, !0, -1),
        (u = e.input.charCodeAt(e.position)),
        (e.line === r || e.lineIndent > t) && u !== 0)
      )
        me(e, "bad indentation of a sequence entry");
      else if (e.lineIndent < t) break;
    }
    return l
      ? ((e.tag = n), (e.anchor = i), (e.kind = "sequence"), (e.result = s), !0)
      : !1;
  }
  function Ixt(e, t, r) {
    var n,
      i,
      s,
      o,
      l,
      u,
      h = e.tag,
      f = e.anchor,
      d = {},
      p = Object.create(null),
      m = null,
      g = null,
      y = null,
      b = !1,
      k = !1,
      T;
    if (e.firstTabInLine !== -1) return !1;
    for (
      e.anchor !== null && (e.anchorMap[e.anchor] = d),
        T = e.input.charCodeAt(e.position);
      T !== 0;

    ) {
      if (
        (!b &&
          e.firstTabInLine !== -1 &&
          ((e.position = e.firstTabInLine),
          me(e, "tab characters must not be used in indentation")),
        (n = e.input.charCodeAt(e.position + 1)),
        (s = e.line),
        (T === 63 || T === 58) && os(n))
      )
        (T === 63
          ? (b && (od(e, d, p, m, g, null, o, l, u), (m = g = y = null)),
            (k = !0),
            (b = !0),
            (i = !0))
          : b
            ? ((b = !1), (i = !0))
            : me(
                e,
                "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line",
              ),
          (e.position += 1),
          (T = n));
      else {
        if (
          ((o = e.line),
          (l = e.lineStart),
          (u = e.position),
          !ld(e, r, wG, !1, !0))
        )
          break;
        if (e.line === s) {
          for (T = e.input.charCodeAt(e.position); Ku(T); )
            T = e.input.charCodeAt(++e.position);
          if (T === 58)
            ((T = e.input.charCodeAt(++e.position)),
              os(T) ||
                me(
                  e,
                  "a whitespace character is expected after the key-value separator within a block mapping",
                ),
              b && (od(e, d, p, m, g, null, o, l, u), (m = g = y = null)),
              (k = !0),
              (b = !1),
              (i = !1),
              (m = e.tag),
              (g = e.result));
          else if (k)
            me(e, "can not read an implicit mapping pair; a colon is missed");
          else return ((e.tag = h), (e.anchor = f), !0);
        } else if (k)
          me(
            e,
            "can not read a block mapping entry; a multiline key may not be an implicit key",
          );
        else return ((e.tag = h), (e.anchor = f), !0);
      }
      if (
        ((e.line === s || e.lineIndent > t) &&
          (b && ((o = e.line), (l = e.lineStart), (u = e.position)),
          ld(e, t, bb, !0, i) && (b ? (g = e.result) : (y = e.result)),
          b || (od(e, d, p, m, g, y, o, l, u), (m = g = y = null)),
          En(e, !0, -1),
          (T = e.input.charCodeAt(e.position))),
        (e.line === s || e.lineIndent > t) && T !== 0)
      )
        me(e, "bad indentation of a mapping entry");
      else if (e.lineIndent < t) break;
    }
    return (
      b && od(e, d, p, m, g, null, o, l, u),
      k && ((e.tag = h), (e.anchor = f), (e.kind = "mapping"), (e.result = d)),
      k
    );
  }
  function Mxt(e) {
    var t,
      r = !1,
      n = !1,
      i,
      s,
      o;
    if (((o = e.input.charCodeAt(e.position)), o !== 33)) return !1;
    if (
      (e.tag !== null && me(e, "duplication of a tag property"),
      (o = e.input.charCodeAt(++e.position)),
      o === 60
        ? ((r = !0), (o = e.input.charCodeAt(++e.position)))
        : o === 33
          ? ((n = !0), (i = "!!"), (o = e.input.charCodeAt(++e.position)))
          : (i = "!"),
      (t = e.position),
      r)
    ) {
      do o = e.input.charCodeAt(++e.position);
      while (o !== 0 && o !== 62);
      e.position < e.length
        ? ((s = e.input.slice(t, e.position)),
          (o = e.input.charCodeAt(++e.position)))
        : me(e, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; o !== 0 && !os(o); )
        (o === 33 &&
          (n
            ? me(e, "tag suffix cannot contain exclamation marks")
            : ((i = e.input.slice(t - 1, e.position + 1)),
              EG.test(i) ||
                me(e, "named tag handle cannot contain such characters"),
              (n = !0),
              (t = e.position + 1))),
          (o = e.input.charCodeAt(++e.position)));
      ((s = e.input.slice(t, e.position)),
        Sxt.test(s) &&
          me(e, "tag suffix cannot contain flow indicator characters"));
    }
    s && !AG.test(s) && me(e, "tag name cannot contain such characters: " + s);
    try {
      s = decodeURIComponent(s);
    } catch {
      me(e, "tag name is malformed: " + s);
    }
    return (
      r
        ? (e.tag = s)
        : _c.call(e.tagMap, i)
          ? (e.tag = e.tagMap[i] + s)
          : i === "!"
            ? (e.tag = "!" + s)
            : i === "!!"
              ? (e.tag = "tag:yaml.org,2002:" + s)
              : me(e, 'undeclared tag handle "' + i + '"'),
      !0
    );
  }
  function Oxt(e) {
    var t, r;
    if (((r = e.input.charCodeAt(e.position)), r !== 38)) return !1;
    for (
      e.anchor !== null && me(e, "duplication of an anchor property"),
        r = e.input.charCodeAt(++e.position),
        t = e.position;
      r !== 0 && !os(r) && !ad(r);

    )
      r = e.input.charCodeAt(++e.position);
    return (
      e.position === t &&
        me(e, "name of an anchor node must contain at least one character"),
      (e.anchor = e.input.slice(t, e.position)),
      !0
    );
  }
  function Pxt(e) {
    var t, r, n;
    if (((n = e.input.charCodeAt(e.position)), n !== 42)) return !1;
    for (
      n = e.input.charCodeAt(++e.position), t = e.position;
      n !== 0 && !os(n) && !ad(n);

    )
      n = e.input.charCodeAt(++e.position);
    return (
      e.position === t &&
        me(e, "name of an alias node must contain at least one character"),
      (r = e.input.slice(t, e.position)),
      _c.call(e.anchorMap, r) || me(e, 'unidentified alias "' + r + '"'),
      (e.result = e.anchorMap[r]),
      En(e, !0, -1),
      !0
    );
  }
  function ld(e, t, r, n, i) {
    var s,
      o,
      l,
      u = 1,
      h = !1,
      f = !1,
      d,
      p,
      m,
      g,
      y,
      b;
    if (
      (e.listener !== null && e.listener("open", e),
      (e.tag = null),
      (e.anchor = null),
      (e.kind = null),
      (e.result = null),
      (s = o = l = bb === r || vG === r),
      n &&
        En(e, !0, -1) &&
        ((h = !0),
        e.lineIndent > t
          ? (u = 1)
          : e.lineIndent === t
            ? (u = 0)
            : e.lineIndent < t && (u = -1)),
      u === 1)
    )
      for (; Mxt(e) || Oxt(e); )
        En(e, !0, -1)
          ? ((h = !0),
            (l = s),
            e.lineIndent > t
              ? (u = 1)
              : e.lineIndent === t
                ? (u = 0)
                : e.lineIndent < t && (u = -1))
          : (l = !1);
    if (
      (l && (l = h || i),
      (u === 1 || bb === r) &&
        (xb === r || wG === r ? (y = t) : (y = t + 1),
        (b = e.position - e.lineStart),
        u === 1
          ? (l && (uG(e, b) || Ixt(e, b, y))) || Dxt(e, y)
            ? (f = !0)
            : ((o && Nxt(e, y)) || Lxt(e, y) || Rxt(e, y)
                ? (f = !0)
                : Pxt(e)
                  ? ((f = !0),
                    (e.tag !== null || e.anchor !== null) &&
                      me(e, "alias node should not have any properties"))
                  : Axt(e, y, xb === r) &&
                    ((f = !0), e.tag === null && (e.tag = "?")),
              e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
          : u === 0 && (f = l && uG(e, b))),
      e.tag === null)
    )
      e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
    else if (e.tag === "?") {
      for (
        e.result !== null &&
          e.kind !== "scalar" &&
          me(
            e,
            'unacceptable node kind for !<?> tag; it should be "scalar", not "' +
              e.kind +
              '"',
          ),
          d = 0,
          p = e.implicitTypes.length;
        d < p;
        d += 1
      )
        if (((g = e.implicitTypes[d]), g.resolve(e.result))) {
          ((e.result = g.construct(e.result)),
            (e.tag = g.tag),
            e.anchor !== null && (e.anchorMap[e.anchor] = e.result));
          break;
        }
    } else if (e.tag !== "!") {
      if (_c.call(e.typeMap[e.kind || "fallback"], e.tag))
        g = e.typeMap[e.kind || "fallback"][e.tag];
      else
        for (
          g = null,
            m = e.typeMap.multi[e.kind || "fallback"],
            d = 0,
            p = m.length;
          d < p;
          d += 1
        )
          if (e.tag.slice(0, m[d].tag.length) === m[d].tag) {
            g = m[d];
            break;
          }
      (g || me(e, "unknown tag !<" + e.tag + ">"),
        e.result !== null &&
          g.kind !== e.kind &&
          me(
            e,
            "unacceptable node kind for !<" +
              e.tag +
              '> tag; it should be "' +
              g.kind +
              '", not "' +
              e.kind +
              '"',
          ),
        g.resolve(e.result, e.tag)
          ? ((e.result = g.construct(e.result, e.tag)),
            e.anchor !== null && (e.anchorMap[e.anchor] = e.result))
          : me(e, "cannot resolve a node with !<" + e.tag + "> explicit tag"));
    }
    return (
      e.listener !== null && e.listener("close", e),
      e.tag !== null || e.anchor !== null || f
    );
  }
  function Bxt(e) {
    var t = e.position,
      r,
      n,
      i,
      s = !1,
      o;
    for (
      e.version = null,
        e.checkLineBreaks = e.legacy,
        e.tagMap = Object.create(null),
        e.anchorMap = Object.create(null);
      (o = e.input.charCodeAt(e.position)) !== 0 &&
      (En(e, !0, -1),
      (o = e.input.charCodeAt(e.position)),
      !(e.lineIndent > 0 || o !== 37));

    ) {
      for (
        s = !0, o = e.input.charCodeAt(++e.position), r = e.position;
        o !== 0 && !os(o);

      )
        o = e.input.charCodeAt(++e.position);
      for (
        n = e.input.slice(r, e.position),
          i = [],
          n.length < 1 &&
            me(
              e,
              "directive name must not be less than one character in length",
            );
        o !== 0;

      ) {
        for (; Ku(o); ) o = e.input.charCodeAt(++e.position);
        if (o === 35) {
          do o = e.input.charCodeAt(++e.position);
          while (o !== 0 && !bo(o));
          break;
        }
        if (bo(o)) break;
        for (r = e.position; o !== 0 && !os(o); )
          o = e.input.charCodeAt(++e.position);
        i.push(e.input.slice(r, e.position));
      }
      (o !== 0 && j4(e),
        _c.call(lG, n)
          ? lG[n](e, n, i)
          : kb(e, 'unknown document directive "' + n + '"'));
    }
    if (
      (En(e, !0, -1),
      e.lineIndent === 0 &&
      e.input.charCodeAt(e.position) === 45 &&
      e.input.charCodeAt(e.position + 1) === 45 &&
      e.input.charCodeAt(e.position + 2) === 45
        ? ((e.position += 3), En(e, !0, -1))
        : s && me(e, "directives end mark is expected"),
      ld(e, e.lineIndent - 1, bb, !1, !0),
      En(e, !0, -1),
      e.checkLineBreaks &&
        Txt.test(e.input.slice(t, e.position)) &&
        kb(e, "non-ASCII line breaks are interpreted as content"),
      e.documents.push(e.result),
      e.position === e.lineStart && _b(e))
    ) {
      e.input.charCodeAt(e.position) === 46 &&
        ((e.position += 3), En(e, !0, -1));
      return;
    }
    if (e.position < e.length - 1)
      me(e, "end of the stream or a document separator is expected");
    else return;
  }
  function NG(e, t) {
    ((e = String(e)),
      (t = t || {}),
      e.length !== 0 &&
        (e.charCodeAt(e.length - 1) !== 10 &&
          e.charCodeAt(e.length - 1) !== 13 &&
          (e += `
`),
        e.charCodeAt(0) === 65279 && (e = e.slice(1))));
    var r = new Ext(e, t),
      n = e.indexOf("\0");
    for (
      n !== -1 &&
        ((r.position = n), me(r, "null byte is not allowed in input")),
        r.input += "\0";
      r.input.charCodeAt(r.position) === 32;

    )
      ((r.lineIndent += 1), (r.position += 1));
    for (; r.position < r.length - 1; ) Bxt(r);
    return r.documents;
  }
  function Fxt(e, t, r) {
    t !== null &&
      typeof t == "object" &&
      typeof r > "u" &&
      ((r = t), (t = null));
    var n = NG(e, r);
    if (typeof t != "function") return n;
    for (var i = 0, s = n.length; i < s; i += 1) t(n[i]);
  }
  function $xt(e, t) {
    var r = NG(e, t);
    if (r.length !== 0) {
      if (r.length === 1) return r[0];
      throw new as("expected a single document in the stream, but found more");
    }
  }
  function a2t(e, t) {
    var r, n, i, s, o, l, u;
    if (t === null) return {};
    for (r = {}, n = Object.keys(t), i = 0, s = n.length; i < s; i += 1)
      ((o = n[i]),
        (l = String(t[o])),
        o.slice(0, 2) === "!!" && (o = "tag:yaml.org,2002:" + o.slice(2)),
        (u = e.compiledTypeMap.fallback[o]),
        u && OG.call(u.styleAliases, l) && (l = u.styleAliases[l]),
        (r[o] = l));
    return r;
  }
  function o2t(e) {
    var t, r, n;
    if (((t = e.toString(16).toUpperCase()), e <= 255)) ((r = "x"), (n = 2));
    else if (e <= 65535) ((r = "u"), (n = 4));
    else if (e <= 4294967295) ((r = "U"), (n = 8));
    else
      throw new as(
        "code point within a string may not be greater than 0xFFFFFFFF",
      );
    return "\\" + r + Bn.repeat("0", n - t.length) + t;
  }
  function c2t(e) {
    ((this.schema = e.schema || CG),
      (this.indent = Math.max(1, e.indent || 2)),
      (this.noArrayIndent = e.noArrayIndent || !1),
      (this.skipInvalid = e.skipInvalid || !1),
      (this.flowLevel = Bn.isNothing(e.flowLevel) ? -1 : e.flowLevel),
      (this.styleMap = a2t(this.schema, e.styles || null)),
      (this.sortKeys = e.sortKeys || !1),
      (this.lineWidth = e.lineWidth || 80),
      (this.noRefs = e.noRefs || !1),
      (this.noCompatMode = e.noCompatMode || !1),
      (this.condenseFlow = e.condenseFlow || !1),
      (this.quotingType = e.quotingType === '"' ? C0 : l2t),
      (this.forceQuotes = e.forceQuotes || !1),
      (this.replacer = typeof e.replacer == "function" ? e.replacer : null),
      (this.implicitTypes = this.schema.compiledImplicit),
      (this.explicitTypes = this.schema.compiledExplicit),
      (this.tag = null),
      (this.result = ""),
      (this.duplicates = []),
      (this.usedDuplicates = null));
  }
  function hG(e, t) {
    for (
      var r = Bn.repeat(" ", t), n = 0, i = -1, s = "", o, l = e.length;
      n < l;

    )
      ((i = e.indexOf(
        `
`,
        n,
      )),
        i === -1
          ? ((o = e.slice(n)), (n = l))
          : ((o = e.slice(n, i + 1)), (n = i + 1)),
        o.length &&
          o !==
            `
` &&
          (s += r),
        (s += o));
    return s;
  }
  function V4(e, t) {
    return (
      `
` + Bn.repeat(" ", e.indent * t)
    );
  }
  function u2t(e, t) {
    var r, n, i;
    for (r = 0, n = e.implicitTypes.length; r < n; r += 1)
      if (((i = e.implicitTypes[r]), i.resolve(t))) return !0;
    return !1;
  }
  function Sb(e) {
    return e === Uxt || e === zxt;
  }
  function w0(e) {
    return (
      (32 <= e && e <= 126) ||
      (161 <= e && e <= 55295 && e !== 8232 && e !== 8233) ||
      (57344 <= e && e <= 65533 && e !== H4) ||
      (65536 <= e && e <= 1114111)
    );
  }
  function fG(e) {
    return w0(e) && e !== H4 && e !== Wxt && e !== _0;
  }
  function dG(e, t, r) {
    var n = fG(e),
      i = n && !Sb(e);
    return (
      ((r
        ? n
        : n && e !== PG && e !== BG && e !== FG && e !== $G && e !== GG) &&
        e !== G4 &&
        !(t === Tb && !i)) ||
      (fG(t) && !Sb(t) && e === G4) ||
      (t === Tb && i)
    );
  }
  function h2t(e) {
    return (
      w0(e) &&
      e !== H4 &&
      !Sb(e) &&
      e !== Qxt &&
      e !== t2t &&
      e !== Tb &&
      e !== PG &&
      e !== BG &&
      e !== FG &&
      e !== $G &&
      e !== GG &&
      e !== G4 &&
      e !== Yxt &&
      e !== Kxt &&
      e !== jxt &&
      e !== n2t &&
      e !== Zxt &&
      e !== Jxt &&
      e !== Xxt &&
      e !== qxt &&
      e !== Hxt &&
      e !== e2t &&
      e !== r2t
    );
  }
  function f2t(e) {
    return !Sb(e) && e !== Tb;
  }
  function T0(e, t) {
    var r = e.charCodeAt(t),
      n;
    return r >= 55296 &&
      r <= 56319 &&
      t + 1 < e.length &&
      ((n = e.charCodeAt(t + 1)), n >= 56320 && n <= 57343)
      ? (r - 55296) * 1024 + n - 56320 + 65536
      : r;
  }
  function VG(e) {
    var t = /^\n* /;
    return t.test(e);
  }
  function d2t(e, t, r, n, i, s, o, l) {
    var u,
      h = 0,
      f = null,
      d = !1,
      p = !1,
      m = n !== -1,
      g = -1,
      y = h2t(T0(e, 0)) && f2t(T0(e, e.length - 1));
    if (t || o)
      for (u = 0; u < e.length; h >= 65536 ? (u += 2) : u++) {
        if (((h = T0(e, u)), !w0(h))) return sd;
        ((y = y && dG(h, f, l)), (f = h));
      }
    else {
      for (u = 0; u < e.length; h >= 65536 ? (u += 2) : u++) {
        if (((h = T0(e, u)), h === _0))
          ((d = !0),
            m && ((p = p || (u - g - 1 > n && e[g + 1] !== " ")), (g = u)));
        else if (!w0(h)) return sd;
        ((y = y && dG(h, f, l)), (f = h));
      }
      p = p || (m && u - g - 1 > n && e[g + 1] !== " ");
    }
    return !d && !p
      ? y && !o && !i(e)
        ? zG
        : s === C0
          ? sd
          : z4
      : r > 9 && VG(e)
        ? sd
        : o
          ? s === C0
            ? sd
            : z4
          : p
            ? UG
            : WG;
  }
  function p2t(e, t, r, n, i) {
    e.dump = (function () {
      if (t.length === 0) return e.quotingType === C0 ? '""' : "''";
      if (!e.noCompatMode && (i2t.indexOf(t) !== -1 || s2t.test(t)))
        return e.quotingType === C0 ? '"' + t + '"' : "'" + t + "'";
      var s = e.indent * Math.max(1, r),
        o =
          e.lineWidth === -1
            ? -1
            : Math.max(Math.min(e.lineWidth, 40), e.lineWidth - s),
        l = n || (e.flowLevel > -1 && r >= e.flowLevel);
      function u(h) {
        return u2t(e, h);
      }
      switch (
        (a(u, "testAmbiguity"),
        d2t(t, l, e.indent, o, u, e.quotingType, e.forceQuotes && !n, i))
      ) {
        case zG:
          return t;
        case z4:
          return "'" + t.replace(/'/g, "''") + "'";
        case WG:
          return "|" + pG(t, e.indent) + mG(hG(t, s));
        case UG:
          return ">" + pG(t, e.indent) + mG(hG(m2t(t, o), s));
        case sd:
          return '"' + g2t(t) + '"';
        default:
          throw new as("impossible error: invalid scalar style");
      }
    })();
  }
  function pG(e, t) {
    var r = VG(e) ? String(t) : "",
      n =
        e[e.length - 1] ===
        `
`,
      i =
        n &&
        (e[e.length - 2] ===
          `
` ||
          e ===
            `
`),
      s = i ? "+" : n ? "" : "-";
    return (
      r +
      s +
      `
`
    );
  }
  function mG(e) {
    return e[e.length - 1] ===
      `
`
      ? e.slice(0, -1)
      : e;
  }
  function m2t(e, t) {
    for (
      var r = /(\n+)([^\n]*)/g,
        n = (function () {
          var h = e.indexOf(`
`);
          return (
            (h = h !== -1 ? h : e.length),
            (r.lastIndex = h),
            gG(e.slice(0, h), t)
          );
        })(),
        i =
          e[0] ===
            `
` || e[0] === " ",
        s,
        o;
      (o = r.exec(e));

    ) {
      var l = o[1],
        u = o[2];
      ((s = u[0] === " "),
        (n +=
          l +
          (!i && !s && u !== ""
            ? `
`
            : "") +
          gG(u, t)),
        (i = s));
    }
    return n;
  }
  function gG(e, t) {
    if (e === "" || e[0] === " ") return e;
    for (var r = / [^ ]/g, n, i = 0, s, o = 0, l = 0, u = ""; (n = r.exec(e)); )
      ((l = n.index),
        l - i > t &&
          ((s = o > i ? o : l),
          (u +=
            `
` + e.slice(i, s)),
          (i = s + 1)),
        (o = l));
    return (
      (u += `
`),
      e.length - i > t && o > i
        ? (u +=
            e.slice(i, o) +
            `
` +
            e.slice(o + 1))
        : (u += e.slice(i)),
      u.slice(1)
    );
  }
  function g2t(e) {
    for (var t = "", r = 0, n, i = 0; i < e.length; r >= 65536 ? (i += 2) : i++)
      ((r = T0(e, i)),
        (n = yi[r]),
        !n && w0(r)
          ? ((t += e[i]), r >= 65536 && (t += e[i + 1]))
          : (t += n || o2t(r)));
    return t;
  }
  function y2t(e, t, r) {
    var n = "",
      i = e.tag,
      s,
      o,
      l;
    for (s = 0, o = r.length; s < o; s += 1)
      ((l = r[s]),
        e.replacer && (l = e.replacer.call(r, String(s), l)),
        (yl(e, t, l, !1, !1) || (typeof l > "u" && yl(e, t, null, !1, !1))) &&
          (n !== "" && (n += "," + (e.condenseFlow ? "" : " ")),
          (n += e.dump)));
    ((e.tag = i), (e.dump = "[" + n + "]"));
  }
  function yG(e, t, r, n) {
    var i = "",
      s = e.tag,
      o,
      l,
      u;
    for (o = 0, l = r.length; o < l; o += 1)
      ((u = r[o]),
        e.replacer && (u = e.replacer.call(r, String(o), u)),
        (yl(e, t + 1, u, !0, !0, !1, !0) ||
          (typeof u > "u" && yl(e, t + 1, null, !0, !0, !1, !0))) &&
          ((!n || i !== "") && (i += V4(e, t)),
          e.dump && _0 === e.dump.charCodeAt(0) ? (i += "-") : (i += "- "),
          (i += e.dump)));
    ((e.tag = s), (e.dump = i || "[]"));
  }
  function x2t(e, t, r) {
    var n = "",
      i = e.tag,
      s = Object.keys(r),
      o,
      l,
      u,
      h,
      f;
    for (o = 0, l = s.length; o < l; o += 1)
      ((f = ""),
        n !== "" && (f += ", "),
        e.condenseFlow && (f += '"'),
        (u = s[o]),
        (h = r[u]),
        e.replacer && (h = e.replacer.call(r, u, h)),
        yl(e, t, u, !1, !1) &&
          (e.dump.length > 1024 && (f += "? "),
          (f +=
            e.dump +
            (e.condenseFlow ? '"' : "") +
            ":" +
            (e.condenseFlow ? "" : " ")),
          yl(e, t, h, !1, !1) && ((f += e.dump), (n += f))));
    ((e.tag = i), (e.dump = "{" + n + "}"));
  }
  function b2t(e, t, r, n) {
    var i = "",
      s = e.tag,
      o = Object.keys(r),
      l,
      u,
      h,
      f,
      d,
      p;
    if (e.sortKeys === !0) o.sort();
    else if (typeof e.sortKeys == "function") o.sort(e.sortKeys);
    else if (e.sortKeys)
      throw new as("sortKeys must be a boolean or a function");
    for (l = 0, u = o.length; l < u; l += 1)
      ((p = ""),
        (!n || i !== "") && (p += V4(e, t)),
        (h = o[l]),
        (f = r[h]),
        e.replacer && (f = e.replacer.call(r, h, f)),
        yl(e, t + 1, h, !0, !0, !0) &&
          ((d =
            (e.tag !== null && e.tag !== "?") ||
            (e.dump && e.dump.length > 1024)),
          d &&
            (e.dump && _0 === e.dump.charCodeAt(0) ? (p += "?") : (p += "? ")),
          (p += e.dump),
          d && (p += V4(e, t)),
          yl(e, t + 1, f, !0, d) &&
            (e.dump && _0 === e.dump.charCodeAt(0) ? (p += ":") : (p += ": "),
            (p += e.dump),
            (i += p))));
    ((e.tag = s), (e.dump = i || "{}"));
  }
  function xG(e, t, r) {
    var n, i, s, o, l, u;
    for (
      i = r ? e.explicitTypes : e.implicitTypes, s = 0, o = i.length;
      s < o;
      s += 1
    )
      if (
        ((l = i[s]),
        (l.instanceOf || l.predicate) &&
          (!l.instanceOf ||
            (typeof t == "object" && t instanceof l.instanceOf)) &&
          (!l.predicate || l.predicate(t)))
      ) {
        if (
          (r
            ? l.multi && l.representName
              ? (e.tag = l.representName(t))
              : (e.tag = l.tag)
            : (e.tag = "?"),
          l.represent)
        ) {
          if (
            ((u = e.styleMap[l.tag] || l.defaultStyle),
            MG.call(l.represent) === "[object Function]")
          )
            n = l.represent(t, u);
          else if (OG.call(l.represent, u)) n = l.represent[u](t, u);
          else
            throw new as(
              "!<" + l.tag + '> tag resolver accepts not "' + u + '" style',
            );
          e.dump = n;
        }
        return !0;
      }
    return !1;
  }
  function yl(e, t, r, n, i, s, o) {
    ((e.tag = null), (e.dump = r), xG(e, r, !1) || xG(e, r, !0));
    var l = MG.call(e.dump),
      u = n,
      h;
    n && (n = e.flowLevel < 0 || e.flowLevel > t);
    var f = l === "[object Object]" || l === "[object Array]",
      d,
      p;
    if (
      (f && ((d = e.duplicates.indexOf(r)), (p = d !== -1)),
      ((e.tag !== null && e.tag !== "?") || p || (e.indent !== 2 && t > 0)) &&
        (i = !1),
      p && e.usedDuplicates[d])
    )
      e.dump = "*ref_" + d;
    else {
      if (
        (f && p && !e.usedDuplicates[d] && (e.usedDuplicates[d] = !0),
        l === "[object Object]")
      )
        n && Object.keys(e.dump).length !== 0
          ? (b2t(e, t, e.dump, i), p && (e.dump = "&ref_" + d + e.dump))
          : (x2t(e, t, e.dump), p && (e.dump = "&ref_" + d + " " + e.dump));
      else if (l === "[object Array]")
        n && e.dump.length !== 0
          ? (e.noArrayIndent && !o && t > 0
              ? yG(e, t - 1, e.dump, i)
              : yG(e, t, e.dump, i),
            p && (e.dump = "&ref_" + d + e.dump))
          : (y2t(e, t, e.dump), p && (e.dump = "&ref_" + d + " " + e.dump));
      else if (l === "[object String]")
        e.tag !== "?" && p2t(e, e.dump, t, s, u);
      else {
        if (l === "[object Undefined]") return !1;
        if (e.skipInvalid) return !1;
        throw new as("unacceptable kind of an object to dump " + l);
      }
      e.tag !== null &&
        e.tag !== "?" &&
        ((h = encodeURI(e.tag[0] === "!" ? e.tag.slice(1) : e.tag).replace(
          /!/g,
          "%21",
        )),
        e.tag[0] === "!"
          ? (h = "!" + h)
          : h.slice(0, 18) === "tag:yaml.org,2002:"
            ? (h = "!!" + h.slice(18))
            : (h = "!<" + h + ">"),
        (e.dump = h + " " + e.dump));
    }
    return !0;
  }
  function k2t(e, t) {
    var r = [],
      n = [],
      i,
      s;
    for (W4(e, r, n), i = 0, s = n.length; i < s; i += 1)
      t.duplicates.push(r[n[i]]);
    t.usedDuplicates = new Array(s);
  }
  function W4(e, t, r) {
    var n, i, s;
    if (e !== null && typeof e == "object")
      if (((i = t.indexOf(e)), i !== -1)) r.indexOf(i) === -1 && r.push(i);
      else if ((t.push(e), Array.isArray(e)))
        for (i = 0, s = e.length; i < s; i += 1) W4(e[i], t, r);
      else
        for (n = Object.keys(e), i = 0, s = n.length; i < s; i += 1)
          W4(e[n[i]], t, r);
  }
  function T2t(e, t) {
    t = t || {};
    var r = new c2t(t);
    r.noRefs || k2t(e, r);
    var n = e;
    return (
      r.replacer && (n = r.replacer.call({ "": n }, "", n)),
      yl(r, 0, n, !0, !0)
        ? r.dump +
          `
`
        : ""
    );
  }
  function Y4(e, t) {
    return function () {
      throw new Error(
        "Function yaml." +
          e +
          " is removed in js-yaml 4. Use yaml." +
          t +
          " instead, which is now safe by default.",
      );
    };
  }
  var lyt,
    cyt,
    uyt,
    hyt,
    fyt,
    dyt,
    Bn,
    as,
    myt,
    gyt,
    yyt,
    gi,
    Tyt,
    Syt,
    _yt,
    Cyt,
    wyt,
    Lyt,
    Iyt,
    Gyt,
    Vyt,
    Uyt,
    Hyt,
    TG,
    Yyt,
    SG,
    _G,
    Zyt,
    txt,
    U4,
    sxt,
    axt,
    oxt,
    uxt,
    hxt,
    pxt,
    mxt,
    xxt,
    CG,
    _c,
    xb,
    wG,
    vG,
    bb,
    F4,
    bxt,
    sG,
    kxt,
    Txt,
    Sxt,
    EG,
    AG,
    LG,
    RG,
    Xu,
    lG,
    Gxt,
    Vxt,
    IG,
    MG,
    OG,
    H4,
    zxt,
    _0,
    Wxt,
    Uxt,
    jxt,
    qxt,
    G4,
    Hxt,
    Yxt,
    Xxt,
    Kxt,
    PG,
    Qxt,
    Tb,
    Zxt,
    Jxt,
    t2t,
    e2t,
    BG,
    FG,
    r2t,
    $G,
    n2t,
    GG,
    yi,
    i2t,
    s2t,
    l2t,
    C0,
    zG,
    z4,
    WG,
    UG,
    sd,
    S2t,
    _2t,
    Cc,
    wc,
    Lae,
    Rae,
    Dae,
    Nae,
    Iae,
    v0 = x(() => {
      "use strict";
      a(bG, "isNothing");
      a(nyt, "isObject");
      a(iyt, "toArray");
      a(syt, "extend");
      a(ayt, "repeat");
      a(oyt, "isNegativeZero");
      ((lyt = bG),
        (cyt = nyt),
        (uyt = iyt),
        (hyt = ayt),
        (fyt = oyt),
        (dyt = syt),
        (Bn = {
          isNothing: lyt,
          isObject: cyt,
          toArray: uyt,
          repeat: hyt,
          isNegativeZero: fyt,
          extend: dyt,
        }));
      a(kG, "formatError");
      a(S0, "YAMLException$1");
      S0.prototype = Object.create(Error.prototype);
      S0.prototype.constructor = S0;
      S0.prototype.toString = a(function (t) {
        return this.name + ": " + kG(this, t);
      }, "toString");
      as = S0;
      a(P4, "getLine");
      a(B4, "padStart");
      a(pyt, "makeSnippet");
      ((myt = pyt),
        (gyt = [
          "kind",
          "multi",
          "resolve",
          "construct",
          "instanceOf",
          "predicate",
          "represent",
          "representName",
          "defaultStyle",
          "styleAliases",
        ]),
        (yyt = ["scalar", "sequence", "mapping"]));
      a(xyt, "compileStyleAliases");
      a(byt, "Type$1");
      gi = byt;
      a(iG, "compileList");
      a(kyt, "compileMap");
      a($4, "Schema$1");
      $4.prototype.extend = a(function (t) {
        var r = [],
          n = [];
        if (t instanceof gi) n.push(t);
        else if (Array.isArray(t)) n = n.concat(t);
        else if (t && (Array.isArray(t.implicit) || Array.isArray(t.explicit)))
          (t.implicit && (r = r.concat(t.implicit)),
            t.explicit && (n = n.concat(t.explicit)));
        else
          throw new as(
            "Schema.extend argument should be a Type, [ Type ], or a schema definition ({ implicit: [...], explicit: [...] })",
          );
        (r.forEach(function (s) {
          if (!(s instanceof gi))
            throw new as(
              "Specified list of YAML types (or a single Type object) contains a non-Type object.",
            );
          if (s.loadKind && s.loadKind !== "scalar")
            throw new as(
              "There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.",
            );
          if (s.multi)
            throw new as(
              "There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.",
            );
        }),
          n.forEach(function (s) {
            if (!(s instanceof gi))
              throw new as(
                "Specified list of YAML types (or a single Type object) contains a non-Type object.",
              );
          }));
        var i = Object.create($4.prototype);
        return (
          (i.implicit = (this.implicit || []).concat(r)),
          (i.explicit = (this.explicit || []).concat(n)),
          (i.compiledImplicit = iG(i, "implicit")),
          (i.compiledExplicit = iG(i, "explicit")),
          (i.compiledTypeMap = kyt(i.compiledImplicit, i.compiledExplicit)),
          i
        );
      }, "extend");
      ((Tyt = $4),
        (Syt = new gi("tag:yaml.org,2002:str", {
          kind: "scalar",
          construct: a(function (e) {
            return e !== null ? e : "";
          }, "construct"),
        })),
        (_yt = new gi("tag:yaml.org,2002:seq", {
          kind: "sequence",
          construct: a(function (e) {
            return e !== null ? e : [];
          }, "construct"),
        })),
        (Cyt = new gi("tag:yaml.org,2002:map", {
          kind: "mapping",
          construct: a(function (e) {
            return e !== null ? e : {};
          }, "construct"),
        })),
        (wyt = new Tyt({ explicit: [Syt, _yt, Cyt] })));
      a(vyt, "resolveYamlNull");
      a(Eyt, "constructYamlNull");
      a(Ayt, "isNull");
      Lyt = new gi("tag:yaml.org,2002:null", {
        kind: "scalar",
        resolve: vyt,
        construct: Eyt,
        predicate: Ayt,
        represent: {
          canonical: a(function () {
            return "~";
          }, "canonical"),
          lowercase: a(function () {
            return "null";
          }, "lowercase"),
          uppercase: a(function () {
            return "NULL";
          }, "uppercase"),
          camelcase: a(function () {
            return "Null";
          }, "camelcase"),
          empty: a(function () {
            return "";
          }, "empty"),
        },
        defaultStyle: "lowercase",
      });
      a(Ryt, "resolveYamlBoolean");
      a(Dyt, "constructYamlBoolean");
      a(Nyt, "isBoolean");
      Iyt = new gi("tag:yaml.org,2002:bool", {
        kind: "scalar",
        resolve: Ryt,
        construct: Dyt,
        predicate: Nyt,
        represent: {
          lowercase: a(function (e) {
            return e ? "true" : "false";
          }, "lowercase"),
          uppercase: a(function (e) {
            return e ? "TRUE" : "FALSE";
          }, "uppercase"),
          camelcase: a(function (e) {
            return e ? "True" : "False";
          }, "camelcase"),
        },
        defaultStyle: "lowercase",
      });
      a(Myt, "isHexCode");
      a(Oyt, "isOctCode");
      a(Pyt, "isDecCode");
      a(Byt, "resolveYamlInteger");
      a(Fyt, "constructYamlInteger");
      a($yt, "isInteger");
      ((Gyt = new gi("tag:yaml.org,2002:int", {
        kind: "scalar",
        resolve: Byt,
        construct: Fyt,
        predicate: $yt,
        represent: {
          binary: a(function (e) {
            return e >= 0
              ? "0b" + e.toString(2)
              : "-0b" + e.toString(2).slice(1);
          }, "binary"),
          octal: a(function (e) {
            return e >= 0
              ? "0o" + e.toString(8)
              : "-0o" + e.toString(8).slice(1);
          }, "octal"),
          decimal: a(function (e) {
            return e.toString(10);
          }, "decimal"),
          hexadecimal: a(function (e) {
            return e >= 0
              ? "0x" + e.toString(16).toUpperCase()
              : "-0x" + e.toString(16).toUpperCase().slice(1);
          }, "hexadecimal"),
        },
        defaultStyle: "decimal",
        styleAliases: {
          binary: [2, "bin"],
          octal: [8, "oct"],
          decimal: [10, "dec"],
          hexadecimal: [16, "hex"],
        },
      })),
        (Vyt = new RegExp(
          "^(?:[-+]?(?:[0-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$",
        )));
      a(zyt, "resolveYamlFloat");
      a(Wyt, "constructYamlFloat");
      Uyt = /^[-+]?[0-9]+e/;
      a(jyt, "representYamlFloat");
      a(qyt, "isFloat");
      ((Hyt = new gi("tag:yaml.org,2002:float", {
        kind: "scalar",
        resolve: zyt,
        construct: Wyt,
        predicate: qyt,
        represent: jyt,
        defaultStyle: "lowercase",
      })),
        (TG = wyt.extend({ implicit: [Lyt, Iyt, Gyt, Hyt] })),
        (Yyt = TG),
        (SG = new RegExp("^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$")),
        (_G = new RegExp(
          "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$",
        )));
      a(Xyt, "resolveYamlTimestamp");
      a(Kyt, "constructYamlTimestamp");
      a(Qyt, "representYamlTimestamp");
      Zyt = new gi("tag:yaml.org,2002:timestamp", {
        kind: "scalar",
        resolve: Xyt,
        construct: Kyt,
        instanceOf: Date,
        represent: Qyt,
      });
      a(Jyt, "resolveYamlMerge");
      ((txt = new gi("tag:yaml.org,2002:merge", {
        kind: "scalar",
        resolve: Jyt,
      })),
        (U4 = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`));
      a(ext, "resolveYamlBinary");
      a(rxt, "constructYamlBinary");
      a(nxt, "representYamlBinary");
      a(ixt, "isBinary");
      ((sxt = new gi("tag:yaml.org,2002:binary", {
        kind: "scalar",
        resolve: ext,
        construct: rxt,
        predicate: ixt,
        represent: nxt,
      })),
        (axt = Object.prototype.hasOwnProperty),
        (oxt = Object.prototype.toString));
      a(lxt, "resolveYamlOmap");
      a(cxt, "constructYamlOmap");
      ((uxt = new gi("tag:yaml.org,2002:omap", {
        kind: "sequence",
        resolve: lxt,
        construct: cxt,
      })),
        (hxt = Object.prototype.toString));
      a(fxt, "resolveYamlPairs");
      a(dxt, "constructYamlPairs");
      ((pxt = new gi("tag:yaml.org,2002:pairs", {
        kind: "sequence",
        resolve: fxt,
        construct: dxt,
      })),
        (mxt = Object.prototype.hasOwnProperty));
      a(gxt, "resolveYamlSet");
      a(yxt, "constructYamlSet");
      ((xxt = new gi("tag:yaml.org,2002:set", {
        kind: "mapping",
        resolve: gxt,
        construct: yxt,
      })),
        (CG = Yyt.extend({
          implicit: [Zyt, txt],
          explicit: [sxt, uxt, pxt, xxt],
        })),
        (_c = Object.prototype.hasOwnProperty),
        (xb = 1),
        (wG = 2),
        (vG = 3),
        (bb = 4),
        (F4 = 1),
        (bxt = 2),
        (sG = 3),
        (kxt =
          /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/),
        (Txt = /[\x85\u2028\u2029]/),
        (Sxt = /[,\[\]\{\}]/),
        (EG = /^(?:!|!!|![a-z\-]+!)$/i),
        (AG =
          /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i));
      a(aG, "_class");
      a(bo, "is_EOL");
      a(Ku, "is_WHITE_SPACE");
      a(os, "is_WS_OR_EOL");
      a(ad, "is_FLOW_INDICATOR");
      a(_xt, "fromHexCode");
      a(Cxt, "escapedHexLen");
      a(wxt, "fromDecimalCode");
      a(oG, "simpleEscapeSequence");
      a(vxt, "charFromCodepoint");
      ((LG = new Array(256)), (RG = new Array(256)));
      for (Xu = 0; Xu < 256; Xu++)
        ((LG[Xu] = oG(Xu) ? 1 : 0), (RG[Xu] = oG(Xu)));
      a(Ext, "State$1");
      a(DG, "generateError");
      a(me, "throwError");
      a(kb, "throwWarning");
      lG = {
        YAML: a(function (t, r, n) {
          var i, s, o;
          (t.version !== null && me(t, "duplication of %YAML directive"),
            n.length !== 1 &&
              me(t, "YAML directive accepts exactly one argument"),
            (i = /^([0-9]+)\.([0-9]+)$/.exec(n[0])),
            i === null && me(t, "ill-formed argument of the YAML directive"),
            (s = parseInt(i[1], 10)),
            (o = parseInt(i[2], 10)),
            s !== 1 && me(t, "unacceptable YAML version of the document"),
            (t.version = n[0]),
            (t.checkLineBreaks = o < 2),
            o !== 1 &&
              o !== 2 &&
              kb(t, "unsupported YAML version of the document"));
        }, "handleYamlDirective"),
        TAG: a(function (t, r, n) {
          var i, s;
          (n.length !== 2 &&
            me(t, "TAG directive accepts exactly two arguments"),
            (i = n[0]),
            (s = n[1]),
            EG.test(i) ||
              me(
                t,
                "ill-formed tag handle (first argument) of the TAG directive",
              ),
            _c.call(t.tagMap, i) &&
              me(
                t,
                'there is a previously declared suffix for "' +
                  i +
                  '" tag handle',
              ),
            AG.test(s) ||
              me(
                t,
                "ill-formed tag prefix (second argument) of the TAG directive",
              ));
          try {
            s = decodeURIComponent(s);
          } catch {
            me(t, "tag prefix is malformed: " + s);
          }
          t.tagMap[i] = s;
        }, "handleTagDirective"),
      };
      a(Sc, "captureSegment");
      a(cG, "mergeMappings");
      a(od, "storeMappingPair");
      a(j4, "readLineBreak");
      a(En, "skipSeparationSpace");
      a(_b, "testDocumentSeparator");
      a(q4, "writeFoldedLines");
      a(Axt, "readPlainScalar");
      a(Lxt, "readSingleQuotedScalar");
      a(Rxt, "readDoubleQuotedScalar");
      a(Dxt, "readFlowCollection");
      a(Nxt, "readBlockScalar");
      a(uG, "readBlockSequence");
      a(Ixt, "readBlockMapping");
      a(Mxt, "readTagProperty");
      a(Oxt, "readAnchorProperty");
      a(Pxt, "readAlias");
      a(ld, "composeNode");
      a(Bxt, "readDocument");
      a(NG, "loadDocuments");
      a(Fxt, "loadAll$1");
      a($xt, "load$1");
      ((Gxt = Fxt),
        (Vxt = $xt),
        (IG = { loadAll: Gxt, load: Vxt }),
        (MG = Object.prototype.toString),
        (OG = Object.prototype.hasOwnProperty),
        (H4 = 65279),
        (zxt = 9),
        (_0 = 10),
        (Wxt = 13),
        (Uxt = 32),
        (jxt = 33),
        (qxt = 34),
        (G4 = 35),
        (Hxt = 37),
        (Yxt = 38),
        (Xxt = 39),
        (Kxt = 42),
        (PG = 44),
        (Qxt = 45),
        (Tb = 58),
        (Zxt = 61),
        (Jxt = 62),
        (t2t = 63),
        (e2t = 64),
        (BG = 91),
        (FG = 93),
        (r2t = 96),
        ($G = 123),
        (n2t = 124),
        (GG = 125),
        (yi = {}));
      yi[0] = "\\0";
      yi[7] = "\\a";
      yi[8] = "\\b";
      yi[9] = "\\t";
      yi[10] = "\\n";
      yi[11] = "\\v";
      yi[12] = "\\f";
      yi[13] = "\\r";
      yi[27] = "\\e";
      yi[34] = '\\"';
      yi[92] = "\\\\";
      yi[133] = "\\N";
      yi[160] = "\\_";
      yi[8232] = "\\L";
      yi[8233] = "\\P";
      ((i2t = [
        "y",
        "Y",
        "yes",
        "Yes",
        "YES",
        "on",
        "On",
        "ON",
        "n",
        "N",
        "no",
        "No",
        "NO",
        "off",
        "Off",
        "OFF",
      ]),
        (s2t = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\.[0-9_]*)?$/));
      a(a2t, "compileStyleMap");
      a(o2t, "encodeHex");
      ((l2t = 1), (C0 = 2));
      a(c2t, "State");
      a(hG, "indentString");
      a(V4, "generateNextLine");
      a(u2t, "testImplicitResolving");
      a(Sb, "isWhitespace");
      a(w0, "isPrintable");
      a(fG, "isNsCharOrWhitespace");
      a(dG, "isPlainSafe");
      a(h2t, "isPlainSafeFirst");
      a(f2t, "isPlainSafeLast");
      a(T0, "codePointAt");
      a(VG, "needIndentIndicator");
      ((zG = 1), (z4 = 2), (WG = 3), (UG = 4), (sd = 5));
      a(d2t, "chooseScalarStyle");
      a(p2t, "writeScalar");
      a(pG, "blockHeader");
      a(mG, "dropEndingNewline");
      a(m2t, "foldString");
      a(gG, "foldLine");
      a(g2t, "escapeString");
      a(y2t, "writeFlowSequence");
      a(yG, "writeBlockSequence");
      a(x2t, "writeFlowMapping");
      a(b2t, "writeBlockMapping");
      a(xG, "detectType");
      a(yl, "writeNode");
      a(k2t, "getDuplicateReferences");
      a(W4, "inspectNode");
      a(T2t, "dump$1");
      ((S2t = T2t), (_2t = { dump: S2t }));
      a(Y4, "renamed");
      ((Cc = TG),
        (wc = IG.load),
        (Lae = IG.loadAll),
        (Rae = _2t.dump),
        (Dae = Y4("safeLoad", "load")),
        (Nae = Y4("safeLoadAll", "loadAll")),
        (Iae = Y4("safeDump", "dump")));
    });
  function Z4() {
    return {
      async: !1,
      breaks: !1,
      extensions: null,
      gfm: !0,
      hooks: null,
      pedantic: !1,
      renderer: null,
      silent: !1,
      tokenizer: null,
      walkTokens: null,
    };
  }
  function KG(e) {
    Zu = e;
  }
  function Tr(e, t = "") {
    let r = typeof e == "string" ? e : e.source,
      n = {
        replace: a((i, s) => {
          let o = typeof s == "string" ? s : s.source;
          return ((o = o.replace(Fi.caret, "$1")), (r = r.replace(i, o)), n);
        }, "replace"),
        getRegex: a(() => new RegExp(r, t), "getRegex"),
      };
    return n;
  }
  function ko(e, t) {
    if (t) {
      if (Fi.escapeTest.test(e)) return e.replace(Fi.escapeReplace, qG);
    } else if (Fi.escapeTestNoEncode.test(e))
      return e.replace(Fi.escapeReplaceNoEncode, qG);
    return e;
  }
  function HG(e) {
    try {
      e = encodeURI(e).replace(Fi.percentDecode, "%");
    } catch {
      return null;
    }
    return e;
  }
  function YG(e, t) {
    let r = e.replace(Fi.findPipe, (s, o, l) => {
        let u = !1,
          h = o;
        for (; --h >= 0 && l[h] === "\\"; ) u = !u;
        return u ? "|" : " |";
      }),
      n = r.split(Fi.splitPipe),
      i = 0;
    if (
      (n[0].trim() || n.shift(),
      n.length > 0 && !n.at(-1)?.trim() && n.pop(),
      t)
    )
      if (n.length > t) n.splice(t);
      else for (; n.length < t; ) n.push("");
    for (; i < n.length; i++) n[i] = n[i].trim().replace(Fi.slashPipe, "|");
    return n;
  }
  function A0(e, t, r) {
    let n = e.length;
    if (n === 0) return "";
    let i = 0;
    for (; i < n; ) {
      let s = e.charAt(n - i - 1);
      if (s === t && !r) i++;
      else if (s !== t && r) i++;
      else break;
    }
    return e.slice(0, n - i);
  }
  function nbt(e, t) {
    if (e.indexOf(t[1]) === -1) return -1;
    let r = 0;
    for (let n = 0; n < e.length; n++)
      if (e[n] === "\\") n++;
      else if (e[n] === t[0]) r++;
      else if (e[n] === t[1] && (r--, r < 0)) return n;
    return r > 0 ? -2 : -1;
  }
  function XG(e, t, r, n, i) {
    let s = t.href,
      o = t.title || null,
      l = e[1].replace(i.other.outputLinkReplace, "$1");
    n.state.inLink = !0;
    let u = {
      type: e[0].charAt(0) === "!" ? "image" : "link",
      raw: r,
      href: s,
      title: o,
      text: l,
      tokens: n.inlineTokens(l),
    };
    return ((n.state.inLink = !1), u);
  }
  function ibt(e, t, r) {
    let n = e.match(r.other.indentCodeCompensation);
    if (n === null) return t;
    let i = n[1];
    return t
      .split(
        `
`,
      )
      .map((s) => {
        let o = s.match(r.other.beginningSpace);
        if (o === null) return s;
        let [l] = o;
        return l.length >= i.length ? s.slice(i.length) : s;
      }).join(`
`);
  }
  function br(e, t) {
    return Qu.parse(e, t);
  }
  var Zu,
    L0,
    Fi,
    C2t,
    w2t,
    v2t,
    R0,
    E2t,
    J4,
    QG,
    ZG,
    A2t,
    tA,
    L2t,
    eA,
    R2t,
    D2t,
    Rb,
    rA,
    N2t,
    JG,
    I2t,
    nA,
    jG,
    M2t,
    O2t,
    P2t,
    B2t,
    tV,
    F2t,
    Db,
    iA,
    eV,
    $2t,
    rV,
    G2t,
    V2t,
    z2t,
    nV,
    W2t,
    U2t,
    iV,
    j2t,
    q2t,
    H2t,
    Y2t,
    X2t,
    K2t,
    Q2t,
    Eb,
    Z2t,
    sV,
    aV,
    J2t,
    sA,
    tbt,
    X4,
    ebt,
    wb,
    E0,
    rbt,
    qG,
    Ab,
    xl,
    Lb,
    aA,
    bl,
    vb,
    sbt,
    Qu,
    Oae,
    Pae,
    Bae,
    Fae,
    $ae,
    Gae,
    Vae,
    oV = x(() => {
      "use strict";
      a(Z4, "_getDefaults");
      Zu = Z4();
      a(KG, "changeDefaults");
      L0 = { exec: a(() => null, "exec") };
      a(Tr, "edit");
      ((Fi = {
        codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm,
        outputLinkReplace: /\\([\[\]])/g,
        indentCodeCompensation: /^(\s+)(?:```)/,
        beginningSpace: /^\s+/,
        endingHash: /#$/,
        startingSpaceChar: /^ /,
        endingSpaceChar: / $/,
        nonSpaceChar: /[^ ]/,
        newLineCharGlobal: /\n/g,
        tabCharGlobal: /\t/g,
        multipleSpaceGlobal: /\s+/g,
        blankLine: /^[ \t]*$/,
        doubleBlankLine: /\n[ \t]*\n[ \t]*$/,
        blockquoteStart: /^ {0,3}>/,
        blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g,
        blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm,
        listReplaceTabs: /^\t+/,
        listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g,
        listIsTask: /^\[[ xX]\] /,
        listReplaceTask: /^\[[ xX]\] +/,
        anyLine: /\n.*\n/,
        hrefBrackets: /^<(.*)>$/,
        tableDelimiter: /[:|]/,
        tableAlignChars: /^\||\| *$/g,
        tableRowBlankLine: /\n[ \t]*$/,
        tableAlignRight: /^ *-+: *$/,
        tableAlignCenter: /^ *:-+: *$/,
        tableAlignLeft: /^ *:-+ *$/,
        startATag: /^<a /i,
        endATag: /^<\/a>/i,
        startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i,
        endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i,
        startAngleBracket: /^</,
        endAngleBracket: />$/,
        pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/,
        unicodeAlphaNumeric: /[\p{L}\p{N}]/u,
        escapeTest: /[&<>"']/,
        escapeReplace: /[&<>"']/g,
        escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/,
        escapeReplaceNoEncode:
          /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g,
        unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/gi,
        caret: /(^|[^\[])\^/g,
        percentDecode: /%25/g,
        findPipe: /\|/g,
        splitPipe: / \|/,
        slashPipe: /\\\|/g,
        carriageReturn: /\r\n|\r/g,
        spaceLine: /^ +$/gm,
        notSpaceStart: /^\S*/,
        endingNewline: /\n$/,
        listItemRegex: a(
          (e) => new RegExp(`^( {0,3}${e})((?:[	 ][^\\n]*)?(?:\\n|$))`),
          "listItemRegex",
        ),
        nextBulletRegex: a(
          (e) =>
            new RegExp(
              `^ {0,${Math.min(3, e - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`,
            ),
          "nextBulletRegex",
        ),
        hrRegex: a(
          (e) =>
            new RegExp(
              `^ {0,${Math.min(3, e - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`,
            ),
          "hrRegex",
        ),
        fencesBeginRegex: a(
          (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}(?:\`\`\`|~~~)`),
          "fencesBeginRegex",
        ),
        headingBeginRegex: a(
          (e) => new RegExp(`^ {0,${Math.min(3, e - 1)}}#`),
          "headingBeginRegex",
        ),
        htmlBeginRegex: a(
          (e) =>
            new RegExp(`^ {0,${Math.min(3, e - 1)}}<(?:[a-z].*>|!--)`, "i"),
          "htmlBeginRegex",
        ),
      }),
        (C2t = /^(?:[ \t]*(?:\n|$))+/),
        (w2t = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/),
        (v2t =
          /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/),
        (R0 =
          /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/),
        (E2t = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/),
        (J4 = /(?:[*+-]|\d{1,9}[.)])/),
        (QG =
          /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/),
        (ZG = Tr(QG)
          .replace(/bull/g, J4)
          .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
          .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
          .replace(/blockquote/g, / {0,3}>/)
          .replace(/heading/g, / {0,3}#{1,6}/)
          .replace(/html/g, / {0,3}<[^\n>]+>\n/)
          .replace(/\|table/g, "")
          .getRegex()),
        (A2t = Tr(QG)
          .replace(/bull/g, J4)
          .replace(/blockCode/g, /(?: {4}| {0,3}\t)/)
          .replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/)
          .replace(/blockquote/g, / {0,3}>/)
          .replace(/heading/g, / {0,3}#{1,6}/)
          .replace(/html/g, / {0,3}<[^\n>]+>\n/)
          .replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/)
          .getRegex()),
        (tA =
          /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/),
        (L2t = /^[^\n]+/),
        (eA = /(?!\s*\])(?:\\.|[^\[\]\\])+/),
        (R2t = Tr(
          /^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/,
        )
          .replace("label", eA)
          .replace(
            "title",
            /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/,
          )
          .getRegex()),
        (D2t = Tr(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/)
          .replace(/bull/g, J4)
          .getRegex()),
        (Rb =
          "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul"),
        (rA = /<!--(?:-?>|[\s\S]*?(?:-->|$))/),
        (N2t = Tr(
          "^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ 	]*)+\\n|$))",
          "i",
        )
          .replace("comment", rA)
          .replace("tag", Rb)
          .replace(
            "attribute",
            / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/,
          )
          .getRegex()),
        (JG = Tr(tA)
          .replace("hr", R0)
          .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
          .replace("|lheading", "")
          .replace("|table", "")
          .replace("blockquote", " {0,3}>")
          .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
          .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
          .replace(
            "html",
            "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
          )
          .replace("tag", Rb)
          .getRegex()),
        (I2t = Tr(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/)
          .replace("paragraph", JG)
          .getRegex()),
        (nA = {
          blockquote: I2t,
          code: w2t,
          def: R2t,
          fences: v2t,
          heading: E2t,
          hr: R0,
          html: N2t,
          lheading: ZG,
          list: D2t,
          newline: C2t,
          paragraph: JG,
          table: L0,
          text: L2t,
        }),
        (jG = Tr(
          "^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)",
        )
          .replace("hr", R0)
          .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
          .replace("blockquote", " {0,3}>")
          .replace("code", "(?: {4}| {0,3}	)[^\\n]")
          .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
          .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
          .replace(
            "html",
            "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
          )
          .replace("tag", Rb)
          .getRegex()),
        (M2t = {
          ...nA,
          lheading: A2t,
          table: jG,
          paragraph: Tr(tA)
            .replace("hr", R0)
            .replace("heading", " {0,3}#{1,6}(?:\\s|$)")
            .replace("|lheading", "")
            .replace("table", jG)
            .replace("blockquote", " {0,3}>")
            .replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n")
            .replace("list", " {0,3}(?:[*+-]|1[.)]) ")
            .replace(
              "html",
              "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)",
            )
            .replace("tag", Rb)
            .getRegex(),
        }),
        (O2t = {
          ...nA,
          html: Tr(
            `^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`,
          )
            .replace("comment", rA)
            .replace(
              /tag/g,
              "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b",
            )
            .getRegex(),
          def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/,
          heading: /^(#{1,6})(.*)(?:\n+|$)/,
          fences: L0,
          lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/,
          paragraph: Tr(tA)
            .replace("hr", R0)
            .replace(
              "heading",
              ` *#{1,6} *[^
]`,
            )
            .replace("lheading", ZG)
            .replace("|table", "")
            .replace("blockquote", " {0,3}>")
            .replace("|fences", "")
            .replace("|list", "")
            .replace("|html", "")
            .replace("|tag", "")
            .getRegex(),
        }),
        (P2t = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/),
        (B2t = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/),
        (tV = /^( {2,}|\\)\n(?!\s*$)/),
        (F2t =
          /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/),
        (Db = /[\p{P}\p{S}]/u),
        (iA = /[\s\p{P}\p{S}]/u),
        (eV = /[^\s\p{P}\p{S}]/u),
        ($2t = Tr(/^((?![*_])punctSpace)/, "u")
          .replace(/punctSpace/g, iA)
          .getRegex()),
        (rV = /(?!~)[\p{P}\p{S}]/u),
        (G2t = /(?!~)[\s\p{P}\p{S}]/u),
        (V2t = /(?:[^\s\p{P}\p{S}]|~)/u),
        (z2t =
          /\[[^[\]]*?\]\((?:\\.|[^\\\(\)]|\((?:\\.|[^\\\(\)])*\))*\)|`[^`]*?`|<[^<>]*?>/g),
        (nV = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/),
        (W2t = Tr(nV, "u").replace(/punct/g, Db).getRegex()),
        (U2t = Tr(nV, "u").replace(/punct/g, rV).getRegex()),
        (iV =
          "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)"),
        (j2t = Tr(iV, "gu")
          .replace(/notPunctSpace/g, eV)
          .replace(/punctSpace/g, iA)
          .replace(/punct/g, Db)
          .getRegex()),
        (q2t = Tr(iV, "gu")
          .replace(/notPunctSpace/g, V2t)
          .replace(/punctSpace/g, G2t)
          .replace(/punct/g, rV)
          .getRegex()),
        (H2t = Tr(
          "^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)",
          "gu",
        )
          .replace(/notPunctSpace/g, eV)
          .replace(/punctSpace/g, iA)
          .replace(/punct/g, Db)
          .getRegex()),
        (Y2t = Tr(/\\(punct)/, "gu")
          .replace(/punct/g, Db)
          .getRegex()),
        (X2t = Tr(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/)
          .replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/)
          .replace(
            "email",
            /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/,
          )
          .getRegex()),
        (K2t = Tr(rA).replace("(?:-->|$)", "-->").getRegex()),
        (Q2t = Tr(
          "^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>",
        )
          .replace("comment", K2t)
          .replace(
            "attribute",
            /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/,
          )
          .getRegex()),
        (Eb = /(?:\[(?:\\.|[^\[\]\\])*\]|\\.|`[^`]*`|[^\[\]\\`])*?/),
        (Z2t = Tr(
          /^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/,
        )
          .replace("label", Eb)
          .replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/)
          .replace(
            "title",
            /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/,
          )
          .getRegex()),
        (sV = Tr(/^!?\[(label)\]\[(ref)\]/)
          .replace("label", Eb)
          .replace("ref", eA)
          .getRegex()),
        (aV = Tr(/^!?\[(ref)\](?:\[\])?/)
          .replace("ref", eA)
          .getRegex()),
        (J2t = Tr("reflink|nolink(?!\\()", "g")
          .replace("reflink", sV)
          .replace("nolink", aV)
          .getRegex()),
        (sA = {
          _backpedal: L0,
          anyPunctuation: Y2t,
          autolink: X2t,
          blockSkip: z2t,
          br: tV,
          code: B2t,
          del: L0,
          emStrongLDelim: W2t,
          emStrongRDelimAst: j2t,
          emStrongRDelimUnd: H2t,
          escape: P2t,
          link: Z2t,
          nolink: aV,
          punctuation: $2t,
          reflink: sV,
          reflinkSearch: J2t,
          tag: Q2t,
          text: F2t,
          url: L0,
        }),
        (tbt = {
          ...sA,
          link: Tr(/^!?\[(label)\]\((.*?)\)/)
            .replace("label", Eb)
            .getRegex(),
          reflink: Tr(/^!?\[(label)\]\s*\[([^\]]*)\]/)
            .replace("label", Eb)
            .getRegex(),
        }),
        (X4 = {
          ...sA,
          emStrongRDelimAst: q2t,
          emStrongLDelim: U2t,
          url: Tr(
            /^((?:ftp|https?):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/,
            "i",
          )
            .replace(
              "email",
              /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/,
            )
            .getRegex(),
          _backpedal:
            /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/,
          del: /^(~~?)(?=[^\s~])((?:\\.|[^\\])*?(?:\\.|[^\s~\\]))\1(?=[^~]|$)/,
          text: /^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|https?:\/\/|ftp:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/,
        }),
        (ebt = {
          ...X4,
          br: Tr(tV).replace("{2,}", "*").getRegex(),
          text: Tr(X4.text)
            .replace("\\b_", "\\b_| {2,}\\n")
            .replace(/\{2,\}/g, "*")
            .getRegex(),
        }),
        (wb = { normal: nA, gfm: M2t, pedantic: O2t }),
        (E0 = { normal: sA, gfm: X4, breaks: ebt, pedantic: tbt }),
        (rbt = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          '"': "&quot;",
          "'": "&#39;",
        }),
        (qG = a((e) => rbt[e], "getEscapeReplacement")));
      a(ko, "escape2");
      a(HG, "cleanUrl");
      a(YG, "splitCells");
      a(A0, "rtrim");
      a(nbt, "findClosingBracket");
      a(XG, "outputLink");
      a(ibt, "indentCodeCompensation");
      ((Ab = class {
        static {
          a(this, "_Tokenizer");
        }
        options;
        rules;
        lexer;
        constructor(e) {
          this.options = e || Zu;
        }
        space(e) {
          let t = this.rules.block.newline.exec(e);
          if (t && t[0].length > 0) return { type: "space", raw: t[0] };
        }
        code(e) {
          let t = this.rules.block.code.exec(e);
          if (t) {
            let r = t[0].replace(this.rules.other.codeRemoveIndent, "");
            return {
              type: "code",
              raw: t[0],
              codeBlockStyle: "indented",
              text: this.options.pedantic
                ? r
                : A0(
                    r,
                    `
`,
                  ),
            };
          }
        }
        fences(e) {
          let t = this.rules.block.fences.exec(e);
          if (t) {
            let r = t[0],
              n = ibt(r, t[3] || "", this.rules);
            return {
              type: "code",
              raw: r,
              lang: t[2]
                ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1")
                : t[2],
              text: n,
            };
          }
        }
        heading(e) {
          let t = this.rules.block.heading.exec(e);
          if (t) {
            let r = t[2].trim();
            if (this.rules.other.endingHash.test(r)) {
              let n = A0(r, "#");
              (this.options.pedantic ||
                !n ||
                this.rules.other.endingSpaceChar.test(n)) &&
                (r = n.trim());
            }
            return {
              type: "heading",
              raw: t[0],
              depth: t[1].length,
              text: r,
              tokens: this.lexer.inline(r),
            };
          }
        }
        hr(e) {
          let t = this.rules.block.hr.exec(e);
          if (t)
            return {
              type: "hr",
              raw: A0(
                t[0],
                `
`,
              ),
            };
        }
        blockquote(e) {
          let t = this.rules.block.blockquote.exec(e);
          if (t) {
            let r = A0(
                t[0],
                `
`,
              ).split(`
`),
              n = "",
              i = "",
              s = [];
            for (; r.length > 0; ) {
              let o = !1,
                l = [],
                u;
              for (u = 0; u < r.length; u++)
                if (this.rules.other.blockquoteStart.test(r[u]))
                  (l.push(r[u]), (o = !0));
                else if (!o) l.push(r[u]);
                else break;
              r = r.slice(u);
              let h = l.join(`
`),
                f = h
                  .replace(
                    this.rules.other.blockquoteSetextReplace,
                    `
    $1`,
                  )
                  .replace(this.rules.other.blockquoteSetextReplace2, "");
              ((n = n
                ? `${n}
${h}`
                : h),
                (i = i
                  ? `${i}
${f}`
                  : f));
              let d = this.lexer.state.top;
              if (
                ((this.lexer.state.top = !0),
                this.lexer.blockTokens(f, s, !0),
                (this.lexer.state.top = d),
                r.length === 0)
              )
                break;
              let p = s.at(-1);
              if (p?.type === "code") break;
              if (p?.type === "blockquote") {
                let m = p,
                  g =
                    m.raw +
                    `
` +
                    r.join(`
`),
                  y = this.blockquote(g);
                ((s[s.length - 1] = y),
                  (n = n.substring(0, n.length - m.raw.length) + y.raw),
                  (i = i.substring(0, i.length - m.text.length) + y.text));
                break;
              } else if (p?.type === "list") {
                let m = p,
                  g =
                    m.raw +
                    `
` +
                    r.join(`
`),
                  y = this.list(g);
                ((s[s.length - 1] = y),
                  (n = n.substring(0, n.length - p.raw.length) + y.raw),
                  (i = i.substring(0, i.length - m.raw.length) + y.raw),
                  (r = g.substring(s.at(-1).raw.length).split(`
`)));
                continue;
              }
            }
            return { type: "blockquote", raw: n, tokens: s, text: i };
          }
        }
        list(e) {
          let t = this.rules.block.list.exec(e);
          if (t) {
            let r = t[1].trim(),
              n = r.length > 1,
              i = {
                type: "list",
                raw: "",
                ordered: n,
                start: n ? +r.slice(0, -1) : "",
                loose: !1,
                items: [],
              };
            ((r = n ? `\\d{1,9}\\${r.slice(-1)}` : `\\${r}`),
              this.options.pedantic && (r = n ? r : "[*+-]"));
            let s = this.rules.other.listItemRegex(r),
              o = !1;
            for (; e; ) {
              let u = !1,
                h = "",
                f = "";
              if (!(t = s.exec(e)) || this.rules.block.hr.test(e)) break;
              ((h = t[0]), (e = e.substring(h.length)));
              let d = t[2]
                  .split(
                    `
`,
                    1,
                  )[0]
                  .replace(this.rules.other.listReplaceTabs, (k) =>
                    " ".repeat(3 * k.length),
                  ),
                p = e.split(
                  `
`,
                  1,
                )[0],
                m = !d.trim(),
                g = 0;
              if (
                (this.options.pedantic
                  ? ((g = 2), (f = d.trimStart()))
                  : m
                    ? (g = t[1].length + 1)
                    : ((g = t[2].search(this.rules.other.nonSpaceChar)),
                      (g = g > 4 ? 1 : g),
                      (f = d.slice(g)),
                      (g += t[1].length)),
                m &&
                  this.rules.other.blankLine.test(p) &&
                  ((h +=
                    p +
                    `
`),
                  (e = e.substring(p.length + 1)),
                  (u = !0)),
                !u)
              ) {
                let k = this.rules.other.nextBulletRegex(g),
                  T = this.rules.other.hrRegex(g),
                  C = this.rules.other.fencesBeginRegex(g),
                  L = this.rules.other.headingBeginRegex(g),
                  w = this.rules.other.htmlBeginRegex(g);
                for (; e; ) {
                  let D = e.split(
                      `
`,
                      1,
                    )[0],
                    G;
                  if (
                    ((p = D),
                    this.options.pedantic
                      ? ((p = p.replace(
                          this.rules.other.listReplaceNesting,
                          "  ",
                        )),
                        (G = p))
                      : (G = p.replace(this.rules.other.tabCharGlobal, "    ")),
                    C.test(p) ||
                      L.test(p) ||
                      w.test(p) ||
                      k.test(p) ||
                      T.test(p))
                  )
                    break;
                  if (G.search(this.rules.other.nonSpaceChar) >= g || !p.trim())
                    f +=
                      `
` + G.slice(g);
                  else {
                    if (
                      m ||
                      d
                        .replace(this.rules.other.tabCharGlobal, "    ")
                        .search(this.rules.other.nonSpaceChar) >= 4 ||
                      C.test(d) ||
                      L.test(d) ||
                      T.test(d)
                    )
                      break;
                    f +=
                      `
` + p;
                  }
                  (!m && !p.trim() && (m = !0),
                    (h +=
                      D +
                      `
`),
                    (e = e.substring(D.length + 1)),
                    (d = G.slice(g)));
                }
              }
              i.loose ||
                (o
                  ? (i.loose = !0)
                  : this.rules.other.doubleBlankLine.test(h) && (o = !0));
              let y = null,
                b;
              (this.options.gfm &&
                ((y = this.rules.other.listIsTask.exec(f)),
                y &&
                  ((b = y[0] !== "[ ] "),
                  (f = f.replace(this.rules.other.listReplaceTask, "")))),
                i.items.push({
                  type: "list_item",
                  raw: h,
                  task: !!y,
                  checked: b,
                  loose: !1,
                  text: f,
                  tokens: [],
                }),
                (i.raw += h));
            }
            let l = i.items.at(-1);
            if (l) ((l.raw = l.raw.trimEnd()), (l.text = l.text.trimEnd()));
            else return;
            i.raw = i.raw.trimEnd();
            for (let u = 0; u < i.items.length; u++)
              if (
                ((this.lexer.state.top = !1),
                (i.items[u].tokens = this.lexer.blockTokens(
                  i.items[u].text,
                  [],
                )),
                !i.loose)
              ) {
                let h = i.items[u].tokens.filter((d) => d.type === "space"),
                  f =
                    h.length > 0 &&
                    h.some((d) => this.rules.other.anyLine.test(d.raw));
                i.loose = f;
              }
            if (i.loose)
              for (let u = 0; u < i.items.length; u++) i.items[u].loose = !0;
            return i;
          }
        }
        html(e) {
          let t = this.rules.block.html.exec(e);
          if (t)
            return {
              type: "html",
              block: !0,
              raw: t[0],
              pre: t[1] === "pre" || t[1] === "script" || t[1] === "style",
              text: t[0],
            };
        }
        def(e) {
          let t = this.rules.block.def.exec(e);
          if (t) {
            let r = t[1]
                .toLowerCase()
                .replace(this.rules.other.multipleSpaceGlobal, " "),
              n = t[2]
                ? t[2]
                    .replace(this.rules.other.hrefBrackets, "$1")
                    .replace(this.rules.inline.anyPunctuation, "$1")
                : "",
              i = t[3]
                ? t[3]
                    .substring(1, t[3].length - 1)
                    .replace(this.rules.inline.anyPunctuation, "$1")
                : t[3];
            return { type: "def", tag: r, raw: t[0], href: n, title: i };
          }
        }
        table(e) {
          let t = this.rules.block.table.exec(e);
          if (!t || !this.rules.other.tableDelimiter.test(t[2])) return;
          let r = YG(t[1]),
            n = t[2].replace(this.rules.other.tableAlignChars, "").split("|"),
            i = t[3]?.trim()
              ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`)
              : [],
            s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
          if (r.length === n.length) {
            for (let o of n)
              this.rules.other.tableAlignRight.test(o)
                ? s.align.push("right")
                : this.rules.other.tableAlignCenter.test(o)
                  ? s.align.push("center")
                  : this.rules.other.tableAlignLeft.test(o)
                    ? s.align.push("left")
                    : s.align.push(null);
            for (let o = 0; o < r.length; o++)
              s.header.push({
                text: r[o],
                tokens: this.lexer.inline(r[o]),
                header: !0,
                align: s.align[o],
              });
            for (let o of i)
              s.rows.push(
                YG(o, s.header.length).map((l, u) => ({
                  text: l,
                  tokens: this.lexer.inline(l),
                  header: !1,
                  align: s.align[u],
                })),
              );
            return s;
          }
        }
        lheading(e) {
          let t = this.rules.block.lheading.exec(e);
          if (t)
            return {
              type: "heading",
              raw: t[0],
              depth: t[2].charAt(0) === "=" ? 1 : 2,
              text: t[1],
              tokens: this.lexer.inline(t[1]),
            };
        }
        paragraph(e) {
          let t = this.rules.block.paragraph.exec(e);
          if (t) {
            let r =
              t[1].charAt(t[1].length - 1) ===
              `
`
                ? t[1].slice(0, -1)
                : t[1];
            return {
              type: "paragraph",
              raw: t[0],
              text: r,
              tokens: this.lexer.inline(r),
            };
          }
        }
        text(e) {
          let t = this.rules.block.text.exec(e);
          if (t)
            return {
              type: "text",
              raw: t[0],
              text: t[0],
              tokens: this.lexer.inline(t[0]),
            };
        }
        escape(e) {
          let t = this.rules.inline.escape.exec(e);
          if (t) return { type: "escape", raw: t[0], text: t[1] };
        }
        tag(e) {
          let t = this.rules.inline.tag.exec(e);
          if (t)
            return (
              !this.lexer.state.inLink && this.rules.other.startATag.test(t[0])
                ? (this.lexer.state.inLink = !0)
                : this.lexer.state.inLink &&
                  this.rules.other.endATag.test(t[0]) &&
                  (this.lexer.state.inLink = !1),
              !this.lexer.state.inRawBlock &&
              this.rules.other.startPreScriptTag.test(t[0])
                ? (this.lexer.state.inRawBlock = !0)
                : this.lexer.state.inRawBlock &&
                  this.rules.other.endPreScriptTag.test(t[0]) &&
                  (this.lexer.state.inRawBlock = !1),
              {
                type: "html",
                raw: t[0],
                inLink: this.lexer.state.inLink,
                inRawBlock: this.lexer.state.inRawBlock,
                block: !1,
                text: t[0],
              }
            );
        }
        link(e) {
          let t = this.rules.inline.link.exec(e);
          if (t) {
            let r = t[2].trim();
            if (
              !this.options.pedantic &&
              this.rules.other.startAngleBracket.test(r)
            ) {
              if (!this.rules.other.endAngleBracket.test(r)) return;
              let s = A0(r.slice(0, -1), "\\");
              if ((r.length - s.length) % 2 === 0) return;
            } else {
              let s = nbt(t[2], "()");
              if (s === -2) return;
              if (s > -1) {
                let l = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
                ((t[2] = t[2].substring(0, s)),
                  (t[0] = t[0].substring(0, l).trim()),
                  (t[3] = ""));
              }
            }
            let n = t[2],
              i = "";
            if (this.options.pedantic) {
              let s = this.rules.other.pedanticHrefTitle.exec(n);
              s && ((n = s[1]), (i = s[3]));
            } else i = t[3] ? t[3].slice(1, -1) : "";
            return (
              (n = n.trim()),
              this.rules.other.startAngleBracket.test(n) &&
                (this.options.pedantic &&
                !this.rules.other.endAngleBracket.test(r)
                  ? (n = n.slice(1))
                  : (n = n.slice(1, -1))),
              XG(
                t,
                {
                  href: n && n.replace(this.rules.inline.anyPunctuation, "$1"),
                  title: i && i.replace(this.rules.inline.anyPunctuation, "$1"),
                },
                t[0],
                this.lexer,
                this.rules,
              )
            );
          }
        }
        reflink(e, t) {
          let r;
          if (
            (r = this.rules.inline.reflink.exec(e)) ||
            (r = this.rules.inline.nolink.exec(e))
          ) {
            let n = (r[2] || r[1]).replace(
                this.rules.other.multipleSpaceGlobal,
                " ",
              ),
              i = t[n.toLowerCase()];
            if (!i) {
              let s = r[0].charAt(0);
              return { type: "text", raw: s, text: s };
            }
            return XG(r, i, r[0], this.lexer, this.rules);
          }
        }
        emStrong(e, t, r = "") {
          let n = this.rules.inline.emStrongLDelim.exec(e);
          if (!n || (n[3] && r.match(this.rules.other.unicodeAlphaNumeric)))
            return;
          if (
            !(n[1] || n[2] || "") ||
            !r ||
            this.rules.inline.punctuation.exec(r)
          ) {
            let s = [...n[0]].length - 1,
              o,
              l,
              u = s,
              h = 0,
              f =
                n[0][0] === "*"
                  ? this.rules.inline.emStrongRDelimAst
                  : this.rules.inline.emStrongRDelimUnd;
            for (
              f.lastIndex = 0, t = t.slice(-1 * e.length + s);
              (n = f.exec(t)) != null;

            ) {
              if (((o = n[1] || n[2] || n[3] || n[4] || n[5] || n[6]), !o))
                continue;
              if (((l = [...o].length), n[3] || n[4])) {
                u += l;
                continue;
              } else if ((n[5] || n[6]) && s % 3 && !((s + l) % 3)) {
                h += l;
                continue;
              }
              if (((u -= l), u > 0)) continue;
              l = Math.min(l, l + u + h);
              let d = [...n[0]][0].length,
                p = e.slice(0, s + n.index + d + l);
              if (Math.min(s, l) % 2) {
                let g = p.slice(1, -1);
                return {
                  type: "em",
                  raw: p,
                  text: g,
                  tokens: this.lexer.inlineTokens(g),
                };
              }
              let m = p.slice(2, -2);
              return {
                type: "strong",
                raw: p,
                text: m,
                tokens: this.lexer.inlineTokens(m),
              };
            }
          }
        }
        codespan(e) {
          let t = this.rules.inline.code.exec(e);
          if (t) {
            let r = t[2].replace(this.rules.other.newLineCharGlobal, " "),
              n = this.rules.other.nonSpaceChar.test(r),
              i =
                this.rules.other.startingSpaceChar.test(r) &&
                this.rules.other.endingSpaceChar.test(r);
            return (
              n && i && (r = r.substring(1, r.length - 1)),
              { type: "codespan", raw: t[0], text: r }
            );
          }
        }
        br(e) {
          let t = this.rules.inline.br.exec(e);
          if (t) return { type: "br", raw: t[0] };
        }
        del(e) {
          let t = this.rules.inline.del.exec(e);
          if (t)
            return {
              type: "del",
              raw: t[0],
              text: t[2],
              tokens: this.lexer.inlineTokens(t[2]),
            };
        }
        autolink(e) {
          let t = this.rules.inline.autolink.exec(e);
          if (t) {
            let r, n;
            return (
              t[2] === "@"
                ? ((r = t[1]), (n = "mailto:" + r))
                : ((r = t[1]), (n = r)),
              {
                type: "link",
                raw: t[0],
                text: r,
                href: n,
                tokens: [{ type: "text", raw: r, text: r }],
              }
            );
          }
        }
        url(e) {
          let t;
          if ((t = this.rules.inline.url.exec(e))) {
            let r, n;
            if (t[2] === "@") ((r = t[0]), (n = "mailto:" + r));
            else {
              let i;
              do
                ((i = t[0]),
                  (t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? ""));
              while (i !== t[0]);
              ((r = t[0]),
                t[1] === "www." ? (n = "http://" + t[0]) : (n = t[0]));
            }
            return {
              type: "link",
              raw: t[0],
              text: r,
              href: n,
              tokens: [{ type: "text", raw: r, text: r }],
            };
          }
        }
        inlineText(e) {
          let t = this.rules.inline.text.exec(e);
          if (t) {
            let r = this.lexer.state.inRawBlock;
            return { type: "text", raw: t[0], text: t[0], escaped: r };
          }
        }
      }),
        (xl = class K4 {
          static {
            a(this, "__Lexer");
          }
          tokens;
          options;
          state;
          tokenizer;
          inlineQueue;
          constructor(t) {
            ((this.tokens = []),
              (this.tokens.links = Object.create(null)),
              (this.options = t || Zu),
              (this.options.tokenizer = this.options.tokenizer || new Ab()),
              (this.tokenizer = this.options.tokenizer),
              (this.tokenizer.options = this.options),
              (this.tokenizer.lexer = this),
              (this.inlineQueue = []),
              (this.state = { inLink: !1, inRawBlock: !1, top: !0 }));
            let r = { other: Fi, block: wb.normal, inline: E0.normal };
            (this.options.pedantic
              ? ((r.block = wb.pedantic), (r.inline = E0.pedantic))
              : this.options.gfm &&
                ((r.block = wb.gfm),
                this.options.breaks
                  ? (r.inline = E0.breaks)
                  : (r.inline = E0.gfm)),
              (this.tokenizer.rules = r));
          }
          static get rules() {
            return { block: wb, inline: E0 };
          }
          static lex(t, r) {
            return new K4(r).lex(t);
          }
          static lexInline(t, r) {
            return new K4(r).inlineTokens(t);
          }
          lex(t) {
            ((t = t.replace(
              Fi.carriageReturn,
              `
`,
            )),
              this.blockTokens(t, this.tokens));
            for (let r = 0; r < this.inlineQueue.length; r++) {
              let n = this.inlineQueue[r];
              this.inlineTokens(n.src, n.tokens);
            }
            return ((this.inlineQueue = []), this.tokens);
          }
          blockTokens(t, r = [], n = !1) {
            for (
              this.options.pedantic &&
              (t = t
                .replace(Fi.tabCharGlobal, "    ")
                .replace(Fi.spaceLine, ""));
              t;

            ) {
              let i;
              if (
                this.options.extensions?.block?.some((o) =>
                  (i = o.call({ lexer: this }, t, r))
                    ? ((t = t.substring(i.raw.length)), r.push(i), !0)
                    : !1,
                )
              )
                continue;
              if ((i = this.tokenizer.space(t))) {
                t = t.substring(i.raw.length);
                let o = r.at(-1);
                i.raw.length === 1 && o !== void 0
                  ? (o.raw += `
`)
                  : r.push(i);
                continue;
              }
              if ((i = this.tokenizer.code(t))) {
                t = t.substring(i.raw.length);
                let o = r.at(-1);
                o?.type === "paragraph" || o?.type === "text"
                  ? ((o.raw +=
                      `
` + i.raw),
                    (o.text +=
                      `
` + i.text),
                    (this.inlineQueue.at(-1).src = o.text))
                  : r.push(i);
                continue;
              }
              if ((i = this.tokenizer.fences(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              if ((i = this.tokenizer.heading(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              if ((i = this.tokenizer.hr(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              if ((i = this.tokenizer.blockquote(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              if ((i = this.tokenizer.list(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              if ((i = this.tokenizer.html(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              if ((i = this.tokenizer.def(t))) {
                t = t.substring(i.raw.length);
                let o = r.at(-1);
                o?.type === "paragraph" || o?.type === "text"
                  ? ((o.raw +=
                      `
` + i.raw),
                    (o.text +=
                      `
` + i.raw),
                    (this.inlineQueue.at(-1).src = o.text))
                  : this.tokens.links[i.tag] ||
                    (this.tokens.links[i.tag] = {
                      href: i.href,
                      title: i.title,
                    });
                continue;
              }
              if ((i = this.tokenizer.table(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              if ((i = this.tokenizer.lheading(t))) {
                ((t = t.substring(i.raw.length)), r.push(i));
                continue;
              }
              let s = t;
              if (this.options.extensions?.startBlock) {
                let o = 1 / 0,
                  l = t.slice(1),
                  u;
                (this.options.extensions.startBlock.forEach((h) => {
                  ((u = h.call({ lexer: this }, l)),
                    typeof u == "number" && u >= 0 && (o = Math.min(o, u)));
                }),
                  o < 1 / 0 && o >= 0 && (s = t.substring(0, o + 1)));
              }
              if (this.state.top && (i = this.tokenizer.paragraph(s))) {
                let o = r.at(-1);
                (n && o?.type === "paragraph"
                  ? ((o.raw +=
                      `
` + i.raw),
                    (o.text +=
                      `
` + i.text),
                    this.inlineQueue.pop(),
                    (this.inlineQueue.at(-1).src = o.text))
                  : r.push(i),
                  (n = s.length !== t.length),
                  (t = t.substring(i.raw.length)));
                continue;
              }
              if ((i = this.tokenizer.text(t))) {
                t = t.substring(i.raw.length);
                let o = r.at(-1);
                o?.type === "text"
                  ? ((o.raw +=
                      `
` + i.raw),
                    (o.text +=
                      `
` + i.text),
                    this.inlineQueue.pop(),
                    (this.inlineQueue.at(-1).src = o.text))
                  : r.push(i);
                continue;
              }
              if (t) {
                let o = "Infinite loop on byte: " + t.charCodeAt(0);
                if (this.options.silent) {
                  console.error(o);
                  break;
                } else throw new Error(o);
              }
            }
            return ((this.state.top = !0), r);
          }
          inline(t, r = []) {
            return (this.inlineQueue.push({ src: t, tokens: r }), r);
          }
          inlineTokens(t, r = []) {
            let n = t,
              i = null;
            if (this.tokens.links) {
              let l = Object.keys(this.tokens.links);
              if (l.length > 0)
                for (
                  ;
                  (i = this.tokenizer.rules.inline.reflinkSearch.exec(n)) !=
                  null;

                )
                  l.includes(i[0].slice(i[0].lastIndexOf("[") + 1, -1)) &&
                    (n =
                      n.slice(0, i.index) +
                      "[" +
                      "a".repeat(i[0].length - 2) +
                      "]" +
                      n.slice(
                        this.tokenizer.rules.inline.reflinkSearch.lastIndex,
                      ));
            }
            for (
              ;
              (i = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null;

            )
              n =
                n.slice(0, i.index) +
                "++" +
                n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
            for (
              ;
              (i = this.tokenizer.rules.inline.blockSkip.exec(n)) != null;

            )
              n =
                n.slice(0, i.index) +
                "[" +
                "a".repeat(i[0].length - 2) +
                "]" +
                n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
            let s = !1,
              o = "";
            for (; t; ) {
              (s || (o = ""), (s = !1));
              let l;
              if (
                this.options.extensions?.inline?.some((h) =>
                  (l = h.call({ lexer: this }, t, r))
                    ? ((t = t.substring(l.raw.length)), r.push(l), !0)
                    : !1,
                )
              )
                continue;
              if ((l = this.tokenizer.escape(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if ((l = this.tokenizer.tag(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if ((l = this.tokenizer.link(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if ((l = this.tokenizer.reflink(t, this.tokens.links))) {
                t = t.substring(l.raw.length);
                let h = r.at(-1);
                l.type === "text" && h?.type === "text"
                  ? ((h.raw += l.raw), (h.text += l.text))
                  : r.push(l);
                continue;
              }
              if ((l = this.tokenizer.emStrong(t, n, o))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if ((l = this.tokenizer.codespan(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if ((l = this.tokenizer.br(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if ((l = this.tokenizer.del(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if ((l = this.tokenizer.autolink(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              if (!this.state.inLink && (l = this.tokenizer.url(t))) {
                ((t = t.substring(l.raw.length)), r.push(l));
                continue;
              }
              let u = t;
              if (this.options.extensions?.startInline) {
                let h = 1 / 0,
                  f = t.slice(1),
                  d;
                (this.options.extensions.startInline.forEach((p) => {
                  ((d = p.call({ lexer: this }, f)),
                    typeof d == "number" && d >= 0 && (h = Math.min(h, d)));
                }),
                  h < 1 / 0 && h >= 0 && (u = t.substring(0, h + 1)));
              }
              if ((l = this.tokenizer.inlineText(u))) {
                ((t = t.substring(l.raw.length)),
                  l.raw.slice(-1) !== "_" && (o = l.raw.slice(-1)),
                  (s = !0));
                let h = r.at(-1);
                h?.type === "text"
                  ? ((h.raw += l.raw), (h.text += l.text))
                  : r.push(l);
                continue;
              }
              if (t) {
                let h = "Infinite loop on byte: " + t.charCodeAt(0);
                if (this.options.silent) {
                  console.error(h);
                  break;
                } else throw new Error(h);
              }
            }
            return r;
          }
        }),
        (Lb = class {
          static {
            a(this, "_Renderer");
          }
          options;
          parser;
          constructor(e) {
            this.options = e || Zu;
          }
          space(e) {
            return "";
          }
          code({ text: e, lang: t, escaped: r }) {
            let n = (t || "").match(Fi.notSpaceStart)?.[0],
              i =
                e.replace(Fi.endingNewline, "") +
                `
`;
            return n
              ? '<pre><code class="language-' +
                  ko(n) +
                  '">' +
                  (r ? i : ko(i, !0)) +
                  `</code></pre>
`
              : "<pre><code>" +
                  (r ? i : ko(i, !0)) +
                  `</code></pre>
`;
          }
          blockquote({ tokens: e }) {
            return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
          }
          html({ text: e }) {
            return e;
          }
          heading({ tokens: e, depth: t }) {
            return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
          }
          hr(e) {
            return `<hr>
`;
          }
          list(e) {
            let t = e.ordered,
              r = e.start,
              n = "";
            for (let o = 0; o < e.items.length; o++) {
              let l = e.items[o];
              n += this.listitem(l);
            }
            let i = t ? "ol" : "ul",
              s = t && r !== 1 ? ' start="' + r + '"' : "";
            return (
              "<" +
              i +
              s +
              `>
` +
              n +
              "</" +
              i +
              `>
`
            );
          }
          listitem(e) {
            let t = "";
            if (e.task) {
              let r = this.checkbox({ checked: !!e.checked });
              e.loose
                ? e.tokens[0]?.type === "paragraph"
                  ? ((e.tokens[0].text = r + " " + e.tokens[0].text),
                    e.tokens[0].tokens &&
                      e.tokens[0].tokens.length > 0 &&
                      e.tokens[0].tokens[0].type === "text" &&
                      ((e.tokens[0].tokens[0].text =
                        r + " " + ko(e.tokens[0].tokens[0].text)),
                      (e.tokens[0].tokens[0].escaped = !0)))
                  : e.tokens.unshift({
                      type: "text",
                      raw: r + " ",
                      text: r + " ",
                      escaped: !0,
                    })
                : (t += r + " ");
            }
            return (
              (t += this.parser.parse(e.tokens, !!e.loose)),
              `<li>${t}</li>
`
            );
          }
          checkbox({ checked: e }) {
            return (
              "<input " +
              (e ? 'checked="" ' : "") +
              'disabled="" type="checkbox">'
            );
          }
          paragraph({ tokens: e }) {
            return `<p>${this.parser.parseInline(e)}</p>
`;
          }
          table(e) {
            let t = "",
              r = "";
            for (let i = 0; i < e.header.length; i++)
              r += this.tablecell(e.header[i]);
            t += this.tablerow({ text: r });
            let n = "";
            for (let i = 0; i < e.rows.length; i++) {
              let s = e.rows[i];
              r = "";
              for (let o = 0; o < s.length; o++) r += this.tablecell(s[o]);
              n += this.tablerow({ text: r });
            }
            return (
              n && (n = `<tbody>${n}</tbody>`),
              `<table>
<thead>
` +
                t +
                `</thead>
` +
                n +
                `</table>
`
            );
          }
          tablerow({ text: e }) {
            return `<tr>
${e}</tr>
`;
          }
          tablecell(e) {
            let t = this.parser.parseInline(e.tokens),
              r = e.header ? "th" : "td";
            return (
              (e.align ? `<${r} align="${e.align}">` : `<${r}>`) +
              t +
              `</${r}>
`
            );
          }
          strong({ tokens: e }) {
            return `<strong>${this.parser.parseInline(e)}</strong>`;
          }
          em({ tokens: e }) {
            return `<em>${this.parser.parseInline(e)}</em>`;
          }
          codespan({ text: e }) {
            return `<code>${ko(e, !0)}</code>`;
          }
          br(e) {
            return "<br>";
          }
          del({ tokens: e }) {
            return `<del>${this.parser.parseInline(e)}</del>`;
          }
          link({ href: e, title: t, tokens: r }) {
            let n = this.parser.parseInline(r),
              i = HG(e);
            if (i === null) return n;
            e = i;
            let s = '<a href="' + e + '"';
            return (
              t && (s += ' title="' + ko(t) + '"'),
              (s += ">" + n + "</a>"),
              s
            );
          }
          image({ href: e, title: t, text: r, tokens: n }) {
            n && (r = this.parser.parseInline(n, this.parser.textRenderer));
            let i = HG(e);
            if (i === null) return ko(r);
            e = i;
            let s = `<img src="${e}" alt="${r}"`;
            return (t && (s += ` title="${ko(t)}"`), (s += ">"), s);
          }
          text(e) {
            return "tokens" in e && e.tokens
              ? this.parser.parseInline(e.tokens)
              : "escaped" in e && e.escaped
                ? e.text
                : ko(e.text);
          }
        }),
        (aA = class {
          static {
            a(this, "_TextRenderer");
          }
          strong({ text: e }) {
            return e;
          }
          em({ text: e }) {
            return e;
          }
          codespan({ text: e }) {
            return e;
          }
          del({ text: e }) {
            return e;
          }
          html({ text: e }) {
            return e;
          }
          text({ text: e }) {
            return e;
          }
          link({ text: e }) {
            return "" + e;
          }
          image({ text: e }) {
            return "" + e;
          }
          br() {
            return "";
          }
        }),
        (bl = class Q4 {
          static {
            a(this, "__Parser");
          }
          options;
          renderer;
          textRenderer;
          constructor(t) {
            ((this.options = t || Zu),
              (this.options.renderer = this.options.renderer || new Lb()),
              (this.renderer = this.options.renderer),
              (this.renderer.options = this.options),
              (this.renderer.parser = this),
              (this.textRenderer = new aA()));
          }
          static parse(t, r) {
            return new Q4(r).parse(t);
          }
          static parseInline(t, r) {
            return new Q4(r).parseInline(t);
          }
          parse(t, r = !0) {
            let n = "";
            for (let i = 0; i < t.length; i++) {
              let s = t[i];
              if (this.options.extensions?.renderers?.[s.type]) {
                let l = s,
                  u = this.options.extensions.renderers[l.type].call(
                    { parser: this },
                    l,
                  );
                if (
                  u !== !1 ||
                  ![
                    "space",
                    "hr",
                    "heading",
                    "code",
                    "table",
                    "blockquote",
                    "list",
                    "html",
                    "paragraph",
                    "text",
                  ].includes(l.type)
                ) {
                  n += u || "";
                  continue;
                }
              }
              let o = s;
              switch (o.type) {
                case "space": {
                  n += this.renderer.space(o);
                  continue;
                }
                case "hr": {
                  n += this.renderer.hr(o);
                  continue;
                }
                case "heading": {
                  n += this.renderer.heading(o);
                  continue;
                }
                case "code": {
                  n += this.renderer.code(o);
                  continue;
                }
                case "table": {
                  n += this.renderer.table(o);
                  continue;
                }
                case "blockquote": {
                  n += this.renderer.blockquote(o);
                  continue;
                }
                case "list": {
                  n += this.renderer.list(o);
                  continue;
                }
                case "html": {
                  n += this.renderer.html(o);
                  continue;
                }
                case "paragraph": {
                  n += this.renderer.paragraph(o);
                  continue;
                }
                case "text": {
                  let l = o,
                    u = this.renderer.text(l);
                  for (; i + 1 < t.length && t[i + 1].type === "text"; )
                    ((l = t[++i]),
                      (u +=
                        `
` + this.renderer.text(l)));
                  r
                    ? (n += this.renderer.paragraph({
                        type: "paragraph",
                        raw: u,
                        text: u,
                        tokens: [
                          { type: "text", raw: u, text: u, escaped: !0 },
                        ],
                      }))
                    : (n += u);
                  continue;
                }
                default: {
                  let l = 'Token with "' + o.type + '" type was not found.';
                  if (this.options.silent) return (console.error(l), "");
                  throw new Error(l);
                }
              }
            }
            return n;
          }
          parseInline(t, r = this.renderer) {
            let n = "";
            for (let i = 0; i < t.length; i++) {
              let s = t[i];
              if (this.options.extensions?.renderers?.[s.type]) {
                let l = this.options.extensions.renderers[s.type].call(
                  { parser: this },
                  s,
                );
                if (
                  l !== !1 ||
                  ![
                    "escape",
                    "html",
                    "link",
                    "image",
                    "strong",
                    "em",
                    "codespan",
                    "br",
                    "del",
                    "text",
                  ].includes(s.type)
                ) {
                  n += l || "";
                  continue;
                }
              }
              let o = s;
              switch (o.type) {
                case "escape": {
                  n += r.text(o);
                  break;
                }
                case "html": {
                  n += r.html(o);
                  break;
                }
                case "link": {
                  n += r.link(o);
                  break;
                }
                case "image": {
                  n += r.image(o);
                  break;
                }
                case "strong": {
                  n += r.strong(o);
                  break;
                }
                case "em": {
                  n += r.em(o);
                  break;
                }
                case "codespan": {
                  n += r.codespan(o);
                  break;
                }
                case "br": {
                  n += r.br(o);
                  break;
                }
                case "del": {
                  n += r.del(o);
                  break;
                }
                case "text": {
                  n += r.text(o);
                  break;
                }
                default: {
                  let l = 'Token with "' + o.type + '" type was not found.';
                  if (this.options.silent) return (console.error(l), "");
                  throw new Error(l);
                }
              }
            }
            return n;
          }
        }),
        (vb = class {
          static {
            a(this, "_Hooks");
          }
          options;
          block;
          constructor(e) {
            this.options = e || Zu;
          }
          static passThroughHooks = new Set([
            "preprocess",
            "postprocess",
            "processAllTokens",
          ]);
          preprocess(e) {
            return e;
          }
          postprocess(e) {
            return e;
          }
          processAllTokens(e) {
            return e;
          }
          provideLexer() {
            return this.block ? xl.lex : xl.lexInline;
          }
          provideParser() {
            return this.block ? bl.parse : bl.parseInline;
          }
        }),
        (sbt = class {
          static {
            a(this, "Marked");
          }
          defaults = Z4();
          options = this.setOptions;
          parse = this.parseMarkdown(!0);
          parseInline = this.parseMarkdown(!1);
          Parser = bl;
          Renderer = Lb;
          TextRenderer = aA;
          Lexer = xl;
          Tokenizer = Ab;
          Hooks = vb;
          constructor(...e) {
            this.use(...e);
          }
          walkTokens(e, t) {
            let r = [];
            for (let n of e)
              switch (((r = r.concat(t.call(this, n))), n.type)) {
                case "table": {
                  let i = n;
                  for (let s of i.header)
                    r = r.concat(this.walkTokens(s.tokens, t));
                  for (let s of i.rows)
                    for (let o of s) r = r.concat(this.walkTokens(o.tokens, t));
                  break;
                }
                case "list": {
                  let i = n;
                  r = r.concat(this.walkTokens(i.items, t));
                  break;
                }
                default: {
                  let i = n;
                  this.defaults.extensions?.childTokens?.[i.type]
                    ? this.defaults.extensions.childTokens[i.type].forEach(
                        (s) => {
                          let o = i[s].flat(1 / 0);
                          r = r.concat(this.walkTokens(o, t));
                        },
                      )
                    : i.tokens && (r = r.concat(this.walkTokens(i.tokens, t)));
                }
              }
            return r;
          }
          use(...e) {
            let t = this.defaults.extensions || {
              renderers: {},
              childTokens: {},
            };
            return (
              e.forEach((r) => {
                let n = { ...r };
                if (
                  ((n.async = this.defaults.async || n.async || !1),
                  r.extensions &&
                    (r.extensions.forEach((i) => {
                      if (!i.name) throw new Error("extension name required");
                      if ("renderer" in i) {
                        let s = t.renderers[i.name];
                        s
                          ? (t.renderers[i.name] = function (...o) {
                              let l = i.renderer.apply(this, o);
                              return (l === !1 && (l = s.apply(this, o)), l);
                            })
                          : (t.renderers[i.name] = i.renderer);
                      }
                      if ("tokenizer" in i) {
                        if (
                          !i.level ||
                          (i.level !== "block" && i.level !== "inline")
                        )
                          throw new Error(
                            "extension level must be 'block' or 'inline'",
                          );
                        let s = t[i.level];
                        (s
                          ? s.unshift(i.tokenizer)
                          : (t[i.level] = [i.tokenizer]),
                          i.start &&
                            (i.level === "block"
                              ? t.startBlock
                                ? t.startBlock.push(i.start)
                                : (t.startBlock = [i.start])
                              : i.level === "inline" &&
                                (t.startInline
                                  ? t.startInline.push(i.start)
                                  : (t.startInline = [i.start]))));
                      }
                      "childTokens" in i &&
                        i.childTokens &&
                        (t.childTokens[i.name] = i.childTokens);
                    }),
                    (n.extensions = t)),
                  r.renderer)
                ) {
                  let i = this.defaults.renderer || new Lb(this.defaults);
                  for (let s in r.renderer) {
                    if (!(s in i))
                      throw new Error(`renderer '${s}' does not exist`);
                    if (["options", "parser"].includes(s)) continue;
                    let o = s,
                      l = r.renderer[o],
                      u = i[o];
                    i[o] = (...h) => {
                      let f = l.apply(i, h);
                      return (f === !1 && (f = u.apply(i, h)), f || "");
                    };
                  }
                  n.renderer = i;
                }
                if (r.tokenizer) {
                  let i = this.defaults.tokenizer || new Ab(this.defaults);
                  for (let s in r.tokenizer) {
                    if (!(s in i))
                      throw new Error(`tokenizer '${s}' does not exist`);
                    if (["options", "rules", "lexer"].includes(s)) continue;
                    let o = s,
                      l = r.tokenizer[o],
                      u = i[o];
                    i[o] = (...h) => {
                      let f = l.apply(i, h);
                      return (f === !1 && (f = u.apply(i, h)), f);
                    };
                  }
                  n.tokenizer = i;
                }
                if (r.hooks) {
                  let i = this.defaults.hooks || new vb();
                  for (let s in r.hooks) {
                    if (!(s in i))
                      throw new Error(`hook '${s}' does not exist`);
                    if (["options", "block"].includes(s)) continue;
                    let o = s,
                      l = r.hooks[o],
                      u = i[o];
                    vb.passThroughHooks.has(s)
                      ? (i[o] = (h) => {
                          if (this.defaults.async)
                            return Promise.resolve(l.call(i, h)).then((d) =>
                              u.call(i, d),
                            );
                          let f = l.call(i, h);
                          return u.call(i, f);
                        })
                      : (i[o] = (...h) => {
                          let f = l.apply(i, h);
                          return (f === !1 && (f = u.apply(i, h)), f);
                        });
                  }
                  n.hooks = i;
                }
                if (r.walkTokens) {
                  let i = this.defaults.walkTokens,
                    s = r.walkTokens;
                  n.walkTokens = function (o) {
                    let l = [];
                    return (
                      l.push(s.call(this, o)),
                      i && (l = l.concat(i.call(this, o))),
                      l
                    );
                  };
                }
                this.defaults = { ...this.defaults, ...n };
              }),
              this
            );
          }
          setOptions(e) {
            return ((this.defaults = { ...this.defaults, ...e }), this);
          }
          lexer(e, t) {
            return xl.lex(e, t ?? this.defaults);
          }
          parser(e, t) {
            return bl.parse(e, t ?? this.defaults);
          }
          parseMarkdown(e) {
            return a((r, n) => {
              let i = { ...n },
                s = { ...this.defaults, ...i },
                o = this.onError(!!s.silent, !!s.async);
              if (this.defaults.async === !0 && i.async === !1)
                return o(
                  new Error(
                    "marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise.",
                  ),
                );
              if (typeof r > "u" || r === null)
                return o(
                  new Error("marked(): input parameter is undefined or null"),
                );
              if (typeof r != "string")
                return o(
                  new Error(
                    "marked(): input parameter is of type " +
                      Object.prototype.toString.call(r) +
                      ", string expected",
                  ),
                );
              s.hooks && ((s.hooks.options = s), (s.hooks.block = e));
              let l = s.hooks
                  ? s.hooks.provideLexer()
                  : e
                    ? xl.lex
                    : xl.lexInline,
                u = s.hooks
                  ? s.hooks.provideParser()
                  : e
                    ? bl.parse
                    : bl.parseInline;
              if (s.async)
                return Promise.resolve(s.hooks ? s.hooks.preprocess(r) : r)
                  .then((h) => l(h, s))
                  .then((h) => (s.hooks ? s.hooks.processAllTokens(h) : h))
                  .then((h) =>
                    s.walkTokens
                      ? Promise.all(this.walkTokens(h, s.walkTokens)).then(
                          () => h,
                        )
                      : h,
                  )
                  .then((h) => u(h, s))
                  .then((h) => (s.hooks ? s.hooks.postprocess(h) : h))
                  .catch(o);
              try {
                s.hooks && (r = s.hooks.preprocess(r));
                let h = l(r, s);
                (s.hooks && (h = s.hooks.processAllTokens(h)),
                  s.walkTokens && this.walkTokens(h, s.walkTokens));
                let f = u(h, s);
                return (s.hooks && (f = s.hooks.postprocess(f)), f);
              } catch (h) {
                return o(h);
              }
            }, "parse2");
          }
          onError(e, t) {
            return (r) => {
              if (
                ((r.message += `
Please report this to https://github.com/markedjs/marked.`),
                e)
              ) {
                let n =
                  "<p>An error occurred:</p><pre>" +
                  ko(r.message + "", !0) +
                  "</pre>";
                return t ? Promise.resolve(n) : n;
              }
              if (t) return Promise.reject(r);
              throw r;
            };
          }
        }),
        (Qu = new sbt()));
      a(br, "marked");
      br.options = br.setOptions = function (e) {
        return (
          Qu.setOptions(e),
          (br.defaults = Qu.defaults),
          KG(br.defaults),
          br
        );
      };
      br.getDefaults = Z4;
      br.defaults = Zu;
      br.use = function (...e) {
        return (Qu.use(...e), (br.defaults = Qu.defaults), KG(br.defaults), br);
      };
      br.walkTokens = function (e, t) {
        return Qu.walkTokens(e, t);
      };
      br.parseInline = Qu.parseInline;
      br.Parser = bl;
      br.parser = bl.parse;
      br.Renderer = Lb;
      br.TextRenderer = aA;
      br.Lexer = xl;
      br.lexer = xl.lex;
      br.Tokenizer = Ab;
      br.Hooks = vb;
      br.parse = br;
      ((Oae = br.options),
        (Pae = br.setOptions),
        (Bae = br.use),
        (Fae = br.walkTokens),
        ($ae = br.parseInline),
        (Gae = bl.parse),
        (Vae = xl.lex));
    });
  function abt(e, { markdownAutoWrap: t }) {
    let n = e
        .replace(
          /<br\/>/g,
          `
`,
        )
        .replace(
          /\n{2,}/g,
          `
`,
        ),
      i = bx(n);
    return t === !1 ? i.replace(/ /g, "&nbsp;") : i;
  }
  function lV(e, t = {}) {
    let r = abt(e, t),
      n = br.lexer(r),
      i = [[]],
      s = 0;
    function o(l, u = "normal") {
      l.type === "text"
        ? l.text
            .split(
              `
`,
            )
            .forEach((f, d) => {
              (d !== 0 && (s++, i.push([])),
                f.split(" ").forEach((p) => {
                  ((p = p.replace(/&#39;/g, "'")),
                    p && i[s].push({ content: p, type: u }));
                }));
            })
        : l.type === "strong" || l.type === "em"
          ? l.tokens.forEach((h) => {
              o(h, l.type);
            })
          : l.type === "html" && i[s].push({ content: l.text, type: "normal" });
    }
    return (
      a(o, "processNode"),
      n.forEach((l) => {
        l.type === "paragraph"
          ? l.tokens?.forEach((u) => {
              o(u);
            })
          : l.type === "html"
            ? i[s].push({ content: l.text, type: "normal" })
            : i[s].push({ content: l.raw, type: "normal" });
      }),
      i
    );
  }
  function cV(e, { markdownAutoWrap: t } = {}) {
    let r = br.lexer(e);
    function n(i) {
      return i.type === "text"
        ? t === !1
          ? i.text.replace(/\n */g, "<br/>").replace(/ /g, "&nbsp;")
          : i.text.replace(/\n */g, "<br/>")
        : i.type === "strong"
          ? `<strong>${i.tokens?.map(n).join("")}</strong>`
          : i.type === "em"
            ? `<em>${i.tokens?.map(n).join("")}</em>`
            : i.type === "paragraph"
              ? `<p>${i.tokens?.map(n).join("")}</p>`
              : i.type === "space"
                ? ""
                : i.type === "html"
                  ? `${i.text}`
                  : i.type === "escape"
                    ? i.text
                    : (P.warn(`Unsupported markdown: ${i.type}`), i.raw);
    }
    return (a(n, "output"), r.map(n).join(""));
  }
  var uV = x(() => {
    "use strict";
    oV();
    mw();
    Vt();
    a(abt, "preprocessMarkdown");
    a(lV, "markdownToLines");
    a(cV, "markdownToHTML");
  });
  function obt(e) {
    return Intl.Segmenter
      ? [...new Intl.Segmenter().segment(e)].map((t) => t.segment)
      : [...e];
  }
  function lbt(e, t) {
    let r = obt(t.content);
    return hV(e, [], r, t.type);
  }
  function hV(e, t, r, n) {
    if (r.length === 0)
      return [
        { content: t.join(""), type: n },
        { content: "", type: n },
      ];
    let [i, ...s] = r,
      o = [...t, i];
    return e([{ content: o.join(""), type: n }])
      ? hV(e, o, s, n)
      : (t.length === 0 && i && (t.push(i), r.shift()),
        [
          { content: t.join(""), type: n },
          { content: r.join(""), type: n },
        ]);
  }
  function fV(e, t) {
    if (
      e.some(({ content: r }) =>
        r.includes(`
`),
      )
    )
      throw new Error(
        "splitLineToFitWidth does not support newlines in the line",
      );
    return oA(e, t);
  }
  function oA(e, t, r = [], n = []) {
    if (e.length === 0)
      return (n.length > 0 && r.push(n), r.length > 0 ? r : []);
    let i = "";
    e[0].content === " " && ((i = " "), e.shift());
    let s = e.shift() ?? { content: " ", type: "normal" },
      o = [...n];
    if ((i !== "" && o.push({ content: i, type: "normal" }), o.push(s), t(o)))
      return oA(e, t, r, o);
    if (n.length > 0) (r.push(n), e.unshift(s));
    else if (s.content) {
      let [l, u] = lbt(t, s);
      (r.push([l]), u.content && e.unshift(u));
    }
    return oA(e, t, r);
  }
  var dV = x(() => {
    "use strict";
    a(obt, "splitTextToChars");
    a(lbt, "splitWordToFitWidth");
    a(hV, "splitWordToFitWidthRecursion");
    a(fV, "splitLineToFitWidth");
    a(oA, "splitLineToFitWidthRecursion");
  });
  function pV(e, t) {
    t && e.attr("style", t);
  }
  async function cbt(e, t, r, n, i = !1, s = ke()) {
    let o = e.append("foreignObject");
    (o.attr("width", `${10 * r}px`), o.attr("height", `${10 * r}px`));
    let l = o.append("xhtml:div"),
      u = $r(t.label)
        ? await Kl(
            t.label.replace(
              Rt.lineBreakRegex,
              `
`,
            ),
            s,
          )
        : Ie(t.label, s),
      h = t.isNode ? "nodeLabel" : "edgeLabel",
      f = l.append("span");
    (f.html(u),
      pV(f, t.labelStyle),
      f.attr("class", `${h} ${n}`),
      pV(l, t.labelStyle),
      l.style("display", "table-cell"),
      l.style("white-space", "nowrap"),
      l.style("line-height", "1.5"),
      l.style("max-width", r + "px"),
      l.style("text-align", "center"),
      l.attr("xmlns", "http://www.w3.org/1999/xhtml"),
      i && l.attr("class", "labelBkg"));
    let d = l.node().getBoundingClientRect();
    return (
      d.width === r &&
        (l.style("display", "table"),
        l.style("white-space", "break-spaces"),
        l.style("width", r + "px"),
        (d = l.node().getBoundingClientRect())),
      o.node()
    );
  }
  function lA(e, t, r) {
    return e
      .append("tspan")
      .attr("class", "text-outer-tspan")
      .attr("x", 0)
      .attr("y", t * r - 0.1 + "em")
      .attr("dy", r + "em");
  }
  function ubt(e, t, r) {
    let n = e.append("text"),
      i = lA(n, 1, t);
    cA(i, r);
    let s = i.node().getComputedTextLength();
    return (n.remove(), s);
  }
  function mV(e, t, r) {
    let n = e.append("text"),
      i = lA(n, 1, t);
    cA(i, [{ content: r, type: "normal" }]);
    let s = i.node()?.getBoundingClientRect();
    return (s && n.remove(), s);
  }
  function hbt(e, t, r, n = !1) {
    let s = t.append("g"),
      o = s
        .insert("rect")
        .attr("class", "background")
        .attr("style", "stroke: none"),
      l = s.append("text").attr("y", "-10.1"),
      u = 0;
    for (let h of r) {
      let f = a((p) => ubt(s, 1.1, p) <= e, "checkWidth"),
        d = f(h) ? [h] : fV(h, f);
      for (let p of d) {
        let m = lA(l, u, 1.1);
        (cA(m, p), u++);
      }
    }
    if (n) {
      let h = l.node().getBBox(),
        f = 2;
      return (
        o
          .attr("x", h.x - f)
          .attr("y", h.y - f)
          .attr("width", h.width + 2 * f)
          .attr("height", h.height + 2 * f),
        s.node()
      );
    } else return l.node();
  }
  function cA(e, t) {
    (e.text(""),
      t.forEach((r, n) => {
        let i = e
          .append("tspan")
          .attr("font-style", r.type === "em" ? "italic" : "normal")
          .attr("class", "text-inner-tspan")
          .attr("font-weight", r.type === "strong" ? "bold" : "normal");
        n === 0 ? i.text(r.content) : i.text(" " + r.content);
      }));
  }
  async function uA(e, t = {}) {
    let r = [];
    e.replace(
      /(fa[bklrs]?):fa-([\w-]+)/g,
      (i, s, o) => (
        r.push(
          (async () => {
            let l = `${s}:${o}`;
            return (await _7(l))
              ? await no(l, void 0, { class: "label-icon" })
              : `<i class='${Ie(i, t).replace(":", " ")}'></i>`;
          })(),
        ),
        i
      ),
    );
    let n = await Promise.all(r);
    return e.replace(/(fa[bklrs]?):fa-([\w-]+)/g, () => n.shift() ?? "");
  }
  var Kn,
    Ga = x(() => {
      "use strict";
      Ge();
      Be();
      Vt();
      uV();
      _e();
      bu();
      dV();
      un();
      a(pV, "applyStyle");
      a(cbt, "addHtmlSpan");
      a(lA, "createTspan");
      a(ubt, "computeWidthOfText");
      a(mV, "computeDimensionOfText");
      a(hbt, "createFormattedText");
      a(cA, "updateTextContentAndStyles");
      a(uA, "replaceIconSubstring");
      Kn = a(
        async (
          e,
          t = "",
          {
            style: r = "",
            isTitle: n = !1,
            classes: i = "",
            useHtmlLabels: s = !0,
            isNode: o = !0,
            width: l = 200,
            addSvgBackground: u = !1,
          } = {},
          h,
        ) => {
          if (
            (P.debug(
              "XYZ createText",
              t,
              r,
              n,
              i,
              s,
              o,
              "addSvgBackground: ",
              u,
            ),
            s)
          ) {
            let f = cV(t, h),
              d = await uA(Xn(f), h),
              p = t.replace(/\\\\/g, "\\"),
              m = {
                isNode: o,
                label: $r(t) ? p : d,
                labelStyle: r.replace("fill:", "color:"),
              };
            return await cbt(e, m, l, i, u, h);
          } else {
            let f = t.replace(/<br\s*\/?>/g, "<br/>"),
              d = lV(f.replace("<br>", "<br/>"), h),
              p = hbt(l, e, d, t ? u : !1);
            if (o) {
              /stroke:/.exec(r) && (r = r.replace("stroke:", "lineColor:"));
              let m = r
                .replace(/stroke:[^;]+;?/g, "")
                .replace(/stroke-width:[^;]+;?/g, "")
                .replace(/fill:[^;]+;?/g, "")
                .replace(/color:/g, "fill:");
              xt(p).attr("style", m);
            } else {
              let m = r
                .replace(/stroke:[^;]+;?/g, "")
                .replace(/stroke-width:[^;]+;?/g, "")
                .replace(/fill:[^;]+;?/g, "")
                .replace(/background:/g, "fill:");
              xt(p)
                .select("rect")
                .attr("style", m.replace(/background:/g, "fill:"));
              let g = r
                .replace(/stroke:[^;]+;?/g, "")
                .replace(/stroke-width:[^;]+;?/g, "")
                .replace(/fill:[^;]+;?/g, "")
                .replace(/color:/g, "fill:");
              xt(p).select("text").attr("style", g);
            }
            return p;
          }
        },
        "createText",
      );
    });
  function ie(e) {
    let t = e.map((r, n) => `${n === 0 ? "M" : "L"}${r.x},${r.y}`);
    return (t.push("Z"), t.join(" "));
  }
  function ra(e, t, r, n, i, s) {
    let o = [],
      u = r - e,
      h = n - t,
      f = u / s,
      d = (2 * Math.PI) / f,
      p = t + h / 2;
    for (let m = 0; m <= 50; m++) {
      let g = m / 50,
        y = e + g * u,
        b = p + i * Math.sin(d * (y - e));
      o.push({ x: y, y: b });
    }
    return o;
  }
  function Ju(e, t, r, n, i, s) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1);
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p);
      o.push({ x: -m, y: -g });
    }
    return o;
  }
  var Bt,
    Nb,
    Ct,
    Ot,
    Qt = x(() => {
      "use strict";
      Ga();
      pe();
      Ge();
      Ss();
      Be();
      _e();
      ((Bt = a(async (e, t, r) => {
        let n,
          i = t.useHtmlLabels || Pe(K()?.htmlLabels);
        r ? (n = r) : (n = "node default");
        let s = e
            .insert("g")
            .attr("class", n)
            .attr("id", t.domId || t.id),
          o = s
            .insert("g")
            .attr("class", "label")
            .attr("style", Ir(t.labelStyle)),
          l;
        t.label === void 0
          ? (l = "")
          : (l = typeof t.label == "string" ? t.label : t.label[0]);
        let u = await Kn(o, Ie(Xn(l), K()), {
            useHtmlLabels: i,
            width: t.width || K().flowchart?.wrappingWidth,
            cssClasses: "markdown-node-label",
            style: t.labelStyle,
            addSvgBackground: !!t.icon || !!t.img,
          }),
          h = u.getBBox(),
          f = (t?.padding ?? 0) / 2;
        if (i) {
          let d = u.children[0],
            p = xt(u),
            m = d.getElementsByTagName("img");
          if (m) {
            let g = l.replace(/<img[^>]*>/g, "").trim() === "";
            await Promise.all(
              [...m].map(
                (y) =>
                  new Promise((b) => {
                    function k() {
                      if (
                        ((y.style.display = "flex"),
                        (y.style.flexDirection = "column"),
                        g)
                      ) {
                        let T = K().fontSize
                            ? K().fontSize
                            : window.getComputedStyle(document.body).fontSize,
                          C = 5,
                          [L = ze.fontSize] = xo(T),
                          w = L * C + "px";
                        ((y.style.minWidth = w), (y.style.maxWidth = w));
                      } else y.style.width = "100%";
                      b(y);
                    }
                    (a(k, "setupImage"),
                      setTimeout(() => {
                        y.complete && k();
                      }),
                      y.addEventListener("error", k),
                      y.addEventListener("load", k));
                  }),
              ),
            );
          }
          ((h = d.getBoundingClientRect()),
            p.attr("width", h.width),
            p.attr("height", h.height));
        }
        return (
          i
            ? o.attr(
                "transform",
                "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")",
              )
            : o.attr("transform", "translate(0, " + -h.height / 2 + ")"),
          t.centerLabel &&
            o.attr(
              "transform",
              "translate(" + -h.width / 2 + ", " + -h.height / 2 + ")",
            ),
          o.insert("rect", ":first-child"),
          { shapeSvg: s, bbox: h, halfPadding: f, label: o }
        );
      }, "labelHelper")),
        (Nb = a(async (e, t, r) => {
          let n = r.useHtmlLabels || Pe(K()?.flowchart?.htmlLabels),
            i = e
              .insert("g")
              .attr("class", "label")
              .attr("style", r.labelStyle || ""),
            s = await Kn(i, Ie(Xn(t), K()), {
              useHtmlLabels: n,
              width: r.width || K()?.flowchart?.wrappingWidth,
              style: r.labelStyle,
              addSvgBackground: !!r.icon || !!r.img,
            }),
            o = s.getBBox(),
            l = r.padding / 2;
          if (Pe(K()?.flowchart?.htmlLabels)) {
            let u = s.children[0],
              h = xt(s);
            ((o = u.getBoundingClientRect()),
              h.attr("width", o.width),
              h.attr("height", o.height));
          }
          return (
            n
              ? i.attr(
                  "transform",
                  "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")",
                )
              : i.attr("transform", "translate(0, " + -o.height / 2 + ")"),
            r.centerLabel &&
              i.attr(
                "transform",
                "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")",
              ),
            i.insert("rect", ":first-child"),
            { shapeSvg: e, bbox: o, halfPadding: l, label: i }
          );
        }, "insertLabel")),
        (Ct = a((e, t) => {
          let r = t.node().getBBox();
          ((e.width = r.width), (e.height = r.height));
        }, "updateNodeBounds")),
        (Ot = a(
          (e, t) =>
            (e.look === "handDrawn" ? "rough-node" : "node") +
            " " +
            e.cssClasses +
            " " +
            (t || ""),
          "getNodeClasses",
        )));
      a(ie, "createPathFromPoints");
      a(ra, "generateFullSineWavePoints");
      a(Ju, "generateCirclePoints");
    });
  function fbt(e, t) {
    return e.intersect(t);
  }
  var gV,
    yV = x(() => {
      "use strict";
      a(fbt, "intersectNode");
      gV = fbt;
    });
  function dbt(e, t, r, n) {
    var i = e.x,
      s = e.y,
      o = i - n.x,
      l = s - n.y,
      u = Math.sqrt(t * t * l * l + r * r * o * o),
      h = Math.abs((t * r * o) / u);
    n.x < i && (h = -h);
    var f = Math.abs((t * r * l) / u);
    return (n.y < s && (f = -f), { x: i + h, y: s + f });
  }
  var Ib,
    hA = x(() => {
      "use strict";
      a(dbt, "intersectEllipse");
      Ib = dbt;
    });
  function pbt(e, t, r) {
    return Ib(e, t, t, r);
  }
  var xV,
    bV = x(() => {
      "use strict";
      hA();
      a(pbt, "intersectCircle");
      xV = pbt;
    });
  function mbt(e, t, r, n) {
    {
      let i = t.y - e.y,
        s = e.x - t.x,
        o = t.x * e.y - e.x * t.y,
        l = i * r.x + s * r.y + o,
        u = i * n.x + s * n.y + o,
        h = 1e-6;
      if (l !== 0 && u !== 0 && kV(l, u)) return;
      let f = n.y - r.y,
        d = r.x - n.x,
        p = n.x * r.y - r.x * n.y,
        m = f * e.x + d * e.y + p,
        g = f * t.x + d * t.y + p;
      if (Math.abs(m) < h && Math.abs(g) < h && kV(m, g)) return;
      let y = i * d - f * s;
      if (y === 0) return;
      let b = Math.abs(y / 2),
        k = s * p - d * o,
        T = k < 0 ? (k - b) / y : (k + b) / y;
      k = f * o - i * p;
      let C = k < 0 ? (k - b) / y : (k + b) / y;
      return { x: T, y: C };
    }
  }
  function kV(e, t) {
    return e * t > 0;
  }
  var TV,
    SV = x(() => {
      "use strict";
      a(mbt, "intersectLine");
      a(kV, "sameSign");
      TV = mbt;
    });
  function gbt(e, t, r) {
    let n = e.x,
      i = e.y,
      s = [],
      o = Number.POSITIVE_INFINITY,
      l = Number.POSITIVE_INFINITY;
    typeof t.forEach == "function"
      ? t.forEach(function (f) {
          ((o = Math.min(o, f.x)), (l = Math.min(l, f.y)));
        })
      : ((o = Math.min(o, t.x)), (l = Math.min(l, t.y)));
    let u = n - e.width / 2 - o,
      h = i - e.height / 2 - l;
    for (let f = 0; f < t.length; f++) {
      let d = t[f],
        p = t[f < t.length - 1 ? f + 1 : 0],
        m = TV(e, r, { x: u + d.x, y: h + d.y }, { x: u + p.x, y: h + p.y });
      m && s.push(m);
    }
    return s.length
      ? (s.length > 1 &&
          s.sort(function (f, d) {
            let p = f.x - r.x,
              m = f.y - r.y,
              g = Math.sqrt(p * p + m * m),
              y = d.x - r.x,
              b = d.y - r.y,
              k = Math.sqrt(y * y + b * b);
            return g < k ? -1 : g === k ? 0 : 1;
          }),
        s[0])
      : e;
  }
  var _V,
    CV = x(() => {
      "use strict";
      SV();
      a(gbt, "intersectPolygon");
      _V = gbt;
    });
  var ybt,
    vc,
    fA = x(() => {
      "use strict";
      ((ybt = a((e, t) => {
        var r = e.x,
          n = e.y,
          i = t.x - r,
          s = t.y - n,
          o = e.width / 2,
          l = e.height / 2,
          u,
          h;
        return (
          Math.abs(s) * o > Math.abs(i) * l
            ? (s < 0 && (l = -l), (u = s === 0 ? 0 : (l * i) / s), (h = l))
            : (i < 0 && (o = -o), (u = o), (h = i === 0 ? 0 : (o * s) / i)),
          { x: r + u, y: n + h }
        );
      }, "intersectRect")),
        (vc = ybt));
    });
  var Tt,
    ae = x(() => {
      "use strict";
      yV();
      bV();
      hA();
      CV();
      fA();
      Tt = { node: gV, circle: xV, ellipse: Ib, polygon: _V, rect: vc };
    });
  var wV,
    To,
    xbt,
    D0,
    St,
    vt,
    bbt,
    re = x(() => {
      "use strict";
      pe();
      ((wV = a((e) => {
        let { handDrawnSeed: t } = K();
        return {
          fill: e,
          hachureAngle: 120,
          hachureGap: 4,
          fillWeight: 2,
          roughness: 0.7,
          stroke: e,
          seed: t,
        };
      }, "solidStateFill")),
        (To = a((e) => {
          let t = xbt([...(e.cssCompiledStyles || []), ...(e.cssStyles || [])]);
          return { stylesMap: t, stylesArray: [...t] };
        }, "compileStyles")),
        (xbt = a((e) => {
          let t = new Map();
          return (
            e.forEach((r) => {
              let [n, i] = r.split(":");
              t.set(n.trim(), i?.trim());
            }),
            t
          );
        }, "styles2Map")),
        (D0 = a(
          (e) =>
            e === "color" ||
            e === "font-size" ||
            e === "font-family" ||
            e === "font-weight" ||
            e === "font-style" ||
            e === "text-decoration" ||
            e === "text-align" ||
            e === "text-transform" ||
            e === "line-height" ||
            e === "letter-spacing" ||
            e === "word-spacing" ||
            e === "text-shadow" ||
            e === "text-overflow" ||
            e === "white-space" ||
            e === "word-wrap" ||
            e === "word-break" ||
            e === "overflow-wrap" ||
            e === "hyphens",
          "isLabelStyle",
        )),
        (St = a((e) => {
          let { stylesArray: t } = To(e),
            r = [],
            n = [],
            i = [],
            s = [];
          return (
            t.forEach((o) => {
              let l = o[0];
              D0(l)
                ? r.push(o.join(":") + " !important")
                : (n.push(o.join(":") + " !important"),
                  l.includes("stroke") && i.push(o.join(":") + " !important"),
                  l === "fill" && s.push(o.join(":") + " !important"));
            }),
            {
              labelStyles: r.join(";"),
              nodeStyles: n.join(";"),
              stylesArray: t,
              borderStyles: i,
              backgroundStyles: s,
            }
          );
        }, "styles2String")),
        (vt = a((e, t) => {
          let { themeVariables: r, handDrawnSeed: n } = K(),
            { nodeBorder: i, mainBkg: s } = r,
            { stylesMap: o } = To(e);
          return Object.assign(
            {
              roughness: 0.7,
              fill: o.get("fill") || s,
              fillStyle: "hachure",
              fillWeight: 4,
              hachureGap: 5.2,
              stroke: o.get("stroke") || i,
              seed: n,
              strokeWidth: o.get("stroke-width")?.replace("px", "") || 1.3,
              fillLineDash: [0, 0],
              strokeLineDash: bbt(o.get("stroke-dasharray")),
            },
            t,
          );
        }, "userNodeOverrides")),
        (bbt = a((e) => {
          if (!e) return [0, 0];
          let t = e.trim().split(/\s+/).map(Number);
          if (t.length === 1) {
            let i = isNaN(t[0]) ? 0 : t[0];
            return [i, i];
          }
          let r = isNaN(t[0]) ? 0 : t[0],
            n = isNaN(t[1]) ? 0 : t[1];
          return [r, n];
        }, "getStrokeDashArray")));
    });
  function dA(e, t, r) {
    if (e && e.length) {
      let [n, i] = t,
        s = (Math.PI / 180) * r,
        o = Math.cos(s),
        l = Math.sin(s);
      for (let u of e) {
        let [h, f] = u;
        ((u[0] = (h - n) * o - (f - i) * l + n),
          (u[1] = (h - n) * l + (f - i) * o + i));
      }
    }
  }
  function kbt(e, t) {
    return e[0] === t[0] && e[1] === t[1];
  }
  function Tbt(e, t, r, n = 1) {
    let i = r,
      s = Math.max(t, 0.1),
      o = e[0] && e[0][0] && typeof e[0][0] == "number" ? [e] : e,
      l = [0, 0];
    if (i) for (let h of o) dA(h, l, i);
    let u = (function (h, f, d) {
      let p = [];
      for (let T of h) {
        let C = [...T];
        (kbt(C[0], C[C.length - 1]) || C.push([C[0][0], C[0][1]]),
          C.length > 2 && p.push(C));
      }
      let m = [];
      f = Math.max(f, 0.1);
      let g = [];
      for (let T of p)
        for (let C = 0; C < T.length - 1; C++) {
          let L = T[C],
            w = T[C + 1];
          if (L[1] !== w[1]) {
            let D = Math.min(L[1], w[1]);
            g.push({
              ymin: D,
              ymax: Math.max(L[1], w[1]),
              x: D === L[1] ? L[0] : w[0],
              islope: (w[0] - L[0]) / (w[1] - L[1]),
            });
          }
        }
      if (
        (g.sort((T, C) =>
          T.ymin < C.ymin
            ? -1
            : T.ymin > C.ymin
              ? 1
              : T.x < C.x
                ? -1
                : T.x > C.x
                  ? 1
                  : T.ymax === C.ymax
                    ? 0
                    : (T.ymax - C.ymax) / Math.abs(T.ymax - C.ymax),
        ),
        !g.length)
      )
        return m;
      let y = [],
        b = g[0].ymin,
        k = 0;
      for (; y.length || g.length; ) {
        if (g.length) {
          let T = -1;
          for (let C = 0; C < g.length && !(g[C].ymin > b); C++) T = C;
          g.splice(0, T + 1).forEach((C) => {
            y.push({ s: b, edge: C });
          });
        }
        if (
          ((y = y.filter((T) => !(T.edge.ymax <= b))),
          y.sort((T, C) =>
            T.edge.x === C.edge.x
              ? 0
              : (T.edge.x - C.edge.x) / Math.abs(T.edge.x - C.edge.x),
          ),
          (d !== 1 || k % f == 0) && y.length > 1)
        )
          for (let T = 0; T < y.length; T += 2) {
            let C = T + 1;
            if (C >= y.length) break;
            let L = y[T].edge,
              w = y[C].edge;
            m.push([
              [Math.round(L.x), b],
              [Math.round(w.x), b],
            ]);
          }
        ((b += d),
          y.forEach((T) => {
            T.edge.x = T.edge.x + d * T.edge.islope;
          }),
          k++);
      }
      return m;
    })(o, s, n);
    if (i) {
      for (let h of o) dA(h, l, -i);
      (function (h, f, d) {
        let p = [];
        (h.forEach((m) => p.push(...m)), dA(p, f, d));
      })(u, l, -i);
    }
    return u;
  }
  function O0(e, t) {
    var r;
    let n = t.hachureAngle + 90,
      i = t.hachureGap;
    (i < 0 && (i = 4 * t.strokeWidth), (i = Math.round(Math.max(i, 0.1))));
    let s = 1;
    return (
      t.roughness >= 1 &&
        (((r = t.randomizer) === null || r === void 0 ? void 0 : r.next()) ||
          Math.random()) > 0.7 &&
        (s = i),
      Tbt(e, i, n, s || 1)
    );
  }
  function zb(e) {
    let t = e[0],
      r = e[1];
    return Math.sqrt(Math.pow(t[0] - r[0], 2) + Math.pow(t[1] - r[1], 2));
  }
  function mA(e, t) {
    return e.type === t;
  }
  function LA(e) {
    let t = [],
      r = (function (o) {
        let l = new Array();
        for (; o !== ""; )
          if (o.match(/^([ \t\r\n,]+)/)) o = o.substr(RegExp.$1.length);
          else if (o.match(/^([aAcChHlLmMqQsStTvVzZ])/))
            ((l[l.length] = { type: Sbt, text: RegExp.$1 }),
              (o = o.substr(RegExp.$1.length)));
          else {
            if (
              !o.match(
                /^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/,
              )
            )
              return [];
            ((l[l.length] = { type: pA, text: `${parseFloat(RegExp.$1)}` }),
              (o = o.substr(RegExp.$1.length)));
          }
        return ((l[l.length] = { type: vV, text: "" }), l);
      })(e),
      n = "BOD",
      i = 0,
      s = r[i];
    for (; !mA(s, vV); ) {
      let o = 0,
        l = [];
      if (n === "BOD") {
        if (s.text !== "M" && s.text !== "m") return LA("M0,0" + e);
        (i++, (o = Mb[s.text]), (n = s.text));
      } else mA(s, pA) ? (o = Mb[n]) : (i++, (o = Mb[s.text]), (n = s.text));
      if (!(i + o < r.length)) throw new Error("Path data ended short");
      for (let u = i; u < i + o; u++) {
        let h = r[u];
        if (!mA(h, pA))
          throw new Error("Param not a number: " + n + "," + h.text);
        l[l.length] = +h.text;
      }
      if (typeof Mb[n] != "number") throw new Error("Bad segment: " + n);
      {
        let u = { key: n, data: l };
        (t.push(u),
          (i += o),
          (s = r[i]),
          n === "M" && (n = "L"),
          n === "m" && (n = "l"));
      }
    }
    return t;
  }
  function MV(e) {
    let t = 0,
      r = 0,
      n = 0,
      i = 0,
      s = [];
    for (let { key: o, data: l } of e)
      switch (o) {
        case "M":
          (s.push({ key: "M", data: [...l] }), ([t, r] = l), ([n, i] = l));
          break;
        case "m":
          ((t += l[0]),
            (r += l[1]),
            s.push({ key: "M", data: [t, r] }),
            (n = t),
            (i = r));
          break;
        case "L":
          (s.push({ key: "L", data: [...l] }), ([t, r] = l));
          break;
        case "l":
          ((t += l[0]), (r += l[1]), s.push({ key: "L", data: [t, r] }));
          break;
        case "C":
          (s.push({ key: "C", data: [...l] }), (t = l[4]), (r = l[5]));
          break;
        case "c": {
          let u = l.map((h, f) => (f % 2 ? h + r : h + t));
          (s.push({ key: "C", data: u }), (t = u[4]), (r = u[5]));
          break;
        }
        case "Q":
          (s.push({ key: "Q", data: [...l] }), (t = l[2]), (r = l[3]));
          break;
        case "q": {
          let u = l.map((h, f) => (f % 2 ? h + r : h + t));
          (s.push({ key: "Q", data: u }), (t = u[2]), (r = u[3]));
          break;
        }
        case "A":
          (s.push({ key: "A", data: [...l] }), (t = l[5]), (r = l[6]));
          break;
        case "a":
          ((t += l[5]),
            (r += l[6]),
            s.push({ key: "A", data: [l[0], l[1], l[2], l[3], l[4], t, r] }));
          break;
        case "H":
          (s.push({ key: "H", data: [...l] }), (t = l[0]));
          break;
        case "h":
          ((t += l[0]), s.push({ key: "H", data: [t] }));
          break;
        case "V":
          (s.push({ key: "V", data: [...l] }), (r = l[0]));
          break;
        case "v":
          ((r += l[0]), s.push({ key: "V", data: [r] }));
          break;
        case "S":
          (s.push({ key: "S", data: [...l] }), (t = l[2]), (r = l[3]));
          break;
        case "s": {
          let u = l.map((h, f) => (f % 2 ? h + r : h + t));
          (s.push({ key: "S", data: u }), (t = u[2]), (r = u[3]));
          break;
        }
        case "T":
          (s.push({ key: "T", data: [...l] }), (t = l[0]), (r = l[1]));
          break;
        case "t":
          ((t += l[0]), (r += l[1]), s.push({ key: "T", data: [t, r] }));
          break;
        case "Z":
        case "z":
          (s.push({ key: "Z", data: [] }), (t = n), (r = i));
      }
    return s;
  }
  function OV(e) {
    let t = [],
      r = "",
      n = 0,
      i = 0,
      s = 0,
      o = 0,
      l = 0,
      u = 0;
    for (let { key: h, data: f } of e) {
      switch (h) {
        case "M":
          (t.push({ key: "M", data: [...f] }), ([n, i] = f), ([s, o] = f));
          break;
        case "C":
          (t.push({ key: "C", data: [...f] }),
            (n = f[4]),
            (i = f[5]),
            (l = f[2]),
            (u = f[3]));
          break;
        case "L":
          (t.push({ key: "L", data: [...f] }), ([n, i] = f));
          break;
        case "H":
          ((n = f[0]), t.push({ key: "L", data: [n, i] }));
          break;
        case "V":
          ((i = f[0]), t.push({ key: "L", data: [n, i] }));
          break;
        case "S": {
          let d = 0,
            p = 0;
          (r === "C" || r === "S"
            ? ((d = n + (n - l)), (p = i + (i - u)))
            : ((d = n), (p = i)),
            t.push({ key: "C", data: [d, p, ...f] }),
            (l = f[0]),
            (u = f[1]),
            (n = f[2]),
            (i = f[3]));
          break;
        }
        case "T": {
          let [d, p] = f,
            m = 0,
            g = 0;
          r === "Q" || r === "T"
            ? ((m = n + (n - l)), (g = i + (i - u)))
            : ((m = n), (g = i));
          let y = n + (2 * (m - n)) / 3,
            b = i + (2 * (g - i)) / 3,
            k = d + (2 * (m - d)) / 3,
            T = p + (2 * (g - p)) / 3;
          (t.push({ key: "C", data: [y, b, k, T, d, p] }),
            (l = m),
            (u = g),
            (n = d),
            (i = p));
          break;
        }
        case "Q": {
          let [d, p, m, g] = f,
            y = n + (2 * (d - n)) / 3,
            b = i + (2 * (p - i)) / 3,
            k = m + (2 * (d - m)) / 3,
            T = g + (2 * (p - g)) / 3;
          (t.push({ key: "C", data: [y, b, k, T, m, g] }),
            (l = d),
            (u = p),
            (n = m),
            (i = g));
          break;
        }
        case "A": {
          let d = Math.abs(f[0]),
            p = Math.abs(f[1]),
            m = f[2],
            g = f[3],
            y = f[4],
            b = f[5],
            k = f[6];
          d === 0 || p === 0
            ? (t.push({ key: "C", data: [n, i, b, k, b, k] }), (n = b), (i = k))
            : (n !== b || i !== k) &&
              (PV(n, i, b, k, d, p, m, g, y).forEach(function (T) {
                t.push({ key: "C", data: T });
              }),
              (n = b),
              (i = k));
          break;
        }
        case "Z":
          (t.push({ key: "Z", data: [] }), (n = s), (i = o));
      }
      r = h;
    }
    return t;
  }
  function N0(e, t, r) {
    return [
      e * Math.cos(r) - t * Math.sin(r),
      e * Math.sin(r) + t * Math.cos(r),
    ];
  }
  function PV(e, t, r, n, i, s, o, l, u, h) {
    let f = ((d = o), (Math.PI * d) / 180);
    var d;
    let p = [],
      m = 0,
      g = 0,
      y = 0,
      b = 0;
    if (h) [m, g, y, b] = h;
    else {
      (([e, t] = N0(e, t, -f)), ([r, n] = N0(r, n, -f)));
      let v = (e - r) / 2,
        _ = (t - n) / 2,
        A = (v * v) / (i * i) + (_ * _) / (s * s);
      A > 1 && ((A = Math.sqrt(A)), (i *= A), (s *= A));
      let N = i * i,
        B = s * s,
        M = N * B - N * _ * _ - B * v * v,
        I = N * _ * _ + B * v * v,
        V = (l === u ? -1 : 1) * Math.sqrt(Math.abs(M / I));
      ((y = (V * i * _) / s + (e + r) / 2),
        (b = (V * -s * v) / i + (t + n) / 2),
        (m = Math.asin(parseFloat(((t - b) / s).toFixed(9)))),
        (g = Math.asin(parseFloat(((n - b) / s).toFixed(9)))),
        e < y && (m = Math.PI - m),
        r < y && (g = Math.PI - g),
        m < 0 && (m = 2 * Math.PI + m),
        g < 0 && (g = 2 * Math.PI + g),
        u && m > g && (m -= 2 * Math.PI),
        !u && g > m && (g -= 2 * Math.PI));
    }
    let k = g - m;
    if (Math.abs(k) > (120 * Math.PI) / 180) {
      let v = g,
        _ = r,
        A = n;
      ((g =
        u && g > m
          ? m + ((120 * Math.PI) / 180) * 1
          : m + ((120 * Math.PI) / 180) * -1),
        (p = PV(
          (r = y + i * Math.cos(g)),
          (n = b + s * Math.sin(g)),
          _,
          A,
          i,
          s,
          o,
          0,
          u,
          [g, v, y, b],
        )));
    }
    k = g - m;
    let T = Math.cos(m),
      C = Math.sin(m),
      L = Math.cos(g),
      w = Math.sin(g),
      D = Math.tan(k / 4),
      G = (4 / 3) * i * D,
      E = (4 / 3) * s * D,
      R = [e, t],
      F = [e + G * C, t - E * T],
      S = [r + G * w, n - E * L],
      O = [r, n];
    if (((F[0] = 2 * R[0] - F[0]), (F[1] = 2 * R[1] - F[1]), h))
      return [F, S, O].concat(p);
    {
      p = [F, S, O].concat(p);
      let v = [];
      for (let _ = 0; _ < p.length; _ += 3) {
        let A = N0(p[_][0], p[_][1], f),
          N = N0(p[_ + 1][0], p[_ + 1][1], f),
          B = N0(p[_ + 2][0], p[_ + 2][1], f);
        v.push([A[0], A[1], N[0], N[1], B[0], B[1]]);
      }
      return v;
    }
  }
  function BV(e, t, r, n, i) {
    return { type: "path", ops: Ec(e, t, r, n, i) };
  }
  function Bb(e, t, r) {
    let n = (e || []).length;
    if (n > 2) {
      let i = [];
      for (let s = 0; s < n - 1; s++)
        i.push(...Ec(e[s][0], e[s][1], e[s + 1][0], e[s + 1][1], r));
      return (
        t && i.push(...Ec(e[n - 1][0], e[n - 1][1], e[0][0], e[0][1], r)),
        { type: "path", ops: i }
      );
    }
    return n === 2
      ? BV(e[0][0], e[0][1], e[1][0], e[1][1], r)
      : { type: "path", ops: [] };
  }
  function Cbt(e, t, r, n, i) {
    return (function (s, o) {
      return Bb(s, !0, o);
    })(
      [
        [e, t],
        [e + r, t],
        [e + r, t + n],
        [e, t + n],
      ],
      i,
    );
  }
  function EV(e, t) {
    if (e.length) {
      let r = typeof e[0][0] == "number" ? [e] : e,
        n = Ob(r[0], 1 * (1 + 0.2 * t.roughness), t),
        i = t.disableMultiStroke
          ? []
          : Ob(r[0], 1.5 * (1 + 0.22 * t.roughness), RV(t));
      for (let s = 1; s < r.length; s++) {
        let o = r[s];
        if (o.length) {
          let l = Ob(o, 1 * (1 + 0.2 * t.roughness), t),
            u = t.disableMultiStroke
              ? []
              : Ob(o, 1.5 * (1 + 0.22 * t.roughness), RV(t));
          for (let h of l) h.op !== "move" && n.push(h);
          for (let h of u) h.op !== "move" && i.push(h);
        }
      }
      return { type: "path", ops: n.concat(i) };
    }
    return { type: "path", ops: [] };
  }
  function FV(e, t, r) {
    let n = Math.sqrt(
        2 * Math.PI * Math.sqrt((Math.pow(e / 2, 2) + Math.pow(t / 2, 2)) / 2),
      ),
      i = Math.ceil(
        Math.max(r.curveStepCount, (r.curveStepCount / Math.sqrt(200)) * n),
      ),
      s = (2 * Math.PI) / i,
      o = Math.abs(e / 2),
      l = Math.abs(t / 2),
      u = 1 - r.curveFitting;
    return (
      (o += we(o * u, r)),
      (l += we(l * u, r)),
      { increment: s, rx: o, ry: l }
    );
  }
  function CA(e, t, r, n) {
    let [i, s] = DV(
        n.increment,
        e,
        t,
        n.rx,
        n.ry,
        1,
        n.increment * $b(0.1, $b(0.4, 1, r), r),
        r,
      ),
      o = Gb(i, null, r);
    if (!r.disableMultiStroke && r.roughness !== 0) {
      let [l] = DV(n.increment, e, t, n.rx, n.ry, 1.5, 0, r),
        u = Gb(l, null, r);
      o = o.concat(u);
    }
    return { estimatedPoints: s, opset: { type: "path", ops: o } };
  }
  function AV(e, t, r, n, i, s, o, l, u) {
    let h = e,
      f = t,
      d = Math.abs(r / 2),
      p = Math.abs(n / 2);
    ((d += we(0.01 * d, u)), (p += we(0.01 * p, u)));
    let m = i,
      g = s;
    for (; m < 0; ) ((m += 2 * Math.PI), (g += 2 * Math.PI));
    g - m > 2 * Math.PI && ((m = 0), (g = 2 * Math.PI));
    let y = (2 * Math.PI) / u.curveStepCount,
      b = Math.min(y / 2, (g - m) / 2),
      k = NV(b, h, f, d, p, m, g, 1, u);
    if (!u.disableMultiStroke) {
      let T = NV(b, h, f, d, p, m, g, 1.5, u);
      k.push(...T);
    }
    return (
      o &&
        (l
          ? k.push(
              ...Ec(h, f, h + d * Math.cos(m), f + p * Math.sin(m), u),
              ...Ec(h, f, h + d * Math.cos(g), f + p * Math.sin(g), u),
            )
          : k.push(
              { op: "lineTo", data: [h, f] },
              {
                op: "lineTo",
                data: [h + d * Math.cos(m), f + p * Math.sin(m)],
              },
            )),
      { type: "path", ops: k }
    );
  }
  function LV(e, t) {
    let r = OV(MV(LA(e))),
      n = [],
      i = [0, 0],
      s = [0, 0];
    for (let { key: o, data: l } of r)
      switch (o) {
        case "M":
          ((s = [l[0], l[1]]), (i = [l[0], l[1]]));
          break;
        case "L":
          (n.push(...Ec(s[0], s[1], l[0], l[1], t)), (s = [l[0], l[1]]));
          break;
        case "C": {
          let [u, h, f, d, p, m] = l;
          (n.push(...wbt(u, h, f, d, p, m, s, t)), (s = [p, m]));
          break;
        }
        case "Z":
          (n.push(...Ec(s[0], s[1], i[0], i[1], t)), (s = [i[0], i[1]]));
      }
    return { type: "path", ops: n };
  }
  function gA(e, t) {
    let r = [];
    for (let n of e)
      if (n.length) {
        let i = t.maxRandomnessOffset || 0,
          s = n.length;
        if (s > 2) {
          r.push({
            op: "move",
            data: [n[0][0] + we(i, t), n[0][1] + we(i, t)],
          });
          for (let o = 1; o < s; o++)
            r.push({
              op: "lineTo",
              data: [n[o][0] + we(i, t), n[o][1] + we(i, t)],
            });
        }
      }
    return { type: "fillPath", ops: r };
  }
  function cd(e, t) {
    return (function (r, n) {
      let i = r.fillStyle || "hachure";
      if (!ls[i])
        switch (i) {
          case "zigzag":
            ls[i] || (ls[i] = new xA(n));
            break;
          case "cross-hatch":
            ls[i] || (ls[i] = new bA(n));
            break;
          case "dots":
            ls[i] || (ls[i] = new kA(n));
            break;
          case "dashed":
            ls[i] || (ls[i] = new TA(n));
            break;
          case "zigzag-line":
            ls[i] || (ls[i] = new SA(n));
            break;
          default:
            ((i = "hachure"), ls[i] || (ls[i] = new M0(n)));
        }
      return ls[i];
    })(t, _bt).fillPolygons(e, t);
  }
  function RV(e) {
    let t = Object.assign({}, e);
    return ((t.randomizer = void 0), e.seed && (t.seed = e.seed + 1), t);
  }
  function $V(e) {
    return (
      e.randomizer || (e.randomizer = new _A(e.seed || 0)),
      e.randomizer.next()
    );
  }
  function $b(e, t, r, n = 1) {
    return r.roughness * n * ($V(r) * (t - e) + e);
  }
  function we(e, t, r = 1) {
    return $b(-e, e, t, r);
  }
  function Ec(e, t, r, n, i, s = !1) {
    let o = s ? i.disableMultiStrokeFill : i.disableMultiStroke,
      l = wA(e, t, r, n, i, !0, !1);
    if (o) return l;
    let u = wA(e, t, r, n, i, !0, !0);
    return l.concat(u);
  }
  function wA(e, t, r, n, i, s, o) {
    let l = Math.pow(e - r, 2) + Math.pow(t - n, 2),
      u = Math.sqrt(l),
      h = 1;
    h = u < 200 ? 1 : u > 500 ? 0.4 : -0.0016668 * u + 1.233334;
    let f = i.maxRandomnessOffset || 0;
    f * f * 100 > l && (f = u / 10);
    let d = f / 2,
      p = 0.2 + 0.2 * $V(i),
      m = (i.bowing * i.maxRandomnessOffset * (n - t)) / 200,
      g = (i.bowing * i.maxRandomnessOffset * (e - r)) / 200;
    ((m = we(m, i, h)), (g = we(g, i, h)));
    let y = [],
      b = a(() => we(d, i, h), "M"),
      k = a(() => we(f, i, h), "k"),
      T = i.preserveVertices;
    return (
      s &&
        (o
          ? y.push({ op: "move", data: [e + (T ? 0 : b()), t + (T ? 0 : b())] })
          : y.push({
              op: "move",
              data: [e + (T ? 0 : we(f, i, h)), t + (T ? 0 : we(f, i, h))],
            })),
      o
        ? y.push({
            op: "bcurveTo",
            data: [
              m + e + (r - e) * p + b(),
              g + t + (n - t) * p + b(),
              m + e + 2 * (r - e) * p + b(),
              g + t + 2 * (n - t) * p + b(),
              r + (T ? 0 : b()),
              n + (T ? 0 : b()),
            ],
          })
        : y.push({
            op: "bcurveTo",
            data: [
              m + e + (r - e) * p + k(),
              g + t + (n - t) * p + k(),
              m + e + 2 * (r - e) * p + k(),
              g + t + 2 * (n - t) * p + k(),
              r + (T ? 0 : k()),
              n + (T ? 0 : k()),
            ],
          }),
      y
    );
  }
  function Ob(e, t, r) {
    if (!e.length) return [];
    let n = [];
    (n.push([e[0][0] + we(t, r), e[0][1] + we(t, r)]),
      n.push([e[0][0] + we(t, r), e[0][1] + we(t, r)]));
    for (let i = 1; i < e.length; i++)
      (n.push([e[i][0] + we(t, r), e[i][1] + we(t, r)]),
        i === e.length - 1 && n.push([e[i][0] + we(t, r), e[i][1] + we(t, r)]));
    return Gb(n, null, r);
  }
  function Gb(e, t, r) {
    let n = e.length,
      i = [];
    if (n > 3) {
      let s = [],
        o = 1 - r.curveTightness;
      i.push({ op: "move", data: [e[1][0], e[1][1]] });
      for (let l = 1; l + 2 < n; l++) {
        let u = e[l];
        ((s[0] = [u[0], u[1]]),
          (s[1] = [
            u[0] + (o * e[l + 1][0] - o * e[l - 1][0]) / 6,
            u[1] + (o * e[l + 1][1] - o * e[l - 1][1]) / 6,
          ]),
          (s[2] = [
            e[l + 1][0] + (o * e[l][0] - o * e[l + 2][0]) / 6,
            e[l + 1][1] + (o * e[l][1] - o * e[l + 2][1]) / 6,
          ]),
          (s[3] = [e[l + 1][0], e[l + 1][1]]),
          i.push({
            op: "bcurveTo",
            data: [s[1][0], s[1][1], s[2][0], s[2][1], s[3][0], s[3][1]],
          }));
      }
      if (t && t.length === 2) {
        let l = r.maxRandomnessOffset;
        i.push({ op: "lineTo", data: [t[0] + we(l, r), t[1] + we(l, r)] });
      }
    } else
      n === 3
        ? (i.push({ op: "move", data: [e[1][0], e[1][1]] }),
          i.push({
            op: "bcurveTo",
            data: [e[1][0], e[1][1], e[2][0], e[2][1], e[2][0], e[2][1]],
          }))
        : n === 2 &&
          i.push(...wA(e[0][0], e[0][1], e[1][0], e[1][1], r, !0, !0));
    return i;
  }
  function DV(e, t, r, n, i, s, o, l) {
    let u = [],
      h = [];
    if (l.roughness === 0) {
      ((e /= 4), h.push([t + n * Math.cos(-e), r + i * Math.sin(-e)]));
      for (let f = 0; f <= 2 * Math.PI; f += e) {
        let d = [t + n * Math.cos(f), r + i * Math.sin(f)];
        (u.push(d), h.push(d));
      }
      (h.push([t + n * Math.cos(0), r + i * Math.sin(0)]),
        h.push([t + n * Math.cos(e), r + i * Math.sin(e)]));
    } else {
      let f = we(0.5, l) - Math.PI / 2;
      h.push([
        we(s, l) + t + 0.9 * n * Math.cos(f - e),
        we(s, l) + r + 0.9 * i * Math.sin(f - e),
      ]);
      let d = 2 * Math.PI + f - 0.01;
      for (let p = f; p < d; p += e) {
        let m = [
          we(s, l) + t + n * Math.cos(p),
          we(s, l) + r + i * Math.sin(p),
        ];
        (u.push(m), h.push(m));
      }
      (h.push([
        we(s, l) + t + n * Math.cos(f + 2 * Math.PI + 0.5 * o),
        we(s, l) + r + i * Math.sin(f + 2 * Math.PI + 0.5 * o),
      ]),
        h.push([
          we(s, l) + t + 0.98 * n * Math.cos(f + o),
          we(s, l) + r + 0.98 * i * Math.sin(f + o),
        ]),
        h.push([
          we(s, l) + t + 0.9 * n * Math.cos(f + 0.5 * o),
          we(s, l) + r + 0.9 * i * Math.sin(f + 0.5 * o),
        ]));
    }
    return [h, u];
  }
  function NV(e, t, r, n, i, s, o, l, u) {
    let h = s + we(0.1, u),
      f = [];
    f.push([
      we(l, u) + t + 0.9 * n * Math.cos(h - e),
      we(l, u) + r + 0.9 * i * Math.sin(h - e),
    ]);
    for (let d = h; d <= o; d += e)
      f.push([we(l, u) + t + n * Math.cos(d), we(l, u) + r + i * Math.sin(d)]);
    return (
      f.push([t + n * Math.cos(o), r + i * Math.sin(o)]),
      f.push([t + n * Math.cos(o), r + i * Math.sin(o)]),
      Gb(f, null, u)
    );
  }
  function wbt(e, t, r, n, i, s, o, l) {
    let u = [],
      h = [l.maxRandomnessOffset || 1, (l.maxRandomnessOffset || 1) + 0.3],
      f = [0, 0],
      d = l.disableMultiStroke ? 1 : 2,
      p = l.preserveVertices;
    for (let m = 0; m < d; m++)
      (m === 0
        ? u.push({ op: "move", data: [o[0], o[1]] })
        : u.push({
            op: "move",
            data: [o[0] + (p ? 0 : we(h[0], l)), o[1] + (p ? 0 : we(h[0], l))],
          }),
        (f = p ? [i, s] : [i + we(h[m], l), s + we(h[m], l)]),
        u.push({
          op: "bcurveTo",
          data: [
            e + we(h[m], l),
            t + we(h[m], l),
            r + we(h[m], l),
            n + we(h[m], l),
            f[0],
            f[1],
          ],
        }));
    return u;
  }
  function I0(e) {
    return [...e];
  }
  function IV(e, t = 0) {
    let r = e.length;
    if (r < 3) throw new Error("A curve must have at least three points.");
    let n = [];
    if (r === 3) n.push(I0(e[0]), I0(e[1]), I0(e[2]), I0(e[2]));
    else {
      let i = [];
      i.push(e[0], e[0]);
      for (let l = 1; l < e.length; l++)
        (i.push(e[l]), l === e.length - 1 && i.push(e[l]));
      let s = [],
        o = 1 - t;
      n.push(I0(i[0]));
      for (let l = 1; l + 2 < i.length; l++) {
        let u = i[l];
        ((s[0] = [u[0], u[1]]),
          (s[1] = [
            u[0] + (o * i[l + 1][0] - o * i[l - 1][0]) / 6,
            u[1] + (o * i[l + 1][1] - o * i[l - 1][1]) / 6,
          ]),
          (s[2] = [
            i[l + 1][0] + (o * i[l][0] - o * i[l + 2][0]) / 6,
            i[l + 1][1] + (o * i[l][1] - o * i[l + 2][1]) / 6,
          ]),
          (s[3] = [i[l + 1][0], i[l + 1][1]]),
          n.push(s[1], s[2], s[3]));
      }
    }
    return n;
  }
  function Fb(e, t) {
    return Math.pow(e[0] - t[0], 2) + Math.pow(e[1] - t[1], 2);
  }
  function vbt(e, t, r) {
    let n = Fb(t, r);
    if (n === 0) return Fb(e, t);
    let i = ((e[0] - t[0]) * (r[0] - t[0]) + (e[1] - t[1]) * (r[1] - t[1])) / n;
    return ((i = Math.max(0, Math.min(1, i))), Fb(e, th(t, r, i)));
  }
  function th(e, t, r) {
    return [e[0] + (t[0] - e[0]) * r, e[1] + (t[1] - e[1]) * r];
  }
  function vA(e, t, r, n) {
    let i = n || [];
    if (
      (function (l, u) {
        let h = l[u + 0],
          f = l[u + 1],
          d = l[u + 2],
          p = l[u + 3],
          m = 3 * f[0] - 2 * h[0] - p[0];
        m *= m;
        let g = 3 * f[1] - 2 * h[1] - p[1];
        g *= g;
        let y = 3 * d[0] - 2 * p[0] - h[0];
        y *= y;
        let b = 3 * d[1] - 2 * p[1] - h[1];
        return ((b *= b), m < y && (m = y), g < b && (g = b), m + g);
      })(e, t) < r
    ) {
      let l = e[t + 0];
      (i.length
        ? ((s = i[i.length - 1]), (o = l), Math.sqrt(Fb(s, o)) > 1 && i.push(l))
        : i.push(l),
        i.push(e[t + 3]));
    } else {
      let u = e[t + 0],
        h = e[t + 1],
        f = e[t + 2],
        d = e[t + 3],
        p = th(u, h, 0.5),
        m = th(h, f, 0.5),
        g = th(f, d, 0.5),
        y = th(p, m, 0.5),
        b = th(m, g, 0.5),
        k = th(y, b, 0.5);
      (vA([u, p, y, k], 0, r, i), vA([k, b, g, d], 0, r, i));
    }
    var s, o;
    return i;
  }
  function Ebt(e, t) {
    return Vb(e, 0, e.length, t);
  }
  function Vb(e, t, r, n, i) {
    let s = i || [],
      o = e[t],
      l = e[r - 1],
      u = 0,
      h = 1;
    for (let f = t + 1; f < r - 1; ++f) {
      let d = vbt(e[f], o, l);
      d > u && ((u = d), (h = f));
    }
    return (
      Math.sqrt(u) > n
        ? (Vb(e, t, h + 1, n, s), Vb(e, h, r, n, s))
        : (s.length || s.push(o), s.push(l)),
      s
    );
  }
  function yA(e, t = 0.15, r) {
    let n = [],
      i = (e.length - 1) / 3;
    for (let s = 0; s < i; s++) vA(e, 3 * s, t, n);
    return r && r > 0 ? Vb(n, 0, n.length, r) : n;
  }
  var M0,
    xA,
    bA,
    kA,
    TA,
    SA,
    ls,
    _A,
    Sbt,
    pA,
    vV,
    Mb,
    _bt,
    Ls,
    ud,
    EA,
    Pb,
    AA,
    wt,
    oe = x(() => {
      "use strict";
      a(dA, "t");
      a(kbt, "e");
      a(Tbt, "s");
      a(O0, "n");
      M0 = class {
        static {
          a(this, "o");
        }
        constructor(t) {
          this.helper = t;
        }
        fillPolygons(t, r) {
          return this._fillPolygons(t, r);
        }
        _fillPolygons(t, r) {
          let n = O0(t, r);
          return { type: "fillSketch", ops: this.renderLines(n, r) };
        }
        renderLines(t, r) {
          let n = [];
          for (let i of t)
            n.push(
              ...this.helper.doubleLineOps(
                i[0][0],
                i[0][1],
                i[1][0],
                i[1][1],
                r,
              ),
            );
          return n;
        }
      };
      a(zb, "a");
      ((xA = class extends M0 {
        static {
          a(this, "h");
        }
        fillPolygons(t, r) {
          let n = r.hachureGap;
          (n < 0 && (n = 4 * r.strokeWidth), (n = Math.max(n, 0.1)));
          let i = O0(t, Object.assign({}, r, { hachureGap: n })),
            s = (Math.PI / 180) * r.hachureAngle,
            o = [],
            l = 0.5 * n * Math.cos(s),
            u = 0.5 * n * Math.sin(s);
          for (let [h, f] of i)
            zb([h, f]) &&
              o.push(
                [[h[0] - l, h[1] + u], [...f]],
                [[h[0] + l, h[1] - u], [...f]],
              );
          return { type: "fillSketch", ops: this.renderLines(o, r) };
        }
      }),
        (bA = class extends M0 {
          static {
            a(this, "r");
          }
          fillPolygons(t, r) {
            let n = this._fillPolygons(t, r),
              i = Object.assign({}, r, { hachureAngle: r.hachureAngle + 90 }),
              s = this._fillPolygons(t, i);
            return ((n.ops = n.ops.concat(s.ops)), n);
          }
        }),
        (kA = class {
          static {
            a(this, "i");
          }
          constructor(t) {
            this.helper = t;
          }
          fillPolygons(t, r) {
            let n = O0(t, (r = Object.assign({}, r, { hachureAngle: 0 })));
            return this.dotsOnLines(n, r);
          }
          dotsOnLines(t, r) {
            let n = [],
              i = r.hachureGap;
            (i < 0 && (i = 4 * r.strokeWidth), (i = Math.max(i, 0.1)));
            let s = r.fillWeight;
            s < 0 && (s = r.strokeWidth / 2);
            let o = i / 4;
            for (let l of t) {
              let u = zb(l),
                h = u / i,
                f = Math.ceil(h) - 1,
                d = u - f * i,
                p = (l[0][0] + l[1][0]) / 2 - i / 4,
                m = Math.min(l[0][1], l[1][1]);
              for (let g = 0; g < f; g++) {
                let y = m + d + g * i,
                  b = p - o + 2 * Math.random() * o,
                  k = y - o + 2 * Math.random() * o,
                  T = this.helper.ellipse(b, k, s, s, r);
                n.push(...T.ops);
              }
            }
            return { type: "fillSketch", ops: n };
          }
        }),
        (TA = class {
          static {
            a(this, "c");
          }
          constructor(t) {
            this.helper = t;
          }
          fillPolygons(t, r) {
            let n = O0(t, r);
            return { type: "fillSketch", ops: this.dashedLine(n, r) };
          }
          dashedLine(t, r) {
            let n =
                r.dashOffset < 0
                  ? r.hachureGap < 0
                    ? 4 * r.strokeWidth
                    : r.hachureGap
                  : r.dashOffset,
              i =
                r.dashGap < 0
                  ? r.hachureGap < 0
                    ? 4 * r.strokeWidth
                    : r.hachureGap
                  : r.dashGap,
              s = [];
            return (
              t.forEach((o) => {
                let l = zb(o),
                  u = Math.floor(l / (n + i)),
                  h = (l + i - u * (n + i)) / 2,
                  f = o[0],
                  d = o[1];
                f[0] > d[0] && ((f = o[1]), (d = o[0]));
                let p = Math.atan((d[1] - f[1]) / (d[0] - f[0]));
                for (let m = 0; m < u; m++) {
                  let g = m * (n + i),
                    y = g + n,
                    b = [
                      f[0] + g * Math.cos(p) + h * Math.cos(p),
                      f[1] + g * Math.sin(p) + h * Math.sin(p),
                    ],
                    k = [
                      f[0] + y * Math.cos(p) + h * Math.cos(p),
                      f[1] + y * Math.sin(p) + h * Math.sin(p),
                    ];
                  s.push(
                    ...this.helper.doubleLineOps(b[0], b[1], k[0], k[1], r),
                  );
                }
              }),
              s
            );
          }
        }),
        (SA = class {
          static {
            a(this, "l");
          }
          constructor(t) {
            this.helper = t;
          }
          fillPolygons(t, r) {
            let n = r.hachureGap < 0 ? 4 * r.strokeWidth : r.hachureGap,
              i = r.zigzagOffset < 0 ? n : r.zigzagOffset,
              s = O0(t, (r = Object.assign({}, r, { hachureGap: n + i })));
            return { type: "fillSketch", ops: this.zigzagLines(s, i, r) };
          }
          zigzagLines(t, r, n) {
            let i = [];
            return (
              t.forEach((s) => {
                let o = zb(s),
                  l = Math.round(o / (2 * r)),
                  u = s[0],
                  h = s[1];
                u[0] > h[0] && ((u = s[1]), (h = s[0]));
                let f = Math.atan((h[1] - u[1]) / (h[0] - u[0]));
                for (let d = 0; d < l; d++) {
                  let p = 2 * d * r,
                    m = 2 * (d + 1) * r,
                    g = Math.sqrt(2 * Math.pow(r, 2)),
                    y = [u[0] + p * Math.cos(f), u[1] + p * Math.sin(f)],
                    b = [u[0] + m * Math.cos(f), u[1] + m * Math.sin(f)],
                    k = [
                      y[0] + g * Math.cos(f + Math.PI / 4),
                      y[1] + g * Math.sin(f + Math.PI / 4),
                    ];
                  i.push(
                    ...this.helper.doubleLineOps(y[0], y[1], k[0], k[1], n),
                    ...this.helper.doubleLineOps(k[0], k[1], b[0], b[1], n),
                  );
                }
              }),
              i
            );
          }
        }),
        (ls = {}),
        (_A = class {
          static {
            a(this, "p");
          }
          constructor(t) {
            this.seed = t;
          }
          next() {
            return this.seed
              ? ((2 ** 31 - 1) & (this.seed = Math.imul(48271, this.seed))) /
                  2 ** 31
              : Math.random();
          }
        }),
        (Sbt = 0),
        (pA = 1),
        (vV = 2),
        (Mb = {
          A: 7,
          a: 7,
          C: 6,
          c: 6,
          H: 1,
          h: 1,
          L: 2,
          l: 2,
          M: 2,
          m: 2,
          Q: 4,
          q: 4,
          S: 4,
          s: 4,
          T: 2,
          t: 2,
          V: 1,
          v: 1,
          Z: 0,
          z: 0,
        }));
      a(mA, "k");
      a(LA, "b");
      a(MV, "y");
      a(OV, "m");
      a(N0, "w");
      a(PV, "x");
      _bt = {
        randOffset: a(function (e, t) {
          return we(e, t);
        }, "randOffset"),
        randOffsetWithRange: a(function (e, t, r) {
          return $b(e, t, r);
        }, "randOffsetWithRange"),
        ellipse: a(function (e, t, r, n, i) {
          let s = FV(r, n, i);
          return CA(e, t, i, s).opset;
        }, "ellipse"),
        doubleLineOps: a(function (e, t, r, n, i) {
          return Ec(e, t, r, n, i, !0);
        }, "doubleLineOps"),
      };
      a(BV, "v");
      a(Bb, "S");
      a(Cbt, "O");
      a(EV, "L");
      a(FV, "T");
      a(CA, "D");
      a(AV, "A");
      a(LV, "_");
      a(gA, "I");
      a(cd, "C");
      a(RV, "z");
      a($V, "W");
      a($b, "E");
      a(we, "G");
      a(Ec, "$");
      a(wA, "R");
      a(Ob, "j");
      a(Gb, "q");
      a(DV, "F");
      a(NV, "V");
      a(wbt, "Z");
      a(I0, "Q");
      a(IV, "H");
      a(Fb, "N");
      a(vbt, "B");
      a(th, "J");
      a(vA, "K");
      a(Ebt, "U");
      a(Vb, "X");
      a(yA, "Y");
      ((Ls = "none"),
        (ud = class {
          static {
            a(this, "et");
          }
          constructor(t) {
            ((this.defaultOptions = {
              maxRandomnessOffset: 2,
              roughness: 1,
              bowing: 1,
              stroke: "#000",
              strokeWidth: 1,
              curveTightness: 0,
              curveFitting: 0.95,
              curveStepCount: 9,
              fillStyle: "hachure",
              fillWeight: -1,
              hachureAngle: -41,
              hachureGap: -1,
              dashOffset: -1,
              dashGap: -1,
              zigzagOffset: -1,
              seed: 0,
              disableMultiStroke: !1,
              disableMultiStrokeFill: !1,
              preserveVertices: !1,
              fillShapeRoughnessGain: 0.8,
            }),
              (this.config = t || {}),
              this.config.options &&
                (this.defaultOptions = this._o(this.config.options)));
          }
          static newSeed() {
            return Math.floor(Math.random() * 2 ** 31);
          }
          _o(t) {
            return t
              ? Object.assign({}, this.defaultOptions, t)
              : this.defaultOptions;
          }
          _d(t, r, n) {
            return {
              shape: t,
              sets: r || [],
              options: n || this.defaultOptions,
            };
          }
          line(t, r, n, i, s) {
            let o = this._o(s);
            return this._d("line", [BV(t, r, n, i, o)], o);
          }
          rectangle(t, r, n, i, s) {
            let o = this._o(s),
              l = [],
              u = Cbt(t, r, n, i, o);
            if (o.fill) {
              let h = [
                [t, r],
                [t + n, r],
                [t + n, r + i],
                [t, r + i],
              ];
              o.fillStyle === "solid" ? l.push(gA([h], o)) : l.push(cd([h], o));
            }
            return (o.stroke !== Ls && l.push(u), this._d("rectangle", l, o));
          }
          ellipse(t, r, n, i, s) {
            let o = this._o(s),
              l = [],
              u = FV(n, i, o),
              h = CA(t, r, o, u);
            if (o.fill)
              if (o.fillStyle === "solid") {
                let f = CA(t, r, o, u).opset;
                ((f.type = "fillPath"), l.push(f));
              } else l.push(cd([h.estimatedPoints], o));
            return (
              o.stroke !== Ls && l.push(h.opset),
              this._d("ellipse", l, o)
            );
          }
          circle(t, r, n, i) {
            let s = this.ellipse(t, r, n, n, i);
            return ((s.shape = "circle"), s);
          }
          linearPath(t, r) {
            let n = this._o(r);
            return this._d("linearPath", [Bb(t, !1, n)], n);
          }
          arc(t, r, n, i, s, o, l = !1, u) {
            let h = this._o(u),
              f = [],
              d = AV(t, r, n, i, s, o, l, !0, h);
            if (l && h.fill)
              if (h.fillStyle === "solid") {
                let p = Object.assign({}, h);
                p.disableMultiStroke = !0;
                let m = AV(t, r, n, i, s, o, !0, !1, p);
                ((m.type = "fillPath"), f.push(m));
              } else
                f.push(
                  (function (p, m, g, y, b, k, T) {
                    let C = p,
                      L = m,
                      w = Math.abs(g / 2),
                      D = Math.abs(y / 2);
                    ((w += we(0.01 * w, T)), (D += we(0.01 * D, T)));
                    let G = b,
                      E = k;
                    for (; G < 0; ) ((G += 2 * Math.PI), (E += 2 * Math.PI));
                    E - G > 2 * Math.PI && ((G = 0), (E = 2 * Math.PI));
                    let R = (E - G) / T.curveStepCount,
                      F = [];
                    for (let S = G; S <= E; S += R)
                      F.push([C + w * Math.cos(S), L + D * Math.sin(S)]);
                    return (
                      F.push([C + w * Math.cos(E), L + D * Math.sin(E)]),
                      F.push([C, L]),
                      cd([F], T)
                    );
                  })(t, r, n, i, s, o, h),
                );
            return (h.stroke !== Ls && f.push(d), this._d("arc", f, h));
          }
          curve(t, r) {
            let n = this._o(r),
              i = [],
              s = EV(t, n);
            if (n.fill && n.fill !== Ls)
              if (n.fillStyle === "solid") {
                let o = EV(
                  t,
                  Object.assign(Object.assign({}, n), {
                    disableMultiStroke: !0,
                    roughness: n.roughness
                      ? n.roughness + n.fillShapeRoughnessGain
                      : 0,
                  }),
                );
                i.push({ type: "fillPath", ops: this._mergedShape(o.ops) });
              } else {
                let o = [],
                  l = t;
                if (l.length) {
                  let u = typeof l[0][0] == "number" ? [l] : l;
                  for (let h of u)
                    h.length < 3
                      ? o.push(...h)
                      : h.length === 3
                        ? o.push(
                            ...yA(
                              IV([h[0], h[0], h[1], h[2]]),
                              10,
                              (1 + n.roughness) / 2,
                            ),
                          )
                        : o.push(...yA(IV(h), 10, (1 + n.roughness) / 2));
                }
                o.length && i.push(cd([o], n));
              }
            return (n.stroke !== Ls && i.push(s), this._d("curve", i, n));
          }
          polygon(t, r) {
            let n = this._o(r),
              i = [],
              s = Bb(t, !0, n);
            return (
              n.fill &&
                (n.fillStyle === "solid"
                  ? i.push(gA([t], n))
                  : i.push(cd([t], n))),
              n.stroke !== Ls && i.push(s),
              this._d("polygon", i, n)
            );
          }
          path(t, r) {
            let n = this._o(r),
              i = [];
            if (!t) return this._d("path", i, n);
            t = (t || "")
              .replace(/\n/g, " ")
              .replace(/(-\s)/g, "-")
              .replace("/(ss)/g", " ");
            let s = n.fill && n.fill !== "transparent" && n.fill !== Ls,
              o = n.stroke !== Ls,
              l = !!(n.simplification && n.simplification < 1),
              u = (function (f, d, p) {
                let m = OV(MV(LA(f))),
                  g = [],
                  y = [],
                  b = [0, 0],
                  k = [],
                  T = a(() => {
                    (k.length >= 4 && y.push(...yA(k, d)), (k = []));
                  }, "i"),
                  C = a(() => {
                    (T(), y.length && (g.push(y), (y = [])));
                  }, "c");
                for (let { key: w, data: D } of m)
                  switch (w) {
                    case "M":
                      (C(), (b = [D[0], D[1]]), y.push(b));
                      break;
                    case "L":
                      (T(), y.push([D[0], D[1]]));
                      break;
                    case "C":
                      if (!k.length) {
                        let G = y.length ? y[y.length - 1] : b;
                        k.push([G[0], G[1]]);
                      }
                      (k.push([D[0], D[1]]),
                        k.push([D[2], D[3]]),
                        k.push([D[4], D[5]]));
                      break;
                    case "Z":
                      (T(), y.push([b[0], b[1]]));
                  }
                if ((C(), !p)) return g;
                let L = [];
                for (let w of g) {
                  let D = Ebt(w, p);
                  D.length && L.push(D);
                }
                return L;
              })(
                t,
                1,
                l ? 4 - 4 * (n.simplification || 1) : (1 + n.roughness) / 2,
              ),
              h = LV(t, n);
            if (s)
              if (n.fillStyle === "solid")
                if (u.length === 1) {
                  let f = LV(
                    t,
                    Object.assign(Object.assign({}, n), {
                      disableMultiStroke: !0,
                      roughness: n.roughness
                        ? n.roughness + n.fillShapeRoughnessGain
                        : 0,
                    }),
                  );
                  i.push({ type: "fillPath", ops: this._mergedShape(f.ops) });
                } else i.push(gA(u, n));
              else i.push(cd(u, n));
            return (
              o &&
                (l
                  ? u.forEach((f) => {
                      i.push(Bb(f, !1, n));
                    })
                  : i.push(h)),
              this._d("path", i, n)
            );
          }
          opsToPath(t, r) {
            let n = "";
            for (let i of t.ops) {
              let s =
                typeof r == "number" && r >= 0
                  ? i.data.map((o) => +o.toFixed(r))
                  : i.data;
              switch (i.op) {
                case "move":
                  n += `M${s[0]} ${s[1]} `;
                  break;
                case "bcurveTo":
                  n += `C${s[0]} ${s[1]}, ${s[2]} ${s[3]}, ${s[4]} ${s[5]} `;
                  break;
                case "lineTo":
                  n += `L${s[0]} ${s[1]} `;
              }
            }
            return n.trim();
          }
          toPaths(t) {
            let r = t.sets || [],
              n = t.options || this.defaultOptions,
              i = [];
            for (let s of r) {
              let o = null;
              switch (s.type) {
                case "path":
                  o = {
                    d: this.opsToPath(s),
                    stroke: n.stroke,
                    strokeWidth: n.strokeWidth,
                    fill: Ls,
                  };
                  break;
                case "fillPath":
                  o = {
                    d: this.opsToPath(s),
                    stroke: Ls,
                    strokeWidth: 0,
                    fill: n.fill || Ls,
                  };
                  break;
                case "fillSketch":
                  o = this.fillSketch(s, n);
              }
              o && i.push(o);
            }
            return i;
          }
          fillSketch(t, r) {
            let n = r.fillWeight;
            return (
              n < 0 && (n = r.strokeWidth / 2),
              {
                d: this.opsToPath(t),
                stroke: r.fill || Ls,
                strokeWidth: n,
                fill: Ls,
              }
            );
          }
          _mergedShape(t) {
            return t.filter((r, n) => n === 0 || r.op !== "move");
          }
        }),
        (EA = class {
          static {
            a(this, "st");
          }
          constructor(t, r) {
            ((this.canvas = t),
              (this.ctx = this.canvas.getContext("2d")),
              (this.gen = new ud(r)));
          }
          draw(t) {
            let r = t.sets || [],
              n = t.options || this.getDefaultOptions(),
              i = this.ctx,
              s = t.options.fixedDecimalPlaceDigits;
            for (let o of r)
              switch (o.type) {
                case "path":
                  (i.save(),
                    (i.strokeStyle =
                      n.stroke === "none" ? "transparent" : n.stroke),
                    (i.lineWidth = n.strokeWidth),
                    n.strokeLineDash && i.setLineDash(n.strokeLineDash),
                    n.strokeLineDashOffset &&
                      (i.lineDashOffset = n.strokeLineDashOffset),
                    this._drawToContext(i, o, s),
                    i.restore());
                  break;
                case "fillPath": {
                  (i.save(), (i.fillStyle = n.fill || ""));
                  let l =
                    t.shape === "curve" ||
                    t.shape === "polygon" ||
                    t.shape === "path"
                      ? "evenodd"
                      : "nonzero";
                  (this._drawToContext(i, o, s, l), i.restore());
                  break;
                }
                case "fillSketch":
                  this.fillSketch(i, o, n);
              }
          }
          fillSketch(t, r, n) {
            let i = n.fillWeight;
            (i < 0 && (i = n.strokeWidth / 2),
              t.save(),
              n.fillLineDash && t.setLineDash(n.fillLineDash),
              n.fillLineDashOffset && (t.lineDashOffset = n.fillLineDashOffset),
              (t.strokeStyle = n.fill || ""),
              (t.lineWidth = i),
              this._drawToContext(t, r, n.fixedDecimalPlaceDigits),
              t.restore());
          }
          _drawToContext(t, r, n, i = "nonzero") {
            t.beginPath();
            for (let s of r.ops) {
              let o =
                typeof n == "number" && n >= 0
                  ? s.data.map((l) => +l.toFixed(n))
                  : s.data;
              switch (s.op) {
                case "move":
                  t.moveTo(o[0], o[1]);
                  break;
                case "bcurveTo":
                  t.bezierCurveTo(o[0], o[1], o[2], o[3], o[4], o[5]);
                  break;
                case "lineTo":
                  t.lineTo(o[0], o[1]);
              }
            }
            r.type === "fillPath" ? t.fill(i) : t.stroke();
          }
          get generator() {
            return this.gen;
          }
          getDefaultOptions() {
            return this.gen.defaultOptions;
          }
          line(t, r, n, i, s) {
            let o = this.gen.line(t, r, n, i, s);
            return (this.draw(o), o);
          }
          rectangle(t, r, n, i, s) {
            let o = this.gen.rectangle(t, r, n, i, s);
            return (this.draw(o), o);
          }
          ellipse(t, r, n, i, s) {
            let o = this.gen.ellipse(t, r, n, i, s);
            return (this.draw(o), o);
          }
          circle(t, r, n, i) {
            let s = this.gen.circle(t, r, n, i);
            return (this.draw(s), s);
          }
          linearPath(t, r) {
            let n = this.gen.linearPath(t, r);
            return (this.draw(n), n);
          }
          polygon(t, r) {
            let n = this.gen.polygon(t, r);
            return (this.draw(n), n);
          }
          arc(t, r, n, i, s, o, l = !1, u) {
            let h = this.gen.arc(t, r, n, i, s, o, l, u);
            return (this.draw(h), h);
          }
          curve(t, r) {
            let n = this.gen.curve(t, r);
            return (this.draw(n), n);
          }
          path(t, r) {
            let n = this.gen.path(t, r);
            return (this.draw(n), n);
          }
        }),
        (Pb = "http://www.w3.org/2000/svg"),
        (AA = class {
          static {
            a(this, "ot");
          }
          constructor(t, r) {
            ((this.svg = t), (this.gen = new ud(r)));
          }
          draw(t) {
            let r = t.sets || [],
              n = t.options || this.getDefaultOptions(),
              i = this.svg.ownerDocument || window.document,
              s = i.createElementNS(Pb, "g"),
              o = t.options.fixedDecimalPlaceDigits;
            for (let l of r) {
              let u = null;
              switch (l.type) {
                case "path":
                  ((u = i.createElementNS(Pb, "path")),
                    u.setAttribute("d", this.opsToPath(l, o)),
                    u.setAttribute("stroke", n.stroke),
                    u.setAttribute("stroke-width", n.strokeWidth + ""),
                    u.setAttribute("fill", "none"),
                    n.strokeLineDash &&
                      u.setAttribute(
                        "stroke-dasharray",
                        n.strokeLineDash.join(" ").trim(),
                      ),
                    n.strokeLineDashOffset &&
                      u.setAttribute(
                        "stroke-dashoffset",
                        `${n.strokeLineDashOffset}`,
                      ));
                  break;
                case "fillPath":
                  ((u = i.createElementNS(Pb, "path")),
                    u.setAttribute("d", this.opsToPath(l, o)),
                    u.setAttribute("stroke", "none"),
                    u.setAttribute("stroke-width", "0"),
                    u.setAttribute("fill", n.fill || ""),
                    (t.shape !== "curve" && t.shape !== "polygon") ||
                      u.setAttribute("fill-rule", "evenodd"));
                  break;
                case "fillSketch":
                  u = this.fillSketch(i, l, n);
              }
              u && s.appendChild(u);
            }
            return s;
          }
          fillSketch(t, r, n) {
            let i = n.fillWeight;
            i < 0 && (i = n.strokeWidth / 2);
            let s = t.createElementNS(Pb, "path");
            return (
              s.setAttribute("d", this.opsToPath(r, n.fixedDecimalPlaceDigits)),
              s.setAttribute("stroke", n.fill || ""),
              s.setAttribute("stroke-width", i + ""),
              s.setAttribute("fill", "none"),
              n.fillLineDash &&
                s.setAttribute(
                  "stroke-dasharray",
                  n.fillLineDash.join(" ").trim(),
                ),
              n.fillLineDashOffset &&
                s.setAttribute("stroke-dashoffset", `${n.fillLineDashOffset}`),
              s
            );
          }
          get generator() {
            return this.gen;
          }
          getDefaultOptions() {
            return this.gen.defaultOptions;
          }
          opsToPath(t, r) {
            return this.gen.opsToPath(t, r);
          }
          line(t, r, n, i, s) {
            let o = this.gen.line(t, r, n, i, s);
            return this.draw(o);
          }
          rectangle(t, r, n, i, s) {
            let o = this.gen.rectangle(t, r, n, i, s);
            return this.draw(o);
          }
          ellipse(t, r, n, i, s) {
            let o = this.gen.ellipse(t, r, n, i, s);
            return this.draw(o);
          }
          circle(t, r, n, i) {
            let s = this.gen.circle(t, r, n, i);
            return this.draw(s);
          }
          linearPath(t, r) {
            let n = this.gen.linearPath(t, r);
            return this.draw(n);
          }
          polygon(t, r) {
            let n = this.gen.polygon(t, r);
            return this.draw(n);
          }
          arc(t, r, n, i, s, o, l = !1, u) {
            let h = this.gen.arc(t, r, n, i, s, o, l, u);
            return this.draw(h);
          }
          curve(t, r) {
            let n = this.gen.curve(t, r);
            return this.draw(n);
          }
          path(t, r) {
            let n = this.gen.path(t, r);
            return this.draw(n);
          }
        }),
        (wt = {
          canvas: a((e, t) => new EA(e, t), "canvas"),
          svg: a((e, t) => new AA(e, t), "svg"),
          generator: a((e) => new ud(e), "generator"),
          newSeed: a(() => ud.newSeed(), "newSeed"),
        }));
    });
  function GV(e, t) {
    let { labelStyles: r } = St(t);
    t.labelStyle = r;
    let n = Ot(t),
      i = n;
    n || (i = "anchor");
    let s = e
        .insert("g")
        .attr("class", i)
        .attr("id", t.domId || t.id),
      o = 1,
      { cssStyles: l } = t,
      u = wt.svg(s),
      h = vt(t, { fill: "black", stroke: "none", fillStyle: "solid" });
    t.look !== "handDrawn" && (h.roughness = 0);
    let f = u.circle(0, 0, o * 2, h),
      d = s.insert(() => f, ":first-child");
    return (
      d.attr("class", "anchor").attr("style", Ir(l)),
      Ct(t, d),
      (t.intersect = function (p) {
        return (P.info("Circle intersect", t, o, p), Tt.circle(t, o, p));
      }),
      s
    );
  }
  var VV = x(() => {
    "use strict";
    Vt();
    Qt();
    ae();
    re();
    oe();
    _e();
    a(GV, "anchor");
  });
  function zV(e, t, r, n, i, s, o) {
    let u = (e + r) / 2,
      h = (t + n) / 2,
      f = Math.atan2(n - t, r - e),
      d = (r - e) / 2,
      p = (n - t) / 2,
      m = d / i,
      g = p / s,
      y = Math.sqrt(m ** 2 + g ** 2);
    if (y > 1)
      throw new Error(
        "The given radii are too small to create an arc between the points.",
      );
    let b = Math.sqrt(1 - y ** 2),
      k = u + b * s * Math.sin(f) * (o ? -1 : 1),
      T = h - b * i * Math.cos(f) * (o ? -1 : 1),
      C = Math.atan2((t - T) / s, (e - k) / i),
      w = Math.atan2((n - T) / s, (r - k) / i) - C;
    (o && w < 0 && (w += 2 * Math.PI), !o && w > 0 && (w -= 2 * Math.PI));
    let D = [];
    for (let G = 0; G < 20; G++) {
      let E = G / 19,
        R = C + E * w,
        F = k + i * Math.cos(R),
        S = T + s * Math.sin(R);
      D.push({ x: F, y: S });
    }
    return D;
  }
  async function WV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.width + t.padding + 20,
      l = s.height + t.padding,
      u = l / 2,
      h = u / (2.5 + l / 50),
      { cssStyles: f } = t,
      d = [
        { x: o / 2, y: -l / 2 },
        { x: -o / 2, y: -l / 2 },
        ...zV(-o / 2, -l / 2, -o / 2, l / 2, h, u, !1),
        { x: o / 2, y: l / 2 },
        ...zV(o / 2, l / 2, o / 2, -l / 2, h, u, !0),
      ],
      p = wt.svg(i),
      m = vt(t, {});
    t.look !== "handDrawn" && ((m.roughness = 0), (m.fillStyle = "solid"));
    let g = ie(d),
      y = p.path(g, m),
      b = i.insert(() => y, ":first-child");
    return (
      b.attr("class", "basic label-container"),
      f && t.look !== "handDrawn" && b.selectAll("path").attr("style", f),
      n && t.look !== "handDrawn" && b.selectAll("path").attr("style", n),
      b.attr("transform", `translate(${h / 2}, 0)`),
      Ct(t, b),
      (t.intersect = function (k) {
        return Tt.polygon(t, d, k);
      }),
      i
    );
  }
  var UV = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(zV, "generateArcPoints");
    a(WV, "bowTieRect");
  });
  function cs(e, t, r, n) {
    return e
      .insert("polygon", ":first-child")
      .attr(
        "points",
        n
          .map(function (i) {
            return i.x + "," + i.y;
          })
          .join(" "),
      )
      .attr("class", "label-container")
      .attr("transform", "translate(" + -t / 2 + "," + r / 2 + ")");
  }
  var Ac = x(() => {
    "use strict";
    a(cs, "insertPolygonShape");
  });
  async function jV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.height + t.padding,
      l = 12,
      u = s.width + t.padding + l,
      h = 0,
      f = u,
      d = -o,
      p = 0,
      m = [
        { x: h + l, y: d },
        { x: f, y: d },
        { x: f, y: p },
        { x: h, y: p },
        { x: h, y: d + l },
        { x: h + l, y: d },
      ],
      g,
      { cssStyles: y } = t;
    if (t.look === "handDrawn") {
      let b = wt.svg(i),
        k = vt(t, {}),
        T = ie(m),
        C = b.path(T, k);
      ((g = i
        .insert(() => C, ":first-child")
        .attr("transform", `translate(${-u / 2}, ${o / 2})`)),
        y && g.attr("style", y));
    } else g = cs(i, u, o, m);
    return (
      n && g.attr("style", n),
      Ct(t, g),
      (t.intersect = function (b) {
        return Tt.polygon(t, m, b);
      }),
      i
    );
  }
  var qV = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    Ac();
    Qt();
    a(jV, "card");
  });
  function HV(e, t) {
    let { nodeStyles: r } = St(t);
    t.label = "";
    let n = e
        .insert("g")
        .attr("class", Ot(t))
        .attr("id", t.domId ?? t.id),
      { cssStyles: i } = t,
      s = Math.max(28, t.width ?? 0),
      o = [
        { x: 0, y: s / 2 },
        { x: s / 2, y: 0 },
        { x: 0, y: -s / 2 },
        { x: -s / 2, y: 0 },
      ],
      l = wt.svg(n),
      u = vt(t, {});
    t.look !== "handDrawn" && ((u.roughness = 0), (u.fillStyle = "solid"));
    let h = ie(o),
      f = l.path(h, u),
      d = n.insert(() => f, ":first-child");
    return (
      i && t.look !== "handDrawn" && d.selectAll("path").attr("style", i),
      r && t.look !== "handDrawn" && d.selectAll("path").attr("style", r),
      (t.width = 28),
      (t.height = 28),
      (t.intersect = function (p) {
        return Tt.polygon(t, o, p);
      }),
      n
    );
  }
  var YV = x(() => {
    "use strict";
    ae();
    oe();
    re();
    Qt();
    a(HV, "choice");
  });
  async function Wb(e, t, r) {
    let { labelStyles: n, nodeStyles: i } = St(t);
    t.labelStyle = n;
    let { shapeSvg: s, bbox: o, halfPadding: l } = await Bt(e, t, Ot(t)),
      u = r?.padding ?? l,
      h = o.width / 2 + u,
      f,
      { cssStyles: d } = t;
    if (t.look === "handDrawn") {
      let p = wt.svg(s),
        m = vt(t, {}),
        g = p.circle(0, 0, h * 2, m);
      ((f = s.insert(() => g, ":first-child")),
        f.attr("class", "basic label-container").attr("style", Ir(d)));
    } else
      f = s
        .insert("circle", ":first-child")
        .attr("class", "basic label-container")
        .attr("style", i)
        .attr("r", h)
        .attr("cx", 0)
        .attr("cy", 0);
    return (
      Ct(t, f),
      (t.calcIntersect = function (p, m) {
        let g = p.width / 2;
        return Tt.circle(p, g, m);
      }),
      (t.intersect = function (p) {
        return (P.info("Circle intersect", t, h, p), Tt.circle(t, h, p));
      }),
      s
    );
  }
  var RA = x(() => {
    "use strict";
    oe();
    Vt();
    _e();
    ae();
    re();
    Qt();
    a(Wb, "circle");
  });
  function Abt(e) {
    let t = Math.cos(Math.PI / 4),
      r = Math.sin(Math.PI / 4),
      n = e * 2,
      i = { x: (n / 2) * t, y: (n / 2) * r },
      s = { x: -(n / 2) * t, y: (n / 2) * r },
      o = { x: -(n / 2) * t, y: -(n / 2) * r },
      l = { x: (n / 2) * t, y: -(n / 2) * r };
    return `M ${s.x},${s.y} L ${l.x},${l.y}
                   M ${i.x},${i.y} L ${o.x},${o.y}`;
  }
  function XV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    ((t.labelStyle = r), (t.label = ""));
    let i = e
        .insert("g")
        .attr("class", Ot(t))
        .attr("id", t.domId ?? t.id),
      s = Math.max(30, t?.width ?? 0),
      { cssStyles: o } = t,
      l = wt.svg(i),
      u = vt(t, {});
    t.look !== "handDrawn" && ((u.roughness = 0), (u.fillStyle = "solid"));
    let h = l.circle(0, 0, s * 2, u),
      f = Abt(s),
      d = l.path(f, u),
      p = i.insert(() => h, ":first-child");
    return (
      p.insert(() => d),
      o && t.look !== "handDrawn" && p.selectAll("path").attr("style", o),
      n && t.look !== "handDrawn" && p.selectAll("path").attr("style", n),
      Ct(t, p),
      (t.intersect = function (m) {
        return (
          P.info("crossedCircle intersect", t, { radius: s, point: m }),
          Tt.circle(t, s, m)
        );
      }),
      i
    );
  }
  var KV = x(() => {
    "use strict";
    Vt();
    Qt();
    re();
    oe();
    ae();
    a(Abt, "createLine");
    a(XV, "crossedCircle");
  });
  function Lc(e, t, r, n = 100, i = 0, s = 180) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1);
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p);
      o.push({ x: -m, y: -g });
    }
    return o;
  }
  async function QV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = s.height + (t.padding ?? 0),
      h = Math.max(5, u * 0.1),
      { cssStyles: f } = t,
      d = [
        ...Lc(l / 2, -u / 2, h, 30, -90, 0),
        { x: -l / 2 - h, y: h },
        ...Lc(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...Lc(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: -u / 2 },
        ...Lc(l / 2, u / 2, h, 20, 0, 90),
      ],
      p = [
        { x: l / 2, y: -u / 2 - h },
        { x: -l / 2, y: -u / 2 - h },
        ...Lc(l / 2, -u / 2, h, 20, -90, 0),
        { x: -l / 2 - h, y: -h },
        ...Lc(l / 2 + l * 0.1, -h, h, 20, -180, -270),
        ...Lc(l / 2 + l * 0.1, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: u / 2 },
        ...Lc(l / 2, u / 2, h, 20, 0, 90),
        { x: -l / 2, y: u / 2 + h },
        { x: l / 2, y: u / 2 + h },
      ],
      m = wt.svg(i),
      g = vt(t, { fill: "none" });
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let b = ie(d).replace("Z", ""),
      k = m.path(b, g),
      T = ie(p),
      C = m.path(T, { ...g }),
      L = i.insert("g", ":first-child");
    return (
      L.insert(() => C, ":first-child").attr("stroke-opacity", 0),
      L.insert(() => k, ":first-child"),
      L.attr("class", "text"),
      f && t.look !== "handDrawn" && L.selectAll("path").attr("style", f),
      n && t.look !== "handDrawn" && L.selectAll("path").attr("style", n),
      L.attr("transform", `translate(${h}, 0)`),
      o.attr(
        "transform",
        `translate(${-l / 2 + h - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, L),
      (t.intersect = function (w) {
        return Tt.polygon(t, p, w);
      }),
      i
    );
  }
  var ZV = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(Lc, "generateCirclePoints");
    a(QV, "curlyBraceLeft");
  });
  function Rc(e, t, r, n = 100, i = 0, s = 180) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1);
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p);
      o.push({ x: m, y: g });
    }
    return o;
  }
  async function JV(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = s.height + (t.padding ?? 0),
      h = Math.max(5, u * 0.1),
      { cssStyles: f } = t,
      d = [
        ...Rc(l / 2, -u / 2, h, 20, -90, 0),
        { x: l / 2 + h, y: -h },
        ...Rc(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...Rc(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: l / 2 + h, y: u / 2 },
        ...Rc(l / 2, u / 2, h, 20, 0, 90),
      ],
      p = [
        { x: -l / 2, y: -u / 2 - h },
        { x: l / 2, y: -u / 2 - h },
        ...Rc(l / 2, -u / 2, h, 20, -90, 0),
        { x: l / 2 + h, y: -h },
        ...Rc(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...Rc(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: l / 2 + h, y: u / 2 },
        ...Rc(l / 2, u / 2, h, 20, 0, 90),
        { x: l / 2, y: u / 2 + h },
        { x: -l / 2, y: u / 2 + h },
      ],
      m = wt.svg(i),
      g = vt(t, { fill: "none" });
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let b = ie(d).replace("Z", ""),
      k = m.path(b, g),
      T = ie(p),
      C = m.path(T, { ...g }),
      L = i.insert("g", ":first-child");
    return (
      L.insert(() => C, ":first-child").attr("stroke-opacity", 0),
      L.insert(() => k, ":first-child"),
      L.attr("class", "text"),
      f && t.look !== "handDrawn" && L.selectAll("path").attr("style", f),
      n && t.look !== "handDrawn" && L.selectAll("path").attr("style", n),
      L.attr("transform", `translate(${-h}, 0)`),
      o.attr(
        "transform",
        `translate(${-l / 2 + (t.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, L),
      (t.intersect = function (w) {
        return Tt.polygon(t, p, w);
      }),
      i
    );
  }
  var tz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(Rc, "generateCirclePoints");
    a(JV, "curlyBraceRight");
  });
  function xi(e, t, r, n = 100, i = 0, s = 180) {
    let o = [],
      l = (i * Math.PI) / 180,
      f = ((s * Math.PI) / 180 - l) / (n - 1);
    for (let d = 0; d < n; d++) {
      let p = l + d * f,
        m = e + r * Math.cos(p),
        g = t + r * Math.sin(p);
      o.push({ x: -m, y: -g });
    }
    return o;
  }
  async function ez(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = s.height + (t.padding ?? 0),
      h = Math.max(5, u * 0.1),
      { cssStyles: f } = t,
      d = [
        ...xi(l / 2, -u / 2, h, 30, -90, 0),
        { x: -l / 2 - h, y: h },
        ...xi(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...xi(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: -u / 2 },
        ...xi(l / 2, u / 2, h, 20, 0, 90),
      ],
      p = [
        ...xi(-l / 2 + h + h / 2, -u / 2, h, 20, -90, -180),
        { x: l / 2 - h / 2, y: h },
        ...xi(-l / 2 - h / 2, -h, h, 20, 0, 90),
        ...xi(-l / 2 - h / 2, h, h, 20, -90, 0),
        { x: l / 2 - h / 2, y: -h },
        ...xi(-l / 2 + h + h / 2, u / 2, h, 30, -180, -270),
      ],
      m = [
        { x: l / 2, y: -u / 2 - h },
        { x: -l / 2, y: -u / 2 - h },
        ...xi(l / 2, -u / 2, h, 20, -90, 0),
        { x: -l / 2 - h, y: -h },
        ...xi(l / 2 + h * 2, -h, h, 20, -180, -270),
        ...xi(l / 2 + h * 2, h, h, 20, -90, -180),
        { x: -l / 2 - h, y: u / 2 },
        ...xi(l / 2, u / 2, h, 20, 0, 90),
        { x: -l / 2, y: u / 2 + h },
        { x: l / 2 - h - h / 2, y: u / 2 + h },
        ...xi(-l / 2 + h + h / 2, -u / 2, h, 20, -90, -180),
        { x: l / 2 - h / 2, y: h },
        ...xi(-l / 2 - h / 2, -h, h, 20, 0, 90),
        ...xi(-l / 2 - h / 2, h, h, 20, -90, 0),
        { x: l / 2 - h / 2, y: -h },
        ...xi(-l / 2 + h + h / 2, u / 2, h, 30, -180, -270),
      ],
      g = wt.svg(i),
      y = vt(t, { fill: "none" });
    t.look !== "handDrawn" && ((y.roughness = 0), (y.fillStyle = "solid"));
    let k = ie(d).replace("Z", ""),
      T = g.path(k, y),
      L = ie(p).replace("Z", ""),
      w = g.path(L, y),
      D = ie(m),
      G = g.path(D, { ...y }),
      E = i.insert("g", ":first-child");
    return (
      E.insert(() => G, ":first-child").attr("stroke-opacity", 0),
      E.insert(() => T, ":first-child"),
      E.insert(() => w, ":first-child"),
      E.attr("class", "text"),
      f && t.look !== "handDrawn" && E.selectAll("path").attr("style", f),
      n && t.look !== "handDrawn" && E.selectAll("path").attr("style", n),
      E.attr("transform", `translate(${h - h / 4}, 0)`),
      o.attr(
        "transform",
        `translate(${-l / 2 + (t.padding ?? 0) / 2 - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, E),
      (t.intersect = function (R) {
        return Tt.polygon(t, m, R);
      }),
      i
    );
  }
  var rz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(xi, "generateCirclePoints");
    a(ez, "curlyBraces");
  });
  async function nz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = 80,
      l = 20,
      u = Math.max(o, (s.width + (t.padding ?? 0) * 2) * 1.25, t?.width ?? 0),
      h = Math.max(l, s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = h / 2,
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = vt(t, {});
    t.look !== "handDrawn" && ((m.roughness = 0), (m.fillStyle = "solid"));
    let g = u,
      y = h,
      b = g - f,
      k = y / 4,
      T = [
        { x: b, y: 0 },
        { x: k, y: 0 },
        { x: 0, y: y / 2 },
        { x: k, y },
        { x: b, y },
        ...Ju(-b, -y / 2, f, 50, 270, 90),
      ],
      C = ie(T),
      L = p.path(C, m),
      w = i.insert(() => L, ":first-child");
    return (
      w.attr("class", "basic label-container"),
      d && t.look !== "handDrawn" && w.selectChildren("path").attr("style", d),
      n && t.look !== "handDrawn" && w.selectChildren("path").attr("style", n),
      w.attr("transform", `translate(${-u / 2}, ${-h / 2})`),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, T, D);
      }),
      i
    );
  }
  var iz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(nz, "curvedTrapezoid");
  });
  async function sz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + t.padding, t.width ?? 0),
      u = l / 2,
      h = u / (2.5 + l / 50),
      f = Math.max(s.height + h + t.padding, t.height ?? 0),
      d,
      { cssStyles: p } = t;
    if (t.look === "handDrawn") {
      let m = wt.svg(i),
        g = Rbt(0, 0, l, f, u, h),
        y = Dbt(0, h, l, f, u, h),
        b = m.path(g, vt(t, {})),
        k = m.path(y, vt(t, { fill: "none" }));
      ((d = i.insert(() => k, ":first-child")),
        (d = i.insert(() => b, ":first-child")),
        d.attr("class", "basic label-container"),
        p && d.attr("style", p));
    } else {
      let m = Lbt(0, 0, l, f, u, h);
      d = i
        .insert("path", ":first-child")
        .attr("d", m)
        .attr("class", "basic label-container")
        .attr("style", Ir(p))
        .attr("style", n);
    }
    return (
      d.attr("label-offset-y", h),
      d.attr("transform", `translate(${-l / 2}, ${-(f / 2 + h)})`),
      Ct(t, d),
      o.attr(
        "transform",
        `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + (t.padding ?? 0) / 1.5 - (s.y - (s.top ?? 0))})`,
      ),
      (t.intersect = function (m) {
        let g = Tt.rect(t, m),
          y = g.x - (t.x ?? 0);
        if (
          u != 0 &&
          (Math.abs(y) < (t.width ?? 0) / 2 ||
            (Math.abs(y) == (t.width ?? 0) / 2 &&
              Math.abs(g.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - h))
        ) {
          let b = h * h * (1 - (y * y) / (u * u));
          (b > 0 && (b = Math.sqrt(b)),
            (b = h - b),
            m.y - (t.y ?? 0) > 0 && (b = -b),
            (g.y += b));
        }
        return g;
      }),
      i
    );
  }
  var Lbt,
    Rbt,
    Dbt,
    az = x(() => {
      "use strict";
      Qt();
      ae();
      re();
      oe();
      _e();
      ((Lbt = a(
        (e, t, r, n, i, s) =>
          [
            `M${e},${t + s}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `a${i},${s} 0,0,0 ${-r},0`,
            `l0,${n}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `l0,${-n}`,
          ].join(" "),
        "createCylinderPathD",
      )),
        (Rbt = a(
          (e, t, r, n, i, s) =>
            [
              `M${e},${t + s}`,
              `M${e + r},${t + s}`,
              `a${i},${s} 0,0,0 ${-r},0`,
              `l0,${n}`,
              `a${i},${s} 0,0,0 ${r},0`,
              `l0,${-n}`,
            ].join(" "),
          "createOuterCylinderPathD",
        )),
        (Dbt = a(
          (e, t, r, n, i, s) =>
            [`M${e - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(" "),
          "createInnerCylinderPathD",
        )));
      a(sz, "cylinder");
    });
  async function oz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + t.padding,
      u = s.height + t.padding,
      h = u * 0.2,
      f = -l / 2,
      d = -u / 2 - h / 2,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = vt(t, {});
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let y = [
        { x: f, y: d + h },
        { x: -f, y: d + h },
        { x: -f, y: -d },
        { x: f, y: -d },
        { x: f, y: d },
        { x: -f, y: d },
        { x: -f, y: d + h },
      ],
      b = m.polygon(
        y.map((T) => [T.x, T.y]),
        g,
      ),
      k = i.insert(() => b, ":first-child");
    return (
      k.attr("class", "basic label-container"),
      p && t.look !== "handDrawn" && k.selectAll("path").attr("style", p),
      n && t.look !== "handDrawn" && k.selectAll("path").attr("style", n),
      o.attr(
        "transform",
        `translate(${f + (t.padding ?? 0) / 2 - (s.x - (s.left ?? 0))}, ${d + h + (t.padding ?? 0) / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.rect(t, T);
      }),
      i
    );
  }
  var lz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(oz, "dividedRectangle");
  });
  async function cz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, halfPadding: o } = await Bt(e, t, Ot(t)),
      u = s.width / 2 + o + 5,
      h = s.width / 2 + o,
      f,
      { cssStyles: d } = t;
    if (t.look === "handDrawn") {
      let p = wt.svg(i),
        m = vt(t, { roughness: 0.2, strokeWidth: 2.5 }),
        g = vt(t, { roughness: 0.2, strokeWidth: 1.5 }),
        y = p.circle(0, 0, u * 2, m),
        b = p.circle(0, 0, h * 2, g);
      ((f = i.insert("g", ":first-child")),
        f.attr("class", Ir(t.cssClasses)).attr("style", Ir(d)),
        f.node()?.appendChild(y),
        f.node()?.appendChild(b));
    } else {
      f = i.insert("g", ":first-child");
      let p = f.insert("circle", ":first-child"),
        m = f.insert("circle");
      (f.attr("class", "basic label-container").attr("style", n),
        p
          .attr("class", "outer-circle")
          .attr("style", n)
          .attr("r", u)
          .attr("cx", 0)
          .attr("cy", 0),
        m
          .attr("class", "inner-circle")
          .attr("style", n)
          .attr("r", h)
          .attr("cx", 0)
          .attr("cy", 0));
    }
    return (
      Ct(t, f),
      (t.intersect = function (p) {
        return (P.info("DoubleCircle intersect", t, u, p), Tt.circle(t, u, p));
      }),
      i
    );
  }
  var uz = x(() => {
    "use strict";
    Vt();
    Qt();
    ae();
    re();
    oe();
    _e();
    a(cz, "doublecircle");
  });
  function hz(e, t, { config: { themeVariables: r } }) {
    let { labelStyles: n, nodeStyles: i } = St(t);
    ((t.label = ""), (t.labelStyle = n));
    let s = e
        .insert("g")
        .attr("class", Ot(t))
        .attr("id", t.domId ?? t.id),
      o = 7,
      { cssStyles: l } = t,
      u = wt.svg(s),
      { nodeBorder: h } = r,
      f = vt(t, { fillStyle: "solid" });
    t.look !== "handDrawn" && (f.roughness = 0);
    let d = u.circle(0, 0, o * 2, f),
      p = s.insert(() => d, ":first-child");
    return (
      p.selectAll("path").attr("style", `fill: ${h} !important;`),
      l &&
        l.length > 0 &&
        t.look !== "handDrawn" &&
        p.selectAll("path").attr("style", l),
      i && t.look !== "handDrawn" && p.selectAll("path").attr("style", i),
      Ct(t, p),
      (t.intersect = function (m) {
        return (
          P.info("filledCircle intersect", t, { radius: o, point: m }),
          Tt.circle(t, o, m)
        );
      }),
      s
    );
  }
  var fz = x(() => {
    "use strict";
    oe();
    Vt();
    ae();
    re();
    Qt();
    a(hz, "filledCircle");
  });
  async function dz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = s.width + (t.padding ?? 0),
      u = l + s.height,
      h = l + s.height,
      f = [
        { x: 0, y: -u },
        { x: h, y: -u },
        { x: h / 2, y: 0 },
      ],
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = vt(t, {});
    t.look !== "handDrawn" && ((m.roughness = 0), (m.fillStyle = "solid"));
    let g = ie(f),
      y = p.path(g, m),
      b = i
        .insert(() => y, ":first-child")
        .attr("transform", `translate(${-u / 2}, ${u / 2})`);
    return (
      d && t.look !== "handDrawn" && b.selectChildren("path").attr("style", d),
      n && t.look !== "handDrawn" && b.selectChildren("path").attr("style", n),
      (t.width = l),
      (t.height = u),
      Ct(t, b),
      o.attr(
        "transform",
        `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${-u / 2 + (t.padding ?? 0) / 2 + (s.y - (s.top ?? 0))})`,
      ),
      (t.intersect = function (k) {
        return (P.info("Triangle intersect", t, f, k), Tt.polygon(t, f, k));
      }),
      i
    );
  }
  var pz = x(() => {
    "use strict";
    Vt();
    Qt();
    ae();
    re();
    oe();
    Qt();
    a(dz, "flippedTriangle");
  });
  function mz(e, t, { dir: r, config: { state: n, themeVariables: i } }) {
    let { nodeStyles: s } = St(t);
    t.label = "";
    let o = e
        .insert("g")
        .attr("class", Ot(t))
        .attr("id", t.domId ?? t.id),
      { cssStyles: l } = t,
      u = Math.max(70, t?.width ?? 0),
      h = Math.max(10, t?.height ?? 0);
    r === "LR" &&
      ((u = Math.max(10, t?.width ?? 0)), (h = Math.max(70, t?.height ?? 0)));
    let f = (-1 * u) / 2,
      d = (-1 * h) / 2,
      p = wt.svg(o),
      m = vt(t, { stroke: i.lineColor, fill: i.lineColor });
    t.look !== "handDrawn" && ((m.roughness = 0), (m.fillStyle = "solid"));
    let g = p.rectangle(f, d, u, h, m),
      y = o.insert(() => g, ":first-child");
    (l && t.look !== "handDrawn" && y.selectAll("path").attr("style", l),
      s && t.look !== "handDrawn" && y.selectAll("path").attr("style", s),
      Ct(t, y));
    let b = n?.padding ?? 0;
    return (
      t.width &&
        t.height &&
        ((t.width += b / 2 || 0), (t.height += b / 2 || 0)),
      (t.intersect = function (k) {
        return Tt.rect(t, k);
      }),
      o
    );
  }
  var gz = x(() => {
    "use strict";
    oe();
    ae();
    re();
    Qt();
    a(mz, "forkJoin");
  });
  async function yz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let i = 80,
      s = 50,
      { shapeSvg: o, bbox: l } = await Bt(e, t, Ot(t)),
      u = Math.max(i, l.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(s, l.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = h / 2,
      { cssStyles: d } = t,
      p = wt.svg(o),
      m = vt(t, {});
    t.look !== "handDrawn" && ((m.roughness = 0), (m.fillStyle = "solid"));
    let g = [
        { x: -u / 2, y: -h / 2 },
        { x: u / 2 - f, y: -h / 2 },
        ...Ju(-u / 2 + f, 0, f, 50, 90, 270),
        { x: u / 2 - f, y: h / 2 },
        { x: -u / 2, y: h / 2 },
      ],
      y = ie(g),
      b = p.path(y, m),
      k = o.insert(() => b, ":first-child");
    return (
      k.attr("class", "basic label-container"),
      d && t.look !== "handDrawn" && k.selectChildren("path").attr("style", d),
      n && t.look !== "handDrawn" && k.selectChildren("path").attr("style", n),
      Ct(t, k),
      (t.intersect = function (T) {
        return (
          P.info("Pill intersect", t, { radius: f, point: T }),
          Tt.polygon(t, g, T)
        );
      }),
      o
    );
  }
  var xz = x(() => {
    "use strict";
    Vt();
    Qt();
    ae();
    re();
    oe();
    a(yz, "halfRoundedRectangle");
  });
  async function bz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.height + (t.padding ?? 0),
      l = s.width + (t.padding ?? 0) * 2.5,
      { cssStyles: u } = t,
      h = wt.svg(i),
      f = vt(t, {});
    t.look !== "handDrawn" && ((f.roughness = 0), (f.fillStyle = "solid"));
    let d = l / 2,
      p = d / 6;
    d = d + p;
    let m = o / 2,
      g = m / 2,
      y = d - g,
      b = [
        { x: -y, y: -m },
        { x: 0, y: -m },
        { x: y, y: -m },
        { x: d, y: 0 },
        { x: y, y: m },
        { x: 0, y: m },
        { x: -y, y: m },
        { x: -d, y: 0 },
      ],
      k = ie(b),
      T = h.path(k, f),
      C = i.insert(() => T, ":first-child");
    return (
      C.attr("class", "basic label-container"),
      u && t.look !== "handDrawn" && C.selectChildren("path").attr("style", u),
      n && t.look !== "handDrawn" && C.selectChildren("path").attr("style", n),
      (t.width = l),
      (t.height = o),
      Ct(t, C),
      (t.intersect = function (L) {
        return Tt.polygon(t, b, L);
      }),
      i
    );
  }
  var kz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(bz, "hexagon");
  });
  async function Tz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    ((t.label = ""), (t.labelStyle = r));
    let { shapeSvg: i } = await Bt(e, t, Ot(t)),
      s = Math.max(30, t?.width ?? 0),
      o = Math.max(30, t?.height ?? 0),
      { cssStyles: l } = t,
      u = wt.svg(i),
      h = vt(t, {});
    t.look !== "handDrawn" && ((h.roughness = 0), (h.fillStyle = "solid"));
    let f = [
        { x: 0, y: 0 },
        { x: s, y: 0 },
        { x: 0, y: o },
        { x: s, y: o },
      ],
      d = ie(f),
      p = u.path(d, h),
      m = i.insert(() => p, ":first-child");
    return (
      m.attr("class", "basic label-container"),
      l && t.look !== "handDrawn" && m.selectChildren("path").attr("style", l),
      n && t.look !== "handDrawn" && m.selectChildren("path").attr("style", n),
      m.attr("transform", `translate(${-s / 2}, ${-o / 2})`),
      Ct(t, m),
      (t.intersect = function (g) {
        return (
          P.info("Pill intersect", t, { points: f }),
          Tt.polygon(t, f, g)
        );
      }),
      i
    );
  }
  var Sz = x(() => {
    "use strict";
    Vt();
    Qt();
    ae();
    re();
    oe();
    a(Tz, "hourglass");
  });
  async function _z(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t);
    t.labelStyle = i;
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth;
    t.width = Math.max(l, u ?? 0);
    let {
        shapeSvg: h,
        bbox: f,
        label: d,
      } = await Bt(e, t, "icon-shape default"),
      p = t.pos === "t",
      m = l,
      g = l,
      { nodeBorder: y } = r,
      { stylesMap: b } = To(t),
      k = -g / 2,
      T = -m / 2,
      C = t.label ? 8 : 0,
      L = wt.svg(h),
      w = vt(t, { stroke: "none", fill: "none" });
    t.look !== "handDrawn" && ((w.roughness = 0), (w.fillStyle = "solid"));
    let D = L.rectangle(k, T, g, m, w),
      G = Math.max(g, f.width),
      E = m + f.height + C,
      R = L.rectangle(-G / 2, -E / 2, G, E, {
        ...w,
        fill: "transparent",
        stroke: "none",
      }),
      F = h.insert(() => D, ":first-child"),
      S = h.insert(() => R);
    if (t.icon) {
      let O = h.append("g");
      O.html(
        `<g>${await no(t.icon, { height: l, width: l, fallbackPrefix: "" })}</g>`,
      );
      let v = O.node().getBBox(),
        _ = v.width,
        A = v.height,
        N = v.x,
        B = v.y;
      (O.attr(
        "transform",
        `translate(${-_ / 2 - N},${p ? f.height / 2 + C / 2 - A / 2 - B : -f.height / 2 - C / 2 - A / 2 - B})`,
      ),
        O.attr("style", `color: ${b.get("stroke") ?? y};`));
    }
    return (
      d.attr(
        "transform",
        `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${p ? -E / 2 : E / 2 - f.height})`,
      ),
      F.attr(
        "transform",
        `translate(0,${p ? f.height / 2 + C / 2 : -f.height / 2 - C / 2})`,
      ),
      Ct(t, S),
      (t.intersect = function (O) {
        if ((P.info("iconSquare intersect", t, O), !t.label))
          return Tt.rect(t, O);
        let v = t.x ?? 0,
          _ = t.y ?? 0,
          A = t.height ?? 0,
          N = [];
        return (
          p
            ? (N = [
                { x: v - f.width / 2, y: _ - A / 2 },
                { x: v + f.width / 2, y: _ - A / 2 },
                { x: v + f.width / 2, y: _ - A / 2 + f.height + C },
                { x: v + g / 2, y: _ - A / 2 + f.height + C },
                { x: v + g / 2, y: _ + A / 2 },
                { x: v - g / 2, y: _ + A / 2 },
                { x: v - g / 2, y: _ - A / 2 + f.height + C },
                { x: v - f.width / 2, y: _ - A / 2 + f.height + C },
              ])
            : (N = [
                { x: v - g / 2, y: _ - A / 2 },
                { x: v + g / 2, y: _ - A / 2 },
                { x: v + g / 2, y: _ - A / 2 + m },
                { x: v + f.width / 2, y: _ - A / 2 + m },
                { x: v + f.width / 2 / 2, y: _ + A / 2 },
                { x: v - f.width / 2, y: _ + A / 2 },
                { x: v - f.width / 2, y: _ - A / 2 + m },
                { x: v - g / 2, y: _ - A / 2 + m },
              ]),
          Tt.polygon(t, N, O)
        );
      }),
      h
    );
  }
  var Cz = x(() => {
    "use strict";
    oe();
    Vt();
    bu();
    ae();
    re();
    Qt();
    a(_z, "icon");
  });
  async function wz(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t);
    t.labelStyle = i;
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth;
    t.width = Math.max(l, u ?? 0);
    let {
        shapeSvg: h,
        bbox: f,
        label: d,
      } = await Bt(e, t, "icon-shape default"),
      p = 20,
      m = t.label ? 8 : 0,
      g = t.pos === "t",
      { nodeBorder: y, mainBkg: b } = r,
      { stylesMap: k } = To(t),
      T = wt.svg(h),
      C = vt(t, {});
    t.look !== "handDrawn" && ((C.roughness = 0), (C.fillStyle = "solid"));
    let L = k.get("fill");
    C.stroke = L ?? b;
    let w = h.append("g");
    t.icon &&
      w.html(
        `<g>${await no(t.icon, { height: l, width: l, fallbackPrefix: "" })}</g>`,
      );
    let D = w.node().getBBox(),
      G = D.width,
      E = D.height,
      R = D.x,
      F = D.y,
      S = Math.max(G, E) * Math.SQRT2 + p * 2,
      O = T.circle(0, 0, S, C),
      v = Math.max(S, f.width),
      _ = S + f.height + m,
      A = T.rectangle(-v / 2, -_ / 2, v, _, {
        ...C,
        fill: "transparent",
        stroke: "none",
      }),
      N = h.insert(() => O, ":first-child"),
      B = h.insert(() => A);
    return (
      w.attr(
        "transform",
        `translate(${-G / 2 - R},${g ? f.height / 2 + m / 2 - E / 2 - F : -f.height / 2 - m / 2 - E / 2 - F})`,
      ),
      w.attr("style", `color: ${k.get("stroke") ?? y};`),
      d.attr(
        "transform",
        `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${g ? -_ / 2 : _ / 2 - f.height})`,
      ),
      N.attr(
        "transform",
        `translate(0,${g ? f.height / 2 + m / 2 : -f.height / 2 - m / 2})`,
      ),
      Ct(t, B),
      (t.intersect = function (M) {
        return (P.info("iconSquare intersect", t, M), Tt.rect(t, M));
      }),
      h
    );
  }
  var vz = x(() => {
    "use strict";
    oe();
    Vt();
    bu();
    ae();
    re();
    Qt();
    a(wz, "iconCircle");
  });
  var us,
    eh = x(() => {
      "use strict";
      us = a(
        (e, t, r, n, i) =>
          [
            "M",
            e + i,
            t,
            "H",
            e + r - i,
            "A",
            i,
            i,
            0,
            0,
            1,
            e + r,
            t + i,
            "V",
            t + n - i,
            "A",
            i,
            i,
            0,
            0,
            1,
            e + r - i,
            t + n,
            "H",
            e + i,
            "A",
            i,
            i,
            0,
            0,
            1,
            e,
            t + n - i,
            "V",
            t + i,
            "A",
            i,
            i,
            0,
            0,
            1,
            e + i,
            t,
            "Z",
          ].join(" "),
        "createRoundedRectPathD",
      );
    });
  async function Ez(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t);
    t.labelStyle = i;
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth;
    t.width = Math.max(l, u ?? 0);
    let {
        shapeSvg: h,
        bbox: f,
        halfPadding: d,
        label: p,
      } = await Bt(e, t, "icon-shape default"),
      m = t.pos === "t",
      g = l + d * 2,
      y = l + d * 2,
      { nodeBorder: b, mainBkg: k } = r,
      { stylesMap: T } = To(t),
      C = -y / 2,
      L = -g / 2,
      w = t.label ? 8 : 0,
      D = wt.svg(h),
      G = vt(t, {});
    t.look !== "handDrawn" && ((G.roughness = 0), (G.fillStyle = "solid"));
    let E = T.get("fill");
    G.stroke = E ?? k;
    let R = D.path(us(C, L, y, g, 5), G),
      F = Math.max(y, f.width),
      S = g + f.height + w,
      O = D.rectangle(-F / 2, -S / 2, F, S, {
        ...G,
        fill: "transparent",
        stroke: "none",
      }),
      v = h.insert(() => R, ":first-child").attr("class", "icon-shape2"),
      _ = h.insert(() => O);
    if (t.icon) {
      let A = h.append("g");
      A.html(
        `<g>${await no(t.icon, { height: l, width: l, fallbackPrefix: "" })}</g>`,
      );
      let N = A.node().getBBox(),
        B = N.width,
        M = N.height,
        I = N.x,
        V = N.y;
      (A.attr(
        "transform",
        `translate(${-B / 2 - I},${m ? f.height / 2 + w / 2 - M / 2 - V : -f.height / 2 - w / 2 - M / 2 - V})`,
      ),
        A.attr("style", `color: ${T.get("stroke") ?? b};`));
    }
    return (
      p.attr(
        "transform",
        `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${m ? -S / 2 : S / 2 - f.height})`,
      ),
      v.attr(
        "transform",
        `translate(0,${m ? f.height / 2 + w / 2 : -f.height / 2 - w / 2})`,
      ),
      Ct(t, _),
      (t.intersect = function (A) {
        if ((P.info("iconSquare intersect", t, A), !t.label))
          return Tt.rect(t, A);
        let N = t.x ?? 0,
          B = t.y ?? 0,
          M = t.height ?? 0,
          I = [];
        return (
          m
            ? (I = [
                { x: N - f.width / 2, y: B - M / 2 },
                { x: N + f.width / 2, y: B - M / 2 },
                { x: N + f.width / 2, y: B - M / 2 + f.height + w },
                { x: N + y / 2, y: B - M / 2 + f.height + w },
                { x: N + y / 2, y: B + M / 2 },
                { x: N - y / 2, y: B + M / 2 },
                { x: N - y / 2, y: B - M / 2 + f.height + w },
                { x: N - f.width / 2, y: B - M / 2 + f.height + w },
              ])
            : (I = [
                { x: N - y / 2, y: B - M / 2 },
                { x: N + y / 2, y: B - M / 2 },
                { x: N + y / 2, y: B - M / 2 + g },
                { x: N + f.width / 2, y: B - M / 2 + g },
                { x: N + f.width / 2 / 2, y: B + M / 2 },
                { x: N - f.width / 2, y: B + M / 2 },
                { x: N - f.width / 2, y: B - M / 2 + g },
                { x: N - y / 2, y: B - M / 2 + g },
              ]),
          Tt.polygon(t, I, A)
        );
      }),
      h
    );
  }
  var Az = x(() => {
    "use strict";
    oe();
    Vt();
    bu();
    ae();
    re();
    eh();
    Qt();
    a(Ez, "iconRounded");
  });
  async function Lz(e, t, { config: { themeVariables: r, flowchart: n } }) {
    let { labelStyles: i } = St(t);
    t.labelStyle = i;
    let s = t.assetHeight ?? 48,
      o = t.assetWidth ?? 48,
      l = Math.max(s, o),
      u = n?.wrappingWidth;
    t.width = Math.max(l, u ?? 0);
    let {
        shapeSvg: h,
        bbox: f,
        halfPadding: d,
        label: p,
      } = await Bt(e, t, "icon-shape default"),
      m = t.pos === "t",
      g = l + d * 2,
      y = l + d * 2,
      { nodeBorder: b, mainBkg: k } = r,
      { stylesMap: T } = To(t),
      C = -y / 2,
      L = -g / 2,
      w = t.label ? 8 : 0,
      D = wt.svg(h),
      G = vt(t, {});
    t.look !== "handDrawn" && ((G.roughness = 0), (G.fillStyle = "solid"));
    let E = T.get("fill");
    G.stroke = E ?? k;
    let R = D.path(us(C, L, y, g, 0.1), G),
      F = Math.max(y, f.width),
      S = g + f.height + w,
      O = D.rectangle(-F / 2, -S / 2, F, S, {
        ...G,
        fill: "transparent",
        stroke: "none",
      }),
      v = h.insert(() => R, ":first-child"),
      _ = h.insert(() => O);
    if (t.icon) {
      let A = h.append("g");
      A.html(
        `<g>${await no(t.icon, { height: l, width: l, fallbackPrefix: "" })}</g>`,
      );
      let N = A.node().getBBox(),
        B = N.width,
        M = N.height,
        I = N.x,
        V = N.y;
      (A.attr(
        "transform",
        `translate(${-B / 2 - I},${m ? f.height / 2 + w / 2 - M / 2 - V : -f.height / 2 - w / 2 - M / 2 - V})`,
      ),
        A.attr("style", `color: ${T.get("stroke") ?? b};`));
    }
    return (
      p.attr(
        "transform",
        `translate(${-f.width / 2 - (f.x - (f.left ?? 0))},${m ? -S / 2 : S / 2 - f.height})`,
      ),
      v.attr(
        "transform",
        `translate(0,${m ? f.height / 2 + w / 2 : -f.height / 2 - w / 2})`,
      ),
      Ct(t, _),
      (t.intersect = function (A) {
        if ((P.info("iconSquare intersect", t, A), !t.label))
          return Tt.rect(t, A);
        let N = t.x ?? 0,
          B = t.y ?? 0,
          M = t.height ?? 0,
          I = [];
        return (
          m
            ? (I = [
                { x: N - f.width / 2, y: B - M / 2 },
                { x: N + f.width / 2, y: B - M / 2 },
                { x: N + f.width / 2, y: B - M / 2 + f.height + w },
                { x: N + y / 2, y: B - M / 2 + f.height + w },
                { x: N + y / 2, y: B + M / 2 },
                { x: N - y / 2, y: B + M / 2 },
                { x: N - y / 2, y: B - M / 2 + f.height + w },
                { x: N - f.width / 2, y: B - M / 2 + f.height + w },
              ])
            : (I = [
                { x: N - y / 2, y: B - M / 2 },
                { x: N + y / 2, y: B - M / 2 },
                { x: N + y / 2, y: B - M / 2 + g },
                { x: N + f.width / 2, y: B - M / 2 + g },
                { x: N + f.width / 2 / 2, y: B + M / 2 },
                { x: N - f.width / 2, y: B + M / 2 },
                { x: N - f.width / 2, y: B - M / 2 + g },
                { x: N - y / 2, y: B - M / 2 + g },
              ]),
          Tt.polygon(t, I, A)
        );
      }),
      h
    );
  }
  var Rz = x(() => {
    "use strict";
    oe();
    Vt();
    bu();
    ae();
    eh();
    re();
    Qt();
    a(Lz, "iconSquare");
  });
  async function Dz(e, t, { config: { flowchart: r } }) {
    let n = new Image();
    ((n.src = t?.img ?? ""), await n.decode());
    let i = Number(n.naturalWidth.toString().replace("px", "")),
      s = Number(n.naturalHeight.toString().replace("px", ""));
    t.imageAspectRatio = i / s;
    let { labelStyles: o } = St(t);
    t.labelStyle = o;
    let l = r?.wrappingWidth;
    t.defaultWidth = r?.wrappingWidth;
    let u = Math.max(t.label ? (l ?? 0) : 0, t?.assetWidth ?? i),
      h =
        t.constraint === "on" && t?.assetHeight
          ? t.assetHeight * t.imageAspectRatio
          : u,
      f =
        t.constraint === "on" ? h / t.imageAspectRatio : (t?.assetHeight ?? s);
    t.width = Math.max(h, l ?? 0);
    let {
        shapeSvg: d,
        bbox: p,
        label: m,
      } = await Bt(e, t, "image-shape default"),
      g = t.pos === "t",
      y = -h / 2,
      b = -f / 2,
      k = t.label ? 8 : 0,
      T = wt.svg(d),
      C = vt(t, {});
    t.look !== "handDrawn" && ((C.roughness = 0), (C.fillStyle = "solid"));
    let L = T.rectangle(y, b, h, f, C),
      w = Math.max(h, p.width),
      D = f + p.height + k,
      G = T.rectangle(-w / 2, -D / 2, w, D, {
        ...C,
        fill: "none",
        stroke: "none",
      }),
      E = d.insert(() => L, ":first-child"),
      R = d.insert(() => G);
    if (t.img) {
      let F = d.append("image");
      (F.attr("href", t.img),
        F.attr("width", h),
        F.attr("height", f),
        F.attr("preserveAspectRatio", "none"),
        F.attr("transform", `translate(${-h / 2},${g ? D / 2 - f : -D / 2})`));
    }
    return (
      m.attr(
        "transform",
        `translate(${-p.width / 2 - (p.x - (p.left ?? 0))},${g ? -f / 2 - p.height / 2 - k / 2 : f / 2 - p.height / 2 + k / 2})`,
      ),
      E.attr(
        "transform",
        `translate(0,${g ? p.height / 2 + k / 2 : -p.height / 2 - k / 2})`,
      ),
      Ct(t, R),
      (t.intersect = function (F) {
        if ((P.info("iconSquare intersect", t, F), !t.label))
          return Tt.rect(t, F);
        let S = t.x ?? 0,
          O = t.y ?? 0,
          v = t.height ?? 0,
          _ = [];
        return (
          g
            ? (_ = [
                { x: S - p.width / 2, y: O - v / 2 },
                { x: S + p.width / 2, y: O - v / 2 },
                { x: S + p.width / 2, y: O - v / 2 + p.height + k },
                { x: S + h / 2, y: O - v / 2 + p.height + k },
                { x: S + h / 2, y: O + v / 2 },
                { x: S - h / 2, y: O + v / 2 },
                { x: S - h / 2, y: O - v / 2 + p.height + k },
                { x: S - p.width / 2, y: O - v / 2 + p.height + k },
              ])
            : (_ = [
                { x: S - h / 2, y: O - v / 2 },
                { x: S + h / 2, y: O - v / 2 },
                { x: S + h / 2, y: O - v / 2 + f },
                { x: S + p.width / 2, y: O - v / 2 + f },
                { x: S + p.width / 2 / 2, y: O + v / 2 },
                { x: S - p.width / 2, y: O + v / 2 },
                { x: S - p.width / 2, y: O - v / 2 + f },
                { x: S - h / 2, y: O - v / 2 + f },
              ]),
          Tt.polygon(t, _, F)
        );
      }),
      d
    );
  }
  var Nz = x(() => {
    "use strict";
    oe();
    Vt();
    ae();
    re();
    Qt();
    a(Dz, "imageSquare");
  });
  async function Iz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      u = [
        { x: 0, y: 0 },
        { x: o, y: 0 },
        { x: o + (3 * l) / 6, y: -l },
        { x: (-3 * l) / 6, y: -l },
      ],
      h,
      { cssStyles: f } = t;
    if (t.look === "handDrawn") {
      let d = wt.svg(i),
        p = vt(t, {}),
        m = ie(u),
        g = d.path(m, p);
      ((h = i
        .insert(() => g, ":first-child")
        .attr("transform", `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr("style", f));
    } else h = cs(i, o, l, u);
    return (
      n && h.attr("style", n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d);
      }),
      i
    );
  }
  var Mz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    Ac();
    a(Iz, "inv_trapezoid");
  });
  async function rh(e, t, r) {
    let { labelStyles: n, nodeStyles: i } = St(t);
    t.labelStyle = n;
    let { shapeSvg: s, bbox: o } = await Bt(e, t, Ot(t)),
      l = Math.max(o.width + r.labelPaddingX * 2, t?.width || 0),
      u = Math.max(o.height + r.labelPaddingY * 2, t?.height || 0),
      h = -l / 2,
      f = -u / 2,
      d,
      { rx: p, ry: m } = t,
      { cssStyles: g } = t;
    if ((r?.rx && r.ry && ((p = r.rx), (m = r.ry)), t.look === "handDrawn")) {
      let y = wt.svg(s),
        b = vt(t, {}),
        k =
          p || m
            ? y.path(us(h, f, l, u, p || 0), b)
            : y.rectangle(h, f, l, u, b);
      ((d = s.insert(() => k, ":first-child")),
        d.attr("class", "basic label-container").attr("style", Ir(g)));
    } else
      ((d = s.insert("rect", ":first-child")),
        d
          .attr("class", "basic label-container")
          .attr("style", i)
          .attr("rx", Ir(p))
          .attr("ry", Ir(m))
          .attr("x", h)
          .attr("y", f)
          .attr("width", l)
          .attr("height", u));
    return (
      Ct(t, d),
      (t.calcIntersect = function (y, b) {
        return Tt.rect(y, b);
      }),
      (t.intersect = function (y) {
        return Tt.rect(t, y);
      }),
      s
    );
  }
  var P0 = x(() => {
    "use strict";
    Qt();
    ae();
    eh();
    re();
    oe();
    _e();
    a(rh, "drawRect");
  });
  async function Oz(e, t) {
    let { shapeSvg: r, bbox: n, label: i } = await Bt(e, t, "label"),
      s = r.insert("rect", ":first-child");
    return (
      s.attr("width", 0.1).attr("height", 0.1),
      r.attr("class", "label edgeLabel"),
      i.attr(
        "transform",
        `translate(${-(n.width / 2) - (n.x - (n.left ?? 0))}, ${-(n.height / 2) - (n.y - (n.top ?? 0))})`,
      ),
      Ct(t, s),
      (t.intersect = function (u) {
        return Tt.rect(t, u);
      }),
      r
    );
  }
  var Pz = x(() => {
    "use strict";
    P0();
    Qt();
    ae();
    a(Oz, "labelRect");
  });
  async function Bz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0), t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0), t?.height ?? 0),
      u = [
        { x: 0, y: 0 },
        { x: o + (3 * l) / 6, y: 0 },
        { x: o, y: -l },
        { x: -(3 * l) / 6, y: -l },
      ],
      h,
      { cssStyles: f } = t;
    if (t.look === "handDrawn") {
      let d = wt.svg(i),
        p = vt(t, {}),
        m = ie(u),
        g = d.path(m, p);
      ((h = i
        .insert(() => g, ":first-child")
        .attr("transform", `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr("style", f));
    } else h = cs(i, o, l, u);
    return (
      n && h.attr("style", n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d);
      }),
      i
    );
  }
  var Fz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    Ac();
    a(Bz, "lean_left");
  });
  async function $z(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0), t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0), t?.height ?? 0),
      u = [
        { x: (-3 * l) / 6, y: 0 },
        { x: o, y: 0 },
        { x: o + (3 * l) / 6, y: -l },
        { x: 0, y: -l },
      ],
      h,
      { cssStyles: f } = t;
    if (t.look === "handDrawn") {
      let d = wt.svg(i),
        p = vt(t, {}),
        m = ie(u),
        g = d.path(m, p);
      ((h = i
        .insert(() => g, ":first-child")
        .attr("transform", `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr("style", f));
    } else h = cs(i, o, l, u);
    return (
      n && h.attr("style", n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d);
      }),
      i
    );
  }
  var Gz = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    Ac();
    a($z, "lean_right");
  });
  function Vz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    ((t.label = ""), (t.labelStyle = r));
    let i = e
        .insert("g")
        .attr("class", Ot(t))
        .attr("id", t.domId ?? t.id),
      { cssStyles: s } = t,
      o = Math.max(35, t?.width ?? 0),
      l = Math.max(35, t?.height ?? 0),
      u = 7,
      h = [
        { x: o, y: 0 },
        { x: 0, y: l + u / 2 },
        { x: o - 2 * u, y: l + u / 2 },
        { x: 0, y: 2 * l },
        { x: o, y: l - u / 2 },
        { x: 2 * u, y: l - u / 2 },
      ],
      f = wt.svg(i),
      d = vt(t, {});
    t.look !== "handDrawn" && ((d.roughness = 0), (d.fillStyle = "solid"));
    let p = ie(h),
      m = f.path(p, d),
      g = i.insert(() => m, ":first-child");
    return (
      s && t.look !== "handDrawn" && g.selectAll("path").attr("style", s),
      n && t.look !== "handDrawn" && g.selectAll("path").attr("style", n),
      g.attr("transform", `translate(-${o / 2},${-l})`),
      Ct(t, g),
      (t.intersect = function (y) {
        return (P.info("lightningBolt intersect", t, y), Tt.polygon(t, h, y));
      }),
      i
    );
  }
  var zz = x(() => {
    "use strict";
    Vt();
    Qt();
    re();
    oe();
    ae();
    Qt();
    a(Vz, "lightningBolt");
  });
  async function Wz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0), t.width ?? 0),
      u = l / 2,
      h = u / (2.5 + l / 50),
      f = Math.max(s.height + h + (t.padding ?? 0), t.height ?? 0),
      d = f * 0.1,
      p,
      { cssStyles: m } = t;
    if (t.look === "handDrawn") {
      let g = wt.svg(i),
        y = Ibt(0, 0, l, f, u, h, d),
        b = Mbt(0, h, l, f, u, h),
        k = vt(t, {}),
        T = g.path(y, k),
        C = g.path(b, k);
      (i.insert(() => C, ":first-child").attr("class", "line"),
        (p = i.insert(() => T, ":first-child")),
        p.attr("class", "basic label-container"),
        m && p.attr("style", m));
    } else {
      let g = Nbt(0, 0, l, f, u, h, d);
      p = i
        .insert("path", ":first-child")
        .attr("d", g)
        .attr("class", "basic label-container")
        .attr("style", Ir(m))
        .attr("style", n);
    }
    return (
      p.attr("label-offset-y", h),
      p.attr("transform", `translate(${-l / 2}, ${-(f / 2 + h)})`),
      Ct(t, p),
      o.attr(
        "transform",
        `translate(${-(s.width / 2) - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + h - (s.y - (s.top ?? 0))})`,
      ),
      (t.intersect = function (g) {
        let y = Tt.rect(t, g),
          b = y.x - (t.x ?? 0);
        if (
          u != 0 &&
          (Math.abs(b) < (t.width ?? 0) / 2 ||
            (Math.abs(b) == (t.width ?? 0) / 2 &&
              Math.abs(y.y - (t.y ?? 0)) > (t.height ?? 0) / 2 - h))
        ) {
          let k = h * h * (1 - (b * b) / (u * u));
          (k > 0 && (k = Math.sqrt(k)),
            (k = h - k),
            g.y - (t.y ?? 0) > 0 && (k = -k),
            (y.y += k));
        }
        return y;
      }),
      i
    );
  }
  var Nbt,
    Ibt,
    Mbt,
    Uz = x(() => {
      "use strict";
      Qt();
      ae();
      re();
      oe();
      _e();
      ((Nbt = a(
        (e, t, r, n, i, s, o) =>
          [
            `M${e},${t + s}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `a${i},${s} 0,0,0 ${-r},0`,
            `l0,${n}`,
            `a${i},${s} 0,0,0 ${r},0`,
            `l0,${-n}`,
            `M${e},${t + s + o}`,
            `a${i},${s} 0,0,0 ${r},0`,
          ].join(" "),
        "createCylinderPathD",
      )),
        (Ibt = a(
          (e, t, r, n, i, s, o) =>
            [
              `M${e},${t + s}`,
              `M${e + r},${t + s}`,
              `a${i},${s} 0,0,0 ${-r},0`,
              `l0,${n}`,
              `a${i},${s} 0,0,0 ${r},0`,
              `l0,${-n}`,
              `M${e},${t + s + o}`,
              `a${i},${s} 0,0,0 ${r},0`,
            ].join(" "),
          "createOuterCylinderPathD",
        )),
        (Mbt = a(
          (e, t, r, n, i, s) =>
            [`M${e - r / 2},${-n / 2}`, `a${i},${s} 0,0,0 ${r},0`].join(" "),
          "createInnerCylinderPathD",
        )));
      a(Wz, "linedCylinder");
    });
  async function jz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 4,
      f = u + h,
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = vt(t, {});
    t.look !== "handDrawn" && ((m.roughness = 0), (m.fillStyle = "solid"));
    let g = [
        { x: -l / 2 - (l / 2) * 0.1, y: -f / 2 },
        { x: -l / 2 - (l / 2) * 0.1, y: f / 2 },
        ...ra(
          -l / 2 - (l / 2) * 0.1,
          f / 2,
          l / 2 + (l / 2) * 0.1,
          f / 2,
          h,
          0.8,
        ),
        { x: l / 2 + (l / 2) * 0.1, y: -f / 2 },
        { x: -l / 2 - (l / 2) * 0.1, y: -f / 2 },
        { x: -l / 2, y: -f / 2 },
        { x: -l / 2, y: (f / 2) * 1.1 },
        { x: -l / 2, y: -f / 2 },
      ],
      y = p.polygon(
        g.map((k) => [k.x, k.y]),
        m,
      ),
      b = i.insert(() => y, ":first-child");
    return (
      b.attr("class", "basic label-container"),
      d && t.look !== "handDrawn" && b.selectAll("path").attr("style", d),
      n && t.look !== "handDrawn" && b.selectAll("path").attr("style", n),
      b.attr("transform", `translate(0,${-h / 2})`),
      o.attr(
        "transform",
        `translate(${-l / 2 + (t.padding ?? 0) + ((l / 2) * 0.1) / 2 - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) - h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, b),
      (t.intersect = function (k) {
        return Tt.polygon(t, g, k);
      }),
      i
    );
  }
  var qz = x(() => {
    "use strict";
    Qt();
    ae();
    oe();
    re();
    a(jz, "linedWaveEdgedRect");
  });
  async function Hz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = 5,
      f = -l / 2,
      d = -u / 2,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = vt(t, {}),
      y = [
        { x: f - h, y: d + h },
        { x: f - h, y: d + u + h },
        { x: f + l - h, y: d + u + h },
        { x: f + l - h, y: d + u },
        { x: f + l, y: d + u },
        { x: f + l, y: d + u - h },
        { x: f + l + h, y: d + u - h },
        { x: f + l + h, y: d - h },
        { x: f + h, y: d - h },
        { x: f + h, y: d },
        { x: f, y: d },
        { x: f, y: d + h },
      ],
      b = [
        { x: f, y: d + h },
        { x: f + l - h, y: d + h },
        { x: f + l - h, y: d + u },
        { x: f + l, y: d + u },
        { x: f + l, y: d },
        { x: f, y: d },
      ];
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let k = ie(y),
      T = m.path(k, g),
      C = ie(b),
      L = m.path(C, { ...g, fill: "none" }),
      w = i.insert(() => L, ":first-child");
    return (
      w.insert(() => T, ":first-child"),
      w.attr("class", "basic label-container"),
      p && t.look !== "handDrawn" && w.selectAll("path").attr("style", p),
      n && t.look !== "handDrawn" && w.selectAll("path").attr("style", n),
      o.attr(
        "transform",
        `translate(${-(s.width / 2) - h - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + h - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, y, D);
      }),
      i
    );
  }
  var Yz = x(() => {
    "use strict";
    Qt();
    re();
    oe();
    ae();
    a(Hz, "multiRect");
  });
  async function Xz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 4,
      f = u + h,
      d = -l / 2,
      p = -f / 2,
      m = 5,
      { cssStyles: g } = t,
      y = ra(d - m, p + f + m, d + l - m, p + f + m, h, 0.8),
      b = y?.[y.length - 1],
      k = [
        { x: d - m, y: p + m },
        { x: d - m, y: p + f + m },
        ...y,
        { x: d + l - m, y: b.y - m },
        { x: d + l, y: b.y - m },
        { x: d + l, y: b.y - 2 * m },
        { x: d + l + m, y: b.y - 2 * m },
        { x: d + l + m, y: p - m },
        { x: d + m, y: p - m },
        { x: d + m, y: p },
        { x: d, y: p },
        { x: d, y: p + m },
      ],
      T = [
        { x: d, y: p + m },
        { x: d + l - m, y: p + m },
        { x: d + l - m, y: b.y - m },
        { x: d + l, y: b.y - m },
        { x: d + l, y: p },
        { x: d, y: p },
      ],
      C = wt.svg(i),
      L = vt(t, {});
    t.look !== "handDrawn" && ((L.roughness = 0), (L.fillStyle = "solid"));
    let w = ie(k),
      D = C.path(w, L),
      G = ie(T),
      E = C.path(G, L),
      R = i.insert(() => D, ":first-child");
    return (
      R.insert(() => E),
      R.attr("class", "basic label-container"),
      g && t.look !== "handDrawn" && R.selectAll("path").attr("style", g),
      n && t.look !== "handDrawn" && R.selectAll("path").attr("style", n),
      R.attr("transform", `translate(0,${-h / 2})`),
      o.attr(
        "transform",
        `translate(${-(s.width / 2) - m - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + m - h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, R),
      (t.intersect = function (F) {
        return Tt.polygon(t, k, F);
      }),
      i
    );
  }
  var Kz = x(() => {
    "use strict";
    Qt();
    ae();
    oe();
    re();
    a(Xz, "multiWaveEdgedRectangle");
  });
  async function Qz(e, t, { config: { themeVariables: r } }) {
    let { labelStyles: n, nodeStyles: i } = St(t);
    ((t.labelStyle = n),
      t.useHtmlLabels ||
        ke().flowchart?.htmlLabels !== !1 ||
        (t.centerLabel = !0));
    let { shapeSvg: o, bbox: l, label: u } = await Bt(e, t, Ot(t)),
      h = Math.max(l.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      f = Math.max(l.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      d = -h / 2,
      p = -f / 2,
      { cssStyles: m } = t,
      g = wt.svg(o),
      y = vt(t, { fill: r.noteBkgColor, stroke: r.noteBorderColor });
    t.look !== "handDrawn" && ((y.roughness = 0), (y.fillStyle = "solid"));
    let b = g.rectangle(d, p, h, f, y),
      k = o.insert(() => b, ":first-child");
    return (
      k.attr("class", "basic label-container"),
      m && t.look !== "handDrawn" && k.selectAll("path").attr("style", m),
      i && t.look !== "handDrawn" && k.selectAll("path").attr("style", i),
      u.attr(
        "transform",
        `translate(${-l.width / 2 - (l.x - (l.left ?? 0))}, ${-(l.height / 2) - (l.y - (l.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.rect(t, T);
      }),
      o
    );
  }
  var Zz = x(() => {
    "use strict";
    oe();
    ae();
    re();
    Qt();
    un();
    a(Qz, "note");
  });
  async function Jz(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.width + t.padding,
      l = s.height + t.padding,
      u = o + l,
      h = 0.5,
      f = [
        { x: u / 2, y: 0 },
        { x: u, y: -u / 2 },
        { x: u / 2, y: -u },
        { x: 0, y: -u / 2 },
      ],
      d,
      { cssStyles: p } = t;
    if (t.look === "handDrawn") {
      let m = wt.svg(i),
        g = vt(t, {}),
        y = Obt(0, 0, u),
        b = m.path(y, g);
      ((d = i
        .insert(() => b, ":first-child")
        .attr("transform", `translate(${-u / 2 + h}, ${u / 2})`)),
        p && d.attr("style", p));
    } else
      ((d = cs(i, u, u, f)),
        d.attr("transform", `translate(${-u / 2 + h}, ${u / 2})`));
    return (
      n && d.attr("style", n),
      Ct(t, d),
      (t.calcIntersect = function (m, g) {
        let y = m.width,
          b = [
            { x: y / 2, y: 0 },
            { x: y, y: -y / 2 },
            { x: y / 2, y: -y },
            { x: 0, y: -y / 2 },
          ],
          k = Tt.polygon(m, b, g);
        return { x: k.x - 0.5, y: k.y - 0.5 };
      }),
      (t.intersect = function (m) {
        return this.calcIntersect(t, m);
      }),
      i
    );
  }
  var Obt,
    tW = x(() => {
      "use strict";
      Qt();
      ae();
      re();
      oe();
      Ac();
      Obt = a(
        (e, t, r) =>
          [
            `M${e + r / 2},${t}`,
            `L${e + r},${t - r / 2}`,
            `L${e + r / 2},${t - r}`,
            `L${e},${t - r / 2}`,
            "Z",
          ].join(" "),
        "createDecisionBoxPathD",
      );
      a(Jz, "question");
    });
  async function eW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0), t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0), t?.height ?? 0),
      h = -l / 2,
      f = -u / 2,
      d = f / 2,
      p = [
        { x: h + d, y: f },
        { x: h, y: 0 },
        { x: h + d, y: -f },
        { x: -h, y: -f },
        { x: -h, y: f },
      ],
      { cssStyles: m } = t,
      g = wt.svg(i),
      y = vt(t, {});
    t.look !== "handDrawn" && ((y.roughness = 0), (y.fillStyle = "solid"));
    let b = ie(p),
      k = g.path(b, y),
      T = i.insert(() => k, ":first-child");
    return (
      T.attr("class", "basic label-container"),
      m && t.look !== "handDrawn" && T.selectAll("path").attr("style", m),
      n && t.look !== "handDrawn" && T.selectAll("path").attr("style", n),
      T.attr("transform", `translate(${-d / 2},0)`),
      o.attr(
        "transform",
        `translate(${-d / 2 - s.width / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, T),
      (t.intersect = function (C) {
        return Tt.polygon(t, p, C);
      }),
      i
    );
  }
  var rW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(eW, "rect_left_inv_arrow");
  });
  function Pbt(e, t) {
    t && e.attr("style", t);
  }
  async function Bbt(e) {
    let t = xt(
        document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"),
      ),
      r = t.append("xhtml:div"),
      n = K(),
      i = e.label;
    e.label &&
      $r(e.label) &&
      (i = await Kl(
        e.label.replace(
          Rt.lineBreakRegex,
          `
`,
        ),
        n,
      ));
    let o =
      '<span class="' +
      (e.isNode ? "nodeLabel" : "edgeLabel") +
      '" ' +
      (e.labelStyle ? 'style="' + e.labelStyle + '"' : "") +
      ">" +
      i +
      "</span>";
    return (
      r.html(Ie(o, n)),
      Pbt(r, e.labelStyle),
      r.style("display", "inline-block"),
      r.style("padding-right", "1px"),
      r.style("white-space", "nowrap"),
      r.attr("xmlns", "http://www.w3.org/1999/xhtml"),
      t.node()
    );
  }
  var Fbt,
    So,
    Ub = x(() => {
      "use strict";
      Ge();
      pe();
      Be();
      Vt();
      _e();
      a(Pbt, "applyStyle");
      a(Bbt, "addHtmlLabel");
      ((Fbt = a(async (e, t, r, n) => {
        let i = e || "";
        if (
          (typeof i == "object" && (i = i[0]), Pe(K().flowchart.htmlLabels))
        ) {
          ((i = i.replace(/\\n|\n/g, "<br />")), P.info("vertexText" + i));
          let s = {
            isNode: n,
            label: Xn(i).replace(
              /fa[blrs]?:fa-[\w-]+/g,
              (l) => `<i class='${l.replace(":", " ")}'></i>`,
            ),
            labelStyle: t && t.replace("fill:", "color:"),
          };
          return await Bbt(s);
        } else {
          let s = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text",
          );
          s.setAttribute("style", t.replace("color:", "fill:"));
          let o = [];
          typeof i == "string"
            ? (o = i.split(/\\n|\n|<br\s*\/?>/gi))
            : Array.isArray(i)
              ? (o = i)
              : (o = []);
          for (let l of o) {
            let u = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "tspan",
            );
            (u.setAttributeNS(
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              "preserve",
            ),
              u.setAttribute("dy", "1em"),
              u.setAttribute("x", "0"),
              r
                ? u.setAttribute("class", "title-row")
                : u.setAttribute("class", "row"),
              (u.textContent = l.trim()),
              s.appendChild(u));
          }
          return s;
        }
      }, "createLabel")),
        (So = Fbt));
    });
  async function nW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let i;
    t.cssClasses ? (i = "node " + t.cssClasses) : (i = "node default");
    let s = e
        .insert("g")
        .attr("class", i)
        .attr("id", t.domId || t.id),
      o = s.insert("g"),
      l = s.insert("g").attr("class", "label").attr("style", n),
      u = t.description,
      h = t.label,
      f = l.node().appendChild(await So(h, t.labelStyle, !0, !0)),
      d = { width: 0, height: 0 };
    if (Pe(K()?.flowchart?.htmlLabels)) {
      let E = f.children[0],
        R = xt(f);
      ((d = E.getBoundingClientRect()),
        R.attr("width", d.width),
        R.attr("height", d.height));
    }
    P.info("Text 2", u);
    let p = u || [],
      m = f.getBBox(),
      g = l
        .node()
        .appendChild(
          await So(p.join ? p.join("<br/>") : p, t.labelStyle, !0, !0),
        ),
      y = g.children[0],
      b = xt(g);
    ((d = y.getBoundingClientRect()),
      b.attr("width", d.width),
      b.attr("height", d.height));
    let k = (t.padding || 0) / 2;
    (xt(g).attr(
      "transform",
      "translate( " +
        (d.width > m.width ? 0 : (m.width - d.width) / 2) +
        ", " +
        (m.height + k + 5) +
        ")",
    ),
      xt(f).attr(
        "transform",
        "translate( " +
          (d.width < m.width ? 0 : -(m.width - d.width) / 2) +
          ", 0)",
      ),
      (d = l.node().getBBox()),
      l.attr(
        "transform",
        "translate(" + -d.width / 2 + ", " + (-d.height / 2 - k + 3) + ")",
      ));
    let T = d.width + (t.padding || 0),
      C = d.height + (t.padding || 0),
      L = -d.width / 2 - k,
      w = -d.height / 2 - k,
      D,
      G;
    if (t.look === "handDrawn") {
      let E = wt.svg(s),
        R = vt(t, {}),
        F = E.path(us(L, w, T, C, t.rx || 0), R),
        S = E.line(
          -d.width / 2 - k,
          -d.height / 2 - k + m.height + k,
          d.width / 2 + k,
          -d.height / 2 - k + m.height + k,
          R,
        );
      ((G = s.insert(
        () => (P.debug("Rough node insert CXC", F), S),
        ":first-child",
      )),
        (D = s.insert(
          () => (P.debug("Rough node insert CXC", F), F),
          ":first-child",
        )));
    } else
      ((D = o.insert("rect", ":first-child")),
        (G = o.insert("line")),
        D.attr("class", "outer title-state")
          .attr("style", n)
          .attr("x", -d.width / 2 - k)
          .attr("y", -d.height / 2 - k)
          .attr("width", d.width + (t.padding || 0))
          .attr("height", d.height + (t.padding || 0)),
        G.attr("class", "divider")
          .attr("x1", -d.width / 2 - k)
          .attr("x2", d.width / 2 + k)
          .attr("y1", -d.height / 2 - k + m.height + k)
          .attr("y2", -d.height / 2 - k + m.height + k));
    return (
      Ct(t, D),
      (t.intersect = function (E) {
        return Tt.rect(t, E);
      }),
      s
    );
  }
  var iW = x(() => {
    "use strict";
    Ge();
    Be();
    Qt();
    Ub();
    ae();
    re();
    oe();
    pe();
    eh();
    Vt();
    a(nW, "rectWithTitle");
  });
  function jb(e, t, r, n, i, s, o) {
    let u = (e + r) / 2,
      h = (t + n) / 2,
      f = Math.atan2(n - t, r - e),
      d = (r - e) / 2,
      p = (n - t) / 2,
      m = d / i,
      g = p / s,
      y = Math.sqrt(m ** 2 + g ** 2);
    if (y > 1)
      throw new Error(
        "The given radii are too small to create an arc between the points.",
      );
    let b = Math.sqrt(1 - y ** 2),
      k = u + b * s * Math.sin(f) * (o ? -1 : 1),
      T = h - b * i * Math.cos(f) * (o ? -1 : 1),
      C = Math.atan2((t - T) / s, (e - k) / i),
      w = Math.atan2((n - T) / s, (r - k) / i) - C;
    (o && w < 0 && (w += 2 * Math.PI), !o && w > 0 && (w -= 2 * Math.PI));
    let D = [];
    for (let G = 0; G < 20; G++) {
      let E = G / 19,
        R = C + E * w,
        F = k + i * Math.cos(R),
        S = T + s * Math.sin(R);
      D.push({ x: F, y: S });
    }
    return D;
  }
  async function sW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = t?.padding ?? 0,
      l = t?.padding ?? 0,
      u = (t?.width ? t?.width : s.width) + o * 2,
      h = (t?.height ? t?.height : s.height) + l * 2,
      f = t.radius || 5,
      d = t.taper || 5,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = vt(t, {});
    (t.stroke && (g.stroke = t.stroke),
      t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid")));
    let y = [
        { x: -u / 2 + d, y: -h / 2 },
        { x: u / 2 - d, y: -h / 2 },
        ...jb(u / 2 - d, -h / 2, u / 2, -h / 2 + d, f, f, !0),
        { x: u / 2, y: -h / 2 + d },
        { x: u / 2, y: h / 2 - d },
        ...jb(u / 2, h / 2 - d, u / 2 - d, h / 2, f, f, !0),
        { x: u / 2 - d, y: h / 2 },
        { x: -u / 2 + d, y: h / 2 },
        ...jb(-u / 2 + d, h / 2, -u / 2, h / 2 - d, f, f, !0),
        { x: -u / 2, y: h / 2 - d },
        { x: -u / 2, y: -h / 2 + d },
        ...jb(-u / 2, -h / 2 + d, -u / 2 + d, -h / 2, f, f, !0),
      ],
      b = ie(y),
      k = m.path(b, g),
      T = i.insert(() => k, ":first-child");
    return (
      T.attr("class", "basic label-container outer-path"),
      p && t.look !== "handDrawn" && T.selectChildren("path").attr("style", p),
      n && t.look !== "handDrawn" && T.selectChildren("path").attr("style", n),
      Ct(t, T),
      (t.intersect = function (C) {
        return Tt.polygon(t, y, C);
      }),
      i
    );
  }
  var aW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(jb, "generateArcPoints");
    a(sW, "roundedRect");
  });
  async function oW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = t?.padding ?? 0,
      u = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = -s.width / 2 - l,
      d = -s.height / 2 - l,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = vt(t, {});
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let y = [
        { x: f, y: d },
        { x: f + u + 8, y: d },
        { x: f + u + 8, y: d + h },
        { x: f - 8, y: d + h },
        { x: f - 8, y: d },
        { x: f, y: d },
        { x: f, y: d + h },
      ],
      b = m.polygon(
        y.map((T) => [T.x, T.y]),
        g,
      ),
      k = i.insert(() => b, ":first-child");
    return (
      k.attr("class", "basic label-container").attr("style", Ir(p)),
      n && t.look !== "handDrawn" && k.selectAll("path").attr("style", n),
      p && t.look !== "handDrawn" && k.selectAll("path").attr("style", n),
      o.attr(
        "transform",
        `translate(${-u / 2 + 4 + (t.padding ?? 0) - (s.x - (s.left ?? 0))},${-h / 2 + (t.padding ?? 0) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.rect(t, T);
      }),
      i
    );
  }
  var lW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    _e();
    a(oW, "shadedProcess");
  });
  async function cW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = -l / 2,
      f = -u / 2,
      { cssStyles: d } = t,
      p = wt.svg(i),
      m = vt(t, {});
    t.look !== "handDrawn" && ((m.roughness = 0), (m.fillStyle = "solid"));
    let g = [
        { x: h, y: f },
        { x: h, y: f + u },
        { x: h + l, y: f + u },
        { x: h + l, y: f - u / 2 },
      ],
      y = ie(g),
      b = p.path(y, m),
      k = i.insert(() => b, ":first-child");
    return (
      k.attr("class", "basic label-container"),
      d && t.look !== "handDrawn" && k.selectChildren("path").attr("style", d),
      n && t.look !== "handDrawn" && k.selectChildren("path").attr("style", n),
      k.attr("transform", `translate(0, ${u / 4})`),
      o.attr(
        "transform",
        `translate(${-l / 2 + (t.padding ?? 0) - (s.x - (s.left ?? 0))}, ${-u / 4 + (t.padding ?? 0) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, k),
      (t.intersect = function (T) {
        return Tt.polygon(t, g, T);
      }),
      i
    );
  }
  var uW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(cW, "slopedRect");
  });
  async function hW(e, t) {
    let r = {
      rx: 0,
      ry: 0,
      classes: "",
      labelPaddingX: t.labelPaddingX ?? (t?.padding || 0) * 2,
      labelPaddingY: (t?.padding || 0) * 1,
    };
    return rh(e, t, r);
  }
  var fW = x(() => {
    "use strict";
    P0();
    a(hW, "squareRect");
  });
  async function dW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.height + t.padding,
      l = s.width + o / 4 + t.padding,
      u = o / 2,
      { cssStyles: h } = t,
      f = wt.svg(i),
      d = vt(t, {});
    t.look !== "handDrawn" && ((d.roughness = 0), (d.fillStyle = "solid"));
    let p = [
        { x: -l / 2 + u, y: -o / 2 },
        { x: l / 2 - u, y: -o / 2 },
        ...Ju(-l / 2 + u, 0, u, 50, 90, 270),
        { x: l / 2 - u, y: o / 2 },
        ...Ju(l / 2 - u, 0, u, 50, 270, 450),
      ],
      m = ie(p),
      g = f.path(m, d),
      y = i.insert(() => g, ":first-child");
    return (
      y.attr("class", "basic label-container outer-path"),
      h && t.look !== "handDrawn" && y.selectChildren("path").attr("style", h),
      n && t.look !== "handDrawn" && y.selectChildren("path").attr("style", n),
      Ct(t, y),
      (t.intersect = function (b) {
        return Tt.polygon(t, p, b);
      }),
      i
    );
  }
  var pW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(dW, "stadium");
  });
  async function mW(e, t) {
    return rh(e, t, { rx: 5, ry: 5, classes: "flowchart-node" });
  }
  var gW = x(() => {
    "use strict";
    P0();
    a(mW, "state");
  });
  function yW(e, t, { config: { themeVariables: r } }) {
    let { labelStyles: n, nodeStyles: i } = St(t);
    t.labelStyle = n;
    let { cssStyles: s } = t,
      { lineColor: o, stateBorder: l, nodeBorder: u } = r,
      h = e
        .insert("g")
        .attr("class", "node default")
        .attr("id", t.domId || t.id),
      f = wt.svg(h),
      d = vt(t, {});
    t.look !== "handDrawn" && ((d.roughness = 0), (d.fillStyle = "solid"));
    let p = f.circle(0, 0, 14, { ...d, stroke: o, strokeWidth: 2 }),
      m = l ?? u,
      g = f.circle(0, 0, 5, {
        ...d,
        fill: m,
        stroke: m,
        strokeWidth: 2,
        fillStyle: "solid",
      }),
      y = h.insert(() => p, ":first-child");
    return (
      y.insert(() => g),
      s && y.selectAll("path").attr("style", s),
      i && y.selectAll("path").attr("style", i),
      Ct(t, y),
      (t.intersect = function (b) {
        return Tt.circle(t, 7, b);
      }),
      h
    );
  }
  var xW = x(() => {
    "use strict";
    oe();
    ae();
    re();
    Qt();
    a(yW, "stateEnd");
  });
  function bW(e, t, { config: { themeVariables: r } }) {
    let { lineColor: n } = r,
      i = e
        .insert("g")
        .attr("class", "node default")
        .attr("id", t.domId || t.id),
      s;
    if (t.look === "handDrawn") {
      let l = wt.svg(i).circle(0, 0, 14, wV(n));
      ((s = i.insert(() => l)),
        s
          .attr("class", "state-start")
          .attr("r", 7)
          .attr("width", 14)
          .attr("height", 14));
    } else
      ((s = i.insert("circle", ":first-child")),
        s
          .attr("class", "state-start")
          .attr("r", 7)
          .attr("width", 14)
          .attr("height", 14));
    return (
      Ct(t, s),
      (t.intersect = function (o) {
        return Tt.circle(t, 7, o);
      }),
      i
    );
  }
  var kW = x(() => {
    "use strict";
    oe();
    ae();
    re();
    Qt();
    a(bW, "stateStart");
  });
  async function TW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = (t?.padding || 0) / 2,
      l = s.width + t.padding,
      u = s.height + t.padding,
      h = -s.width / 2 - o,
      f = -s.height / 2 - o,
      d = [
        { x: 0, y: 0 },
        { x: l, y: 0 },
        { x: l, y: -u },
        { x: 0, y: -u },
        { x: 0, y: 0 },
        { x: -8, y: 0 },
        { x: l + 8, y: 0 },
        { x: l + 8, y: -u },
        { x: -8, y: -u },
        { x: -8, y: 0 },
      ];
    if (t.look === "handDrawn") {
      let p = wt.svg(i),
        m = vt(t, {}),
        g = p.rectangle(h - 8, f, l + 16, u, m),
        y = p.line(h, f, h, f + u, m),
        b = p.line(h + l, f, h + l, f + u, m);
      (i.insert(() => y, ":first-child"), i.insert(() => b, ":first-child"));
      let k = i.insert(() => g, ":first-child"),
        { cssStyles: T } = t;
      (k.attr("class", "basic label-container").attr("style", Ir(T)), Ct(t, k));
    } else {
      let p = cs(i, l, u, d);
      (n && p.attr("style", n), Ct(t, p));
    }
    return (
      (t.intersect = function (p) {
        return Tt.polygon(t, d, p);
      }),
      i
    );
  }
  var SW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    Ac();
    _e();
    a(TW, "subroutine");
  });
  async function _W(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      l = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      u = -o / 2,
      h = -l / 2,
      f = 0.2 * l,
      d = 0.2 * l,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = vt(t, {}),
      y = [
        { x: u - f / 2, y: h },
        { x: u + o + f / 2, y: h },
        { x: u + o + f / 2, y: h + l },
        { x: u - f / 2, y: h + l },
      ],
      b = [
        { x: u + o - f / 2, y: h + l },
        { x: u + o + f / 2, y: h + l },
        { x: u + o + f / 2, y: h + l - d },
      ];
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let k = ie(y),
      T = m.path(k, g),
      C = ie(b),
      L = m.path(C, { ...g, fillStyle: "solid" }),
      w = i.insert(() => L, ":first-child");
    return (
      w.insert(() => T, ":first-child"),
      w.attr("class", "basic label-container"),
      p && t.look !== "handDrawn" && w.selectAll("path").attr("style", p),
      n && t.look !== "handDrawn" && w.selectAll("path").attr("style", n),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, y, D);
      }),
      i
    );
  }
  var CW = x(() => {
    "use strict";
    Qt();
    re();
    oe();
    ae();
    a(_W, "taggedRect");
  });
  async function wW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 4,
      f = 0.2 * l,
      d = 0.2 * u,
      p = u + h,
      { cssStyles: m } = t,
      g = wt.svg(i),
      y = vt(t, {});
    t.look !== "handDrawn" && ((y.roughness = 0), (y.fillStyle = "solid"));
    let b = [
        { x: -l / 2 - (l / 2) * 0.1, y: p / 2 },
        ...ra(
          -l / 2 - (l / 2) * 0.1,
          p / 2,
          l / 2 + (l / 2) * 0.1,
          p / 2,
          h,
          0.8,
        ),
        { x: l / 2 + (l / 2) * 0.1, y: -p / 2 },
        { x: -l / 2 - (l / 2) * 0.1, y: -p / 2 },
      ],
      k = -l / 2 + (l / 2) * 0.1,
      T = -p / 2 - d * 0.4,
      C = [
        { x: k + l - f, y: (T + u) * 1.4 },
        { x: k + l, y: T + u - d },
        { x: k + l, y: (T + u) * 0.9 },
        ...ra(k + l, (T + u) * 1.3, k + l - f, (T + u) * 1.5, -u * 0.03, 0.5),
      ],
      L = ie(b),
      w = g.path(L, y),
      D = ie(C),
      G = g.path(D, { ...y, fillStyle: "solid" }),
      E = i.insert(() => G, ":first-child");
    return (
      E.insert(() => w, ":first-child"),
      E.attr("class", "basic label-container"),
      m && t.look !== "handDrawn" && E.selectAll("path").attr("style", m),
      n && t.look !== "handDrawn" && E.selectAll("path").attr("style", n),
      E.attr("transform", `translate(0,${-h / 2})`),
      o.attr(
        "transform",
        `translate(${-l / 2 + (t.padding ?? 0) - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) - h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, E),
      (t.intersect = function (R) {
        return Tt.polygon(t, b, R);
      }),
      i
    );
  }
  var vW = x(() => {
    "use strict";
    Qt();
    ae();
    oe();
    re();
    a(wW, "taggedWaveEdgedRectangle");
  });
  async function EW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = Math.max(s.width + t.padding, t?.width || 0),
      l = Math.max(s.height + t.padding, t?.height || 0),
      u = -o / 2,
      h = -l / 2,
      f = i.insert("rect", ":first-child");
    return (
      f
        .attr("class", "text")
        .attr("style", n)
        .attr("rx", 0)
        .attr("ry", 0)
        .attr("x", u)
        .attr("y", h)
        .attr("width", o)
        .attr("height", l),
      Ct(t, f),
      (t.intersect = function (d) {
        return Tt.rect(t, d);
      }),
      i
    );
  }
  var AW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    a(EW, "text");
  });
  async function LW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let {
        shapeSvg: i,
        bbox: s,
        label: o,
        halfPadding: l,
      } = await Bt(e, t, Ot(t)),
      u = t.look === "neo" ? l * 2 : l,
      h = s.height + u,
      f = h / 2,
      d = f / (2.5 + h / 50),
      p = s.width + d + u,
      { cssStyles: m } = t,
      g;
    if (t.look === "handDrawn") {
      let y = wt.svg(i),
        b = Gbt(0, 0, p, h, d, f),
        k = Vbt(0, 0, p, h, d, f),
        T = y.path(b, vt(t, {})),
        C = y.path(k, vt(t, { fill: "none" }));
      ((g = i.insert(() => C, ":first-child")),
        (g = i.insert(() => T, ":first-child")),
        g.attr("class", "basic label-container"),
        m && g.attr("style", m));
    } else {
      let y = $bt(0, 0, p, h, d, f);
      ((g = i
        .insert("path", ":first-child")
        .attr("d", y)
        .attr("class", "basic label-container")
        .attr("style", Ir(m))
        .attr("style", n)),
        g.attr("class", "basic label-container"),
        m && g.selectAll("path").attr("style", m),
        n && g.selectAll("path").attr("style", n));
    }
    return (
      g.attr("label-offset-x", d),
      g.attr("transform", `translate(${-p / 2}, ${h / 2} )`),
      o.attr(
        "transform",
        `translate(${-(s.width / 2) - d - (s.x - (s.left ?? 0))}, ${-(s.height / 2) - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, g),
      (t.intersect = function (y) {
        let b = Tt.rect(t, y),
          k = b.y - (t.y ?? 0);
        if (
          f != 0 &&
          (Math.abs(k) < (t.height ?? 0) / 2 ||
            (Math.abs(k) == (t.height ?? 0) / 2 &&
              Math.abs(b.x - (t.x ?? 0)) > (t.width ?? 0) / 2 - d))
        ) {
          let T = d * d * (1 - (k * k) / (f * f));
          (T != 0 && (T = Math.sqrt(Math.abs(T))),
            (T = d - T),
            y.x - (t.x ?? 0) > 0 && (T = -T),
            (b.x += T));
        }
        return b;
      }),
      i
    );
  }
  var $bt,
    Gbt,
    Vbt,
    RW = x(() => {
      "use strict";
      Qt();
      re();
      oe();
      ae();
      _e();
      (($bt = a(
        (e, t, r, n, i, s) => `M${e},${t}
    a${i},${s} 0,0,1 0,${-n}
    l${r},0
    a${i},${s} 0,0,1 0,${n}
    M${r},${-n}
    a${i},${s} 0,0,0 0,${n}
    l${-r},0`,
        "createCylinderPathD",
      )),
        (Gbt = a(
          (e, t, r, n, i, s) =>
            [
              `M${e},${t}`,
              `M${e + r},${t}`,
              `a${i},${s} 0,0,0 0,${-n}`,
              `l${-r},0`,
              `a${i},${s} 0,0,0 0,${n}`,
              `l${r},0`,
            ].join(" "),
          "createOuterCylinderPathD",
        )),
        (Vbt = a(
          (e, t, r, n, i, s) =>
            [`M${e + r / 2},${-n / 2}`, `a${i},${s} 0,0,0 0,${n}`].join(" "),
          "createInnerCylinderPathD",
        )));
      a(LW, "tiltedCylinder");
    });
  async function DW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = s.width + t.padding,
      l = s.height + t.padding,
      u = [
        { x: (-3 * l) / 6, y: 0 },
        { x: o + (3 * l) / 6, y: 0 },
        { x: o, y: -l },
        { x: 0, y: -l },
      ],
      h,
      { cssStyles: f } = t;
    if (t.look === "handDrawn") {
      let d = wt.svg(i),
        p = vt(t, {}),
        m = ie(u),
        g = d.path(m, p);
      ((h = i
        .insert(() => g, ":first-child")
        .attr("transform", `translate(${-o / 2}, ${l / 2})`)),
        f && h.attr("style", f));
    } else h = cs(i, o, l, u);
    return (
      n && h.attr("style", n),
      (t.width = o),
      (t.height = l),
      Ct(t, h),
      (t.intersect = function (d) {
        return Tt.polygon(t, u, d);
      }),
      i
    );
  }
  var NW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    Ac();
    a(DW, "trapezoid");
  });
  async function IW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = 60,
      l = 20,
      u = Math.max(o, s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(l, s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      { cssStyles: f } = t,
      d = wt.svg(i),
      p = vt(t, {});
    t.look !== "handDrawn" && ((p.roughness = 0), (p.fillStyle = "solid"));
    let m = [
        { x: (-u / 2) * 0.8, y: -h / 2 },
        { x: (u / 2) * 0.8, y: -h / 2 },
        { x: u / 2, y: (-h / 2) * 0.6 },
        { x: u / 2, y: h / 2 },
        { x: -u / 2, y: h / 2 },
        { x: -u / 2, y: (-h / 2) * 0.6 },
      ],
      g = ie(m),
      y = d.path(g, p),
      b = i.insert(() => y, ":first-child");
    return (
      b.attr("class", "basic label-container"),
      f && t.look !== "handDrawn" && b.selectChildren("path").attr("style", f),
      n && t.look !== "handDrawn" && b.selectChildren("path").attr("style", n),
      Ct(t, b),
      (t.intersect = function (k) {
        return Tt.polygon(t, m, k);
      }),
      i
    );
  }
  var MW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a(IW, "trapezoidalPentagon");
  });
  async function OW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Pe(K().flowchart?.htmlLabels),
      u = s.width + (t.padding ?? 0),
      h = u + s.height,
      f = u + s.height,
      d = [
        { x: 0, y: 0 },
        { x: f, y: 0 },
        { x: f / 2, y: -h },
      ],
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = vt(t, {});
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let y = ie(d),
      b = m.path(y, g),
      k = i
        .insert(() => b, ":first-child")
        .attr("transform", `translate(${-h / 2}, ${h / 2})`);
    return (
      p && t.look !== "handDrawn" && k.selectChildren("path").attr("style", p),
      n && t.look !== "handDrawn" && k.selectChildren("path").attr("style", n),
      (t.width = u),
      (t.height = h),
      Ct(t, k),
      o.attr(
        "transform",
        `translate(${-s.width / 2 - (s.x - (s.left ?? 0))}, ${h / 2 - (s.height + (t.padding ?? 0) / (l ? 2 : 1) - (s.y - (s.top ?? 0)))})`,
      ),
      (t.intersect = function (T) {
        return (P.info("Triangle intersect", t, d, T), Tt.polygon(t, d, T));
      }),
      i
    );
  }
  var PW = x(() => {
    "use strict";
    Vt();
    Qt();
    ae();
    re();
    oe();
    Qt();
    Be();
    pe();
    a(OW, "triangle");
  });
  async function BW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = u / 8,
      f = u + h,
      { cssStyles: d } = t,
      m = 70 - l,
      g = m > 0 ? m / 2 : 0,
      y = wt.svg(i),
      b = vt(t, {});
    t.look !== "handDrawn" && ((b.roughness = 0), (b.fillStyle = "solid"));
    let k = [
        { x: -l / 2 - g, y: f / 2 },
        ...ra(-l / 2 - g, f / 2, l / 2 + g, f / 2, h, 0.8),
        { x: l / 2 + g, y: -f / 2 },
        { x: -l / 2 - g, y: -f / 2 },
      ],
      T = ie(k),
      C = y.path(T, b),
      L = i.insert(() => C, ":first-child");
    return (
      L.attr("class", "basic label-container"),
      d && t.look !== "handDrawn" && L.selectAll("path").attr("style", d),
      n && t.look !== "handDrawn" && L.selectAll("path").attr("style", n),
      L.attr("transform", `translate(0,${-h / 2})`),
      o.attr(
        "transform",
        `translate(${-l / 2 + (t.padding ?? 0) - (s.x - (s.left ?? 0))},${-u / 2 + (t.padding ?? 0) - h - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, L),
      (t.intersect = function (w) {
        return Tt.polygon(t, k, w);
      }),
      i
    );
  }
  var FW = x(() => {
    "use strict";
    Qt();
    ae();
    oe();
    re();
    a(BW, "waveEdgedRectangle");
  });
  async function $W(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s } = await Bt(e, t, Ot(t)),
      o = 100,
      l = 50,
      u = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      h = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      f = u / h,
      d = u,
      p = h;
    (d > p * f ? (p = d / f) : (d = p * f),
      (d = Math.max(d, o)),
      (p = Math.max(p, l)));
    let m = Math.min(p * 0.2, p / 4),
      g = p + m * 2,
      { cssStyles: y } = t,
      b = wt.svg(i),
      k = vt(t, {});
    t.look !== "handDrawn" && ((k.roughness = 0), (k.fillStyle = "solid"));
    let T = [
        { x: -d / 2, y: g / 2 },
        ...ra(-d / 2, g / 2, d / 2, g / 2, m, 1),
        { x: d / 2, y: -g / 2 },
        ...ra(d / 2, -g / 2, -d / 2, -g / 2, m, -1),
      ],
      C = ie(T),
      L = b.path(C, k),
      w = i.insert(() => L, ":first-child");
    return (
      w.attr("class", "basic label-container"),
      y && t.look !== "handDrawn" && w.selectAll("path").attr("style", y),
      n && t.look !== "handDrawn" && w.selectAll("path").attr("style", n),
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.polygon(t, T, D);
      }),
      i
    );
  }
  var GW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    a($W, "waveRectangle");
  });
  async function VW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let { shapeSvg: i, bbox: s, label: o } = await Bt(e, t, Ot(t)),
      l = Math.max(s.width + (t.padding ?? 0) * 2, t?.width ?? 0),
      u = Math.max(s.height + (t.padding ?? 0) * 2, t?.height ?? 0),
      h = 5,
      f = -l / 2,
      d = -u / 2,
      { cssStyles: p } = t,
      m = wt.svg(i),
      g = vt(t, {}),
      y = [
        { x: f - h, y: d - h },
        { x: f - h, y: d + u },
        { x: f + l, y: d + u },
        { x: f + l, y: d - h },
      ],
      b = `M${f - h},${d - h} L${f + l},${d - h} L${f + l},${d + u} L${f - h},${d + u} L${f - h},${d - h}
                M${f - h},${d} L${f + l},${d}
                M${f},${d - h} L${f},${d + u}`;
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let k = m.path(b, g),
      T = i.insert(() => k, ":first-child");
    return (
      T.attr("transform", `translate(${h / 2}, ${h / 2})`),
      T.attr("class", "basic label-container"),
      p && t.look !== "handDrawn" && T.selectAll("path").attr("style", p),
      n && t.look !== "handDrawn" && T.selectAll("path").attr("style", n),
      o.attr(
        "transform",
        `translate(${-(s.width / 2) + h / 2 - (s.x - (s.left ?? 0))}, ${-(s.height / 2) + h / 2 - (s.y - (s.top ?? 0))})`,
      ),
      Ct(t, T),
      (t.intersect = function (C) {
        return Tt.polygon(t, y, C);
      }),
      i
    );
  }
  var zW = x(() => {
    "use strict";
    Qt();
    re();
    oe();
    ae();
    a(VW, "windowPane");
  });
  async function DA(e, t) {
    let r = t;
    if ((r.alias && (t.label = r.alias), t.look === "handDrawn")) {
      let { themeVariables: q } = ke(),
        { background: tt } = q,
        ht = {
          ...t,
          id: t.id + "-background",
          look: "default",
          cssStyles: ["stroke: none", `fill: ${tt}`],
        };
      await DA(e, ht);
    }
    let n = ke();
    t.useHtmlLabels = n.htmlLabels;
    let i = n.er?.diagramPadding ?? 10,
      s = n.er?.entityPadding ?? 6,
      { cssStyles: o } = t,
      { labelStyles: l, nodeStyles: u } = St(t);
    if (r.attributes.length === 0 && t.label) {
      let q = {
        rx: 0,
        ry: 0,
        labelPaddingX: i,
        labelPaddingY: i * 1.5,
        classes: "",
      };
      Yn(t.label, n) + q.labelPaddingX * 2 < n.er.minEntityWidth &&
        (t.width = n.er.minEntityWidth);
      let tt = await rh(e, t, q);
      if (!Pe(n.htmlLabels)) {
        let ht = tt.select("text"),
          H = ht.node()?.getBBox();
        ht.attr("transform", `translate(${-H.width / 2}, 0)`);
      }
      return tt;
    }
    n.htmlLabels || ((i *= 1.25), (s *= 1.25));
    let h = Ot(t);
    h || (h = "node default");
    let f = e
        .insert("g")
        .attr("class", h)
        .attr("id", t.domId || t.id),
      d = await B0(f, t.label ?? "", n, 0, 0, ["name"], l);
    d.height += s;
    let p = 0,
      m = [],
      g = [],
      y = 0,
      b = 0,
      k = 0,
      T = 0,
      C = !0,
      L = !0;
    for (let q of r.attributes) {
      let tt = await B0(f, q.type, n, 0, p, ["attribute-type"], l);
      y = Math.max(y, tt.width + i);
      let ht = await B0(f, q.name, n, 0, p, ["attribute-name"], l);
      b = Math.max(b, ht.width + i);
      let H = await B0(f, q.keys.join(), n, 0, p, ["attribute-keys"], l);
      k = Math.max(k, H.width + i);
      let kt = await B0(f, q.comment, n, 0, p, ["attribute-comment"], l);
      T = Math.max(T, kt.width + i);
      let ft = Math.max(tt.height, ht.height, H.height, kt.height) + s;
      (g.push({ yOffset: p, rowHeight: ft }), (p += ft));
    }
    let w = 4;
    (k <= i && ((C = !1), (k = 0), w--), T <= i && ((L = !1), (T = 0), w--));
    let D = f.node().getBBox();
    if (d.width + i * 2 - (y + b + k + T) > 0) {
      let q = d.width + i * 2 - (y + b + k + T);
      ((y += q / w),
        (b += q / w),
        k > 0 && (k += q / w),
        T > 0 && (T += q / w));
    }
    let G = y + b + k + T,
      E = wt.svg(f),
      R = vt(t, {});
    t.look !== "handDrawn" && ((R.roughness = 0), (R.fillStyle = "solid"));
    let F = 0;
    g.length > 0 && (F = g.reduce((q, tt) => q + (tt?.rowHeight ?? 0), 0));
    let S = Math.max(D.width + i * 2, t?.width || 0, G),
      O = Math.max((F ?? 0) + d.height, t?.height || 0),
      v = -S / 2,
      _ = -O / 2;
    (f.selectAll("g:not(:first-child)").each((q, tt, ht) => {
      let H = xt(ht[tt]),
        kt = H.attr("transform"),
        ft = 0,
        yt = 0;
      if (kt) {
        let dt = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(kt);
        dt &&
          ((ft = parseFloat(dt[1])),
          (yt = parseFloat(dt[2])),
          H.attr("class").includes("attribute-name")
            ? (ft += y)
            : H.attr("class").includes("attribute-keys")
              ? (ft += y + b)
              : H.attr("class").includes("attribute-comment") &&
                (ft += y + b + k));
      }
      H.attr(
        "transform",
        `translate(${v + i / 2 + ft}, ${yt + _ + d.height + s / 2})`,
      );
    }),
      f
        .select(".name")
        .attr(
          "transform",
          "translate(" + -d.width / 2 + ", " + (_ + s / 2) + ")",
        ));
    let A = E.rectangle(v, _, S, O, R),
      N = f.insert(() => A, ":first-child").attr("style", o.join("")),
      { themeVariables: B } = ke(),
      { rowEven: M, rowOdd: I, nodeBorder: V } = B;
    m.push(0);
    for (let [q, tt] of g.entries()) {
      let H = (q + 1) % 2 === 0 && tt.yOffset !== 0,
        kt = E.rectangle(v, d.height + _ + tt?.yOffset, S, tt?.rowHeight, {
          ...R,
          fill: H ? M : I,
          stroke: V,
        });
      f.insert(() => kt, "g.label")
        .attr("style", o.join(""))
        .attr("class", `row-rect-${H ? "even" : "odd"}`);
    }
    let $ = E.line(v, d.height + _, S + v, d.height + _, R);
    (f.insert(() => $).attr("class", "divider"),
      ($ = E.line(y + v, d.height + _, y + v, O + _, R)),
      f.insert(() => $).attr("class", "divider"),
      C &&
        (($ = E.line(y + b + v, d.height + _, y + b + v, O + _, R)),
        f.insert(() => $).attr("class", "divider")),
      L &&
        (($ = E.line(y + b + k + v, d.height + _, y + b + k + v, O + _, R)),
        f.insert(() => $).attr("class", "divider")));
    for (let q of m)
      (($ = E.line(v, d.height + _ + q, S + v, d.height + _ + q, R)),
        f.insert(() => $).attr("class", "divider"));
    if ((Ct(t, N), u && t.look !== "handDrawn")) {
      let tt = u
        .split(";")
        ?.filter((ht) => ht.includes("stroke"))
        ?.map((ht) => `${ht}`)
        .join("; ");
      (f.selectAll("path").attr("style", tt ?? ""),
        f.selectAll(".row-rect-even path").attr("style", u));
    }
    return (
      (t.intersect = function (q) {
        return Tt.rect(t, q);
      }),
      f
    );
  }
  async function B0(e, t, r, n = 0, i = 0, s = [], o = "") {
    let l = e
      .insert("g")
      .attr("class", `label ${s.join(" ")}`)
      .attr("transform", `translate(${n}, ${i})`)
      .attr("style", o);
    t !== ro(t) &&
      ((t = ro(t)), (t = t.replaceAll("<", "&lt;").replaceAll(">", "&gt;")));
    let u = l
      .node()
      .appendChild(
        await Kn(
          l,
          t,
          { width: Yn(t, r) + 100, style: o, useHtmlLabels: r.htmlLabels },
          r,
        ),
      );
    if (t.includes("&lt;") || t.includes("&gt;")) {
      let f = u.children[0];
      for (
        f.textContent = f.textContent
          .replaceAll("&lt;", "<")
          .replaceAll("&gt;", ">");
        f.childNodes[0];

      )
        ((f = f.childNodes[0]),
          (f.textContent = f.textContent
            .replaceAll("&lt;", "<")
            .replaceAll("&gt;", ">")));
    }
    let h = u.getBBox();
    if (Pe(r.htmlLabels)) {
      let f = u.children[0];
      f.style.textAlign = "start";
      let d = xt(u);
      ((h = f.getBoundingClientRect()),
        d.attr("width", h.width),
        d.attr("height", h.height));
    }
    return h;
  }
  var WW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    P0();
    un();
    Ga();
    Be();
    Ge();
    _e();
    a(DA, "erBox");
    a(B0, "addText");
  });
  async function UW(e, t, r, n, i = r.class.padding ?? 12) {
    let s = n ? 0 : 3,
      o = e
        .insert("g")
        .attr("class", Ot(t))
        .attr("id", t.domId || t.id),
      l = null,
      u = null,
      h = null,
      f = null,
      d = 0,
      p = 0,
      m = 0;
    if (
      ((l = o.insert("g").attr("class", "annotation-group text")),
      t.annotations.length > 0)
    ) {
      let T = t.annotations[0];
      (await qb(l, { text: `\xAB${T}\xBB` }, 0),
        (d = l.node().getBBox().height));
    }
    ((u = o.insert("g").attr("class", "label-group text")),
      await qb(u, t, 0, ["font-weight: bolder"]));
    let g = u.node().getBBox();
    ((p = g.height), (h = o.insert("g").attr("class", "members-group text")));
    let y = 0;
    for (let T of t.members) {
      let C = await qb(h, T, y, [T.parseClassifier()]);
      y += C + s;
    }
    ((m = h.node().getBBox().height),
      m <= 0 && (m = i / 2),
      (f = o.insert("g").attr("class", "methods-group text")));
    let b = 0;
    for (let T of t.methods) {
      let C = await qb(f, T, b, [T.parseClassifier()]);
      b += C + s;
    }
    let k = o.node().getBBox();
    if (l !== null) {
      let T = l.node().getBBox();
      l.attr("transform", `translate(${-T.width / 2})`);
    }
    return (
      u.attr("transform", `translate(${-g.width / 2}, ${d})`),
      (k = o.node().getBBox()),
      h.attr("transform", `translate(0, ${d + p + i * 2})`),
      (k = o.node().getBBox()),
      f.attr("transform", `translate(0, ${d + p + (m ? m + i * 4 : i * 2)})`),
      (k = o.node().getBBox()),
      { shapeSvg: o, bbox: k }
    );
  }
  async function qb(e, t, r, n = []) {
    let i = e.insert("g").attr("class", "label").attr("style", n.join("; ")),
      s = ke(),
      o = "useHtmlLabels" in t ? t.useHtmlLabels : (Pe(s.htmlLabels) ?? !0),
      l = "";
    ("text" in t ? (l = t.text) : (l = t.label),
      !o && l.startsWith("\\") && (l = l.substring(1)),
      $r(l) && (o = !0));
    let u = await Kn(
        i,
        lg(Xn(l)),
        {
          width: Yn(l, s) + 50,
          classes: "markdown-node-label",
          useHtmlLabels: o,
        },
        s,
      ),
      h,
      f = 1;
    if (o) {
      let d = u.children[0],
        p = xt(u);
      ((f = d.innerHTML.split("<br>").length),
        d.innerHTML.includes("</math>") &&
          (f += d.innerHTML.split("<mrow>").length - 1));
      let m = d.getElementsByTagName("img");
      if (m) {
        let g = l.replace(/<img[^>]*>/g, "").trim() === "";
        await Promise.all(
          [...m].map(
            (y) =>
              new Promise((b) => {
                function k() {
                  if (
                    ((y.style.display = "flex"),
                    (y.style.flexDirection = "column"),
                    g)
                  ) {
                    let T =
                        s.fontSize?.toString() ??
                        window.getComputedStyle(document.body).fontSize,
                      L = parseInt(T, 10) * 5 + "px";
                    ((y.style.minWidth = L), (y.style.maxWidth = L));
                  } else y.style.width = "100%";
                  b(y);
                }
                (a(k, "setupImage"),
                  setTimeout(() => {
                    y.complete && k();
                  }),
                  y.addEventListener("error", k),
                  y.addEventListener("load", k));
              }),
          ),
        );
      }
      ((h = d.getBoundingClientRect()),
        p.attr("width", h.width),
        p.attr("height", h.height));
    } else {
      (n.includes("font-weight: bolder") &&
        xt(u).selectAll("tspan").attr("font-weight", ""),
        (f = u.children.length));
      let d = u.children[0];
      ((u.textContent === "" || u.textContent.includes("&gt")) &&
        ((d.textContent =
          l[0] +
          l
            .substring(1)
            .replaceAll("&gt;", ">")
            .replaceAll("&lt;", "<")
            .trim()),
        l[1] === " " &&
          (d.textContent =
            d.textContent[0] + " " + d.textContent.substring(1))),
        d.textContent === "undefined" && (d.textContent = ""),
        (h = u.getBBox()));
    }
    return (
      i.attr("transform", "translate(0," + (-h.height / (2 * f) + r) + ")"),
      h.height
    );
  }
  var jW = x(() => {
    "use strict";
    Ge();
    un();
    Qt();
    _e();
    pe();
    Ga();
    Be();
    a(UW, "textHelper");
    a(qb, "addText");
  });
  async function qW(e, t) {
    let r = K(),
      n = r.class.padding ?? 12,
      i = n,
      s = t.useHtmlLabels ?? Pe(r.htmlLabels) ?? !0,
      o = t;
    ((o.annotations = o.annotations ?? []),
      (o.members = o.members ?? []),
      (o.methods = o.methods ?? []));
    let { shapeSvg: l, bbox: u } = await UW(e, t, r, s, i),
      { labelStyles: h, nodeStyles: f } = St(t);
    ((t.labelStyle = h), (t.cssStyles = o.styles || ""));
    let d = o.styles?.join(";") || f || "";
    t.cssStyles || (t.cssStyles = d.replaceAll("!important", "").split(";"));
    let p =
        o.members.length === 0 &&
        o.methods.length === 0 &&
        !r.class?.hideEmptyMembersBox,
      m = wt.svg(l),
      g = vt(t, {});
    t.look !== "handDrawn" && ((g.roughness = 0), (g.fillStyle = "solid"));
    let y = u.width,
      b = u.height;
    o.members.length === 0 && o.methods.length === 0
      ? (b += i)
      : o.members.length > 0 && o.methods.length === 0 && (b += i * 2);
    let k = -y / 2,
      T = -b / 2,
      C = m.rectangle(
        k - n,
        T -
          n -
          (p
            ? n
            : o.members.length === 0 && o.methods.length === 0
              ? -n / 2
              : 0),
        y + 2 * n,
        b +
          2 * n +
          (p
            ? n * 2
            : o.members.length === 0 && o.methods.length === 0
              ? -n
              : 0),
        g,
      ),
      L = l.insert(() => C, ":first-child");
    L.attr("class", "basic label-container");
    let w = L.node().getBBox();
    l.selectAll(".text").each((R, F, S) => {
      let O = xt(S[F]),
        v = O.attr("transform"),
        _ = 0;
      if (v) {
        let M = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(v);
        M && (_ = parseFloat(M[2]));
      }
      let A =
        _ +
        T +
        n -
        (p ? n : o.members.length === 0 && o.methods.length === 0 ? -n / 2 : 0);
      s || (A -= 4);
      let N = k;
      ((O.attr("class").includes("label-group") ||
        O.attr("class").includes("annotation-group")) &&
        ((N = -O.node()?.getBBox().width / 2 || 0),
        l.selectAll("text").each(function (B, M, I) {
          window.getComputedStyle(I[M]).textAnchor === "middle" && (N = 0);
        })),
        O.attr("transform", `translate(${N}, ${A})`));
    });
    let D =
        l.select(".annotation-group").node().getBBox().height -
          (p ? n / 2 : 0) || 0,
      G =
        l.select(".label-group").node().getBBox().height - (p ? n / 2 : 0) || 0,
      E =
        l.select(".members-group").node().getBBox().height - (p ? n / 2 : 0) ||
        0;
    if (o.members.length > 0 || o.methods.length > 0 || p) {
      let R = m.line(w.x, D + G + T + n, w.x + w.width, D + G + T + n, g);
      l.insert(() => R)
        .attr("class", "divider")
        .attr("style", d);
    }
    if (p || o.members.length > 0 || o.methods.length > 0) {
      let R = m.line(
        w.x,
        D + G + E + T + i * 2 + n,
        w.x + w.width,
        D + G + E + T + n + i * 2,
        g,
      );
      l.insert(() => R)
        .attr("class", "divider")
        .attr("style", d);
    }
    if (
      (o.look !== "handDrawn" && l.selectAll("path").attr("style", d),
      L.select(":nth-child(2)").attr("style", d),
      l.selectAll(".divider").select("path").attr("style", d),
      t.labelStyle
        ? l.selectAll("span").attr("style", t.labelStyle)
        : l.selectAll("span").attr("style", d),
      !s)
    ) {
      let R = RegExp(/color\s*:\s*([^;]*)/),
        F = R.exec(d);
      if (F) {
        let S = F[0].replace("color", "fill");
        l.selectAll("tspan").attr("style", S);
      } else if (h) {
        let S = R.exec(h);
        if (S) {
          let O = S[0].replace("color", "fill");
          l.selectAll("tspan").attr("style", O);
        }
      }
    }
    return (
      Ct(t, L),
      (t.intersect = function (R) {
        return Tt.rect(t, R);
      }),
      l
    );
  }
  var HW = x(() => {
    "use strict";
    Qt();
    pe();
    Ge();
    oe();
    re();
    ae();
    jW();
    Be();
    a(qW, "classBox");
  });
  async function YW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let i = t,
      s = t,
      o = 20,
      l = 20,
      u = "verifyMethod" in t,
      h = Ot(t),
      f = e
        .insert("g")
        .attr("class", h)
        .attr("id", t.domId ?? t.id),
      d;
    u
      ? (d = await kl(f, `&lt;&lt;${i.type}&gt;&gt;`, 0, t.labelStyle))
      : (d = await kl(f, "&lt;&lt;Element&gt;&gt;", 0, t.labelStyle));
    let p = d,
      m = await kl(f, i.name, p, t.labelStyle + "; font-weight: bold;");
    if (((p += m + l), u)) {
      let D = await kl(
        f,
        `${i.requirementId ? `ID: ${i.requirementId}` : ""}`,
        p,
        t.labelStyle,
      );
      p += D;
      let G = await kl(
        f,
        `${i.text ? `Text: ${i.text}` : ""}`,
        p,
        t.labelStyle,
      );
      p += G;
      let E = await kl(
        f,
        `${i.risk ? `Risk: ${i.risk}` : ""}`,
        p,
        t.labelStyle,
      );
      ((p += E),
        await kl(
          f,
          `${i.verifyMethod ? `Verification: ${i.verifyMethod}` : ""}`,
          p,
          t.labelStyle,
        ));
    } else {
      let D = await kl(
        f,
        `${s.type ? `Type: ${s.type}` : ""}`,
        p,
        t.labelStyle,
      );
      ((p += D),
        await kl(
          f,
          `${s.docRef ? `Doc Ref: ${s.docRef}` : ""}`,
          p,
          t.labelStyle,
        ));
    }
    let g = (f.node()?.getBBox().width ?? 200) + o,
      y = (f.node()?.getBBox().height ?? 200) + o,
      b = -g / 2,
      k = -y / 2,
      T = wt.svg(f),
      C = vt(t, {});
    t.look !== "handDrawn" && ((C.roughness = 0), (C.fillStyle = "solid"));
    let L = T.rectangle(b, k, g, y, C),
      w = f.insert(() => L, ":first-child");
    if (
      (w.attr("class", "basic label-container").attr("style", n),
      f.selectAll(".label").each((D, G, E) => {
        let R = xt(E[G]),
          F = R.attr("transform"),
          S = 0,
          O = 0;
        if (F) {
          let N = RegExp(/translate\(([^,]+),([^)]+)\)/).exec(F);
          N && ((S = parseFloat(N[1])), (O = parseFloat(N[2])));
        }
        let v = O - y / 2,
          _ = b + o / 2;
        ((G === 0 || G === 1) && (_ = S),
          R.attr("transform", `translate(${_}, ${v + o})`));
      }),
      p > d + m + l)
    ) {
      let D = T.line(b, k + d + m + l, b + g, k + d + m + l, C);
      f.insert(() => D).attr("style", n);
    }
    return (
      Ct(t, w),
      (t.intersect = function (D) {
        return Tt.rect(t, D);
      }),
      f
    );
  }
  async function kl(e, t, r, n = "") {
    if (t === "") return 0;
    let i = e.insert("g").attr("class", "label").attr("style", n),
      s = K(),
      o = s.htmlLabels ?? !0,
      l = await Kn(
        i,
        lg(Xn(t)),
        {
          width: Yn(t, s) + 50,
          classes: "markdown-node-label",
          useHtmlLabels: o,
          style: n,
        },
        s,
      ),
      u;
    if (o) {
      let h = l.children[0],
        f = xt(l);
      ((u = h.getBoundingClientRect()),
        f.attr("width", u.width),
        f.attr("height", u.height));
    } else {
      let h = l.children[0];
      for (let f of h.children)
        ((f.textContent = f.textContent
          .replaceAll("&gt;", ">")
          .replaceAll("&lt;", "<")),
          n && f.setAttribute("style", n));
      ((u = l.getBBox()), (u.height += 6));
    }
    return (
      i.attr("transform", `translate(${-u.width / 2},${-u.height / 2 + r})`),
      u.height
    );
  }
  var XW = x(() => {
    "use strict";
    Qt();
    ae();
    re();
    oe();
    _e();
    pe();
    Ga();
    Ge();
    a(YW, "requirementBox");
    a(kl, "addText");
  });
  async function KW(e, t, { config: r }) {
    let { labelStyles: n, nodeStyles: i } = St(t);
    t.labelStyle = n || "";
    let s = 10,
      o = t.width;
    t.width = (t.width ?? 200) - 10;
    let { shapeSvg: l, bbox: u, label: h } = await Bt(e, t, Ot(t)),
      f = t.padding || 10,
      d = "",
      p;
    "ticket" in t &&
      t.ticket &&
      r?.kanban?.ticketBaseUrl &&
      ((d = r?.kanban?.ticketBaseUrl.replace("#TICKET#", t.ticket)),
      (p = l
        .insert("svg:a", ":first-child")
        .attr("class", "kanban-ticket-link")
        .attr("xlink:href", d)
        .attr("target", "_blank")));
    let m = {
        useHtmlLabels: t.useHtmlLabels,
        labelStyle: t.labelStyle || "",
        width: t.width,
        img: t.img,
        padding: t.padding || 8,
        centerLabel: !1,
      },
      g,
      y;
    p
      ? ({ label: g, bbox: y } = await Nb(
          p,
          ("ticket" in t && t.ticket) || "",
          m,
        ))
      : ({ label: g, bbox: y } = await Nb(
          l,
          ("ticket" in t && t.ticket) || "",
          m,
        ));
    let { label: b, bbox: k } = await Nb(
      l,
      ("assigned" in t && t.assigned) || "",
      m,
    );
    t.width = o;
    let T = 10,
      C = t?.width || 0,
      L = Math.max(y.height, k.height) / 2,
      w = Math.max(u.height + T * 2, t?.height || 0) + L,
      D = -C / 2,
      G = -w / 2;
    (h.attr(
      "transform",
      "translate(" + (f - C / 2) + ", " + (-L - u.height / 2) + ")",
    ),
      g.attr(
        "transform",
        "translate(" + (f - C / 2) + ", " + (-L + u.height / 2) + ")",
      ),
      b.attr(
        "transform",
        "translate(" +
          (f + C / 2 - k.width - 2 * s) +
          ", " +
          (-L + u.height / 2) +
          ")",
      ));
    let E,
      { rx: R, ry: F } = t,
      { cssStyles: S } = t;
    if (t.look === "handDrawn") {
      let O = wt.svg(l),
        v = vt(t, {}),
        _ =
          R || F
            ? O.path(us(D, G, C, w, R || 0), v)
            : O.rectangle(D, G, C, w, v);
      ((E = l.insert(() => _, ":first-child")),
        E.attr("class", "basic label-container").attr("style", S || null));
    } else {
      ((E = l.insert("rect", ":first-child")),
        E.attr("class", "basic label-container __APA__")
          .attr("style", i)
          .attr("rx", R ?? 5)
          .attr("ry", F ?? 5)
          .attr("x", D)
          .attr("y", G)
          .attr("width", C)
          .attr("height", w));
      let O = "priority" in t && t.priority;
      if (O) {
        let v = l.append("line"),
          _ = D + 2,
          A = G + Math.floor((R ?? 0) / 2),
          N = G + w - Math.floor((R ?? 0) / 2);
        v.attr("x1", _)
          .attr("y1", A)
          .attr("x2", _)
          .attr("y2", N)
          .attr("stroke-width", "4")
          .attr("stroke", zbt(O));
      }
    }
    return (
      Ct(t, E),
      (t.height = w),
      (t.intersect = function (O) {
        return Tt.rect(t, O);
      }),
      l
    );
  }
  var zbt,
    QW = x(() => {
      "use strict";
      Qt();
      ae();
      eh();
      re();
      oe();
      zbt = a((e) => {
        switch (e) {
          case "Very High":
            return "red";
          case "High":
            return "orange";
          case "Medium":
            return null;
          case "Low":
            return "blue";
          case "Very Low":
            return "lightblue";
        }
      }, "colorFromPriority");
      a(KW, "kanbanItem");
    });
  async function ZW(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let {
        shapeSvg: i,
        bbox: s,
        halfPadding: o,
        label: l,
      } = await Bt(e, t, Ot(t)),
      u = s.width + 10 * o,
      h = s.height + 8 * o,
      f = 0.15 * u,
      { cssStyles: d } = t,
      p = s.width + 20,
      m = s.height + 20,
      g = Math.max(u, p),
      y = Math.max(h, m);
    l.attr("transform", `translate(${-s.width / 2}, ${-s.height / 2})`);
    let b,
      k = `M0 0 
    a${f},${f} 1 0,0 ${g * 0.25},${-1 * y * 0.1}
    a${f},${f} 1 0,0 ${g * 0.25},0
    a${f},${f} 1 0,0 ${g * 0.25},0
    a${f},${f} 1 0,0 ${g * 0.25},${y * 0.1}

    a${f},${f} 1 0,0 ${g * 0.15},${y * 0.33}
    a${f * 0.8},${f * 0.8} 1 0,0 0,${y * 0.34}
    a${f},${f} 1 0,0 ${-1 * g * 0.15},${y * 0.33}

    a${f},${f} 1 0,0 ${-1 * g * 0.25},${y * 0.15}
    a${f},${f} 1 0,0 ${-1 * g * 0.25},0
    a${f},${f} 1 0,0 ${-1 * g * 0.25},0
    a${f},${f} 1 0,0 ${-1 * g * 0.25},${-1 * y * 0.15}

    a${f},${f} 1 0,0 ${-1 * g * 0.1},${-1 * y * 0.33}
    a${f * 0.8},${f * 0.8} 1 0,0 0,${-1 * y * 0.34}
    a${f},${f} 1 0,0 ${g * 0.1},${-1 * y * 0.33}
  H0 V0 Z`;
    if (t.look === "handDrawn") {
      let T = wt.svg(i),
        C = vt(t, {}),
        L = T.path(k, C);
      ((b = i.insert(() => L, ":first-child")),
        b.attr("class", "basic label-container").attr("style", Ir(d)));
    } else
      b = i
        .insert("path", ":first-child")
        .attr("class", "basic label-container")
        .attr("style", n)
        .attr("d", k);
    return (
      b.attr("transform", `translate(${-g / 2}, ${-y / 2})`),
      Ct(t, b),
      (t.calcIntersect = function (T, C) {
        return Tt.rect(T, C);
      }),
      (t.intersect = function (T) {
        return (P.info("Bang intersect", t, T), Tt.rect(t, T));
      }),
      i
    );
  }
  var JW = x(() => {
    "use strict";
    Vt();
    Qt();
    ae();
    re();
    oe();
    _e();
    a(ZW, "bang");
  });
  async function tU(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let {
        shapeSvg: i,
        bbox: s,
        halfPadding: o,
        label: l,
      } = await Bt(e, t, Ot(t)),
      u = s.width + 2 * o,
      h = s.height + 2 * o,
      f = 0.15 * u,
      d = 0.25 * u,
      p = 0.35 * u,
      m = 0.2 * u,
      { cssStyles: g } = t,
      y,
      b = `M0 0 
    a${f},${f} 0 0,1 ${u * 0.25},${-1 * u * 0.1}
    a${p},${p} 1 0,1 ${u * 0.4},${-1 * u * 0.1}
    a${d},${d} 1 0,1 ${u * 0.35},${u * 0.2}

    a${f},${f} 1 0,1 ${u * 0.15},${h * 0.35}
    a${m},${m} 1 0,1 ${-1 * u * 0.15},${h * 0.65}

    a${d},${f} 1 0,1 ${-1 * u * 0.25},${u * 0.15}
    a${p},${p} 1 0,1 ${-1 * u * 0.5},0
    a${f},${f} 1 0,1 ${-1 * u * 0.25},${-1 * u * 0.15}

    a${f},${f} 1 0,1 ${-1 * u * 0.1},${-1 * h * 0.35}
    a${m},${m} 1 0,1 ${u * 0.1},${-1 * h * 0.65}
  H0 V0 Z`;
    if (t.look === "handDrawn") {
      let k = wt.svg(i),
        T = vt(t, {}),
        C = k.path(b, T);
      ((y = i.insert(() => C, ":first-child")),
        y.attr("class", "basic label-container").attr("style", Ir(g)));
    } else
      y = i
        .insert("path", ":first-child")
        .attr("class", "basic label-container")
        .attr("style", n)
        .attr("d", b);
    return (
      l.attr("transform", `translate(${-s.width / 2}, ${-s.height / 2})`),
      y.attr("transform", `translate(${-u / 2}, ${-h / 2})`),
      Ct(t, y),
      (t.calcIntersect = function (k, T) {
        return Tt.rect(k, T);
      }),
      (t.intersect = function (k) {
        return (P.info("Cloud intersect", t, k), Tt.rect(t, k));
      }),
      i
    );
  }
  var eU = x(() => {
    "use strict";
    oe();
    Vt();
    _e();
    ae();
    re();
    Qt();
    a(tU, "cloud");
  });
  async function rU(e, t) {
    let { labelStyles: r, nodeStyles: n } = St(t);
    t.labelStyle = r;
    let {
        shapeSvg: i,
        bbox: s,
        halfPadding: o,
        label: l,
      } = await Bt(e, t, Ot(t)),
      u = s.width + 8 * o,
      h = s.height + 2 * o,
      f = 5,
      d = `
    M${-u / 2} ${h / 2 - f}
    v${-h + 2 * f}
    q0,-${f} ${f},-${f}
    h${u - 2 * f}
    q${f},0 ${f},${f}
    v${h - 2 * f}
    q0,${f} -${f},${f}
    h${-u + 2 * f}
    q-${f},0 -${f},-${f}
    Z
  `,
      p = i
        .append("path")
        .attr("id", "node-" + t.id)
        .attr("class", "node-bkg node-" + t.type)
        .attr("style", n)
        .attr("d", d);
    return (
      i
        .append("line")
        .attr("class", "node-line-")
        .attr("x1", -u / 2)
        .attr("y1", h / 2)
        .attr("x2", u / 2)
        .attr("y2", h / 2),
      l.attr("transform", `translate(${-s.width / 2}, ${-s.height / 2})`),
      i.append(() => l.node()),
      Ct(t, p),
      (t.calcIntersect = function (m, g) {
        return Tt.rect(m, g);
      }),
      (t.intersect = function (m) {
        return Tt.rect(t, m);
      }),
      i
    );
  }
  var nU = x(() => {
    "use strict";
    ae();
    re();
    Qt();
    a(rU, "defaultMindmapNode");
  });
  async function iU(e, t) {
    let r = { padding: t.padding ?? 0 };
    return Wb(e, t, r);
  }
  var sU = x(() => {
    "use strict";
    RA();
    a(iU, "mindmapCircle");
  });
  function aU(e) {
    return e in NA;
  }
  var Wbt,
    Ubt,
    NA,
    IA = x(() => {
      "use strict";
      VV();
      UV();
      qV();
      YV();
      RA();
      KV();
      ZV();
      tz();
      rz();
      iz();
      az();
      lz();
      uz();
      fz();
      pz();
      gz();
      xz();
      kz();
      Sz();
      Cz();
      vz();
      Az();
      Rz();
      Nz();
      Mz();
      Pz();
      Fz();
      Gz();
      zz();
      Uz();
      qz();
      Yz();
      Kz();
      Zz();
      tW();
      rW();
      iW();
      aW();
      lW();
      uW();
      fW();
      pW();
      gW();
      xW();
      kW();
      SW();
      CW();
      vW();
      AW();
      RW();
      NW();
      MW();
      PW();
      FW();
      GW();
      zW();
      WW();
      HW();
      XW();
      QW();
      JW();
      eU();
      nU();
      sU();
      ((Wbt = [
        {
          semanticName: "Process",
          name: "Rectangle",
          shortName: "rect",
          description: "Standard process shape",
          aliases: ["proc", "process", "rectangle"],
          internalAliases: ["squareRect"],
          handler: hW,
        },
        {
          semanticName: "Event",
          name: "Rounded Rectangle",
          shortName: "rounded",
          description: "Represents an event",
          aliases: ["event"],
          internalAliases: ["roundedRect"],
          handler: sW,
        },
        {
          semanticName: "Terminal Point",
          name: "Stadium",
          shortName: "stadium",
          description: "Terminal point",
          aliases: ["terminal", "pill"],
          handler: dW,
        },
        {
          semanticName: "Subprocess",
          name: "Framed Rectangle",
          shortName: "fr-rect",
          description: "Subprocess",
          aliases: ["subprocess", "subproc", "framed-rectangle", "subroutine"],
          handler: TW,
        },
        {
          semanticName: "Database",
          name: "Cylinder",
          shortName: "cyl",
          description: "Database storage",
          aliases: ["db", "database", "cylinder"],
          handler: sz,
        },
        {
          semanticName: "Start",
          name: "Circle",
          shortName: "circle",
          description: "Starting point",
          aliases: ["circ"],
          handler: Wb,
        },
        {
          semanticName: "Bang",
          name: "Bang",
          shortName: "bang",
          description: "Bang",
          aliases: ["bang"],
          handler: ZW,
        },
        {
          semanticName: "Cloud",
          name: "Cloud",
          shortName: "cloud",
          description: "cloud",
          aliases: ["cloud"],
          handler: tU,
        },
        {
          semanticName: "Decision",
          name: "Diamond",
          shortName: "diam",
          description: "Decision-making step",
          aliases: ["decision", "diamond", "question"],
          handler: Jz,
        },
        {
          semanticName: "Prepare Conditional",
          name: "Hexagon",
          shortName: "hex",
          description: "Preparation or condition step",
          aliases: ["hexagon", "prepare"],
          handler: bz,
        },
        {
          semanticName: "Data Input/Output",
          name: "Lean Right",
          shortName: "lean-r",
          description: "Represents input or output",
          aliases: ["lean-right", "in-out"],
          internalAliases: ["lean_right"],
          handler: $z,
        },
        {
          semanticName: "Data Input/Output",
          name: "Lean Left",
          shortName: "lean-l",
          description: "Represents output or input",
          aliases: ["lean-left", "out-in"],
          internalAliases: ["lean_left"],
          handler: Bz,
        },
        {
          semanticName: "Priority Action",
          name: "Trapezoid Base Bottom",
          shortName: "trap-b",
          description: "Priority action",
          aliases: ["priority", "trapezoid-bottom", "trapezoid"],
          handler: DW,
        },
        {
          semanticName: "Manual Operation",
          name: "Trapezoid Base Top",
          shortName: "trap-t",
          description: "Represents a manual task",
          aliases: ["manual", "trapezoid-top", "inv-trapezoid"],
          internalAliases: ["inv_trapezoid"],
          handler: Iz,
        },
        {
          semanticName: "Stop",
          name: "Double Circle",
          shortName: "dbl-circ",
          description: "Represents a stop point",
          aliases: ["double-circle"],
          internalAliases: ["doublecircle"],
          handler: cz,
        },
        {
          semanticName: "Text Block",
          name: "Text Block",
          shortName: "text",
          description: "Text block",
          handler: EW,
        },
        {
          semanticName: "Card",
          name: "Notched Rectangle",
          shortName: "notch-rect",
          description: "Represents a card",
          aliases: ["card", "notched-rectangle"],
          handler: jV,
        },
        {
          semanticName: "Lined/Shaded Process",
          name: "Lined Rectangle",
          shortName: "lin-rect",
          description: "Lined process shape",
          aliases: [
            "lined-rectangle",
            "lined-process",
            "lin-proc",
            "shaded-process",
          ],
          handler: oW,
        },
        {
          semanticName: "Start",
          name: "Small Circle",
          shortName: "sm-circ",
          description: "Small starting point",
          aliases: ["start", "small-circle"],
          internalAliases: ["stateStart"],
          handler: bW,
        },
        {
          semanticName: "Stop",
          name: "Framed Circle",
          shortName: "fr-circ",
          description: "Stop point",
          aliases: ["stop", "framed-circle"],
          internalAliases: ["stateEnd"],
          handler: yW,
        },
        {
          semanticName: "Fork/Join",
          name: "Filled Rectangle",
          shortName: "fork",
          description: "Fork or join in process flow",
          aliases: ["join"],
          internalAliases: ["forkJoin"],
          handler: mz,
        },
        {
          semanticName: "Collate",
          name: "Hourglass",
          shortName: "hourglass",
          description: "Represents a collate operation",
          aliases: ["hourglass", "collate"],
          handler: Tz,
        },
        {
          semanticName: "Comment",
          name: "Curly Brace",
          shortName: "brace",
          description: "Adds a comment",
          aliases: ["comment", "brace-l"],
          handler: QV,
        },
        {
          semanticName: "Comment Right",
          name: "Curly Brace",
          shortName: "brace-r",
          description: "Adds a comment",
          handler: JV,
        },
        {
          semanticName: "Comment with braces on both sides",
          name: "Curly Braces",
          shortName: "braces",
          description: "Adds a comment",
          handler: ez,
        },
        {
          semanticName: "Com Link",
          name: "Lightning Bolt",
          shortName: "bolt",
          description: "Communication link",
          aliases: ["com-link", "lightning-bolt"],
          handler: Vz,
        },
        {
          semanticName: "Document",
          name: "Document",
          shortName: "doc",
          description: "Represents a document",
          aliases: ["doc", "document"],
          handler: BW,
        },
        {
          semanticName: "Delay",
          name: "Half-Rounded Rectangle",
          shortName: "delay",
          description: "Represents a delay",
          aliases: ["half-rounded-rectangle"],
          handler: yz,
        },
        {
          semanticName: "Direct Access Storage",
          name: "Horizontal Cylinder",
          shortName: "h-cyl",
          description: "Direct access storage",
          aliases: ["das", "horizontal-cylinder"],
          handler: LW,
        },
        {
          semanticName: "Disk Storage",
          name: "Lined Cylinder",
          shortName: "lin-cyl",
          description: "Disk storage",
          aliases: ["disk", "lined-cylinder"],
          handler: Wz,
        },
        {
          semanticName: "Display",
          name: "Curved Trapezoid",
          shortName: "curv-trap",
          description: "Represents a display",
          aliases: ["curved-trapezoid", "display"],
          handler: nz,
        },
        {
          semanticName: "Divided Process",
          name: "Divided Rectangle",
          shortName: "div-rect",
          description: "Divided process shape",
          aliases: ["div-proc", "divided-rectangle", "divided-process"],
          handler: oz,
        },
        {
          semanticName: "Extract",
          name: "Triangle",
          shortName: "tri",
          description: "Extraction process",
          aliases: ["extract", "triangle"],
          handler: OW,
        },
        {
          semanticName: "Internal Storage",
          name: "Window Pane",
          shortName: "win-pane",
          description: "Internal storage",
          aliases: ["internal-storage", "window-pane"],
          handler: VW,
        },
        {
          semanticName: "Junction",
          name: "Filled Circle",
          shortName: "f-circ",
          description: "Junction point",
          aliases: ["junction", "filled-circle"],
          handler: hz,
        },
        {
          semanticName: "Loop Limit",
          name: "Trapezoidal Pentagon",
          shortName: "notch-pent",
          description: "Loop limit step",
          aliases: ["loop-limit", "notched-pentagon"],
          handler: IW,
        },
        {
          semanticName: "Manual File",
          name: "Flipped Triangle",
          shortName: "flip-tri",
          description: "Manual file operation",
          aliases: ["manual-file", "flipped-triangle"],
          handler: dz,
        },
        {
          semanticName: "Manual Input",
          name: "Sloped Rectangle",
          shortName: "sl-rect",
          description: "Manual input step",
          aliases: ["manual-input", "sloped-rectangle"],
          handler: cW,
        },
        {
          semanticName: "Multi-Document",
          name: "Stacked Document",
          shortName: "docs",
          description: "Multiple documents",
          aliases: ["documents", "st-doc", "stacked-document"],
          handler: Xz,
        },
        {
          semanticName: "Multi-Process",
          name: "Stacked Rectangle",
          shortName: "st-rect",
          description: "Multiple processes",
          aliases: ["procs", "processes", "stacked-rectangle"],
          handler: Hz,
        },
        {
          semanticName: "Stored Data",
          name: "Bow Tie Rectangle",
          shortName: "bow-rect",
          description: "Stored data",
          aliases: ["stored-data", "bow-tie-rectangle"],
          handler: WV,
        },
        {
          semanticName: "Summary",
          name: "Crossed Circle",
          shortName: "cross-circ",
          description: "Summary",
          aliases: ["summary", "crossed-circle"],
          handler: XV,
        },
        {
          semanticName: "Tagged Document",
          name: "Tagged Document",
          shortName: "tag-doc",
          description: "Tagged document",
          aliases: ["tag-doc", "tagged-document"],
          handler: wW,
        },
        {
          semanticName: "Tagged Process",
          name: "Tagged Rectangle",
          shortName: "tag-rect",
          description: "Tagged process",
          aliases: ["tagged-rectangle", "tag-proc", "tagged-process"],
          handler: _W,
        },
        {
          semanticName: "Paper Tape",
          name: "Flag",
          shortName: "flag",
          description: "Paper tape",
          aliases: ["paper-tape"],
          handler: $W,
        },
        {
          semanticName: "Odd",
          name: "Odd",
          shortName: "odd",
          description: "Odd shape",
          internalAliases: ["rect_left_inv_arrow"],
          handler: eW,
        },
        {
          semanticName: "Lined Document",
          name: "Lined Document",
          shortName: "lin-doc",
          description: "Lined document",
          aliases: ["lined-document"],
          handler: jz,
        },
      ]),
        (Ubt = a(() => {
          let t = [
            ...Object.entries({
              state: mW,
              choice: HV,
              note: Qz,
              rectWithTitle: nW,
              labelRect: Oz,
              iconSquare: Lz,
              iconCircle: wz,
              icon: _z,
              iconRounded: Ez,
              imageSquare: Dz,
              anchor: GV,
              kanbanItem: KW,
              mindmapCircle: iU,
              defaultMindmapNode: rU,
              classBox: qW,
              erBox: DA,
              requirementBox: YW,
            }),
            ...Wbt.flatMap((r) =>
              [
                r.shortName,
                ...("aliases" in r ? r.aliases : []),
                ...("internalAliases" in r ? r.internalAliases : []),
              ].map((i) => [i, r.handler]),
            ),
          ];
          return Object.fromEntries(t);
        }, "generateShapeMap")),
        (NA = Ubt()));
      a(aU, "isValidShape");
    });
  var jbt,
    Hb,
    oU = x(() => {
      "use strict";
      Ge();
      v0();
      pe();
      Vt();
      IA();
      _e();
      Be();
      yn();
      ((jbt = "flowchart-"),
        (Hb = class {
          constructor() {
            this.vertexCounter = 0;
            this.config = K();
            this.vertices = new Map();
            this.edges = [];
            this.classes = new Map();
            this.subGraphs = [];
            this.subGraphLookup = new Map();
            this.tooltips = new Map();
            this.subCount = 0;
            this.firstGraphFlag = !0;
            this.secCount = -1;
            this.posCrossRef = [];
            this.funs = [];
            this.setAccTitle = Xe;
            this.setAccDescription = er;
            this.setDiagramTitle = lr;
            this.getAccTitle = tr;
            this.getAccDescription = rr;
            this.getDiagramTitle = nr;
            (this.funs.push(this.setupToolTips.bind(this)),
              (this.addVertex = this.addVertex.bind(this)),
              (this.firstGraph = this.firstGraph.bind(this)),
              (this.setDirection = this.setDirection.bind(this)),
              (this.addSubGraph = this.addSubGraph.bind(this)),
              (this.addLink = this.addLink.bind(this)),
              (this.setLink = this.setLink.bind(this)),
              (this.updateLink = this.updateLink.bind(this)),
              (this.addClass = this.addClass.bind(this)),
              (this.setClass = this.setClass.bind(this)),
              (this.destructLink = this.destructLink.bind(this)),
              (this.setClickEvent = this.setClickEvent.bind(this)),
              (this.setTooltip = this.setTooltip.bind(this)),
              (this.updateLinkInterpolate =
                this.updateLinkInterpolate.bind(this)),
              (this.setClickFun = this.setClickFun.bind(this)),
              (this.bindFunctions = this.bindFunctions.bind(this)),
              (this.lex = { firstGraph: this.firstGraph.bind(this) }),
              this.clear(),
              this.setGen("gen-2"));
          }
          static {
            a(this, "FlowDB");
          }
          sanitizeText(t) {
            return Rt.sanitizeText(t, this.config);
          }
          lookUpDomId(t) {
            for (let r of this.vertices.values())
              if (r.id === t) return r.domId;
            return t;
          }
          addVertex(t, r, n, i, s, o, l = {}, u) {
            if (!t || t.trim().length === 0) return;
            let h;
            if (u !== void 0) {
              let m;
              (u.includes(`
`)
                ? (m =
                    u +
                    `
`)
                : (m =
                    `{
` +
                    u +
                    `
}`),
                (h = wc(m, { schema: Cc })));
            }
            let f = this.edges.find((m) => m.id === t);
            if (f) {
              let m = h;
              (m?.animate !== void 0 && (f.animate = m.animate),
                m?.animation !== void 0 && (f.animation = m.animation),
                m?.curve !== void 0 && (f.interpolate = m.curve));
              return;
            }
            let d,
              p = this.vertices.get(t);
            if (
              (p === void 0 &&
                ((p = {
                  id: t,
                  labelType: "text",
                  domId: jbt + t + "-" + this.vertexCounter,
                  styles: [],
                  classes: [],
                }),
                this.vertices.set(t, p)),
              this.vertexCounter++,
              r !== void 0
                ? ((this.config = K()),
                  (d = this.sanitizeText(r.text.trim())),
                  (p.labelType = r.type),
                  d.startsWith('"') &&
                    d.endsWith('"') &&
                    (d = d.substring(1, d.length - 1)),
                  (p.text = d))
                : p.text === void 0 && (p.text = t),
              n !== void 0 && (p.type = n),
              i?.forEach((m) => {
                p.styles.push(m);
              }),
              s?.forEach((m) => {
                p.classes.push(m);
              }),
              o !== void 0 && (p.dir = o),
              p.props === void 0
                ? (p.props = l)
                : l !== void 0 && Object.assign(p.props, l),
              h !== void 0)
            ) {
              if (h.shape) {
                if (h.shape !== h.shape.toLowerCase() || h.shape.includes("_"))
                  throw new Error(
                    `No such shape: ${h.shape}. Shape names should be lowercase.`,
                  );
                if (!aU(h.shape)) throw new Error(`No such shape: ${h.shape}.`);
                p.type = h?.shape;
              }
              (h?.label && (p.text = h?.label),
                h?.icon &&
                  ((p.icon = h?.icon),
                  !h.label?.trim() && p.text === t && (p.text = "")),
                h?.form && (p.form = h?.form),
                h?.pos && (p.pos = h?.pos),
                h?.img &&
                  ((p.img = h?.img),
                  !h.label?.trim() && p.text === t && (p.text = "")),
                h?.constraint && (p.constraint = h.constraint),
                h.w && (p.assetWidth = Number(h.w)),
                h.h && (p.assetHeight = Number(h.h)));
            }
          }
          addSingleLink(t, r, n, i) {
            let l = {
              start: t,
              end: r,
              type: void 0,
              text: "",
              labelType: "text",
              classes: [],
              isUserDefinedId: !1,
              interpolate: this.edges.defaultInterpolate,
            };
            P.info("abc78 Got edge...", l);
            let u = n.text;
            if (
              (u !== void 0 &&
                ((l.text = this.sanitizeText(u.text.trim())),
                l.text.startsWith('"') &&
                  l.text.endsWith('"') &&
                  (l.text = l.text.substring(1, l.text.length - 1)),
                (l.labelType = u.type)),
              n !== void 0 &&
                ((l.type = n.type),
                (l.stroke = n.stroke),
                (l.length = n.length > 10 ? 10 : n.length)),
              i && !this.edges.some((h) => h.id === i))
            )
              ((l.id = i), (l.isUserDefinedId = !0));
            else {
              let h = this.edges.filter(
                (f) => f.start === l.start && f.end === l.end,
              );
              h.length === 0
                ? (l.id = Tc(l.start, l.end, { counter: 0, prefix: "L" }))
                : (l.id = Tc(l.start, l.end, {
                    counter: h.length + 1,
                    prefix: "L",
                  }));
            }
            if (this.edges.length < (this.config.maxEdges ?? 500))
              (P.info("Pushing edge..."), this.edges.push(l));
            else
              throw new Error(`Edge limit exceeded. ${this.edges.length} edges found, but the limit is ${this.config.maxEdges}.

Initialize mermaid with maxEdges set to a higher number to allow more edges.
You cannot set this config via configuration inside the diagram as it is a secure config.
You have to call mermaid.initialize.`);
          }
          isLinkData(t) {
            return (
              t !== null &&
              typeof t == "object" &&
              "id" in t &&
              typeof t.id == "string"
            );
          }
          addLink(t, r, n) {
            let i = this.isLinkData(n) ? n.id.replace("@", "") : void 0;
            P.info("addLink", t, r, i);
            for (let s of t)
              for (let o of r) {
                let l = s === t[t.length - 1],
                  u = o === r[0];
                l && u
                  ? this.addSingleLink(s, o, n, i)
                  : this.addSingleLink(s, o, n, void 0);
              }
          }
          updateLinkInterpolate(t, r) {
            t.forEach((n) => {
              n === "default"
                ? (this.edges.defaultInterpolate = r)
                : (this.edges[n].interpolate = r);
            });
          }
          updateLink(t, r) {
            t.forEach((n) => {
              if (typeof n == "number" && n >= this.edges.length)
                throw new Error(
                  `The index ${n} for linkStyle is out of bounds. Valid indices for linkStyle are between 0 and ${this.edges.length - 1}. (Help: Ensure that the index is within the range of existing edges.)`,
                );
              n === "default"
                ? (this.edges.defaultStyle = r)
                : ((this.edges[n].style = r),
                  (this.edges[n]?.style?.length ?? 0) > 0 &&
                    !this.edges[n]?.style?.some((i) => i?.startsWith("fill")) &&
                    this.edges[n]?.style?.push("fill:none"));
            });
          }
          addClass(t, r) {
            let n = r
              .join()
              .replace(/\\,/g, "\xA7\xA7\xA7")
              .replace(/,/g, ";")
              .replace(/§§§/g, ",")
              .split(";");
            t.split(",").forEach((i) => {
              let s = this.classes.get(i);
              (s === void 0 &&
                ((s = { id: i, styles: [], textStyles: [] }),
                this.classes.set(i, s)),
                n?.forEach((o) => {
                  if (/color/.exec(o)) {
                    let l = o.replace("fill", "bgFill");
                    s.textStyles.push(l);
                  }
                  s.styles.push(o);
                }));
            });
          }
          setDirection(t) {
            ((this.direction = t.trim()),
              /.*</.exec(this.direction) && (this.direction = "RL"),
              /.*\^/.exec(this.direction) && (this.direction = "BT"),
              /.*>/.exec(this.direction) && (this.direction = "LR"),
              /.*v/.exec(this.direction) && (this.direction = "TB"),
              this.direction === "TD" && (this.direction = "TB"));
          }
          setClass(t, r) {
            for (let n of t.split(",")) {
              let i = this.vertices.get(n);
              i && i.classes.push(r);
              let s = this.edges.find((l) => l.id === n);
              s && s.classes.push(r);
              let o = this.subGraphLookup.get(n);
              o && o.classes.push(r);
            }
          }
          setTooltip(t, r) {
            if (r !== void 0) {
              r = this.sanitizeText(r);
              for (let n of t.split(","))
                this.tooltips.set(
                  this.version === "gen-1" ? this.lookUpDomId(n) : n,
                  r,
                );
            }
          }
          setClickFun(t, r, n) {
            let i = this.lookUpDomId(t);
            if (K().securityLevel !== "loose" || r === void 0) return;
            let s = [];
            if (typeof n == "string") {
              s = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
              for (let l = 0; l < s.length; l++) {
                let u = s[l].trim();
                (u.startsWith('"') &&
                  u.endsWith('"') &&
                  (u = u.substr(1, u.length - 2)),
                  (s[l] = u));
              }
            }
            s.length === 0 && s.push(t);
            let o = this.vertices.get(t);
            o &&
              ((o.haveCallback = !0),
              this.funs.push(() => {
                let l = document.querySelector(`[id="${i}"]`);
                l !== null &&
                  l.addEventListener(
                    "click",
                    () => {
                      le.runFunc(r, ...s);
                    },
                    !1,
                  );
              }));
          }
          setLink(t, r, n) {
            (t.split(",").forEach((i) => {
              let s = this.vertices.get(i);
              s !== void 0 &&
                ((s.link = le.formatUrl(r, this.config)), (s.linkTarget = n));
            }),
              this.setClass(t, "clickable"));
          }
          getTooltip(t) {
            return this.tooltips.get(t);
          }
          setClickEvent(t, r, n) {
            (t.split(",").forEach((i) => {
              this.setClickFun(i, r, n);
            }),
              this.setClass(t, "clickable"));
          }
          bindFunctions(t) {
            this.funs.forEach((r) => {
              r(t);
            });
          }
          getDirection() {
            return this.direction?.trim();
          }
          getVertices() {
            return this.vertices;
          }
          getEdges() {
            return this.edges;
          }
          getClasses() {
            return this.classes;
          }
          setupToolTips(t) {
            let r = xt(".mermaidTooltip");
            ((r._groups || r)[0][0] === null &&
              (r = xt("body")
                .append("div")
                .attr("class", "mermaidTooltip")
                .style("opacity", 0)),
              xt(t)
                .select("svg")
                .selectAll("g.node")
                .on("mouseover", (s) => {
                  let o = xt(s.currentTarget);
                  if (o.attr("title") === null) return;
                  let u = s.currentTarget?.getBoundingClientRect();
                  (r.transition().duration(200).style("opacity", ".9"),
                    r
                      .text(o.attr("title"))
                      .style(
                        "left",
                        window.scrollX + u.left + (u.right - u.left) / 2 + "px",
                      )
                      .style("top", window.scrollY + u.bottom + "px"),
                    r.html(r.html().replace(/&lt;br\/&gt;/g, "<br/>")),
                    o.classed("hover", !0));
                })
                .on("mouseout", (s) => {
                  (r.transition().duration(500).style("opacity", 0),
                    xt(s.currentTarget).classed("hover", !1));
                }));
          }
          clear(t = "gen-2") {
            ((this.vertices = new Map()),
              (this.classes = new Map()),
              (this.edges = []),
              (this.funs = [this.setupToolTips.bind(this)]),
              (this.subGraphs = []),
              (this.subGraphLookup = new Map()),
              (this.subCount = 0),
              (this.tooltips = new Map()),
              (this.firstGraphFlag = !0),
              (this.version = t),
              (this.config = K()),
              Ye());
          }
          setGen(t) {
            this.version = t || "gen-2";
          }
          defaultStyle() {
            return "fill:#ffa;stroke: #f66; stroke-width: 3px; stroke-dasharray: 5, 5;fill:#ffa;stroke: #666;";
          }
          addSubGraph(t, r, n) {
            let i = t.text.trim(),
              s = n.text;
            t === n && /\s/.exec(n.text) && (i = void 0);
            let l = a((p) => {
                let m = { boolean: {}, number: {}, string: {} },
                  g = [],
                  y;
                return {
                  nodeList: p.filter(function (k) {
                    let T = typeof k;
                    return k.stmt && k.stmt === "dir"
                      ? ((y = k.value), !1)
                      : k.trim() === ""
                        ? !1
                        : T in m
                          ? m[T].hasOwnProperty(k)
                            ? !1
                            : (m[T][k] = !0)
                          : g.includes(k)
                            ? !1
                            : g.push(k);
                  }),
                  dir: y,
                };
              }, "uniq")(r.flat()),
              u = l.nodeList,
              h = l.dir,
              f = K().flowchart ?? {};
            if (
              ((h =
                h ??
                (f.inheritDir
                  ? (this.getDirection() ?? K().direction ?? void 0)
                  : void 0)),
              this.version === "gen-1")
            )
              for (let p = 0; p < u.length; p++) u[p] = this.lookUpDomId(u[p]);
            ((i = i ?? "subGraph" + this.subCount),
              (s = s || ""),
              (s = this.sanitizeText(s)),
              (this.subCount = this.subCount + 1));
            let d = {
              id: i,
              nodes: u,
              title: s.trim(),
              classes: [],
              dir: h,
              labelType: n.type,
            };
            return (
              P.info("Adding", d.id, d.nodes, d.dir),
              (d.nodes = this.makeUniq(d, this.subGraphs).nodes),
              this.subGraphs.push(d),
              this.subGraphLookup.set(i, d),
              i
            );
          }
          getPosForId(t) {
            for (let [r, n] of this.subGraphs.entries())
              if (n.id === t) return r;
            return -1;
          }
          indexNodes2(t, r) {
            let n = this.subGraphs[r].nodes;
            if (((this.secCount = this.secCount + 1), this.secCount > 2e3))
              return { result: !1, count: 0 };
            if (
              ((this.posCrossRef[this.secCount] = r),
              this.subGraphs[r].id === t)
            )
              return { result: !0, count: 0 };
            let i = 0,
              s = 1;
            for (; i < n.length; ) {
              let o = this.getPosForId(n[i]);
              if (o >= 0) {
                let l = this.indexNodes2(t, o);
                if (l.result) return { result: !0, count: s + l.count };
                s = s + l.count;
              }
              i = i + 1;
            }
            return { result: !1, count: s };
          }
          getDepthFirstPos(t) {
            return this.posCrossRef[t];
          }
          indexNodes() {
            ((this.secCount = -1),
              this.subGraphs.length > 0 &&
                this.indexNodes2("none", this.subGraphs.length - 1));
          }
          getSubGraphs() {
            return this.subGraphs;
          }
          firstGraph() {
            return this.firstGraphFlag ? ((this.firstGraphFlag = !1), !0) : !1;
          }
          destructStartLink(t) {
            let r = t.trim(),
              n = "arrow_open";
            switch (r[0]) {
              case "<":
                ((n = "arrow_point"), (r = r.slice(1)));
                break;
              case "x":
                ((n = "arrow_cross"), (r = r.slice(1)));
                break;
              case "o":
                ((n = "arrow_circle"), (r = r.slice(1)));
                break;
            }
            let i = "normal";
            return (
              r.includes("=") && (i = "thick"),
              r.includes(".") && (i = "dotted"),
              { type: n, stroke: i }
            );
          }
          countChar(t, r) {
            let n = r.length,
              i = 0;
            for (let s = 0; s < n; ++s) r[s] === t && ++i;
            return i;
          }
          destructEndLink(t) {
            let r = t.trim(),
              n = r.slice(0, -1),
              i = "arrow_open";
            switch (r.slice(-1)) {
              case "x":
                ((i = "arrow_cross"),
                  r.startsWith("x") && ((i = "double_" + i), (n = n.slice(1))));
                break;
              case ">":
                ((i = "arrow_point"),
                  r.startsWith("<") && ((i = "double_" + i), (n = n.slice(1))));
                break;
              case "o":
                ((i = "arrow_circle"),
                  r.startsWith("o") && ((i = "double_" + i), (n = n.slice(1))));
                break;
            }
            let s = "normal",
              o = n.length - 1;
            (n.startsWith("=") && (s = "thick"),
              n.startsWith("~") && (s = "invisible"));
            let l = this.countChar(".", n);
            return (
              l && ((s = "dotted"), (o = l)),
              { type: i, stroke: s, length: o }
            );
          }
          destructLink(t, r) {
            let n = this.destructEndLink(t),
              i;
            if (r) {
              if (((i = this.destructStartLink(r)), i.stroke !== n.stroke))
                return { type: "INVALID", stroke: "INVALID" };
              if (i.type === "arrow_open") i.type = n.type;
              else {
                if (i.type !== n.type)
                  return { type: "INVALID", stroke: "INVALID" };
                i.type = "double_" + i.type;
              }
              return (
                i.type === "double_arrow" && (i.type = "double_arrow_point"),
                (i.length = n.length),
                i
              );
            }
            return n;
          }
          exists(t, r) {
            for (let n of t) if (n.nodes.includes(r)) return !0;
            return !1;
          }
          makeUniq(t, r) {
            let n = [];
            return (
              t.nodes.forEach((i, s) => {
                this.exists(r, i) || n.push(t.nodes[s]);
              }),
              { nodes: n }
            );
          }
          getTypeFromVertex(t) {
            if (t.img) return "imageSquare";
            if (t.icon)
              return t.form === "circle"
                ? "iconCircle"
                : t.form === "square"
                  ? "iconSquare"
                  : t.form === "rounded"
                    ? "iconRounded"
                    : "icon";
            switch (t.type) {
              case "square":
              case void 0:
                return "squareRect";
              case "round":
                return "roundedRect";
              case "ellipse":
                return "ellipse";
              default:
                return t.type;
            }
          }
          findNode(t, r) {
            return t.find((n) => n.id === r);
          }
          destructEdgeType(t) {
            let r = "none",
              n = "arrow_point";
            switch (t) {
              case "arrow_point":
              case "arrow_circle":
              case "arrow_cross":
                n = t;
                break;
              case "double_arrow_point":
              case "double_arrow_circle":
              case "double_arrow_cross":
                ((r = t.replace("double_", "")), (n = r));
                break;
            }
            return { arrowTypeStart: r, arrowTypeEnd: n };
          }
          addNodeFromVertex(t, r, n, i, s, o) {
            let l = n.get(t.id),
              u = i.get(t.id) ?? !1,
              h = this.findNode(r, t.id);
            if (h)
              ((h.cssStyles = t.styles),
                (h.cssCompiledStyles = this.getCompiledStyles(t.classes)),
                (h.cssClasses = t.classes.join(" ")));
            else {
              let f = {
                id: t.id,
                label: t.text,
                labelStyle: "",
                parentId: l,
                padding: s.flowchart?.padding || 8,
                cssStyles: t.styles,
                cssCompiledStyles: this.getCompiledStyles([
                  "default",
                  "node",
                  ...t.classes,
                ]),
                cssClasses: "default " + t.classes.join(" "),
                dir: t.dir,
                domId: t.domId,
                look: o,
                link: t.link,
                linkTarget: t.linkTarget,
                tooltip: this.getTooltip(t.id),
                icon: t.icon,
                pos: t.pos,
                img: t.img,
                assetWidth: t.assetWidth,
                assetHeight: t.assetHeight,
                constraint: t.constraint,
              };
              u
                ? r.push({ ...f, isGroup: !0, shape: "rect" })
                : r.push({
                    ...f,
                    isGroup: !1,
                    shape: this.getTypeFromVertex(t),
                  });
            }
          }
          getCompiledStyles(t) {
            let r = [];
            for (let n of t) {
              let i = this.classes.get(n);
              (i?.styles &&
                (r = [...r, ...(i.styles ?? [])].map((s) => s.trim())),
                i?.textStyles &&
                  (r = [...r, ...(i.textStyles ?? [])].map((s) => s.trim())));
            }
            return r;
          }
          getData() {
            let t = K(),
              r = [],
              n = [],
              i = this.getSubGraphs(),
              s = new Map(),
              o = new Map();
            for (let h = i.length - 1; h >= 0; h--) {
              let f = i[h];
              f.nodes.length > 0 && o.set(f.id, !0);
              for (let d of f.nodes) s.set(d, f.id);
            }
            for (let h = i.length - 1; h >= 0; h--) {
              let f = i[h];
              r.push({
                id: f.id,
                label: f.title,
                labelStyle: "",
                parentId: s.get(f.id),
                padding: 8,
                cssCompiledStyles: this.getCompiledStyles(f.classes),
                cssClasses: f.classes.join(" "),
                shape: "rect",
                dir: f.dir,
                isGroup: !0,
                look: t.look,
              });
            }
            this.getVertices().forEach((h) => {
              this.addNodeFromVertex(h, r, s, o, t, t.look || "classic");
            });
            let u = this.getEdges();
            return (
              u.forEach((h, f) => {
                let { arrowTypeStart: d, arrowTypeEnd: p } =
                    this.destructEdgeType(h.type),
                  m = [...(u.defaultStyle ?? [])];
                h.style && m.push(...h.style);
                let g = {
                  id: Tc(h.start, h.end, { counter: f, prefix: "L" }, h.id),
                  isUserDefinedId: h.isUserDefinedId,
                  start: h.start,
                  end: h.end,
                  type: h.type ?? "normal",
                  label: h.text,
                  labelpos: "c",
                  thickness: h.stroke,
                  minlen: h.length,
                  classes:
                    h?.stroke === "invisible"
                      ? ""
                      : "edge-thickness-normal edge-pattern-solid flowchart-link",
                  arrowTypeStart:
                    h?.stroke === "invisible" || h?.type === "arrow_open"
                      ? "none"
                      : d,
                  arrowTypeEnd:
                    h?.stroke === "invisible" || h?.type === "arrow_open"
                      ? "none"
                      : p,
                  arrowheadStyle: "fill: #333",
                  cssCompiledStyles: this.getCompiledStyles(h.classes),
                  labelStyle: m,
                  style: m,
                  pattern: h.stroke,
                  look: t.look,
                  animate: h.animate,
                  animation: h.animation,
                  curve:
                    h.interpolate ||
                    this.edges.defaultInterpolate ||
                    t.flowchart?.curve,
                };
                n.push(g);
              }),
              { nodes: r, edges: n, other: {}, config: t }
            );
          }
          defaultConfig() {
            return wx.flowchart;
          }
        }));
    });
  var _o,
    hd = x(() => {
      "use strict";
      Ge();
      _o = a((e, t) => {
        let r;
        return (
          t === "sandbox" && (r = xt("#i" + e)),
          (t === "sandbox"
            ? xt(r.nodes()[0].contentDocument.body)
            : xt("body")
          ).select(`[id="${e}"]`)
        );
      }, "getDiagramElement");
    });
  var Tl,
    F0 = x(() => {
      "use strict";
      Tl = a(({ flowchart: e }) => {
        let t = e?.subGraphTitleMargin?.top ?? 0,
          r = e?.subGraphTitleMargin?.bottom ?? 0,
          n = t + r;
        return {
          subGraphTitleTopMargin: t,
          subGraphTitleBottomMargin: r,
          subGraphTitleTotalMargin: n,
        };
      }, "getSubGraphTitleMargins");
    });
  var lU,
    qbt,
    Hbt,
    Ybt,
    Xbt,
    Kbt,
    Qbt,
    cU,
    fd,
    uU,
    Yb = x(() => {
      "use strict";
      pe();
      Be();
      Vt();
      F0();
      Ge();
      oe();
      Ga();
      fA();
      Ub();
      eh();
      re();
      ((lU = a(async (e, t) => {
        P.info("Creating subgraph rect for ", t.id, t);
        let r = K(),
          { themeVariables: n, handDrawnSeed: i } = r,
          { clusterBkg: s, clusterBorder: o } = n,
          {
            labelStyles: l,
            nodeStyles: u,
            borderStyles: h,
            backgroundStyles: f,
          } = St(t),
          d = e
            .insert("g")
            .attr("class", "cluster " + t.cssClasses)
            .attr("id", t.id)
            .attr("data-look", t.look),
          p = Pe(r.flowchart.htmlLabels),
          m = d.insert("g").attr("class", "cluster-label "),
          g = await Kn(m, t.label, {
            style: t.labelStyle,
            useHtmlLabels: p,
            isNode: !0,
          }),
          y = g.getBBox();
        if (Pe(r.flowchart.htmlLabels)) {
          let G = g.children[0],
            E = xt(g);
          ((y = G.getBoundingClientRect()),
            E.attr("width", y.width),
            E.attr("height", y.height));
        }
        let b = t.width <= y.width + t.padding ? y.width + t.padding : t.width;
        t.width <= y.width + t.padding
          ? (t.diff = (b - t.width) / 2 - t.padding)
          : (t.diff = -t.padding);
        let k = t.height,
          T = t.x - b / 2,
          C = t.y - k / 2;
        P.trace("Data ", t, JSON.stringify(t));
        let L;
        if (t.look === "handDrawn") {
          let G = wt.svg(d),
            E = vt(t, {
              roughness: 0.7,
              fill: s,
              stroke: o,
              fillWeight: 3,
              seed: i,
            }),
            R = G.path(us(T, C, b, k, 0), E);
          ((L = d.insert(
            () => (P.debug("Rough node insert CXC", R), R),
            ":first-child",
          )),
            L.select("path:nth-child(2)").attr("style", h.join(";")),
            L.select("path").attr(
              "style",
              f.join(";").replace("fill", "stroke"),
            ));
        } else
          ((L = d.insert("rect", ":first-child")),
            L.attr("style", u)
              .attr("rx", t.rx)
              .attr("ry", t.ry)
              .attr("x", T)
              .attr("y", C)
              .attr("width", b)
              .attr("height", k));
        let { subGraphTitleTopMargin: w } = Tl(r);
        if (
          (m.attr(
            "transform",
            `translate(${t.x - y.width / 2}, ${t.y - t.height / 2 + w})`,
          ),
          l)
        ) {
          let G = m.select("span");
          G && G.attr("style", l);
        }
        let D = L.node().getBBox();
        return (
          (t.offsetX = 0),
          (t.width = D.width),
          (t.height = D.height),
          (t.offsetY = y.height - t.padding / 2),
          (t.intersect = function (G) {
            return vc(t, G);
          }),
          { cluster: d, labelBBox: y }
        );
      }, "rect")),
        (qbt = a((e, t) => {
          let r = e.insert("g").attr("class", "note-cluster").attr("id", t.id),
            n = r.insert("rect", ":first-child"),
            i = 0 * t.padding,
            s = i / 2;
          n.attr("rx", t.rx)
            .attr("ry", t.ry)
            .attr("x", t.x - t.width / 2 - s)
            .attr("y", t.y - t.height / 2 - s)
            .attr("width", t.width + i)
            .attr("height", t.height + i)
            .attr("fill", "none");
          let o = n.node().getBBox();
          return (
            (t.width = o.width),
            (t.height = o.height),
            (t.intersect = function (l) {
              return vc(t, l);
            }),
            { cluster: r, labelBBox: { width: 0, height: 0 } }
          );
        }, "noteGroup")),
        (Hbt = a(async (e, t) => {
          let r = K(),
            { themeVariables: n, handDrawnSeed: i } = r,
            {
              altBackground: s,
              compositeBackground: o,
              compositeTitleBackground: l,
              nodeBorder: u,
            } = n,
            h = e
              .insert("g")
              .attr("class", t.cssClasses)
              .attr("id", t.id)
              .attr("data-id", t.id)
              .attr("data-look", t.look),
            f = h.insert("g", ":first-child"),
            d = h.insert("g").attr("class", "cluster-label"),
            p = h.append("rect"),
            m = d
              .node()
              .appendChild(await So(t.label, t.labelStyle, void 0, !0)),
            g = m.getBBox();
          if (Pe(r.flowchart.htmlLabels)) {
            let R = m.children[0],
              F = xt(m);
            ((g = R.getBoundingClientRect()),
              F.attr("width", g.width),
              F.attr("height", g.height));
          }
          let y = 0 * t.padding,
            b = y / 2,
            k =
              (t.width <= g.width + t.padding ? g.width + t.padding : t.width) +
              y;
          t.width <= g.width + t.padding
            ? (t.diff = (k - t.width) / 2 - t.padding)
            : (t.diff = -t.padding);
          let T = t.height + y,
            C = t.height + y - g.height - 6,
            L = t.x - k / 2,
            w = t.y - T / 2;
          t.width = k;
          let D = t.y - t.height / 2 - b + g.height + 2,
            G;
          if (t.look === "handDrawn") {
            let R = t.cssClasses.includes("statediagram-cluster-alt"),
              F = wt.svg(h),
              S =
                t.rx || t.ry
                  ? F.path(us(L, w, k, T, 10), {
                      roughness: 0.7,
                      fill: l,
                      fillStyle: "solid",
                      stroke: u,
                      seed: i,
                    })
                  : F.rectangle(L, w, k, T, { seed: i });
            G = h.insert(() => S, ":first-child");
            let O = F.rectangle(L, D, k, C, {
              fill: R ? s : o,
              fillStyle: R ? "hachure" : "solid",
              stroke: u,
              seed: i,
            });
            ((G = h.insert(() => S, ":first-child")), (p = h.insert(() => O)));
          } else
            ((G = f.insert("rect", ":first-child")),
              G.attr("class", "outer")
                .attr("x", L)
                .attr("y", w)
                .attr("width", k)
                .attr("height", T)
                .attr("data-look", t.look),
              p
                .attr("class", "inner")
                .attr("x", L)
                .attr("y", D)
                .attr("width", k)
                .attr("height", C));
          d.attr(
            "transform",
            `translate(${t.x - g.width / 2}, ${w + 1 - (Pe(r.flowchart.htmlLabels) ? 0 : 3)})`,
          );
          let E = G.node().getBBox();
          return (
            (t.height = E.height),
            (t.offsetX = 0),
            (t.offsetY = g.height - t.padding / 2),
            (t.labelBBox = g),
            (t.intersect = function (R) {
              return vc(t, R);
            }),
            { cluster: h, labelBBox: g }
          );
        }, "roundedWithTitle")),
        (Ybt = a(async (e, t) => {
          P.info("Creating subgraph rect for ", t.id, t);
          let r = K(),
            { themeVariables: n, handDrawnSeed: i } = r,
            { clusterBkg: s, clusterBorder: o } = n,
            {
              labelStyles: l,
              nodeStyles: u,
              borderStyles: h,
              backgroundStyles: f,
            } = St(t),
            d = e
              .insert("g")
              .attr("class", "cluster " + t.cssClasses)
              .attr("id", t.id)
              .attr("data-look", t.look),
            p = Pe(r.flowchart.htmlLabels),
            m = d.insert("g").attr("class", "cluster-label "),
            g = await Kn(m, t.label, {
              style: t.labelStyle,
              useHtmlLabels: p,
              isNode: !0,
              width: t.width,
            }),
            y = g.getBBox();
          if (Pe(r.flowchart.htmlLabels)) {
            let G = g.children[0],
              E = xt(g);
            ((y = G.getBoundingClientRect()),
              E.attr("width", y.width),
              E.attr("height", y.height));
          }
          let b =
            t.width <= y.width + t.padding ? y.width + t.padding : t.width;
          t.width <= y.width + t.padding
            ? (t.diff = (b - t.width) / 2 - t.padding)
            : (t.diff = -t.padding);
          let k = t.height,
            T = t.x - b / 2,
            C = t.y - k / 2;
          P.trace("Data ", t, JSON.stringify(t));
          let L;
          if (t.look === "handDrawn") {
            let G = wt.svg(d),
              E = vt(t, {
                roughness: 0.7,
                fill: s,
                stroke: o,
                fillWeight: 4,
                seed: i,
              }),
              R = G.path(us(T, C, b, k, t.rx), E);
            ((L = d.insert(
              () => (P.debug("Rough node insert CXC", R), R),
              ":first-child",
            )),
              L.select("path:nth-child(2)").attr("style", h.join(";")),
              L.select("path").attr(
                "style",
                f.join(";").replace("fill", "stroke"),
              ));
          } else
            ((L = d.insert("rect", ":first-child")),
              L.attr("style", u)
                .attr("rx", t.rx)
                .attr("ry", t.ry)
                .attr("x", T)
                .attr("y", C)
                .attr("width", b)
                .attr("height", k));
          let { subGraphTitleTopMargin: w } = Tl(r);
          if (
            (m.attr(
              "transform",
              `translate(${t.x - y.width / 2}, ${t.y - t.height / 2 + w})`,
            ),
            l)
          ) {
            let G = m.select("span");
            G && G.attr("style", l);
          }
          let D = L.node().getBBox();
          return (
            (t.offsetX = 0),
            (t.width = D.width),
            (t.height = D.height),
            (t.offsetY = y.height - t.padding / 2),
            (t.intersect = function (G) {
              return vc(t, G);
            }),
            { cluster: d, labelBBox: y }
          );
        }, "kanbanSection")),
        (Xbt = a((e, t) => {
          let r = K(),
            { themeVariables: n, handDrawnSeed: i } = r,
            { nodeBorder: s } = n,
            o = e
              .insert("g")
              .attr("class", t.cssClasses)
              .attr("id", t.id)
              .attr("data-look", t.look),
            l = o.insert("g", ":first-child"),
            u = 0 * t.padding,
            h = t.width + u;
          t.diff = -t.padding;
          let f = t.height + u,
            d = t.x - h / 2,
            p = t.y - f / 2;
          t.width = h;
          let m;
          if (t.look === "handDrawn") {
            let b = wt
              .svg(o)
              .rectangle(d, p, h, f, {
                fill: "lightgrey",
                roughness: 0.5,
                strokeLineDash: [5],
                stroke: s,
                seed: i,
              });
            m = o.insert(() => b, ":first-child");
          } else
            ((m = l.insert("rect", ":first-child")),
              m
                .attr("class", "divider")
                .attr("x", d)
                .attr("y", p)
                .attr("width", h)
                .attr("height", f)
                .attr("data-look", t.look));
          let g = m.node().getBBox();
          return (
            (t.height = g.height),
            (t.offsetX = 0),
            (t.offsetY = 0),
            (t.intersect = function (y) {
              return vc(t, y);
            }),
            { cluster: o, labelBBox: {} }
          );
        }, "divider")),
        (Kbt = lU),
        (Qbt = {
          rect: lU,
          squareRect: Kbt,
          roundedWithTitle: Hbt,
          noteGroup: qbt,
          divider: Xbt,
          kanbanSection: Ybt,
        }),
        (cU = new Map()),
        (fd = a(async (e, t) => {
          let r = t.shape || "rect",
            n = await Qbt[r](e, t);
          return (cU.set(t.id, n), n);
        }, "insertCluster")),
        (uU = a(() => {
          cU = new Map();
        }, "clear")));
    });
  function Xb(e, t) {
    if (e === void 0 || t === void 0) return { angle: 0, deltaX: 0, deltaY: 0 };
    ((e = Qr(e)), (t = Qr(t)));
    let [r, n] = [e.x, e.y],
      [i, s] = [t.x, t.y],
      o = i - r,
      l = s - n;
    return { angle: Math.atan(l / o), deltaX: o, deltaY: l };
  }
  var na,
    Qr,
    Kb,
    MA = x(() => {
      "use strict";
      na = {
        aggregation: 18,
        extension: 18,
        composition: 18,
        dependency: 6,
        lollipop: 13.5,
        arrow_point: 4,
      };
      a(Xb, "calculateDeltaAndAngle");
      ((Qr = a(
        (e) => (Array.isArray(e) ? { x: e[0], y: e[1] } : e),
        "pointTransformer",
      )),
        (Kb = a(
          (e) => ({
            x: a(function (t, r, n) {
              let i = 0,
                s = Qr(n[0]).x < Qr(n[n.length - 1]).x ? "left" : "right";
              if (r === 0 && Object.hasOwn(na, e.arrowTypeStart)) {
                let { angle: m, deltaX: g } = Xb(n[0], n[1]);
                i = na[e.arrowTypeStart] * Math.cos(m) * (g >= 0 ? 1 : -1);
              } else if (
                r === n.length - 1 &&
                Object.hasOwn(na, e.arrowTypeEnd)
              ) {
                let { angle: m, deltaX: g } = Xb(
                  n[n.length - 1],
                  n[n.length - 2],
                );
                i = na[e.arrowTypeEnd] * Math.cos(m) * (g >= 0 ? 1 : -1);
              }
              let o = Math.abs(Qr(t).x - Qr(n[n.length - 1]).x),
                l = Math.abs(Qr(t).y - Qr(n[n.length - 1]).y),
                u = Math.abs(Qr(t).x - Qr(n[0]).x),
                h = Math.abs(Qr(t).y - Qr(n[0]).y),
                f = na[e.arrowTypeStart],
                d = na[e.arrowTypeEnd],
                p = 1;
              if (o < d && o > 0 && l < d) {
                let m = d + p - o;
                ((m *= s === "right" ? -1 : 1), (i -= m));
              }
              if (u < f && u > 0 && h < f) {
                let m = f + p - u;
                ((m *= s === "right" ? -1 : 1), (i += m));
              }
              return Qr(t).x + i;
            }, "x"),
            y: a(function (t, r, n) {
              let i = 0,
                s = Qr(n[0]).y < Qr(n[n.length - 1]).y ? "down" : "up";
              if (r === 0 && Object.hasOwn(na, e.arrowTypeStart)) {
                let { angle: m, deltaY: g } = Xb(n[0], n[1]);
                i =
                  na[e.arrowTypeStart] *
                  Math.abs(Math.sin(m)) *
                  (g >= 0 ? 1 : -1);
              } else if (
                r === n.length - 1 &&
                Object.hasOwn(na, e.arrowTypeEnd)
              ) {
                let { angle: m, deltaY: g } = Xb(
                  n[n.length - 1],
                  n[n.length - 2],
                );
                i =
                  na[e.arrowTypeEnd] *
                  Math.abs(Math.sin(m)) *
                  (g >= 0 ? 1 : -1);
              }
              let o = Math.abs(Qr(t).y - Qr(n[n.length - 1]).y),
                l = Math.abs(Qr(t).x - Qr(n[n.length - 1]).x),
                u = Math.abs(Qr(t).y - Qr(n[0]).y),
                h = Math.abs(Qr(t).x - Qr(n[0]).x),
                f = na[e.arrowTypeStart],
                d = na[e.arrowTypeEnd],
                p = 1;
              if (o < d && o > 0 && l < d) {
                let m = d + p - o;
                ((m *= s === "up" ? -1 : 1), (i -= m));
              }
              if (u < f && u > 0 && h < f) {
                let m = f + p - u;
                ((m *= s === "up" ? -1 : 1), (i += m));
              }
              return Qr(t).y + i;
            }, "y"),
          }),
          "getLineFunctionsWithOffset",
        )));
    });
  var fU,
    Zbt,
    hU,
    dU = x(() => {
      "use strict";
      Vt();
      ((fU = a((e, t, r, n, i, s) => {
        (t.arrowTypeStart && hU(e, "start", t.arrowTypeStart, r, n, i, s),
          t.arrowTypeEnd && hU(e, "end", t.arrowTypeEnd, r, n, i, s));
      }, "addEdgeMarkers")),
        (Zbt = {
          arrow_cross: { type: "cross", fill: !1 },
          arrow_point: { type: "point", fill: !0 },
          arrow_barb: { type: "barb", fill: !0 },
          arrow_circle: { type: "circle", fill: !1 },
          aggregation: { type: "aggregation", fill: !1 },
          extension: { type: "extension", fill: !1 },
          composition: { type: "composition", fill: !0 },
          dependency: { type: "dependency", fill: !0 },
          lollipop: { type: "lollipop", fill: !1 },
          only_one: { type: "onlyOne", fill: !1 },
          zero_or_one: { type: "zeroOrOne", fill: !1 },
          one_or_more: { type: "oneOrMore", fill: !1 },
          zero_or_more: { type: "zeroOrMore", fill: !1 },
          requirement_arrow: { type: "requirement_arrow", fill: !1 },
          requirement_contains: { type: "requirement_contains", fill: !1 },
        }),
        (hU = a((e, t, r, n, i, s, o) => {
          let l = Zbt[r];
          if (!l) {
            P.warn(`Unknown arrow type: ${r}`);
            return;
          }
          let u = l.type,
            f = `${i}_${s}-${u}${t === "start" ? "Start" : "End"}`;
          if (o && o.trim() !== "") {
            let d = o.replace(/[^\dA-Za-z]/g, "_"),
              p = `${f}_${d}`;
            if (!document.getElementById(p)) {
              let m = document.getElementById(f);
              if (m) {
                let g = m.cloneNode(!0);
                ((g.id = p),
                  g.querySelectorAll("path, circle, line").forEach((b) => {
                    (b.setAttribute("stroke", o),
                      l.fill && b.setAttribute("fill", o));
                  }),
                  m.parentNode?.appendChild(g));
              }
            }
            e.attr(`marker-${t}`, `url(${n}#${p})`);
          } else e.attr(`marker-${t}`, `url(${n}#${f})`);
        }, "addEdgeMarker")));
    });
  function Qb(e, t) {
    K().flowchart.htmlLabels &&
      e &&
      ((e.style.width = t.length * 9 + "px"), (e.style.height = "12px"));
  }
  function ekt(e) {
    let t = [],
      r = [];
    for (let n = 1; n < e.length - 1; n++) {
      let i = e[n - 1],
        s = e[n],
        o = e[n + 1];
      ((i.x === s.x &&
        s.y === o.y &&
        Math.abs(s.x - o.x) > 5 &&
        Math.abs(s.y - i.y) > 5) ||
        (i.y === s.y &&
          s.x === o.x &&
          Math.abs(s.x - i.x) > 5 &&
          Math.abs(s.y - o.y) > 5)) &&
        (t.push(s), r.push(n));
    }
    return { cornerPoints: t, cornerPointPositions: r };
  }
  var Zb,
    ii,
    gU,
    $0,
    Jb,
    tk,
    Jbt,
    tkt,
    pU,
    mU,
    rkt,
    ek,
    OA = x(() => {
      "use strict";
      pe();
      Be();
      Vt();
      Ga();
      _e();
      MA();
      F0();
      Ge();
      oe();
      Ub();
      dU();
      re();
      ((Zb = new Map()),
        (ii = new Map()),
        (gU = a(() => {
          (Zb.clear(), ii.clear());
        }, "clear")),
        ($0 = a(
          (e) => (e ? e.reduce((r, n) => r + ";" + n, "") : ""),
          "getLabelStyles",
        )),
        (Jb = a(async (e, t) => {
          let r = Pe(K().flowchart.htmlLabels),
            n = await Kn(e, t.label, {
              style: $0(t.labelStyle),
              useHtmlLabels: r,
              addSvgBackground: !0,
              isNode: !1,
            });
          P.info("abc82", t, t.labelType);
          let i = e.insert("g").attr("class", "edgeLabel"),
            s = i.insert("g").attr("class", "label");
          s.node().appendChild(n);
          let o = n.getBBox();
          if (r) {
            let u = n.children[0],
              h = xt(n);
            ((o = u.getBoundingClientRect()),
              h.attr("width", o.width),
              h.attr("height", o.height));
          }
          (s.attr(
            "transform",
            "translate(" + -o.width / 2 + ", " + -o.height / 2 + ")",
          ),
            Zb.set(t.id, i),
            (t.width = o.width),
            (t.height = o.height));
          let l;
          if (t.startLabelLeft) {
            let u = await So(t.startLabelLeft, $0(t.labelStyle)),
              h = e.insert("g").attr("class", "edgeTerminals"),
              f = h.insert("g").attr("class", "inner");
            l = f.node().appendChild(u);
            let d = u.getBBox();
            (f.attr(
              "transform",
              "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")",
            ),
              ii.get(t.id) || ii.set(t.id, {}),
              (ii.get(t.id).startLeft = h),
              Qb(l, t.startLabelLeft));
          }
          if (t.startLabelRight) {
            let u = await So(t.startLabelRight, $0(t.labelStyle)),
              h = e.insert("g").attr("class", "edgeTerminals"),
              f = h.insert("g").attr("class", "inner");
            ((l = h.node().appendChild(u)), f.node().appendChild(u));
            let d = u.getBBox();
            (f.attr(
              "transform",
              "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")",
            ),
              ii.get(t.id) || ii.set(t.id, {}),
              (ii.get(t.id).startRight = h),
              Qb(l, t.startLabelRight));
          }
          if (t.endLabelLeft) {
            let u = await So(t.endLabelLeft, $0(t.labelStyle)),
              h = e.insert("g").attr("class", "edgeTerminals"),
              f = h.insert("g").attr("class", "inner");
            l = f.node().appendChild(u);
            let d = u.getBBox();
            (f.attr(
              "transform",
              "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")",
            ),
              h.node().appendChild(u),
              ii.get(t.id) || ii.set(t.id, {}),
              (ii.get(t.id).endLeft = h),
              Qb(l, t.endLabelLeft));
          }
          if (t.endLabelRight) {
            let u = await So(t.endLabelRight, $0(t.labelStyle)),
              h = e.insert("g").attr("class", "edgeTerminals"),
              f = h.insert("g").attr("class", "inner");
            l = f.node().appendChild(u);
            let d = u.getBBox();
            (f.attr(
              "transform",
              "translate(" + -d.width / 2 + ", " + -d.height / 2 + ")",
            ),
              h.node().appendChild(u),
              ii.get(t.id) || ii.set(t.id, {}),
              (ii.get(t.id).endRight = h),
              Qb(l, t.endLabelRight));
          }
          return n;
        }, "insertEdgeLabel")));
      a(Qb, "setTerminalWidth");
      ((tk = a((e, t) => {
        P.debug("Moving label abc88 ", e.id, e.label, Zb.get(e.id), t);
        let r = t.updatedPath ? t.updatedPath : t.originalPath,
          n = K(),
          { subGraphTitleTotalMargin: i } = Tl(n);
        if (e.label) {
          let s = Zb.get(e.id),
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcLabelPosition(r);
            (P.debug(
              "Moving label " + e.label + " from (",
              o,
              ",",
              l,
              ") to (",
              u.x,
              ",",
              u.y,
              ") abc88",
            ),
              t.updatedPath && ((o = u.x), (l = u.y)));
          }
          s.attr("transform", `translate(${o}, ${l + i / 2})`);
        }
        if (e.startLabelLeft) {
          let s = ii.get(e.id).startLeft,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeStart ? 10 : 0,
              "start_left",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
        if (e.startLabelRight) {
          let s = ii.get(e.id).startRight,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeStart ? 10 : 0,
              "start_right",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
        if (e.endLabelLeft) {
          let s = ii.get(e.id).endLeft,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeEnd ? 10 : 0,
              "end_left",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
        if (e.endLabelRight) {
          let s = ii.get(e.id).endRight,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeEnd ? 10 : 0,
              "end_right",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
      }, "positionEdgeLabel")),
        (Jbt = a((e, t) => {
          let r = e.x,
            n = e.y,
            i = Math.abs(t.x - r),
            s = Math.abs(t.y - n),
            o = e.width / 2,
            l = e.height / 2;
          return i >= o || s >= l;
        }, "outsideNode")),
        (tkt = a((e, t, r) => {
          P.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
          let n = e.x,
            i = e.y,
            s = Math.abs(n - r.x),
            o = e.width / 2,
            l = r.x < t.x ? o - s : o + s,
            u = e.height / 2,
            h = Math.abs(t.y - r.y),
            f = Math.abs(t.x - r.x);
          if (Math.abs(i - t.y) * o > Math.abs(n - t.x) * u) {
            let d = r.y < t.y ? t.y - u - i : i - u - t.y;
            l = (f * d) / h;
            let p = {
              x: r.x < t.x ? r.x + l : r.x - f + l,
              y: r.y < t.y ? r.y + h - d : r.y - h + d,
            };
            return (
              l === 0 && ((p.x = t.x), (p.y = t.y)),
              f === 0 && (p.x = t.x),
              h === 0 && (p.y = t.y),
              P.debug(
                `abc89 top/bottom calc, Q ${h}, q ${d}, R ${f}, r ${l}`,
                p,
              ),
              p
            );
          } else {
            r.x < t.x ? (l = t.x - o - n) : (l = n - o - t.x);
            let d = (h * l) / f,
              p = r.x < t.x ? r.x + f - l : r.x - f + l,
              m = r.y < t.y ? r.y + d : r.y - d;
            return (
              P.debug(`sides calc abc89, Q ${h}, q ${d}, R ${f}, r ${l}`, {
                _x: p,
                _y: m,
              }),
              l === 0 && ((p = t.x), (m = t.y)),
              f === 0 && (p = t.x),
              h === 0 && (m = t.y),
              { x: p, y: m }
            );
          }
        }, "intersection")),
        (pU = a((e, t) => {
          P.warn("abc88 cutPathAtIntersect", e, t);
          let r = [],
            n = e[0],
            i = !1;
          return (
            e.forEach((s) => {
              if ((P.info("abc88 checking point", s, t), !Jbt(t, s) && !i)) {
                let o = tkt(t, n, s);
                (P.debug("abc88 inside", s, n, o),
                  P.debug("abc88 intersection", o, t));
                let l = !1;
                (r.forEach((u) => {
                  l = l || (u.x === o.x && u.y === o.y);
                }),
                  r.some((u) => u.x === o.x && u.y === o.y)
                    ? P.warn("abc88 no intersect", o, r)
                    : r.push(o),
                  (i = !0));
              } else (P.warn("abc88 outside", s, n), (n = s), i || r.push(s));
            }),
            P.debug("returning points", r),
            r
          );
        }, "cutPathAtIntersect")));
      a(ekt, "extractCornerPoints");
      ((mU = a(function (e, t, r) {
        let n = t.x - e.x,
          i = t.y - e.y,
          s = Math.sqrt(n * n + i * i),
          o = r / s;
        return { x: t.x - o * n, y: t.y - o * i };
      }, "findAdjacentPoint")),
        (rkt = a(function (e) {
          let { cornerPointPositions: t } = ekt(e),
            r = [];
          for (let n = 0; n < e.length; n++)
            if (t.includes(n)) {
              let i = e[n - 1],
                s = e[n + 1],
                o = e[n],
                l = mU(i, o, 5),
                u = mU(s, o, 5),
                h = u.x - l.x,
                f = u.y - l.y;
              r.push(l);
              let d = Math.sqrt(2) * 2,
                p = { x: o.x, y: o.y };
              if (Math.abs(s.x - i.x) > 10 && Math.abs(s.y - i.y) >= 10) {
                P.debug(
                  "Corner point fixing",
                  Math.abs(s.x - i.x),
                  Math.abs(s.y - i.y),
                );
                let m = 5;
                o.x === l.x
                  ? (p = {
                      x: h < 0 ? l.x - m + d : l.x + m - d,
                      y: f < 0 ? l.y - d : l.y + d,
                    })
                  : (p = {
                      x: h < 0 ? l.x - d : l.x + d,
                      y: f < 0 ? l.y - m + d : l.y + m - d,
                    });
              } else
                P.debug(
                  "Corner point skipping fixing",
                  Math.abs(s.x - i.x),
                  Math.abs(s.y - i.y),
                );
              r.push(p, u);
            } else r.push(e[n]);
          return r;
        }, "fixCorners")),
        (ek = a(function (e, t, r, n, i, s, o) {
          let { handDrawnSeed: l } = K(),
            u = t.points,
            h = !1,
            f = i;
          var d = s;
          let p = [];
          for (let S in t.cssCompiledStyles)
            D0(S) || p.push(t.cssCompiledStyles[S]);
          (d.intersect &&
            f.intersect &&
            ((u = u.slice(1, t.points.length - 1)),
            u.unshift(f.intersect(u[0])),
            P.debug(
              "Last point APA12",
              t.start,
              "-->",
              t.end,
              u[u.length - 1],
              d,
              d.intersect(u[u.length - 1]),
            ),
            u.push(d.intersect(u[u.length - 1]))),
            t.toCluster &&
              (P.info("to cluster abc88", r.get(t.toCluster)),
              (u = pU(t.points, r.get(t.toCluster).node)),
              (h = !0)),
            t.fromCluster &&
              (P.debug(
                "from cluster abc88",
                r.get(t.fromCluster),
                JSON.stringify(u, null, 2),
              ),
              (u = pU(u.reverse(), r.get(t.fromCluster).node).reverse()),
              (h = !0)));
          let m = u.filter((S) => !Number.isNaN(S.y));
          m = rkt(m);
          let g = Ys;
          switch (((g = hl), t.curve)) {
            case "linear":
              g = hl;
              break;
            case "basis":
              g = Ys;
              break;
            case "cardinal":
              g = Qg;
              break;
            case "bumpX":
              g = qg;
              break;
            case "bumpY":
              g = Hg;
              break;
            case "catmullRom":
              g = t0;
              break;
            case "monotoneX":
              g = e0;
              break;
            case "monotoneY":
              g = r0;
              break;
            case "natural":
              g = $f;
              break;
            case "step":
              g = Gf;
              break;
            case "stepAfter":
              g = i0;
              break;
            case "stepBefore":
              g = n0;
              break;
            default:
              g = Ys;
          }
          let { x: y, y: b } = Kb(t),
            k = Oa().x(y).y(b).curve(g),
            T;
          switch (t.thickness) {
            case "normal":
              T = "edge-thickness-normal";
              break;
            case "thick":
              T = "edge-thickness-thick";
              break;
            case "invisible":
              T = "edge-thickness-invisible";
              break;
            default:
              T = "edge-thickness-normal";
          }
          switch (t.pattern) {
            case "solid":
              T += " edge-pattern-solid";
              break;
            case "dotted":
              T += " edge-pattern-dotted";
              break;
            case "dashed":
              T += " edge-pattern-dashed";
              break;
            default:
              T += " edge-pattern-solid";
          }
          let C,
            L = k(m),
            w = Array.isArray(t.style) ? t.style : t.style ? [t.style] : [],
            D = w.find((S) => S?.startsWith("stroke:"));
          if (t.look === "handDrawn") {
            let S = wt.svg(e);
            Object.assign([], m);
            let O = S.path(L, { roughness: 0.3, seed: l });
            ((T += " transition"),
              (C = xt(O)
                .select("path")
                .attr("id", t.id)
                .attr("class", " " + T + (t.classes ? " " + t.classes : ""))
                .attr("style", w ? w.reduce((_, A) => _ + ";" + A, "") : "")));
            let v = C.attr("d");
            (C.attr("d", v), e.node().appendChild(C.node()));
          } else {
            let S = p.join(";"),
              O = w ? w.reduce((A, N) => A + N + ";", "") : "",
              v = "";
            (t.animate && (v = " edge-animation-fast"),
              t.animation && (v = " edge-animation-" + t.animation));
            let _ = S ? S + ";" + O + ";" : O;
            ((C = e
              .append("path")
              .attr("d", L)
              .attr("id", t.id)
              .attr(
                "class",
                " " + T + (t.classes ? " " + t.classes : "") + (v ?? ""),
              )
              .attr("style", _)),
              (D = _.match(/stroke:([^;]+)/)?.[1]));
          }
          let G = "";
          ((K().flowchart.arrowMarkerAbsolute ||
            K().state.arrowMarkerAbsolute) &&
            (G = tl(!0)),
            P.info("arrowTypeStart", t.arrowTypeStart),
            P.info("arrowTypeEnd", t.arrowTypeEnd),
            fU(C, t, G, o, n, D));
          let E = Math.floor(u.length / 2),
            R = u[E];
          le.isLabelCoordinateInPath(R, C.attr("d")) || (h = !0);
          let F = {};
          return (h && (F.updatedPath = u), (F.originalPath = t.points), F);
        }, "insertEdge")));
    });
  var nkt,
    ikt,
    skt,
    akt,
    okt,
    lkt,
    ckt,
    ukt,
    hkt,
    fkt,
    dkt,
    pkt,
    mkt,
    gkt,
    ykt,
    xkt,
    bkt,
    rk,
    PA = x(() => {
      "use strict";
      Vt();
      ((nkt = a((e, t, r, n) => {
        t.forEach((i) => {
          bkt[i](e, r, n);
        });
      }, "insertMarkers")),
        (ikt = a((e, t, r) => {
          (P.trace("Making markers for ", r),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-extensionStart")
              .attr("class", "marker extension " + t)
              .attr("refX", 18)
              .attr("refY", 7)
              .attr("markerWidth", 190)
              .attr("markerHeight", 240)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 1,7 L18,13 V 1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-extensionEnd")
              .attr("class", "marker extension " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 1,1 V 13 L18,7 Z"));
        }, "extension")),
        (skt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-compositionStart")
            .attr("class", "marker composition " + t)
            .attr("refX", 18)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-compositionEnd")
              .attr("class", "marker composition " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"));
        }, "composition")),
        (akt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-aggregationStart")
            .attr("class", "marker aggregation " + t)
            .attr("refX", 18)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-aggregationEnd")
              .attr("class", "marker aggregation " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"));
        }, "aggregation")),
        (okt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-dependencyStart")
            .attr("class", "marker dependency " + t)
            .attr("refX", 6)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-dependencyEnd")
              .attr("class", "marker dependency " + t)
              .attr("refX", 13)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 18,7 L9,13 L14,7 L9,1 Z"));
        }, "dependency")),
        (lkt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-lollipopStart")
            .attr("class", "marker lollipop " + t)
            .attr("refX", 13)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("circle")
            .attr("stroke", "black")
            .attr("fill", "transparent")
            .attr("cx", 7)
            .attr("cy", 7)
            .attr("r", 6),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-lollipopEnd")
              .attr("class", "marker lollipop " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 190)
              .attr("markerHeight", 240)
              .attr("orient", "auto")
              .append("circle")
              .attr("stroke", "black")
              .attr("fill", "transparent")
              .attr("cx", 7)
              .attr("cy", 7)
              .attr("r", 6));
        }, "lollipop")),
        (ckt = a((e, t, r) => {
          (e
            .append("marker")
            .attr("id", r + "_" + t + "-pointEnd")
            .attr("class", "marker " + t)
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 5)
            .attr("refY", 5)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 8)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .attr("class", "arrowMarkerPath")
            .style("stroke-width", 1)
            .style("stroke-dasharray", "1,0"),
            e
              .append("marker")
              .attr("id", r + "_" + t + "-pointStart")
              .attr("class", "marker " + t)
              .attr("viewBox", "0 0 10 10")
              .attr("refX", 4.5)
              .attr("refY", 5)
              .attr("markerUnits", "userSpaceOnUse")
              .attr("markerWidth", 8)
              .attr("markerHeight", 8)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 0 5 L 10 10 L 10 0 z")
              .attr("class", "arrowMarkerPath")
              .style("stroke-width", 1)
              .style("stroke-dasharray", "1,0"));
        }, "point")),
        (ukt = a((e, t, r) => {
          (e
            .append("marker")
            .attr("id", r + "_" + t + "-circleEnd")
            .attr("class", "marker " + t)
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 11)
            .attr("refY", 5)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 11)
            .attr("markerHeight", 11)
            .attr("orient", "auto")
            .append("circle")
            .attr("cx", "5")
            .attr("cy", "5")
            .attr("r", "5")
            .attr("class", "arrowMarkerPath")
            .style("stroke-width", 1)
            .style("stroke-dasharray", "1,0"),
            e
              .append("marker")
              .attr("id", r + "_" + t + "-circleStart")
              .attr("class", "marker " + t)
              .attr("viewBox", "0 0 10 10")
              .attr("refX", -1)
              .attr("refY", 5)
              .attr("markerUnits", "userSpaceOnUse")
              .attr("markerWidth", 11)
              .attr("markerHeight", 11)
              .attr("orient", "auto")
              .append("circle")
              .attr("cx", "5")
              .attr("cy", "5")
              .attr("r", "5")
              .attr("class", "arrowMarkerPath")
              .style("stroke-width", 1)
              .style("stroke-dasharray", "1,0"));
        }, "circle")),
        (hkt = a((e, t, r) => {
          (e
            .append("marker")
            .attr("id", r + "_" + t + "-crossEnd")
            .attr("class", "marker cross " + t)
            .attr("viewBox", "0 0 11 11")
            .attr("refX", 12)
            .attr("refY", 5.2)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 11)
            .attr("markerHeight", 11)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 1,1 l 9,9 M 10,1 l -9,9")
            .attr("class", "arrowMarkerPath")
            .style("stroke-width", 2)
            .style("stroke-dasharray", "1,0"),
            e
              .append("marker")
              .attr("id", r + "_" + t + "-crossStart")
              .attr("class", "marker cross " + t)
              .attr("viewBox", "0 0 11 11")
              .attr("refX", -1)
              .attr("refY", 5.2)
              .attr("markerUnits", "userSpaceOnUse")
              .attr("markerWidth", 11)
              .attr("markerHeight", 11)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 1,1 l 9,9 M 10,1 l -9,9")
              .attr("class", "arrowMarkerPath")
              .style("stroke-width", 2)
              .style("stroke-dasharray", "1,0"));
        }, "cross")),
        (fkt = a((e, t, r) => {
          e.append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-barbEnd")
            .attr("refX", 19)
            .attr("refY", 7)
            .attr("markerWidth", 20)
            .attr("markerHeight", 14)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
        }, "barb")),
        (dkt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-onlyOneStart")
            .attr("class", "marker onlyOne " + t)
            .attr("refX", 0)
            .attr("refY", 9)
            .attr("markerWidth", 18)
            .attr("markerHeight", 18)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M9,0 L9,18 M15,0 L15,18"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-onlyOneEnd")
              .attr("class", "marker onlyOne " + t)
              .attr("refX", 18)
              .attr("refY", 9)
              .attr("markerWidth", 18)
              .attr("markerHeight", 18)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M3,0 L3,18 M9,0 L9,18"));
        }, "only_one")),
        (pkt = a((e, t, r) => {
          let n = e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-zeroOrOneStart")
            .attr("class", "marker zeroOrOne " + t)
            .attr("refX", 0)
            .attr("refY", 9)
            .attr("markerWidth", 30)
            .attr("markerHeight", 18)
            .attr("orient", "auto");
          (n
            .append("circle")
            .attr("fill", "white")
            .attr("cx", 21)
            .attr("cy", 9)
            .attr("r", 6),
            n.append("path").attr("d", "M9,0 L9,18"));
          let i = e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-zeroOrOneEnd")
            .attr("class", "marker zeroOrOne " + t)
            .attr("refX", 30)
            .attr("refY", 9)
            .attr("markerWidth", 30)
            .attr("markerHeight", 18)
            .attr("orient", "auto");
          (i
            .append("circle")
            .attr("fill", "white")
            .attr("cx", 9)
            .attr("cy", 9)
            .attr("r", 6),
            i.append("path").attr("d", "M21,0 L21,18"));
        }, "zero_or_one")),
        (mkt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-oneOrMoreStart")
            .attr("class", "marker oneOrMore " + t)
            .attr("refX", 18)
            .attr("refY", 18)
            .attr("markerWidth", 45)
            .attr("markerHeight", 36)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M0,18 Q 18,0 36,18 Q 18,36 0,18 M42,9 L42,27"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-oneOrMoreEnd")
              .attr("class", "marker oneOrMore " + t)
              .attr("refX", 27)
              .attr("refY", 18)
              .attr("markerWidth", 45)
              .attr("markerHeight", 36)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M3,9 L3,27 M9,18 Q27,0 45,18 Q27,36 9,18"));
        }, "one_or_more")),
        (gkt = a((e, t, r) => {
          let n = e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-zeroOrMoreStart")
            .attr("class", "marker zeroOrMore " + t)
            .attr("refX", 18)
            .attr("refY", 18)
            .attr("markerWidth", 57)
            .attr("markerHeight", 36)
            .attr("orient", "auto");
          (n
            .append("circle")
            .attr("fill", "white")
            .attr("cx", 48)
            .attr("cy", 18)
            .attr("r", 6),
            n.append("path").attr("d", "M0,18 Q18,0 36,18 Q18,36 0,18"));
          let i = e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-zeroOrMoreEnd")
            .attr("class", "marker zeroOrMore " + t)
            .attr("refX", 39)
            .attr("refY", 18)
            .attr("markerWidth", 57)
            .attr("markerHeight", 36)
            .attr("orient", "auto");
          (i
            .append("circle")
            .attr("fill", "white")
            .attr("cx", 9)
            .attr("cy", 18)
            .attr("r", 6),
            i.append("path").attr("d", "M21,18 Q39,0 57,18 Q39,36 21,18"));
        }, "zero_or_more")),
        (ykt = a((e, t, r) => {
          e.append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-requirement_arrowEnd")
            .attr("refX", 20)
            .attr("refY", 10)
            .attr("markerWidth", 20)
            .attr("markerHeight", 20)
            .attr("orient", "auto")
            .append("path")
            .attr(
              "d",
              `M0,0
      L20,10
      M20,10
      L0,20`,
            );
        }, "requirement_arrow")),
        (xkt = a((e, t, r) => {
          let n = e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-requirement_containsStart")
            .attr("refX", 0)
            .attr("refY", 10)
            .attr("markerWidth", 20)
            .attr("markerHeight", 20)
            .attr("orient", "auto")
            .append("g");
          (n
            .append("circle")
            .attr("cx", 10)
            .attr("cy", 10)
            .attr("r", 9)
            .attr("fill", "none"),
            n
              .append("line")
              .attr("x1", 1)
              .attr("x2", 19)
              .attr("y1", 10)
              .attr("y2", 10),
            n
              .append("line")
              .attr("y1", 1)
              .attr("y2", 19)
              .attr("x1", 10)
              .attr("x2", 10));
        }, "requirement_contains")),
        (bkt = {
          extension: ikt,
          composition: skt,
          aggregation: akt,
          dependency: okt,
          lollipop: lkt,
          point: ckt,
          circle: ukt,
          cross: hkt,
          barb: fkt,
          only_one: dkt,
          zero_or_one: pkt,
          one_or_more: mkt,
          zero_or_more: gkt,
          requirement_arrow: ykt,
          requirement_contains: xkt,
        }),
        (rk = nkt));
    });
  async function dd(e, t, r) {
    let n, i;
    t.shape === "rect" &&
      (t.rx && t.ry ? (t.shape = "roundedRect") : (t.shape = "squareRect"));
    let s = t.shape ? NA[t.shape] : void 0;
    if (!s)
      throw new Error(`No such shape: ${t.shape}. Please check your syntax.`);
    if (t.link) {
      let o;
      (r.config.securityLevel === "sandbox"
        ? (o = "_top")
        : t.linkTarget && (o = t.linkTarget || "_blank"),
        (n = e
          .insert("svg:a")
          .attr("xlink:href", t.link)
          .attr("target", o ?? null)),
        (i = await s(n, t, r)));
    } else ((i = await s(e, t, r)), (n = i));
    return (
      t.tooltip && i.attr("title", t.tooltip),
      nk.set(t.id, n),
      t.haveCallback && n.attr("class", n.attr("class") + " clickable"),
      n
    );
  }
  var nk,
    yU,
    xU,
    G0,
    ik = x(() => {
      "use strict";
      Vt();
      IA();
      nk = new Map();
      a(dd, "insertNode");
      ((yU = a((e, t) => {
        nk.set(t.id, e);
      }, "setNodeElem")),
        (xU = a(() => {
          nk.clear();
        }, "clear")),
        (G0 = a((e) => {
          let t = nk.get(e.id);
          P.trace(
            "Transforming node",
            e.diff,
            e,
            "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")",
          );
          let r = 8,
            n = e.diff || 0;
          return (
            e.clusterNode
              ? t.attr(
                  "transform",
                  "translate(" +
                    (e.x + n - e.width / 2) +
                    ", " +
                    (e.y - e.height / 2 - r) +
                    ")",
                )
              : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"),
            n
          );
        }, "positionNode")));
    });
  var bU,
    kU = x(() => {
      "use strict";
      un();
      Be();
      Vt();
      Yb();
      OA();
      PA();
      ik();
      Qt();
      _e();
      bU = {
        common: Rt,
        getConfig: ke,
        insertCluster: fd,
        insertEdge: ek,
        insertEdgeLabel: Jb,
        insertMarkers: rk,
        insertNode: dd,
        interpolateToCurve: w4,
        labelHelper: Bt,
        log: P,
        positionEdgeLabel: tk,
      };
    });
  function Tkt(e) {
    return typeof e == "symbol" || (an(e) && ni(e) == kkt);
  }
  var kkt,
    Rs,
    nh = x(() => {
      "use strict";
      dl();
      Qs();
      kkt = "[object Symbol]";
      a(Tkt, "isSymbol");
      Rs = Tkt;
    });
  function Skt(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = Array(n); ++r < n; )
      i[r] = t(e[r], r, e);
    return i;
  }
  var hs,
    ih = x(() => {
      "use strict";
      a(Skt, "arrayMap");
      hs = Skt;
    });
  function _U(e) {
    if (typeof e == "string") return e;
    if (Jt(e)) return hs(e, _U) + "";
    if (Rs(e)) return SU ? SU.call(e) : "";
    var t = e + "";
    return t == "0" && 1 / e == -_kt ? "-0" : t;
  }
  var _kt,
    TU,
    SU,
    CU,
    wU = x(() => {
      "use strict";
      zu();
      ih();
      Kr();
      nh();
      ((_kt = 1 / 0),
        (TU = qn ? qn.prototype : void 0),
        (SU = TU ? TU.toString : void 0));
      a(_U, "baseToString");
      CU = _U;
    });
  function wkt(e) {
    for (var t = e.length; t-- && Ckt.test(e.charAt(t)); );
    return t;
  }
  var Ckt,
    vU,
    EU = x(() => {
      "use strict";
      Ckt = /\s/;
      a(wkt, "trimmedEndIndex");
      vU = wkt;
    });
  function Ekt(e) {
    return e && e.slice(0, vU(e) + 1).replace(vkt, "");
  }
  var vkt,
    AU,
    LU = x(() => {
      "use strict";
      EU();
      vkt = /^\s+/;
      a(Ekt, "baseTrim");
      AU = Ekt;
    });
  function Nkt(e) {
    if (typeof e == "number") return e;
    if (Rs(e)) return RU;
    if (Nr(e)) {
      var t = typeof e.valueOf == "function" ? e.valueOf() : e;
      e = Nr(t) ? t + "" : t;
    }
    if (typeof e != "string") return e === 0 ? e : +e;
    e = AU(e);
    var r = Lkt.test(e);
    return r || Rkt.test(e)
      ? Dkt(e.slice(2), r ? 2 : 8)
      : Akt.test(e)
        ? RU
        : +e;
  }
  var RU,
    Akt,
    Lkt,
    Rkt,
    Dkt,
    DU,
    NU = x(() => {
      "use strict";
      LU();
      Es();
      nh();
      ((RU = NaN),
        (Akt = /^[-+]0x[0-9a-f]+$/i),
        (Lkt = /^0b[01]+$/i),
        (Rkt = /^0o[0-7]+$/i),
        (Dkt = parseInt));
      a(Nkt, "toNumber");
      DU = Nkt;
    });
  function Mkt(e) {
    if (!e) return e === 0 ? e : 0;
    if (((e = DU(e)), e === IU || e === -IU)) {
      var t = e < 0 ? -1 : 1;
      return t * Ikt;
    }
    return e === e ? e : 0;
  }
  var IU,
    Ikt,
    pd,
    BA = x(() => {
      "use strict";
      NU();
      ((IU = 1 / 0), (Ikt = 17976931348623157e292));
      a(Mkt, "toFinite");
      pd = Mkt;
    });
  function Okt(e) {
    var t = pd(e),
      r = t % 1;
    return t === t ? (r ? t - r : t) : 0;
  }
  var Co,
    md = x(() => {
      "use strict";
      BA();
      a(Okt, "toInteger");
      Co = Okt;
    });
  var Pkt,
    sk,
    MU = x(() => {
      "use strict";
      fc();
      Xs();
      ((Pkt = rs(fn, "WeakMap")), (sk = Pkt));
    });
  function Bkt() {}
  var ln,
    FA = x(() => {
      "use strict";
      a(Bkt, "noop");
      ln = Bkt;
    });
  function Fkt(e, t) {
    for (
      var r = -1, n = e == null ? 0 : e.length;
      ++r < n && t(e[r], r, e) !== !1;

    );
    return e;
  }
  var ak,
    $A = x(() => {
      "use strict";
      a(Fkt, "arrayEach");
      ak = Fkt;
    });
  function $kt(e, t, r, n) {
    for (var i = e.length, s = r + (n ? 1 : -1); n ? s-- : ++s < i; )
      if (t(e[s], s, e)) return s;
    return -1;
  }
  var ok,
    GA = x(() => {
      "use strict";
      a($kt, "baseFindIndex");
      ok = $kt;
    });
  function Gkt(e) {
    return e !== e;
  }
  var OU,
    PU = x(() => {
      "use strict";
      a(Gkt, "baseIsNaN");
      OU = Gkt;
    });
  function Vkt(e, t, r) {
    for (var n = r - 1, i = e.length; ++n < i; ) if (e[n] === t) return n;
    return -1;
  }
  var BU,
    FU = x(() => {
      "use strict";
      a(Vkt, "strictIndexOf");
      BU = Vkt;
    });
  function zkt(e, t, r) {
    return t === t ? BU(e, t, r) : ok(e, OU, r);
  }
  var gd,
    lk = x(() => {
      "use strict";
      GA();
      PU();
      FU();
      a(zkt, "baseIndexOf");
      gd = zkt;
    });
  function Wkt(e, t) {
    var r = e == null ? 0 : e.length;
    return !!r && gd(e, t, 0) > -1;
  }
  var ck,
    VA = x(() => {
      "use strict";
      lk();
      a(Wkt, "arrayIncludes");
      ck = Wkt;
    });
  var Ukt,
    $U,
    GU = x(() => {
      "use strict";
      f4();
      ((Ukt = nb(Object.keys, Object)), ($U = Ukt));
    });
  function Hkt(e) {
    if (!mo(e)) return $U(e);
    var t = [];
    for (var r in Object(e)) qkt.call(e, r) && r != "constructor" && t.push(r);
    return t;
  }
  var jkt,
    qkt,
    yd,
    uk = x(() => {
      "use strict";
      Jf();
      GU();
      ((jkt = Object.prototype), (qkt = jkt.hasOwnProperty));
      a(Hkt, "baseKeys");
      yd = Hkt;
    });
  function Ykt(e) {
    return dn(e) ? lb(e) : yd(e);
  }
  var cr,
    wo = x(() => {
      "use strict";
      y4();
      uk();
      Zs();
      a(Ykt, "keys");
      cr = Ykt;
    });
  var Xkt,
    Kkt,
    Qkt,
    si,
    VU = x(() => {
      "use strict";
      nd();
      Hu();
      T4();
      Zs();
      Jf();
      wo();
      ((Xkt = Object.prototype),
        (Kkt = Xkt.hasOwnProperty),
        (Qkt = hb(function (e, t) {
          if (mo(t) || dn(t)) {
            ea(t, cr(t), e);
            return;
          }
          for (var r in t) Kkt.call(t, r) && go(e, r, t[r]);
        })),
        (si = Qkt));
    });
  function tTt(e, t) {
    if (Jt(e)) return !1;
    var r = typeof e;
    return r == "number" ||
      r == "symbol" ||
      r == "boolean" ||
      e == null ||
      Rs(e)
      ? !0
      : Jkt.test(e) || !Zkt.test(e) || (t != null && e in Object(t));
  }
  var Zkt,
    Jkt,
    xd,
    hk = x(() => {
      "use strict";
      Kr();
      nh();
      ((Zkt = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/),
        (Jkt = /^\w*$/));
      a(tTt, "isKey");
      xd = tTt;
    });
  function rTt(e) {
    var t = jf(e, function (n) {
        return (r.size === eTt && r.clear(), n);
      }),
      r = t.cache;
    return t;
  }
  var eTt,
    zU,
    WU = x(() => {
      "use strict";
      s4();
      eTt = 500;
      a(rTt, "memoizeCapped");
      zU = rTt;
    });
  var nTt,
    iTt,
    sTt,
    UU,
    jU = x(() => {
      "use strict";
      WU();
      ((nTt =
        /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g),
        (iTt = /\\(\\)?/g),
        (sTt = zU(function (e) {
          var t = [];
          return (
            e.charCodeAt(0) === 46 && t.push(""),
            e.replace(nTt, function (r, n, i, s) {
              t.push(i ? s.replace(iTt, "$1") : n || r);
            }),
            t
          );
        })),
        (UU = sTt));
    });
  function aTt(e) {
    return e == null ? "" : CU(e);
  }
  var fk,
    zA = x(() => {
      "use strict";
      wU();
      a(aTt, "toString");
      fk = aTt;
    });
  function oTt(e, t) {
    return Jt(e) ? e : xd(e, t) ? [e] : UU(fk(e));
  }
  var Dc,
    V0 = x(() => {
      "use strict";
      Kr();
      hk();
      jU();
      zA();
      a(oTt, "castPath");
      Dc = oTt;
    });
  function cTt(e) {
    if (typeof e == "string" || Rs(e)) return e;
    var t = e + "";
    return t == "0" && 1 / e == -lTt ? "-0" : t;
  }
  var lTt,
    vo,
    bd = x(() => {
      "use strict";
      nh();
      lTt = 1 / 0;
      a(cTt, "toKey");
      vo = cTt;
    });
  function uTt(e, t) {
    t = Dc(t, e);
    for (var r = 0, n = t.length; e != null && r < n; ) e = e[vo(t[r++])];
    return r && r == n ? e : void 0;
  }
  var Nc,
    z0 = x(() => {
      "use strict";
      V0();
      bd();
      a(uTt, "baseGet");
      Nc = uTt;
    });
  function hTt(e, t, r) {
    var n = e == null ? void 0 : Nc(e, t);
    return n === void 0 ? r : n;
  }
  var qU,
    HU = x(() => {
      "use strict";
      z0();
      a(hTt, "get");
      qU = hTt;
    });
  function fTt(e, t) {
    for (var r = -1, n = t.length, i = e.length; ++r < n; ) e[i + r] = t[r];
    return e;
  }
  var kd,
    dk = x(() => {
      "use strict";
      a(fTt, "arrayPush");
      kd = fTt;
    });
  function dTt(e) {
    return Jt(e) || Ba(e) || !!(YU && e && e[YU]);
  }
  var YU,
    XU,
    KU = x(() => {
      "use strict";
      zu();
      td();
      Kr();
      YU = qn ? qn.isConcatSpreadable : void 0;
      a(dTt, "isFlattenable");
      XU = dTt;
    });
  function QU(e, t, r, n, i) {
    var s = -1,
      o = e.length;
    for (r || (r = XU), i || (i = []); ++s < o; ) {
      var l = e[s];
      t > 0 && r(l)
        ? t > 1
          ? QU(l, t - 1, r, n, i)
          : kd(i, l)
        : n || (i[i.length] = l);
    }
    return i;
  }
  var Eo,
    Td = x(() => {
      "use strict";
      dk();
      KU();
      a(QU, "baseFlatten");
      Eo = QU;
    });
  function pTt(e) {
    var t = e == null ? 0 : e.length;
    return t ? Eo(e, 1) : [];
  }
  var dr,
    pk = x(() => {
      "use strict";
      Td();
      a(pTt, "flatten");
      dr = pTt;
    });
  function mTt(e) {
    return ub(cb(e, void 0, dr), e + "");
  }
  var ZU,
    JU = x(() => {
      "use strict";
      pk();
      x4();
      k4();
      a(mTt, "flatRest");
      ZU = mTt;
    });
  function gTt(e, t, r) {
    var n = -1,
      i = e.length;
    (t < 0 && (t = -t > i ? 0 : i + t),
      (r = r > i ? i : r),
      r < 0 && (r += i),
      (i = t > r ? 0 : (r - t) >>> 0),
      (t >>>= 0));
    for (var s = Array(i); ++n < i; ) s[n] = e[n + t];
    return s;
  }
  var mk,
    WA = x(() => {
      "use strict";
      a(gTt, "baseSlice");
      mk = gTt;
    });
  function wTt(e) {
    return CTt.test(e);
  }
  var yTt,
    xTt,
    bTt,
    kTt,
    TTt,
    STt,
    _Tt,
    CTt,
    tj,
    ej = x(() => {
      "use strict";
      ((yTt = "\\ud800-\\udfff"),
        (xTt = "\\u0300-\\u036f"),
        (bTt = "\\ufe20-\\ufe2f"),
        (kTt = "\\u20d0-\\u20ff"),
        (TTt = xTt + bTt + kTt),
        (STt = "\\ufe0e\\ufe0f"),
        (_Tt = "\\u200d"),
        (CTt = RegExp("[" + _Tt + yTt + TTt + STt + "]")));
      a(wTt, "hasUnicode");
      tj = wTt;
    });
  function vTt(e, t, r, n) {
    var i = -1,
      s = e == null ? 0 : e.length;
    for (n && s && (r = e[++i]); ++i < s; ) r = t(r, e[i], i, e);
    return r;
  }
  var rj,
    nj = x(() => {
      "use strict";
      a(vTt, "arrayReduce");
      rj = vTt;
    });
  function ETt(e, t) {
    return e && ea(t, cr(t), e);
  }
  var ij,
    sj = x(() => {
      "use strict";
      Hu();
      wo();
      a(ETt, "baseAssign");
      ij = ETt;
    });
  function ATt(e, t) {
    return e && ea(t, ns(t), e);
  }
  var aj,
    oj = x(() => {
      "use strict";
      Hu();
      bc();
      a(ATt, "baseAssignIn");
      aj = ATt;
    });
  function LTt(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length, i = 0, s = []; ++r < n; ) {
      var o = e[r];
      t(o, r, e) && (s[i++] = o);
    }
    return s;
  }
  var Sd,
    gk = x(() => {
      "use strict";
      a(LTt, "arrayFilter");
      Sd = LTt;
    });
  function RTt() {
    return [];
  }
  var yk,
    UA = x(() => {
      "use strict";
      a(RTt, "stubArray");
      yk = RTt;
    });
  var DTt,
    NTt,
    lj,
    ITt,
    _d,
    xk = x(() => {
      "use strict";
      gk();
      UA();
      ((DTt = Object.prototype),
        (NTt = DTt.propertyIsEnumerable),
        (lj = Object.getOwnPropertySymbols),
        (ITt = lj
          ? function (e) {
              return e == null
                ? []
                : ((e = Object(e)),
                  Sd(lj(e), function (t) {
                    return NTt.call(e, t);
                  }));
            }
          : yk),
        (_d = ITt));
    });
  function MTt(e, t) {
    return ea(e, _d(e), t);
  }
  var cj,
    uj = x(() => {
      "use strict";
      Hu();
      xk();
      a(MTt, "copySymbols");
      cj = MTt;
    });
  var OTt,
    PTt,
    bk,
    jA = x(() => {
      "use strict";
      dk();
      ib();
      xk();
      UA();
      ((OTt = Object.getOwnPropertySymbols),
        (PTt = OTt
          ? function (e) {
              for (var t = []; e; ) (kd(t, _d(e)), (e = Zf(e)));
              return t;
            }
          : yk),
        (bk = PTt));
    });
  function BTt(e, t) {
    return ea(e, bk(e), t);
  }
  var hj,
    fj = x(() => {
      "use strict";
      Hu();
      jA();
      a(BTt, "copySymbolsIn");
      hj = BTt;
    });
  function FTt(e, t, r) {
    var n = t(e);
    return Jt(e) ? n : kd(n, r(e));
  }
  var kk,
    qA = x(() => {
      "use strict";
      dk();
      Kr();
      a(FTt, "baseGetAllKeys");
      kk = FTt;
    });
  function $Tt(e) {
    return kk(e, cr, _d);
  }
  var W0,
    HA = x(() => {
      "use strict";
      qA();
      xk();
      wo();
      a($Tt, "getAllKeys");
      W0 = $Tt;
    });
  function GTt(e) {
    return kk(e, ns, bk);
  }
  var Tk,
    YA = x(() => {
      "use strict";
      qA();
      jA();
      bc();
      a(GTt, "getAllKeysIn");
      Tk = GTt;
    });
  var VTt,
    Sk,
    dj = x(() => {
      "use strict";
      fc();
      Xs();
      ((VTt = rs(fn, "DataView")), (Sk = VTt));
    });
  var zTt,
    _k,
    pj = x(() => {
      "use strict";
      fc();
      Xs();
      ((zTt = rs(fn, "Promise")), (_k = zTt));
    });
  var WTt,
    Ic,
    XA = x(() => {
      "use strict";
      fc();
      Xs();
      ((WTt = rs(fn, "Set")), (Ic = WTt));
    });
  var mj,
    UTt,
    gj,
    yj,
    xj,
    bj,
    jTt,
    qTt,
    HTt,
    YTt,
    XTt,
    sh,
    Ds,
    ah = x(() => {
      "use strict";
      dj();
      K2();
      pj();
      XA();
      MU();
      dl();
      r4();
      ((mj = "[object Map]"),
        (UTt = "[object Object]"),
        (gj = "[object Promise]"),
        (yj = "[object Set]"),
        (xj = "[object WeakMap]"),
        (bj = "[object DataView]"),
        (jTt = pl(Sk)),
        (qTt = pl(mc)),
        (HTt = pl(_k)),
        (YTt = pl(Ic)),
        (XTt = pl(sk)),
        (sh = ni));
      ((Sk && sh(new Sk(new ArrayBuffer(1))) != bj) ||
        (mc && sh(new mc()) != mj) ||
        (_k && sh(_k.resolve()) != gj) ||
        (Ic && sh(new Ic()) != yj) ||
        (sk && sh(new sk()) != xj)) &&
        (sh = a(function (e) {
          var t = ni(e),
            r = t == UTt ? e.constructor : void 0,
            n = r ? pl(r) : "";
          if (n)
            switch (n) {
              case jTt:
                return bj;
              case qTt:
                return mj;
              case HTt:
                return gj;
              case YTt:
                return yj;
              case XTt:
                return xj;
            }
          return t;
        }, "getTag"));
      Ds = sh;
    });
  function ZTt(e) {
    var t = e.length,
      r = new e.constructor(t);
    return (
      t &&
        typeof e[0] == "string" &&
        QTt.call(e, "index") &&
        ((r.index = e.index), (r.input = e.input)),
      r
    );
  }
  var KTt,
    QTt,
    kj,
    Tj = x(() => {
      "use strict";
      ((KTt = Object.prototype), (QTt = KTt.hasOwnProperty));
      a(ZTt, "initCloneArray");
      kj = ZTt;
    });
  function JTt(e, t) {
    var r = t ? Qf(e.buffer) : e.buffer;
    return new e.constructor(r, e.byteOffset, e.byteLength);
  }
  var Sj,
    _j = x(() => {
      "use strict";
      tb();
      a(JTt, "cloneDataView");
      Sj = JTt;
    });
  function eSt(e) {
    var t = new e.constructor(e.source, tSt.exec(e));
    return ((t.lastIndex = e.lastIndex), t);
  }
  var tSt,
    Cj,
    wj = x(() => {
      "use strict";
      tSt = /\w*$/;
      a(eSt, "cloneRegExp");
      Cj = eSt;
    });
  function rSt(e) {
    return Ej ? Object(Ej.call(e)) : {};
  }
  var vj,
    Ej,
    Aj,
    Lj = x(() => {
      "use strict";
      zu();
      ((vj = qn ? qn.prototype : void 0), (Ej = vj ? vj.valueOf : void 0));
      a(rSt, "cloneSymbol");
      Aj = rSt;
    });
  function SSt(e, t, r) {
    var n = e.constructor;
    switch (t) {
      case hSt:
        return Qf(e);
      case nSt:
      case iSt:
        return new n(+e);
      case fSt:
        return Sj(e, r);
      case dSt:
      case pSt:
      case mSt:
      case gSt:
      case ySt:
      case xSt:
      case bSt:
      case kSt:
      case TSt:
        return eb(e, r);
      case sSt:
        return new n();
      case aSt:
      case cSt:
        return new n(e);
      case oSt:
        return Cj(e);
      case lSt:
        return new n();
      case uSt:
        return Aj(e);
    }
  }
  var nSt,
    iSt,
    sSt,
    aSt,
    oSt,
    lSt,
    cSt,
    uSt,
    hSt,
    fSt,
    dSt,
    pSt,
    mSt,
    gSt,
    ySt,
    xSt,
    bSt,
    kSt,
    TSt,
    Rj,
    Dj = x(() => {
      "use strict";
      tb();
      _j();
      wj();
      Lj();
      u4();
      ((nSt = "[object Boolean]"),
        (iSt = "[object Date]"),
        (sSt = "[object Map]"),
        (aSt = "[object Number]"),
        (oSt = "[object RegExp]"),
        (lSt = "[object Set]"),
        (cSt = "[object String]"),
        (uSt = "[object Symbol]"),
        (hSt = "[object ArrayBuffer]"),
        (fSt = "[object DataView]"),
        (dSt = "[object Float32Array]"),
        (pSt = "[object Float64Array]"),
        (mSt = "[object Int8Array]"),
        (gSt = "[object Int16Array]"),
        (ySt = "[object Int32Array]"),
        (xSt = "[object Uint8Array]"),
        (bSt = "[object Uint8ClampedArray]"),
        (kSt = "[object Uint16Array]"),
        (TSt = "[object Uint32Array]"));
      a(SSt, "initCloneByTag");
      Rj = SSt;
    });
  function CSt(e) {
    return an(e) && Ds(e) == _St;
  }
  var _St,
    Nj,
    Ij = x(() => {
      "use strict";
      ah();
      Qs();
      _St = "[object Map]";
      a(CSt, "baseIsMap");
      Nj = CSt;
    });
  var Mj,
    wSt,
    Oj,
    Pj = x(() => {
      "use strict";
      Ij();
      qu();
      g0();
      ((Mj = ta && ta.isMap), (wSt = Mj ? Js(Mj) : Nj), (Oj = wSt));
    });
  function ESt(e) {
    return an(e) && Ds(e) == vSt;
  }
  var vSt,
    Bj,
    Fj = x(() => {
      "use strict";
      ah();
      Qs();
      vSt = "[object Set]";
      a(ESt, "baseIsSet");
      Bj = ESt;
    });
  var $j,
    ASt,
    Gj,
    Vj = x(() => {
      "use strict";
      Fj();
      qu();
      g0();
      (($j = ta && ta.isSet), (ASt = $j ? Js($j) : Bj), (Gj = ASt));
    });
  function Ck(e, t, r, n, i, s) {
    var o,
      l = t & LSt,
      u = t & RSt,
      h = t & DSt;
    if ((r && (o = i ? r(e, n, i, s) : r(e)), o !== void 0)) return o;
    if (!Nr(e)) return e;
    var f = Jt(e);
    if (f) {
      if (((o = kj(e)), !l)) return rb(e, o);
    } else {
      var d = Ds(e),
        p = d == Wj || d == PSt;
      if (Fa(e)) return J2(e, l);
      if (d == Uj || d == zj || (p && !i)) {
        if (((o = u || p ? {} : sb(e)), !l))
          return u ? hj(e, aj(o, e)) : cj(e, ij(o, e));
      } else {
        if (!Gr[d]) return i ? e : {};
        o = Rj(e, d, l);
      }
    }
    s || (s = new fo());
    var m = s.get(e);
    if (m) return m;
    (s.set(e, o),
      Gj(e)
        ? e.forEach(function (b) {
            o.add(Ck(b, t, r, b, e, s));
          })
        : Oj(e) &&
          e.forEach(function (b, k) {
            o.set(k, Ck(b, t, r, k, e, s));
          }));
    var g = h ? (u ? Tk : W0) : u ? ns : cr,
      y = f ? void 0 : g(e);
    return (
      ak(y || e, function (b, k) {
        (y && ((k = b), (b = e[k])), go(o, k, Ck(b, t, r, k, e, s)));
      }),
      o
    );
  }
  var LSt,
    RSt,
    DSt,
    zj,
    NSt,
    ISt,
    MSt,
    OSt,
    Wj,
    PSt,
    BSt,
    FSt,
    Uj,
    $St,
    GSt,
    VSt,
    zSt,
    WSt,
    USt,
    jSt,
    qSt,
    HSt,
    YSt,
    XSt,
    KSt,
    QSt,
    ZSt,
    JSt,
    t_t,
    Gr,
    wk,
    KA = x(() => {
      "use strict";
      d0();
      $A();
      nd();
      sj();
      oj();
      l4();
      h4();
      uj();
      fj();
      HA();
      YA();
      ah();
      Tj();
      Dj();
      d4();
      Kr();
      rd();
      Pj();
      Es();
      Vj();
      wo();
      bc();
      ((LSt = 1),
        (RSt = 2),
        (DSt = 4),
        (zj = "[object Arguments]"),
        (NSt = "[object Array]"),
        (ISt = "[object Boolean]"),
        (MSt = "[object Date]"),
        (OSt = "[object Error]"),
        (Wj = "[object Function]"),
        (PSt = "[object GeneratorFunction]"),
        (BSt = "[object Map]"),
        (FSt = "[object Number]"),
        (Uj = "[object Object]"),
        ($St = "[object RegExp]"),
        (GSt = "[object Set]"),
        (VSt = "[object String]"),
        (zSt = "[object Symbol]"),
        (WSt = "[object WeakMap]"),
        (USt = "[object ArrayBuffer]"),
        (jSt = "[object DataView]"),
        (qSt = "[object Float32Array]"),
        (HSt = "[object Float64Array]"),
        (YSt = "[object Int8Array]"),
        (XSt = "[object Int16Array]"),
        (KSt = "[object Int32Array]"),
        (QSt = "[object Uint8Array]"),
        (ZSt = "[object Uint8ClampedArray]"),
        (JSt = "[object Uint16Array]"),
        (t_t = "[object Uint32Array]"),
        (Gr = {}));
      Gr[zj] =
        Gr[NSt] =
        Gr[USt] =
        Gr[jSt] =
        Gr[ISt] =
        Gr[MSt] =
        Gr[qSt] =
        Gr[HSt] =
        Gr[YSt] =
        Gr[XSt] =
        Gr[KSt] =
        Gr[BSt] =
        Gr[FSt] =
        Gr[Uj] =
        Gr[$St] =
        Gr[GSt] =
        Gr[VSt] =
        Gr[zSt] =
        Gr[QSt] =
        Gr[ZSt] =
        Gr[JSt] =
        Gr[t_t] =
          !0;
      Gr[OSt] = Gr[Wj] = Gr[WSt] = !1;
      a(Ck, "baseClone");
      wk = Ck;
    });
  function r_t(e) {
    return wk(e, e_t);
  }
  var e_t,
    Sr,
    QA = x(() => {
      "use strict";
      KA();
      e_t = 4;
      a(r_t, "clone");
      Sr = r_t;
    });
  function s_t(e) {
    return wk(e, n_t | i_t);
  }
  var n_t,
    i_t,
    ZA,
    jj = x(() => {
      "use strict";
      KA();
      ((n_t = 1), (i_t = 4));
      a(s_t, "cloneDeep");
      ZA = s_t;
    });
  function a_t(e) {
    for (var t = -1, r = e == null ? 0 : e.length, n = 0, i = []; ++t < r; ) {
      var s = e[t];
      s && (i[n++] = s);
    }
    return i;
  }
  var Ao,
    qj = x(() => {
      "use strict";
      a(a_t, "compact");
      Ao = a_t;
    });
  function l_t(e) {
    return (this.__data__.set(e, o_t), this);
  }
  var o_t,
    Hj,
    Yj = x(() => {
      "use strict";
      o_t = "__lodash_hash_undefined__";
      a(l_t, "setCacheAdd");
      Hj = l_t;
    });
  function c_t(e) {
    return this.__data__.has(e);
  }
  var Xj,
    Kj = x(() => {
      "use strict";
      a(c_t, "setCacheHas");
      Xj = c_t;
    });
  function vk(e) {
    var t = -1,
      r = e == null ? 0 : e.length;
    for (this.__data__ = new Uu(); ++t < r; ) this.add(e[t]);
  }
  var Cd,
    Ek = x(() => {
      "use strict";
      Q2();
      Yj();
      Kj();
      a(vk, "SetCache");
      vk.prototype.add = vk.prototype.push = Hj;
      vk.prototype.has = Xj;
      Cd = vk;
    });
  function u_t(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
      if (t(e[r], r, e)) return !0;
    return !1;
  }
  var Ak,
    JA = x(() => {
      "use strict";
      a(u_t, "arraySome");
      Ak = u_t;
    });
  function h_t(e, t) {
    return e.has(t);
  }
  var wd,
    Lk = x(() => {
      "use strict";
      a(h_t, "cacheHas");
      wd = h_t;
    });
  function p_t(e, t, r, n, i, s) {
    var o = r & f_t,
      l = e.length,
      u = t.length;
    if (l != u && !(o && u > l)) return !1;
    var h = s.get(e),
      f = s.get(t);
    if (h && f) return h == t && f == e;
    var d = -1,
      p = !0,
      m = r & d_t ? new Cd() : void 0;
    for (s.set(e, t), s.set(t, e); ++d < l; ) {
      var g = e[d],
        y = t[d];
      if (n) var b = o ? n(y, g, d, t, e, s) : n(g, y, d, e, t, s);
      if (b !== void 0) {
        if (b) continue;
        p = !1;
        break;
      }
      if (m) {
        if (
          !Ak(t, function (k, T) {
            if (!wd(m, T) && (g === k || i(g, k, r, n, s))) return m.push(T);
          })
        ) {
          p = !1;
          break;
        }
      } else if (!(g === y || i(g, y, r, n, s))) {
        p = !1;
        break;
      }
    }
    return (s.delete(e), s.delete(t), p);
  }
  var f_t,
    d_t,
    Rk,
    t5 = x(() => {
      "use strict";
      Ek();
      JA();
      Lk();
      ((f_t = 1), (d_t = 2));
      a(p_t, "equalArrays");
      Rk = p_t;
    });
  function m_t(e) {
    var t = -1,
      r = Array(e.size);
    return (
      e.forEach(function (n, i) {
        r[++t] = [i, n];
      }),
      r
    );
  }
  var Qj,
    Zj = x(() => {
      "use strict";
      a(m_t, "mapToArray");
      Qj = m_t;
    });
  function g_t(e) {
    var t = -1,
      r = Array(e.size);
    return (
      e.forEach(function (n) {
        r[++t] = n;
      }),
      r
    );
  }
  var vd,
    Dk = x(() => {
      "use strict";
      a(g_t, "setToArray");
      vd = g_t;
    });
  function R_t(e, t, r, n, i, s, o) {
    switch (r) {
      case L_t:
        if (e.byteLength != t.byteLength || e.byteOffset != t.byteOffset)
          return !1;
        ((e = e.buffer), (t = t.buffer));
      case A_t:
        return !(e.byteLength != t.byteLength || !s(new Kf(e), new Kf(t)));
      case b_t:
      case k_t:
      case __t:
        return Ks(+e, +t);
      case T_t:
        return e.name == t.name && e.message == t.message;
      case C_t:
      case v_t:
        return e == t + "";
      case S_t:
        var l = Qj;
      case w_t:
        var u = n & y_t;
        if ((l || (l = vd), e.size != t.size && !u)) return !1;
        var h = o.get(e);
        if (h) return h == t;
        ((n |= x_t), o.set(e, t));
        var f = Rk(l(e), l(t), n, i, s, o);
        return (o.delete(e), f);
      case E_t:
        if (e5) return e5.call(e) == e5.call(t);
    }
    return !1;
  }
  var y_t,
    x_t,
    b_t,
    k_t,
    T_t,
    S_t,
    __t,
    C_t,
    w_t,
    v_t,
    E_t,
    A_t,
    L_t,
    Jj,
    e5,
    tq,
    eq = x(() => {
      "use strict";
      zu();
      c4();
      Wu();
      t5();
      Zj();
      Dk();
      ((y_t = 1),
        (x_t = 2),
        (b_t = "[object Boolean]"),
        (k_t = "[object Date]"),
        (T_t = "[object Error]"),
        (S_t = "[object Map]"),
        (__t = "[object Number]"),
        (C_t = "[object RegExp]"),
        (w_t = "[object Set]"),
        (v_t = "[object String]"),
        (E_t = "[object Symbol]"),
        (A_t = "[object ArrayBuffer]"),
        (L_t = "[object DataView]"),
        (Jj = qn ? qn.prototype : void 0),
        (e5 = Jj ? Jj.valueOf : void 0));
      a(R_t, "equalByTag");
      tq = R_t;
    });
  function M_t(e, t, r, n, i, s) {
    var o = r & D_t,
      l = W0(e),
      u = l.length,
      h = W0(t),
      f = h.length;
    if (u != f && !o) return !1;
    for (var d = u; d--; ) {
      var p = l[d];
      if (!(o ? p in t : I_t.call(t, p))) return !1;
    }
    var m = s.get(e),
      g = s.get(t);
    if (m && g) return m == t && g == e;
    var y = !0;
    (s.set(e, t), s.set(t, e));
    for (var b = o; ++d < u; ) {
      p = l[d];
      var k = e[p],
        T = t[p];
      if (n) var C = o ? n(T, k, p, t, e, s) : n(k, T, p, e, t, s);
      if (!(C === void 0 ? k === T || i(k, T, r, n, s) : C)) {
        y = !1;
        break;
      }
      b || (b = p == "constructor");
    }
    if (y && !b) {
      var L = e.constructor,
        w = t.constructor;
      L != w &&
        "constructor" in e &&
        "constructor" in t &&
        !(
          typeof L == "function" &&
          L instanceof L &&
          typeof w == "function" &&
          w instanceof w
        ) &&
        (y = !1);
    }
    return (s.delete(e), s.delete(t), y);
  }
  var D_t,
    N_t,
    I_t,
    rq,
    nq = x(() => {
      "use strict";
      HA();
      ((D_t = 1), (N_t = Object.prototype), (I_t = N_t.hasOwnProperty));
      a(M_t, "equalObjects");
      rq = M_t;
    });
  function B_t(e, t, r, n, i, s) {
    var o = Jt(e),
      l = Jt(t),
      u = o ? sq : Ds(e),
      h = l ? sq : Ds(t);
    ((u = u == iq ? Nk : u), (h = h == iq ? Nk : h));
    var f = u == Nk,
      d = h == Nk,
      p = u == h;
    if (p && Fa(e)) {
      if (!Fa(t)) return !1;
      ((o = !0), (f = !1));
    }
    if (p && !f)
      return (
        s || (s = new fo()),
        o || yc(e) ? Rk(e, t, r, n, i, s) : tq(e, t, u, r, n, i, s)
      );
    if (!(r & O_t)) {
      var m = f && aq.call(e, "__wrapped__"),
        g = d && aq.call(t, "__wrapped__");
      if (m || g) {
        var y = m ? e.value() : e,
          b = g ? t.value() : t;
        return (s || (s = new fo()), i(y, b, r, n, s));
      }
    }
    return p ? (s || (s = new fo()), rq(e, t, r, n, i, s)) : !1;
  }
  var O_t,
    iq,
    sq,
    Nk,
    P_t,
    aq,
    oq,
    lq = x(() => {
      "use strict";
      d0();
      t5();
      eq();
      nq();
      ah();
      Kr();
      rd();
      y0();
      ((O_t = 1),
        (iq = "[object Arguments]"),
        (sq = "[object Array]"),
        (Nk = "[object Object]"),
        (P_t = Object.prototype),
        (aq = P_t.hasOwnProperty));
      a(B_t, "baseIsEqualDeep");
      oq = B_t;
    });
  function cq(e, t, r, n, i) {
    return e === t
      ? !0
      : e == null || t == null || (!an(e) && !an(t))
        ? e !== e && t !== t
        : oq(e, t, r, n, cq, i);
  }
  var Ik,
    r5 = x(() => {
      "use strict";
      lq();
      Qs();
      a(cq, "baseIsEqual");
      Ik = cq;
    });
  function G_t(e, t, r, n) {
    var i = r.length,
      s = i,
      o = !n;
    if (e == null) return !s;
    for (e = Object(e); i--; ) {
      var l = r[i];
      if (o && l[2] ? l[1] !== e[l[0]] : !(l[0] in e)) return !1;
    }
    for (; ++i < s; ) {
      l = r[i];
      var u = l[0],
        h = e[u],
        f = l[1];
      if (o && l[2]) {
        if (h === void 0 && !(u in e)) return !1;
      } else {
        var d = new fo();
        if (n) var p = n(h, f, u, e, t, d);
        if (!(p === void 0 ? Ik(f, h, F_t | $_t, n, d) : p)) return !1;
      }
    }
    return !0;
  }
  var F_t,
    $_t,
    uq,
    hq = x(() => {
      "use strict";
      d0();
      r5();
      ((F_t = 1), ($_t = 2));
      a(G_t, "baseIsMatch");
      uq = G_t;
    });
  function V_t(e) {
    return e === e && !Nr(e);
  }
  var Mk,
    n5 = x(() => {
      "use strict";
      Es();
      a(V_t, "isStrictComparable");
      Mk = V_t;
    });
  function z_t(e) {
    for (var t = cr(e), r = t.length; r--; ) {
      var n = t[r],
        i = e[n];
      t[r] = [n, i, Mk(i)];
    }
    return t;
  }
  var fq,
    dq = x(() => {
      "use strict";
      n5();
      wo();
      a(z_t, "getMatchData");
      fq = z_t;
    });
  function W_t(e, t) {
    return function (r) {
      return r == null ? !1 : r[e] === t && (t !== void 0 || e in Object(r));
    };
  }
  var Ok,
    i5 = x(() => {
      "use strict";
      a(W_t, "matchesStrictComparable");
      Ok = W_t;
    });
  function U_t(e) {
    var t = fq(e);
    return t.length == 1 && t[0][2]
      ? Ok(t[0][0], t[0][1])
      : function (r) {
          return r === e || uq(r, e, t);
        };
  }
  var pq,
    mq = x(() => {
      "use strict";
      hq();
      dq();
      i5();
      a(U_t, "baseMatches");
      pq = U_t;
    });
  function j_t(e, t) {
    return e != null && t in Object(e);
  }
  var gq,
    yq = x(() => {
      "use strict";
      a(j_t, "baseHasIn");
      gq = j_t;
    });
  function q_t(e, t, r) {
    t = Dc(t, e);
    for (var n = -1, i = t.length, s = !1; ++n < i; ) {
      var o = vo(t[n]);
      if (!(s = e != null && r(e, o))) break;
      e = e[o];
    }
    return s || ++n != i
      ? s
      : ((i = e == null ? 0 : e.length),
        !!i && ed(i) && xc(o, i) && (Jt(e) || Ba(e)));
  }
  var Pk,
    s5 = x(() => {
      "use strict";
      V0();
      td();
      Kr();
      b0();
      ab();
      bd();
      a(q_t, "hasPath");
      Pk = q_t;
    });
  function H_t(e, t) {
    return e != null && Pk(e, t, gq);
  }
  var Bk,
    a5 = x(() => {
      "use strict";
      yq();
      s5();
      a(H_t, "hasIn");
      Bk = H_t;
    });
  function K_t(e, t) {
    return xd(e) && Mk(t)
      ? Ok(vo(e), t)
      : function (r) {
          var n = qU(r, e);
          return n === void 0 && n === t ? Bk(r, e) : Ik(t, n, Y_t | X_t);
        };
  }
  var Y_t,
    X_t,
    xq,
    bq = x(() => {
      "use strict";
      r5();
      HU();
      a5();
      hk();
      n5();
      i5();
      bd();
      ((Y_t = 1), (X_t = 2));
      a(K_t, "baseMatchesProperty");
      xq = K_t;
    });
  function Q_t(e) {
    return function (t) {
      return t?.[e];
    };
  }
  var Fk,
    o5 = x(() => {
      "use strict";
      a(Q_t, "baseProperty");
      Fk = Q_t;
    });
  function Z_t(e) {
    return function (t) {
      return Nc(t, e);
    };
  }
  var kq,
    Tq = x(() => {
      "use strict";
      z0();
      a(Z_t, "basePropertyDeep");
      kq = Z_t;
    });
  function J_t(e) {
    return xd(e) ? Fk(vo(e)) : kq(e);
  }
  var Sq,
    _q = x(() => {
      "use strict";
      o5();
      Tq();
      hk();
      bd();
      a(J_t, "property");
      Sq = J_t;
    });
  function tCt(e) {
    return typeof e == "function"
      ? e
      : e == null
        ? Hn
        : typeof e == "object"
          ? Jt(e)
            ? xq(e[0], e[1])
            : pq(e)
          : Sq(e);
  }
  var Rr,
    $i = x(() => {
      "use strict";
      mq();
      bq();
      gl();
      Kr();
      _q();
      a(tCt, "baseIteratee");
      Rr = tCt;
    });
  function eCt(e, t, r, n) {
    for (var i = -1, s = e == null ? 0 : e.length; ++i < s; ) {
      var o = e[i];
      t(n, o, r(o), e);
    }
    return n;
  }
  var Cq,
    wq = x(() => {
      "use strict";
      a(eCt, "arrayAggregator");
      Cq = eCt;
    });
  function rCt(e, t) {
    return e && Xf(e, t, cr);
  }
  var Ed,
    $k = x(() => {
      "use strict";
      Z2();
      wo();
      a(rCt, "baseForOwn");
      Ed = rCt;
    });
  function nCt(e, t) {
    return function (r, n) {
      if (r == null) return r;
      if (!dn(r)) return e(r, n);
      for (
        var i = r.length, s = t ? i : -1, o = Object(r);
        (t ? s-- : ++s < i) && n(o[s], s, o) !== !1;

      );
      return r;
    };
  }
  var vq,
    Eq = x(() => {
      "use strict";
      Zs();
      a(nCt, "createBaseEach");
      vq = nCt;
    });
  var iCt,
    fs,
    Mc = x(() => {
      "use strict";
      $k();
      Eq();
      ((iCt = vq(Ed)), (fs = iCt));
    });
  function sCt(e, t, r, n) {
    return (
      fs(e, function (i, s, o) {
        t(n, i, r(i), o);
      }),
      n
    );
  }
  var Aq,
    Lq = x(() => {
      "use strict";
      Mc();
      a(sCt, "baseAggregator");
      Aq = sCt;
    });
  function aCt(e, t) {
    return function (r, n) {
      var i = Jt(r) ? Cq : Aq,
        s = t ? t() : {};
      return i(r, e, Rr(n, 2), s);
    };
  }
  var Rq,
    Dq = x(() => {
      "use strict";
      wq();
      Lq();
      $i();
      Kr();
      a(aCt, "createAggregator");
      Rq = aCt;
    });
  var oCt,
    Gk,
    Nq = x(() => {
      "use strict";
      Xs();
      ((oCt = a(function () {
        return fn.Date.now();
      }, "now")),
        (Gk = oCt));
    });
  var Iq,
    lCt,
    cCt,
    Oc,
    Mq = x(() => {
      "use strict";
      id();
      Wu();
      Yu();
      bc();
      ((Iq = Object.prototype),
        (lCt = Iq.hasOwnProperty),
        (cCt = yo(function (e, t) {
          e = Object(e);
          var r = -1,
            n = t.length,
            i = n > 2 ? t[2] : void 0;
          for (i && As(t[0], t[1], i) && (n = 1); ++r < n; )
            for (var s = t[r], o = ns(s), l = -1, u = o.length; ++l < u; ) {
              var h = o[l],
                f = e[h];
              (f === void 0 || (Ks(f, Iq[h]) && !lCt.call(e, h))) &&
                (e[h] = s[h]);
            }
          return e;
        })),
        (Oc = cCt));
    });
  function uCt(e, t, r) {
    for (var n = -1, i = e == null ? 0 : e.length; ++n < i; )
      if (r(t, e[n])) return !0;
    return !1;
  }
  var Vk,
    l5 = x(() => {
      "use strict";
      a(uCt, "arrayIncludesWith");
      Vk = uCt;
    });
  function fCt(e, t, r, n) {
    var i = -1,
      s = ck,
      o = !0,
      l = e.length,
      u = [],
      h = t.length;
    if (!l) return u;
    (r && (t = hs(t, Js(r))),
      n
        ? ((s = Vk), (o = !1))
        : t.length >= hCt && ((s = wd), (o = !1), (t = new Cd(t))));
    t: for (; ++i < l; ) {
      var f = e[i],
        d = r == null ? f : r(f);
      if (((f = n || f !== 0 ? f : 0), o && d === d)) {
        for (var p = h; p--; ) if (t[p] === d) continue t;
        u.push(f);
      } else s(t, d, n) || u.push(f);
    }
    return u;
  }
  var hCt,
    Oq,
    Pq = x(() => {
      "use strict";
      Ek();
      VA();
      l5();
      ih();
      qu();
      Lk();
      hCt = 200;
      a(fCt, "baseDifference");
      Oq = fCt;
    });
  var dCt,
    Pc,
    Bq = x(() => {
      "use strict";
      Pq();
      Td();
      id();
      ob();
      ((dCt = yo(function (e, t) {
        return ju(e) ? Oq(e, Eo(t, 1, ju, !0)) : [];
      })),
        (Pc = dCt));
    });
  function pCt(e) {
    var t = e == null ? 0 : e.length;
    return t ? e[t - 1] : void 0;
  }
  var ai,
    Fq = x(() => {
      "use strict";
      a(pCt, "last");
      ai = pCt;
    });
  function mCt(e, t, r) {
    var n = e == null ? 0 : e.length;
    return n
      ? ((t = r || t === void 0 ? 1 : Co(t)), mk(e, t < 0 ? 0 : t, n))
      : [];
  }
  var xn,
    $q = x(() => {
      "use strict";
      WA();
      md();
      a(mCt, "drop");
      xn = mCt;
    });
  function gCt(e, t, r) {
    var n = e == null ? 0 : e.length;
    return n
      ? ((t = r || t === void 0 ? 1 : Co(t)),
        (t = n - t),
        mk(e, 0, t < 0 ? 0 : t))
      : [];
  }
  var Sl,
    Gq = x(() => {
      "use strict";
      WA();
      md();
      a(gCt, "dropRight");
      Sl = gCt;
    });
  function yCt(e) {
    return typeof e == "function" ? e : Hn;
  }
  var Ad,
    zk = x(() => {
      "use strict";
      gl();
      a(yCt, "castFunction");
      Ad = yCt;
    });
  function xCt(e, t) {
    var r = Jt(e) ? ak : fs;
    return r(e, Ad(t));
  }
  var rt,
    Wk = x(() => {
      "use strict";
      $A();
      Mc();
      zk();
      Kr();
      a(xCt, "forEach");
      rt = xCt;
    });
  var Vq = x(() => {
    "use strict";
    Wk();
  });
  function bCt(e, t) {
    for (var r = -1, n = e == null ? 0 : e.length; ++r < n; )
      if (!t(e[r], r, e)) return !1;
    return !0;
  }
  var zq,
    Wq = x(() => {
      "use strict";
      a(bCt, "arrayEvery");
      zq = bCt;
    });
  function kCt(e, t) {
    var r = !0;
    return (
      fs(e, function (n, i, s) {
        return ((r = !!t(n, i, s)), r);
      }),
      r
    );
  }
  var Uq,
    jq = x(() => {
      "use strict";
      Mc();
      a(kCt, "baseEvery");
      Uq = kCt;
    });
  function TCt(e, t, r) {
    var n = Jt(e) ? zq : Uq;
    return (r && As(e, t, r) && (t = void 0), n(e, Rr(t, 3)));
  }
  var bi,
    qq = x(() => {
      "use strict";
      Wq();
      jq();
      $i();
      Kr();
      Yu();
      a(TCt, "every");
      bi = TCt;
    });
  function SCt(e, t) {
    var r = [];
    return (
      fs(e, function (n, i, s) {
        t(n, i, s) && r.push(n);
      }),
      r
    );
  }
  var Uk,
    c5 = x(() => {
      "use strict";
      Mc();
      a(SCt, "baseFilter");
      Uk = SCt;
    });
  function _Ct(e, t) {
    var r = Jt(e) ? Sd : Uk;
    return r(e, Rr(t, 3));
  }
  var pr,
    u5 = x(() => {
      "use strict";
      gk();
      c5();
      $i();
      Kr();
      a(_Ct, "filter");
      pr = _Ct;
    });
  function CCt(e) {
    return function (t, r, n) {
      var i = Object(t);
      if (!dn(t)) {
        var s = Rr(r, 3);
        ((t = cr(t)),
          (r = a(function (l) {
            return s(i[l], l, i);
          }, "predicate")));
      }
      var o = e(t, r, n);
      return o > -1 ? i[s ? t[o] : o] : void 0;
    };
  }
  var Hq,
    Yq = x(() => {
      "use strict";
      $i();
      Zs();
      wo();
      a(CCt, "createFind");
      Hq = CCt;
    });
  function vCt(e, t, r) {
    var n = e == null ? 0 : e.length;
    if (!n) return -1;
    var i = r == null ? 0 : Co(r);
    return (i < 0 && (i = wCt(n + i, 0)), ok(e, Rr(t, 3), i));
  }
  var wCt,
    Xq,
    Kq = x(() => {
      "use strict";
      GA();
      $i();
      md();
      wCt = Math.max;
      a(vCt, "findIndex");
      Xq = vCt;
    });
  var ECt,
    Gi,
    Qq = x(() => {
      "use strict";
      Yq();
      Kq();
      ((ECt = Hq(Xq)), (Gi = ECt));
    });
  function ACt(e) {
    return e && e.length ? e[0] : void 0;
  }
  var Qn,
    Zq = x(() => {
      "use strict";
      a(ACt, "head");
      Qn = ACt;
    });
  var Jq = x(() => {
    "use strict";
    Zq();
  });
  function LCt(e, t) {
    var r = -1,
      n = dn(e) ? Array(e.length) : [];
    return (
      fs(e, function (i, s, o) {
        n[++r] = t(i, s, o);
      }),
      n
    );
  }
  var jk,
    h5 = x(() => {
      "use strict";
      Mc();
      Zs();
      a(LCt, "baseMap");
      jk = LCt;
    });
  function RCt(e, t) {
    var r = Jt(e) ? hs : jk;
    return r(e, Rr(t, 3));
  }
  var Dt,
    Ld = x(() => {
      "use strict";
      ih();
      $i();
      h5();
      Kr();
      a(RCt, "map");
      Dt = RCt;
    });
  function DCt(e, t) {
    return Eo(Dt(e, t), 1);
  }
  var oi,
    f5 = x(() => {
      "use strict";
      Td();
      Ld();
      a(DCt, "flatMap");
      oi = DCt;
    });
  function NCt(e, t) {
    return e == null ? e : Xf(e, Ad(t), ns);
  }
  var d5,
    tH = x(() => {
      "use strict";
      Z2();
      zk();
      bc();
      a(NCt, "forIn");
      d5 = NCt;
    });
  function ICt(e, t) {
    return e && Ed(e, Ad(t));
  }
  var p5,
    eH = x(() => {
      "use strict";
      $k();
      zk();
      a(ICt, "forOwn");
      p5 = ICt;
    });
  var MCt,
    OCt,
    PCt,
    m5,
    rH = x(() => {
      "use strict";
      Yf();
      Dq();
      ((MCt = Object.prototype),
        (OCt = MCt.hasOwnProperty),
        (PCt = Rq(function (e, t, r) {
          OCt.call(e, r) ? e[r].push(t) : po(e, r, [t]);
        })),
        (m5 = PCt));
    });
  function BCt(e, t) {
    return e > t;
  }
  var nH,
    iH = x(() => {
      "use strict";
      a(BCt, "baseGt");
      nH = BCt;
    });
  function GCt(e, t) {
    return e != null && $Ct.call(e, t);
  }
  var FCt,
    $Ct,
    sH,
    aH = x(() => {
      "use strict";
      ((FCt = Object.prototype), ($Ct = FCt.hasOwnProperty));
      a(GCt, "baseHas");
      sH = GCt;
    });
  function VCt(e, t) {
    return e != null && Pk(e, t, sH);
  }
  var te,
    oH = x(() => {
      "use strict";
      aH();
      s5();
      a(VCt, "has");
      te = VCt;
    });
  function WCt(e) {
    return typeof e == "string" || (!Jt(e) && an(e) && ni(e) == zCt);
  }
  var zCt,
    bn,
    qk = x(() => {
      "use strict";
      dl();
      Kr();
      Qs();
      zCt = "[object String]";
      a(WCt, "isString");
      bn = WCt;
    });
  function UCt(e, t) {
    return hs(t, function (r) {
      return e[r];
    });
  }
  var lH,
    cH = x(() => {
      "use strict";
      ih();
      a(UCt, "baseValues");
      lH = UCt;
    });
  function jCt(e) {
    return e == null ? [] : lH(e, cr(e));
  }
  var We,
    g5 = x(() => {
      "use strict";
      cH();
      wo();
      a(jCt, "values");
      We = jCt;
    });
  function HCt(e, t, r, n) {
    ((e = dn(e) ? e : We(e)), (r = r && !n ? Co(r) : 0));
    var i = e.length;
    return (
      r < 0 && (r = qCt(i + r, 0)),
      bn(e) ? r <= i && e.indexOf(t, r) > -1 : !!i && gd(e, t, r) > -1
    );
  }
  var qCt,
    Zr,
    uH = x(() => {
      "use strict";
      lk();
      Zs();
      qk();
      md();
      g5();
      qCt = Math.max;
      a(HCt, "includes");
      Zr = HCt;
    });
  function XCt(e, t, r) {
    var n = e == null ? 0 : e.length;
    if (!n) return -1;
    var i = r == null ? 0 : Co(r);
    return (i < 0 && (i = YCt(n + i, 0)), gd(e, t, i));
  }
  var YCt,
    Hk,
    hH = x(() => {
      "use strict";
      lk();
      md();
      YCt = Math.max;
      a(XCt, "indexOf");
      Hk = XCt;
    });
  function twt(e) {
    if (e == null) return !0;
    if (
      dn(e) &&
      (Jt(e) ||
        typeof e == "string" ||
        typeof e.splice == "function" ||
        Fa(e) ||
        yc(e) ||
        Ba(e))
    )
      return !e.length;
    var t = Ds(e);
    if (t == KCt || t == QCt) return !e.size;
    if (mo(e)) return !yd(e).length;
    for (var r in e) if (JCt.call(e, r)) return !1;
    return !0;
  }
  var KCt,
    QCt,
    ZCt,
    JCt,
    De,
    Yk = x(() => {
      "use strict";
      uk();
      ah();
      td();
      Kr();
      Zs();
      rd();
      Jf();
      y0();
      ((KCt = "[object Map]"),
        (QCt = "[object Set]"),
        (ZCt = Object.prototype),
        (JCt = ZCt.hasOwnProperty));
      a(twt, "isEmpty");
      De = twt;
    });
  function rwt(e) {
    return an(e) && ni(e) == ewt;
  }
  var ewt,
    fH,
    dH = x(() => {
      "use strict";
      dl();
      Qs();
      ewt = "[object RegExp]";
      a(rwt, "baseIsRegExp");
      fH = rwt;
    });
  var pH,
    nwt,
    ia,
    mH = x(() => {
      "use strict";
      dH();
      qu();
      g0();
      ((pH = ta && ta.isRegExp), (nwt = pH ? Js(pH) : fH), (ia = nwt));
    });
  function iwt(e) {
    return e === void 0;
  }
  var Fe,
    gH = x(() => {
      "use strict";
      a(iwt, "isUndefined");
      Fe = iwt;
    });
  function swt(e, t) {
    return e < t;
  }
  var Xk,
    y5 = x(() => {
      "use strict";
      a(swt, "baseLt");
      Xk = swt;
    });
  function awt(e, t) {
    var r = {};
    return (
      (t = Rr(t, 3)),
      Ed(e, function (n, i, s) {
        po(r, i, t(n, i, s));
      }),
      r
    );
  }
  var oh,
    yH = x(() => {
      "use strict";
      Yf();
      $k();
      $i();
      a(awt, "mapValues");
      oh = awt;
    });
  function owt(e, t, r) {
    for (var n = -1, i = e.length; ++n < i; ) {
      var s = e[n],
        o = t(s);
      if (o != null && (l === void 0 ? o === o && !Rs(o) : r(o, l)))
        var l = o,
          u = s;
    }
    return u;
  }
  var Rd,
    Kk = x(() => {
      "use strict";
      nh();
      a(owt, "baseExtremum");
      Rd = owt;
    });
  function lwt(e) {
    return e && e.length ? Rd(e, Hn, nH) : void 0;
  }
  var ds,
    xH = x(() => {
      "use strict";
      Kk();
      iH();
      gl();
      a(lwt, "max");
      ds = lwt;
    });
  function cwt(e) {
    return e && e.length ? Rd(e, Hn, Xk) : void 0;
  }
  var Va,
    x5 = x(() => {
      "use strict";
      Kk();
      y5();
      gl();
      a(cwt, "min");
      Va = cwt;
    });
  function uwt(e, t) {
    return e && e.length ? Rd(e, Rr(t, 2), Xk) : void 0;
  }
  var lh,
    bH = x(() => {
      "use strict";
      Kk();
      $i();
      y5();
      a(uwt, "minBy");
      lh = uwt;
    });
  function fwt(e) {
    if (typeof e != "function") throw new TypeError(hwt);
    return function () {
      var t = arguments;
      switch (t.length) {
        case 0:
          return !e.call(this);
        case 1:
          return !e.call(this, t[0]);
        case 2:
          return !e.call(this, t[0], t[1]);
        case 3:
          return !e.call(this, t[0], t[1], t[2]);
      }
      return !e.apply(this, t);
    };
  }
  var hwt,
    kH,
    TH = x(() => {
      "use strict";
      hwt = "Expected a function";
      a(fwt, "negate");
      kH = fwt;
    });
  function dwt(e, t, r, n) {
    if (!Nr(e)) return e;
    t = Dc(t, e);
    for (var i = -1, s = t.length, o = s - 1, l = e; l != null && ++i < s; ) {
      var u = vo(t[i]),
        h = r;
      if (u === "__proto__" || u === "constructor" || u === "prototype")
        return e;
      if (i != o) {
        var f = l[u];
        ((h = n ? n(f, u, l) : void 0),
          h === void 0 && (h = Nr(f) ? f : xc(t[i + 1]) ? [] : {}));
      }
      (go(l, u, h), (l = l[u]));
    }
    return e;
  }
  var SH,
    _H = x(() => {
      "use strict";
      nd();
      V0();
      b0();
      Es();
      bd();
      a(dwt, "baseSet");
      SH = dwt;
    });
  function pwt(e, t, r) {
    for (var n = -1, i = t.length, s = {}; ++n < i; ) {
      var o = t[n],
        l = Nc(e, o);
      r(l, o) && SH(s, Dc(o, e), l);
    }
    return s;
  }
  var Qk,
    b5 = x(() => {
      "use strict";
      z0();
      _H();
      V0();
      a(pwt, "basePickBy");
      Qk = pwt;
    });
  function mwt(e, t) {
    if (e == null) return {};
    var r = hs(Tk(e), function (n) {
      return [n];
    });
    return (
      (t = Rr(t)),
      Qk(e, r, function (n, i) {
        return t(n, i[0]);
      })
    );
  }
  var ps,
    CH = x(() => {
      "use strict";
      ih();
      $i();
      b5();
      YA();
      a(mwt, "pickBy");
      ps = mwt;
    });
  function gwt(e, t) {
    var r = e.length;
    for (e.sort(t); r--; ) e[r] = e[r].value;
    return e;
  }
  var wH,
    vH = x(() => {
      "use strict";
      a(gwt, "baseSortBy");
      wH = gwt;
    });
  function ywt(e, t) {
    if (e !== t) {
      var r = e !== void 0,
        n = e === null,
        i = e === e,
        s = Rs(e),
        o = t !== void 0,
        l = t === null,
        u = t === t,
        h = Rs(t);
      if (
        (!l && !h && !s && e > t) ||
        (s && o && u && !l && !h) ||
        (n && o && u) ||
        (!r && u) ||
        !i
      )
        return 1;
      if (
        (!n && !s && !h && e < t) ||
        (h && r && i && !n && !s) ||
        (l && r && i) ||
        (!o && i) ||
        !u
      )
        return -1;
    }
    return 0;
  }
  var EH,
    AH = x(() => {
      "use strict";
      nh();
      a(ywt, "compareAscending");
      EH = ywt;
    });
  function xwt(e, t, r) {
    for (
      var n = -1, i = e.criteria, s = t.criteria, o = i.length, l = r.length;
      ++n < o;

    ) {
      var u = EH(i[n], s[n]);
      if (u) {
        if (n >= l) return u;
        var h = r[n];
        return u * (h == "desc" ? -1 : 1);
      }
    }
    return e.index - t.index;
  }
  var LH,
    RH = x(() => {
      "use strict";
      AH();
      a(xwt, "compareMultiple");
      LH = xwt;
    });
  function bwt(e, t, r) {
    t.length
      ? (t = hs(t, function (s) {
          return Jt(s)
            ? function (o) {
                return Nc(o, s.length === 1 ? s[0] : s);
              }
            : s;
        }))
      : (t = [Hn]);
    var n = -1;
    t = hs(t, Js(Rr));
    var i = jk(e, function (s, o, l) {
      var u = hs(t, function (h) {
        return h(s);
      });
      return { criteria: u, index: ++n, value: s };
    });
    return wH(i, function (s, o) {
      return LH(s, o, r);
    });
  }
  var DH,
    NH = x(() => {
      "use strict";
      ih();
      z0();
      $i();
      h5();
      vH();
      qu();
      RH();
      gl();
      Kr();
      a(bwt, "baseOrderBy");
      DH = bwt;
    });
  var kwt,
    IH,
    MH = x(() => {
      "use strict";
      o5();
      ((kwt = Fk("length")), (IH = kwt));
    });
  function Nwt(e) {
    for (var t = (OH.lastIndex = 0); OH.test(e); ) ++t;
    return t;
  }
  var PH,
    Twt,
    Swt,
    _wt,
    Cwt,
    wwt,
    vwt,
    k5,
    T5,
    Ewt,
    BH,
    FH,
    $H,
    Awt,
    GH,
    VH,
    Lwt,
    Rwt,
    Dwt,
    OH,
    zH,
    WH = x(() => {
      "use strict";
      ((PH = "\\ud800-\\udfff"),
        (Twt = "\\u0300-\\u036f"),
        (Swt = "\\ufe20-\\ufe2f"),
        (_wt = "\\u20d0-\\u20ff"),
        (Cwt = Twt + Swt + _wt),
        (wwt = "\\ufe0e\\ufe0f"),
        (vwt = "[" + PH + "]"),
        (k5 = "[" + Cwt + "]"),
        (T5 = "\\ud83c[\\udffb-\\udfff]"),
        (Ewt = "(?:" + k5 + "|" + T5 + ")"),
        (BH = "[^" + PH + "]"),
        (FH = "(?:\\ud83c[\\udde6-\\uddff]){2}"),
        ($H = "[\\ud800-\\udbff][\\udc00-\\udfff]"),
        (Awt = "\\u200d"),
        (GH = Ewt + "?"),
        (VH = "[" + wwt + "]?"),
        (Lwt =
          "(?:" + Awt + "(?:" + [BH, FH, $H].join("|") + ")" + VH + GH + ")*"),
        (Rwt = VH + GH + Lwt),
        (Dwt = "(?:" + [BH + k5 + "?", k5, FH, $H, vwt].join("|") + ")"),
        (OH = RegExp(T5 + "(?=" + T5 + ")|" + Dwt + Rwt, "g")));
      a(Nwt, "unicodeSize");
      zH = Nwt;
    });
  function Iwt(e) {
    return tj(e) ? zH(e) : IH(e);
  }
  var UH,
    jH = x(() => {
      "use strict";
      MH();
      ej();
      WH();
      a(Iwt, "stringSize");
      UH = Iwt;
    });
  function Mwt(e, t) {
    return Qk(e, t, function (r, n) {
      return Bk(e, n);
    });
  }
  var qH,
    HH = x(() => {
      "use strict";
      b5();
      a5();
      a(Mwt, "basePick");
      qH = Mwt;
    });
  var Owt,
    ch,
    YH = x(() => {
      "use strict";
      HH();
      JU();
      ((Owt = ZU(function (e, t) {
        return e == null ? {} : qH(e, t);
      })),
        (ch = Owt));
    });
  function Fwt(e, t, r, n) {
    for (var i = -1, s = Bwt(Pwt((t - e) / (r || 1)), 0), o = Array(s); s--; )
      ((o[n ? s : ++i] = e), (e += r));
    return o;
  }
  var Pwt,
    Bwt,
    XH,
    KH = x(() => {
      "use strict";
      ((Pwt = Math.ceil), (Bwt = Math.max));
      a(Fwt, "baseRange");
      XH = Fwt;
    });
  function $wt(e) {
    return function (t, r, n) {
      return (
        n && typeof n != "number" && As(t, r, n) && (r = n = void 0),
        (t = pd(t)),
        r === void 0 ? ((r = t), (t = 0)) : (r = pd(r)),
        (n = n === void 0 ? (t < r ? 1 : -1) : pd(n)),
        XH(t, r, n, e)
      );
    };
  }
  var QH,
    ZH = x(() => {
      "use strict";
      KH();
      Yu();
      BA();
      a($wt, "createRange");
      QH = $wt;
    });
  var Gwt,
    sa,
    JH = x(() => {
      "use strict";
      ZH();
      ((Gwt = QH()), (sa = Gwt));
    });
  function Vwt(e, t, r, n, i) {
    return (
      i(e, function (s, o, l) {
        r = n ? ((n = !1), s) : t(r, s, o, l);
      }),
      r
    );
  }
  var tY,
    eY = x(() => {
      "use strict";
      a(Vwt, "baseReduce");
      tY = Vwt;
    });
  function zwt(e, t, r) {
    var n = Jt(e) ? rj : tY,
      i = arguments.length < 3;
    return n(e, Rr(t, 4), r, i, fs);
  }
  var mr,
    S5 = x(() => {
      "use strict";
      nj();
      Mc();
      $i();
      eY();
      Kr();
      a(zwt, "reduce");
      mr = zwt;
    });
  function Wwt(e, t) {
    var r = Jt(e) ? Sd : Uk;
    return r(e, kH(Rr(t, 3)));
  }
  var Bc,
    rY = x(() => {
      "use strict";
      gk();
      c5();
      $i();
      Kr();
      TH();
      a(Wwt, "reject");
      Bc = Wwt;
    });
  function qwt(e) {
    if (e == null) return 0;
    if (dn(e)) return bn(e) ? UH(e) : e.length;
    var t = Ds(e);
    return t == Uwt || t == jwt ? e.size : yd(e).length;
  }
  var Uwt,
    jwt,
    _5,
    nY = x(() => {
      "use strict";
      uk();
      ah();
      Zs();
      qk();
      jH();
      ((Uwt = "[object Map]"), (jwt = "[object Set]"));
      a(qwt, "size");
      _5 = qwt;
    });
  function Hwt(e, t) {
    var r;
    return (
      fs(e, function (n, i, s) {
        return ((r = t(n, i, s)), !r);
      }),
      !!r
    );
  }
  var iY,
    sY = x(() => {
      "use strict";
      Mc();
      a(Hwt, "baseSome");
      iY = Hwt;
    });
  function Ywt(e, t, r) {
    var n = Jt(e) ? Ak : iY;
    return (r && As(e, t, r) && (t = void 0), n(e, Rr(t, 3)));
  }
  var U0,
    aY = x(() => {
      "use strict";
      JA();
      $i();
      sY();
      Kr();
      Yu();
      a(Ywt, "some");
      U0 = Ywt;
    });
  var Xwt,
    Lo,
    oY = x(() => {
      "use strict";
      Td();
      NH();
      id();
      Yu();
      ((Xwt = yo(function (e, t) {
        if (e == null) return [];
        var r = t.length;
        return (
          r > 1 && As(e, t[0], t[1])
            ? (t = [])
            : r > 2 && As(t[0], t[1], t[2]) && (t = [t[0]]),
          DH(e, Eo(t, 1), [])
        );
      })),
        (Lo = Xwt));
    });
  var Kwt,
    Qwt,
    lY,
    cY = x(() => {
      "use strict";
      XA();
      FA();
      Dk();
      ((Kwt = 1 / 0),
        (Qwt =
          Ic && 1 / vd(new Ic([, -0]))[1] == Kwt
            ? function (e) {
                return new Ic(e);
              }
            : ln),
        (lY = Qwt));
    });
  function Jwt(e, t, r) {
    var n = -1,
      i = ck,
      s = e.length,
      o = !0,
      l = [],
      u = l;
    if (r) ((o = !1), (i = Vk));
    else if (s >= Zwt) {
      var h = t ? null : lY(e);
      if (h) return vd(h);
      ((o = !1), (i = wd), (u = new Cd()));
    } else u = t ? [] : l;
    t: for (; ++n < s; ) {
      var f = e[n],
        d = t ? t(f) : f;
      if (((f = r || f !== 0 ? f : 0), o && d === d)) {
        for (var p = u.length; p--; ) if (u[p] === d) continue t;
        (t && u.push(d), l.push(f));
      } else i(u, d, r) || (u !== l && u.push(d), l.push(f));
    }
    return l;
  }
  var Zwt,
    Dd,
    Zk = x(() => {
      "use strict";
      Ek();
      VA();
      l5();
      Lk();
      cY();
      Dk();
      Zwt = 200;
      a(Jwt, "baseUniq");
      Dd = Jwt;
    });
  var tvt,
    C5,
    uY = x(() => {
      "use strict";
      Td();
      id();
      Zk();
      ob();
      ((tvt = yo(function (e) {
        return Dd(Eo(e, 1, ju, !0));
      })),
        (C5 = tvt));
    });
  function evt(e) {
    return e && e.length ? Dd(e) : [];
  }
  var Nd,
    hY = x(() => {
      "use strict";
      Zk();
      a(evt, "uniq");
      Nd = evt;
    });
  function rvt(e, t) {
    return e && e.length ? Dd(e, Rr(t, 2)) : [];
  }
  var fY,
    dY = x(() => {
      "use strict";
      $i();
      Zk();
      a(rvt, "uniqBy");
      fY = rvt;
    });
  function ivt(e) {
    var t = ++nvt;
    return fk(e) + t;
  }
  var nvt,
    uh,
    pY = x(() => {
      "use strict";
      zA();
      nvt = 0;
      a(ivt, "uniqueId");
      uh = ivt;
    });
  function svt(e, t, r) {
    for (var n = -1, i = e.length, s = t.length, o = {}; ++n < i; ) {
      var l = n < s ? t[n] : void 0;
      r(o, e[n], l);
    }
    return o;
  }
  var mY,
    gY = x(() => {
      "use strict";
      a(svt, "baseZipObject");
      mY = svt;
    });
  function avt(e, t) {
    return mY(e || [], t || [], go);
  }
  var Jk,
    yY = x(() => {
      "use strict";
      nd();
      gY();
      a(avt, "zipObject");
      Jk = avt;
    });
  var he = x(() => {
    "use strict";
    VU();
    QA();
    jj();
    qj();
    b4();
    Mq();
    Bq();
    $q();
    Gq();
    Vq();
    qq();
    u5();
    Qq();
    Jq();
    f5();
    pk();
    Wk();
    tH();
    eH();
    rH();
    oH();
    gl();
    uH();
    hH();
    Kr();
    Yk();
    l0();
    Es();
    mH();
    qk();
    gH();
    wo();
    Fq();
    Ld();
    yH();
    xH();
    S4();
    x5();
    bH();
    FA();
    Nq();
    YH();
    CH();
    JH();
    S5();
    rY();
    nY();
    aY();
    oY();
    uY();
    hY();
    pY();
    g5();
    yY();
  });
  function bY(e, t) {
    e[t] ? e[t]++ : (e[t] = 1);
  }
  function kY(e, t) {
    --e[t] || delete e[t];
  }
  function j0(e, t, r, n) {
    var i = "" + t,
      s = "" + r;
    if (!e && i > s) {
      var o = i;
      ((i = s), (s = o));
    }
    return i + xY + s + xY + (Fe(n) ? ovt : n);
  }
  function lvt(e, t, r, n) {
    var i = "" + t,
      s = "" + r;
    if (!e && i > s) {
      var o = i;
      ((i = s), (s = o));
    }
    var l = { v: i, w: s };
    return (n && (l.name = n), l);
  }
  function w5(e, t) {
    return j0(e, t.v, t.w, t.name);
  }
  var ovt,
    hh,
    xY,
    _r,
    tT = x(() => {
      "use strict";
      he();
      ((ovt = "\0"),
        (hh = "\0"),
        (xY = ""),
        (_r = class {
          static {
            a(this, "Graph");
          }
          constructor(t = {}) {
            ((this._isDirected = Object.prototype.hasOwnProperty.call(
              t,
              "directed",
            )
              ? t.directed
              : !0),
              (this._isMultigraph = Object.prototype.hasOwnProperty.call(
                t,
                "multigraph",
              )
                ? t.multigraph
                : !1),
              (this._isCompound = Object.prototype.hasOwnProperty.call(
                t,
                "compound",
              )
                ? t.compound
                : !1),
              (this._label = void 0),
              (this._defaultNodeLabelFn = is(void 0)),
              (this._defaultEdgeLabelFn = is(void 0)),
              (this._nodes = {}),
              this._isCompound &&
                ((this._parent = {}),
                (this._children = {}),
                (this._children[hh] = {})),
              (this._in = {}),
              (this._preds = {}),
              (this._out = {}),
              (this._sucs = {}),
              (this._edgeObjs = {}),
              (this._edgeLabels = {}));
          }
          isDirected() {
            return this._isDirected;
          }
          isMultigraph() {
            return this._isMultigraph;
          }
          isCompound() {
            return this._isCompound;
          }
          setGraph(t) {
            return ((this._label = t), this);
          }
          graph() {
            return this._label;
          }
          setDefaultNodeLabel(t) {
            return (vn(t) || (t = is(t)), (this._defaultNodeLabelFn = t), this);
          }
          nodeCount() {
            return this._nodeCount;
          }
          nodes() {
            return cr(this._nodes);
          }
          sources() {
            var t = this;
            return pr(this.nodes(), function (r) {
              return De(t._in[r]);
            });
          }
          sinks() {
            var t = this;
            return pr(this.nodes(), function (r) {
              return De(t._out[r]);
            });
          }
          setNodes(t, r) {
            var n = arguments,
              i = this;
            return (
              rt(t, function (s) {
                n.length > 1 ? i.setNode(s, r) : i.setNode(s);
              }),
              this
            );
          }
          setNode(t, r) {
            return Object.prototype.hasOwnProperty.call(this._nodes, t)
              ? (arguments.length > 1 && (this._nodes[t] = r), this)
              : ((this._nodes[t] =
                  arguments.length > 1 ? r : this._defaultNodeLabelFn(t)),
                this._isCompound &&
                  ((this._parent[t] = hh),
                  (this._children[t] = {}),
                  (this._children[hh][t] = !0)),
                (this._in[t] = {}),
                (this._preds[t] = {}),
                (this._out[t] = {}),
                (this._sucs[t] = {}),
                ++this._nodeCount,
                this);
          }
          node(t) {
            return this._nodes[t];
          }
          hasNode(t) {
            return Object.prototype.hasOwnProperty.call(this._nodes, t);
          }
          removeNode(t) {
            if (Object.prototype.hasOwnProperty.call(this._nodes, t)) {
              var r = a(
                (n) => this.removeEdge(this._edgeObjs[n]),
                "removeEdge",
              );
              (delete this._nodes[t],
                this._isCompound &&
                  (this._removeFromParentsChildList(t),
                  delete this._parent[t],
                  rt(this.children(t), (n) => {
                    this.setParent(n);
                  }),
                  delete this._children[t]),
                rt(cr(this._in[t]), r),
                delete this._in[t],
                delete this._preds[t],
                rt(cr(this._out[t]), r),
                delete this._out[t],
                delete this._sucs[t],
                --this._nodeCount);
            }
            return this;
          }
          setParent(t, r) {
            if (!this._isCompound)
              throw new Error("Cannot set parent in a non-compound graph");
            if (Fe(r)) r = hh;
            else {
              r += "";
              for (var n = r; !Fe(n); n = this.parent(n))
                if (n === t)
                  throw new Error(
                    "Setting " +
                      r +
                      " as parent of " +
                      t +
                      " would create a cycle",
                  );
              this.setNode(r);
            }
            return (
              this.setNode(t),
              this._removeFromParentsChildList(t),
              (this._parent[t] = r),
              (this._children[r][t] = !0),
              this
            );
          }
          _removeFromParentsChildList(t) {
            delete this._children[this._parent[t]][t];
          }
          parent(t) {
            if (this._isCompound) {
              var r = this._parent[t];
              if (r !== hh) return r;
            }
          }
          children(t) {
            if ((Fe(t) && (t = hh), this._isCompound)) {
              var r = this._children[t];
              if (r) return cr(r);
            } else {
              if (t === hh) return this.nodes();
              if (this.hasNode(t)) return [];
            }
          }
          predecessors(t) {
            var r = this._preds[t];
            if (r) return cr(r);
          }
          successors(t) {
            var r = this._sucs[t];
            if (r) return cr(r);
          }
          neighbors(t) {
            var r = this.predecessors(t);
            if (r) return C5(r, this.successors(t));
          }
          isLeaf(t) {
            var r;
            return (
              this.isDirected()
                ? (r = this.successors(t))
                : (r = this.neighbors(t)),
              r.length === 0
            );
          }
          filterNodes(t) {
            var r = new this.constructor({
              directed: this._isDirected,
              multigraph: this._isMultigraph,
              compound: this._isCompound,
            });
            r.setGraph(this.graph());
            var n = this;
            (rt(this._nodes, function (o, l) {
              t(l) && r.setNode(l, o);
            }),
              rt(this._edgeObjs, function (o) {
                r.hasNode(o.v) && r.hasNode(o.w) && r.setEdge(o, n.edge(o));
              }));
            var i = {};
            function s(o) {
              var l = n.parent(o);
              return l === void 0 || r.hasNode(l)
                ? ((i[o] = l), l)
                : l in i
                  ? i[l]
                  : s(l);
            }
            return (
              a(s, "findParent"),
              this._isCompound &&
                rt(r.nodes(), function (o) {
                  r.setParent(o, s(o));
                }),
              r
            );
          }
          setDefaultEdgeLabel(t) {
            return (vn(t) || (t = is(t)), (this._defaultEdgeLabelFn = t), this);
          }
          edgeCount() {
            return this._edgeCount;
          }
          edges() {
            return We(this._edgeObjs);
          }
          setPath(t, r) {
            var n = this,
              i = arguments;
            return (
              mr(t, function (s, o) {
                return (i.length > 1 ? n.setEdge(s, o, r) : n.setEdge(s, o), o);
              }),
              this
            );
          }
          setEdge() {
            var t,
              r,
              n,
              i,
              s = !1,
              o = arguments[0];
            (typeof o == "object" && o !== null && "v" in o
              ? ((t = o.v),
                (r = o.w),
                (n = o.name),
                arguments.length === 2 && ((i = arguments[1]), (s = !0)))
              : ((t = o),
                (r = arguments[1]),
                (n = arguments[3]),
                arguments.length > 2 && ((i = arguments[2]), (s = !0))),
              (t = "" + t),
              (r = "" + r),
              Fe(n) || (n = "" + n));
            var l = j0(this._isDirected, t, r, n);
            if (Object.prototype.hasOwnProperty.call(this._edgeLabels, l))
              return (s && (this._edgeLabels[l] = i), this);
            if (!Fe(n) && !this._isMultigraph)
              throw new Error(
                "Cannot set a named edge when isMultigraph = false",
              );
            (this.setNode(t),
              this.setNode(r),
              (this._edgeLabels[l] = s
                ? i
                : this._defaultEdgeLabelFn(t, r, n)));
            var u = lvt(this._isDirected, t, r, n);
            return (
              (t = u.v),
              (r = u.w),
              Object.freeze(u),
              (this._edgeObjs[l] = u),
              bY(this._preds[r], t),
              bY(this._sucs[t], r),
              (this._in[r][l] = u),
              (this._out[t][l] = u),
              this._edgeCount++,
              this
            );
          }
          edge(t, r, n) {
            var i =
              arguments.length === 1
                ? w5(this._isDirected, arguments[0])
                : j0(this._isDirected, t, r, n);
            return this._edgeLabels[i];
          }
          hasEdge(t, r, n) {
            var i =
              arguments.length === 1
                ? w5(this._isDirected, arguments[0])
                : j0(this._isDirected, t, r, n);
            return Object.prototype.hasOwnProperty.call(this._edgeLabels, i);
          }
          removeEdge(t, r, n) {
            var i =
                arguments.length === 1
                  ? w5(this._isDirected, arguments[0])
                  : j0(this._isDirected, t, r, n),
              s = this._edgeObjs[i];
            return (
              s &&
                ((t = s.v),
                (r = s.w),
                delete this._edgeLabels[i],
                delete this._edgeObjs[i],
                kY(this._preds[r], t),
                kY(this._sucs[t], r),
                delete this._in[r][i],
                delete this._out[t][i],
                this._edgeCount--),
              this
            );
          }
          inEdges(t, r) {
            var n = this._in[t];
            if (n) {
              var i = We(n);
              return r
                ? pr(i, function (s) {
                    return s.v === r;
                  })
                : i;
            }
          }
          outEdges(t, r) {
            var n = this._out[t];
            if (n) {
              var i = We(n);
              return r
                ? pr(i, function (s) {
                    return s.w === r;
                  })
                : i;
            }
          }
          nodeEdges(t, r) {
            var n = this.inEdges(t, r);
            if (n) return n.concat(this.outEdges(t, r));
          }
        }));
      _r.prototype._nodeCount = 0;
      _r.prototype._edgeCount = 0;
      a(bY, "incrementOrInitEntry");
      a(kY, "decrementOrRemoveEntry");
      a(j0, "edgeArgsToId");
      a(lvt, "edgeArgsToObj");
      a(w5, "edgeObjToId");
    });
  var aa = x(() => {
    "use strict";
    tT();
  });
  function TY(e) {
    ((e._prev._next = e._next),
      (e._next._prev = e._prev),
      delete e._next,
      delete e._prev);
  }
  function cvt(e, t) {
    if (e !== "_next" && e !== "_prev") return t;
  }
  var rT,
    SY = x(() => {
      "use strict";
      rT = class {
        static {
          a(this, "List");
        }
        constructor() {
          var t = {};
          ((t._next = t._prev = t), (this._sentinel = t));
        }
        dequeue() {
          var t = this._sentinel,
            r = t._prev;
          if (r !== t) return (TY(r), r);
        }
        enqueue(t) {
          var r = this._sentinel;
          (t._prev && t._next && TY(t),
            (t._next = r._next),
            (r._next._prev = t),
            (r._next = t),
            (t._prev = r));
        }
        toString() {
          for (var t = [], r = this._sentinel, n = r._prev; n !== r; )
            (t.push(JSON.stringify(n, cvt)), (n = n._prev));
          return "[" + t.join(", ") + "]";
        }
      };
      a(TY, "unlink");
      a(cvt, "filterOutLinks");
    });
  function _Y(e, t) {
    if (e.nodeCount() <= 1) return [];
    var r = fvt(e, t || uvt),
      n = hvt(r.graph, r.buckets, r.zeroIdx);
    return dr(
      Dt(n, function (i) {
        return e.outEdges(i.v, i.w);
      }),
    );
  }
  function hvt(e, t, r) {
    for (var n = [], i = t[t.length - 1], s = t[0], o; e.nodeCount(); ) {
      for (; (o = s.dequeue()); ) v5(e, t, r, o);
      for (; (o = i.dequeue()); ) v5(e, t, r, o);
      if (e.nodeCount()) {
        for (var l = t.length - 2; l > 0; --l)
          if (((o = t[l].dequeue()), o)) {
            n = n.concat(v5(e, t, r, o, !0));
            break;
          }
      }
    }
    return n;
  }
  function v5(e, t, r, n, i) {
    var s = i ? [] : void 0;
    return (
      rt(e.inEdges(n.v), function (o) {
        var l = e.edge(o),
          u = e.node(o.v);
        (i && s.push({ v: o.v, w: o.w }), (u.out -= l), E5(t, r, u));
      }),
      rt(e.outEdges(n.v), function (o) {
        var l = e.edge(o),
          u = o.w,
          h = e.node(u);
        ((h.in -= l), E5(t, r, h));
      }),
      e.removeNode(n.v),
      s
    );
  }
  function fvt(e, t) {
    var r = new _r(),
      n = 0,
      i = 0;
    (rt(e.nodes(), function (l) {
      r.setNode(l, { v: l, in: 0, out: 0 });
    }),
      rt(e.edges(), function (l) {
        var u = r.edge(l.v, l.w) || 0,
          h = t(l),
          f = u + h;
        (r.setEdge(l.v, l.w, f),
          (i = Math.max(i, (r.node(l.v).out += h))),
          (n = Math.max(n, (r.node(l.w).in += h))));
      }));
    var s = sa(i + n + 3).map(function () {
        return new rT();
      }),
      o = n + 1;
    return (
      rt(r.nodes(), function (l) {
        E5(s, o, r.node(l));
      }),
      { graph: r, buckets: s, zeroIdx: o }
    );
  }
  function E5(e, t, r) {
    r.out
      ? r.in
        ? e[r.out - r.in + t].enqueue(r)
        : e[e.length - 1].enqueue(r)
      : e[0].enqueue(r);
  }
  var uvt,
    CY = x(() => {
      "use strict";
      he();
      aa();
      SY();
      uvt = is(1);
      a(_Y, "greedyFAS");
      a(hvt, "doGreedyFAS");
      a(v5, "removeNode");
      a(fvt, "buildState");
      a(E5, "assignBucket");
    });
  function wY(e) {
    var t = e.graph().acyclicer === "greedy" ? _Y(e, r(e)) : dvt(e);
    rt(t, function (n) {
      var i = e.edge(n);
      (e.removeEdge(n),
        (i.forwardName = n.name),
        (i.reversed = !0),
        e.setEdge(n.w, n.v, i, uh("rev")));
    });
    function r(n) {
      return function (i) {
        return n.edge(i).weight;
      };
    }
    a(r, "weightFn");
  }
  function dvt(e) {
    var t = [],
      r = {},
      n = {};
    function i(s) {
      Object.prototype.hasOwnProperty.call(n, s) ||
        ((n[s] = !0),
        (r[s] = !0),
        rt(e.outEdges(s), function (o) {
          Object.prototype.hasOwnProperty.call(r, o.w) ? t.push(o) : i(o.w);
        }),
        delete r[s]);
    }
    return (a(i, "dfs"), rt(e.nodes(), i), t);
  }
  function vY(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t);
      if (r.reversed) {
        e.removeEdge(t);
        var n = r.forwardName;
        (delete r.reversed, delete r.forwardName, e.setEdge(t.w, t.v, r, n));
      }
    });
  }
  var A5 = x(() => {
    "use strict";
    he();
    CY();
    a(wY, "run");
    a(dvt, "dfsFAS");
    a(vY, "undo");
  });
  function Ro(e, t, r, n) {
    var i;
    do i = uh(n);
    while (e.hasNode(i));
    return ((r.dummy = t), e.setNode(i, r), i);
  }
  function AY(e) {
    var t = new _r().setGraph(e.graph());
    return (
      rt(e.nodes(), function (r) {
        t.setNode(r, e.node(r));
      }),
      rt(e.edges(), function (r) {
        var n = t.edge(r.v, r.w) || { weight: 0, minlen: 1 },
          i = e.edge(r);
        t.setEdge(r.v, r.w, {
          weight: n.weight + i.weight,
          minlen: Math.max(n.minlen, i.minlen),
        });
      }),
      t
    );
  }
  function nT(e) {
    var t = new _r({ multigraph: e.isMultigraph() }).setGraph(e.graph());
    return (
      rt(e.nodes(), function (r) {
        e.children(r).length || t.setNode(r, e.node(r));
      }),
      rt(e.edges(), function (r) {
        t.setEdge(r, e.edge(r));
      }),
      t
    );
  }
  function L5(e, t) {
    var r = e.x,
      n = e.y,
      i = t.x - r,
      s = t.y - n,
      o = e.width / 2,
      l = e.height / 2;
    if (!i && !s)
      throw new Error(
        "Not possible to find intersection inside of the rectangle",
      );
    var u, h;
    return (
      Math.abs(s) * o > Math.abs(i) * l
        ? (s < 0 && (l = -l), (u = (l * i) / s), (h = l))
        : (i < 0 && (o = -o), (u = o), (h = (o * s) / i)),
      { x: r + u, y: n + h }
    );
  }
  function Fc(e) {
    var t = Dt(sa(D5(e) + 1), function () {
      return [];
    });
    return (
      rt(e.nodes(), function (r) {
        var n = e.node(r),
          i = n.rank;
        Fe(i) || (t[i][n.order] = r);
      }),
      t
    );
  }
  function LY(e) {
    var t = Va(
      Dt(e.nodes(), function (r) {
        return e.node(r).rank;
      }),
    );
    rt(e.nodes(), function (r) {
      var n = e.node(r);
      te(n, "rank") && (n.rank -= t);
    });
  }
  function RY(e) {
    var t = Va(
        Dt(e.nodes(), function (s) {
          return e.node(s).rank;
        }),
      ),
      r = [];
    rt(e.nodes(), function (s) {
      var o = e.node(s).rank - t;
      (r[o] || (r[o] = []), r[o].push(s));
    });
    var n = 0,
      i = e.graph().nodeRankFactor;
    rt(r, function (s, o) {
      Fe(s) && o % i !== 0
        ? --n
        : n &&
          rt(s, function (l) {
            e.node(l).rank += n;
          });
    });
  }
  function R5(e, t, r, n) {
    var i = { width: 0, height: 0 };
    return (
      arguments.length >= 4 && ((i.rank = r), (i.order = n)),
      Ro(e, "border", i, t)
    );
  }
  function D5(e) {
    return ds(
      Dt(e.nodes(), function (t) {
        var r = e.node(t).rank;
        if (!Fe(r)) return r;
      }),
    );
  }
  function DY(e, t) {
    var r = { lhs: [], rhs: [] };
    return (
      rt(e, function (n) {
        t(n) ? r.lhs.push(n) : r.rhs.push(n);
      }),
      r
    );
  }
  function NY(e, t) {
    var r = Gk();
    try {
      return t();
    } finally {
      console.log(e + " time: " + (Gk() - r) + "ms");
    }
  }
  function IY(e, t) {
    return t();
  }
  var Do = x(() => {
    "use strict";
    he();
    aa();
    a(Ro, "addDummyNode");
    a(AY, "simplify");
    a(nT, "asNonCompoundGraph");
    a(L5, "intersectRect");
    a(Fc, "buildLayerMatrix");
    a(LY, "normalizeRanks");
    a(RY, "removeEmptyRanks");
    a(R5, "addBorderNode");
    a(D5, "maxRank");
    a(DY, "partition");
    a(NY, "time");
    a(IY, "notime");
  });
  function OY(e) {
    function t(r) {
      var n = e.children(r),
        i = e.node(r);
      if (
        (n.length && rt(n, t),
        Object.prototype.hasOwnProperty.call(i, "minRank"))
      ) {
        ((i.borderLeft = []), (i.borderRight = []));
        for (var s = i.minRank, o = i.maxRank + 1; s < o; ++s)
          (MY(e, "borderLeft", "_bl", r, i, s),
            MY(e, "borderRight", "_br", r, i, s));
      }
    }
    (a(t, "dfs"), rt(e.children(), t));
  }
  function MY(e, t, r, n, i, s) {
    var o = { width: 0, height: 0, rank: s, borderType: t },
      l = i[t][s - 1],
      u = Ro(e, "border", o, r);
    ((i[t][s] = u), e.setParent(u, n), l && e.setEdge(l, u, { weight: 1 }));
  }
  var PY = x(() => {
    "use strict";
    he();
    Do();
    a(OY, "addBorderSegments");
    a(MY, "addBorderNode");
  });
  function FY(e) {
    var t = e.graph().rankdir.toLowerCase();
    (t === "lr" || t === "rl") && GY(e);
  }
  function $Y(e) {
    var t = e.graph().rankdir.toLowerCase();
    ((t === "bt" || t === "rl") && pvt(e),
      (t === "lr" || t === "rl") && (mvt(e), GY(e)));
  }
  function GY(e) {
    (rt(e.nodes(), function (t) {
      BY(e.node(t));
    }),
      rt(e.edges(), function (t) {
        BY(e.edge(t));
      }));
  }
  function BY(e) {
    var t = e.width;
    ((e.width = e.height), (e.height = t));
  }
  function pvt(e) {
    (rt(e.nodes(), function (t) {
      N5(e.node(t));
    }),
      rt(e.edges(), function (t) {
        var r = e.edge(t);
        (rt(r.points, N5),
          Object.prototype.hasOwnProperty.call(r, "y") && N5(r));
      }));
  }
  function N5(e) {
    e.y = -e.y;
  }
  function mvt(e) {
    (rt(e.nodes(), function (t) {
      I5(e.node(t));
    }),
      rt(e.edges(), function (t) {
        var r = e.edge(t);
        (rt(r.points, I5),
          Object.prototype.hasOwnProperty.call(r, "x") && I5(r));
      }));
  }
  function I5(e) {
    var t = e.x;
    ((e.x = e.y), (e.y = t));
  }
  var VY = x(() => {
    "use strict";
    he();
    a(FY, "adjust");
    a($Y, "undo");
    a(GY, "swapWidthHeight");
    a(BY, "swapWidthHeightOne");
    a(pvt, "reverseY");
    a(N5, "reverseYOne");
    a(mvt, "swapXY");
    a(I5, "swapXYOne");
  });
  function zY(e) {
    ((e.graph().dummyChains = []),
      rt(e.edges(), function (t) {
        yvt(e, t);
      }));
  }
  function yvt(e, t) {
    var r = t.v,
      n = e.node(r).rank,
      i = t.w,
      s = e.node(i).rank,
      o = t.name,
      l = e.edge(t),
      u = l.labelRank;
    if (s !== n + 1) {
      e.removeEdge(t);
      var h = void 0,
        f,
        d;
      for (d = 0, ++n; n < s; ++d, ++n)
        ((l.points = []),
          (h = { width: 0, height: 0, edgeLabel: l, edgeObj: t, rank: n }),
          (f = Ro(e, "edge", h, "_d")),
          n === u &&
            ((h.width = l.width),
            (h.height = l.height),
            (h.dummy = "edge-label"),
            (h.labelpos = l.labelpos)),
          e.setEdge(r, f, { weight: l.weight }, o),
          d === 0 && e.graph().dummyChains.push(f),
          (r = f));
      e.setEdge(r, i, { weight: l.weight }, o);
    }
  }
  function WY(e) {
    rt(e.graph().dummyChains, function (t) {
      var r = e.node(t),
        n = r.edgeLabel,
        i;
      for (e.setEdge(r.edgeObj, n); r.dummy; )
        ((i = e.successors(t)[0]),
          e.removeNode(t),
          n.points.push({ x: r.x, y: r.y }),
          r.dummy === "edge-label" &&
            ((n.x = r.x),
            (n.y = r.y),
            (n.width = r.width),
            (n.height = r.height)),
          (t = i),
          (r = e.node(t)));
    });
  }
  var M5 = x(() => {
    "use strict";
    he();
    Do();
    a(zY, "run");
    a(yvt, "normalizeEdge");
    a(WY, "undo");
  });
  function q0(e) {
    var t = {};
    function r(n) {
      var i = e.node(n);
      if (Object.prototype.hasOwnProperty.call(t, n)) return i.rank;
      t[n] = !0;
      var s = Va(
        Dt(e.outEdges(n), function (o) {
          return r(o.w) - e.edge(o).minlen;
        }),
      );
      return (
        (s === Number.POSITIVE_INFINITY || s === void 0 || s === null) &&
          (s = 0),
        (i.rank = s)
      );
    }
    (a(r, "dfs"), rt(e.sources(), r));
  }
  function fh(e, t) {
    return e.node(t.w).rank - e.node(t.v).rank - e.edge(t).minlen;
  }
  var iT = x(() => {
    "use strict";
    he();
    a(q0, "longestPath");
    a(fh, "slack");
  });
  function sT(e) {
    var t = new _r({ directed: !1 }),
      r = e.nodes()[0],
      n = e.nodeCount();
    t.setNode(r, {});
    for (var i, s; xvt(t, e) < n; )
      ((i = bvt(t, e)),
        (s = t.hasNode(i.v) ? fh(e, i) : -fh(e, i)),
        kvt(t, e, s));
    return t;
  }
  function xvt(e, t) {
    function r(n) {
      rt(t.nodeEdges(n), function (i) {
        var s = i.v,
          o = n === s ? i.w : s;
        !e.hasNode(o) &&
          !fh(t, i) &&
          (e.setNode(o, {}), e.setEdge(n, o, {}), r(o));
      });
    }
    return (a(r, "dfs"), rt(e.nodes(), r), e.nodeCount());
  }
  function bvt(e, t) {
    return lh(t.edges(), function (r) {
      if (e.hasNode(r.v) !== e.hasNode(r.w)) return fh(t, r);
    });
  }
  function kvt(e, t, r) {
    rt(e.nodes(), function (n) {
      t.node(n).rank += r;
    });
  }
  var O5 = x(() => {
    "use strict";
    he();
    aa();
    iT();
    a(sT, "feasibleTree");
    a(xvt, "tightTree");
    a(bvt, "findMinSlackEdge");
    a(kvt, "shiftRanks");
  });
  var jY = x(() => {
    "use strict";
  });
  var P5 = x(() => {
    "use strict";
  });
  var hAe,
    B5 = x(() => {
      "use strict";
      he();
      P5();
      hAe = is(1);
    });
  var qY = x(() => {
    "use strict";
    B5();
  });
  var F5 = x(() => {
    "use strict";
  });
  var HY = x(() => {
    "use strict";
    F5();
  });
  var SAe,
    YY = x(() => {
      "use strict";
      he();
      SAe = is(1);
    });
  function $5(e) {
    var t = {},
      r = {},
      n = [];
    function i(s) {
      if (Object.prototype.hasOwnProperty.call(r, s)) throw new H0();
      Object.prototype.hasOwnProperty.call(t, s) ||
        ((r[s] = !0),
        (t[s] = !0),
        rt(e.predecessors(s), i),
        delete r[s],
        n.push(s));
    }
    if ((a(i, "visit"), rt(e.sinks(), i), _5(t) !== e.nodeCount()))
      throw new H0();
    return n;
  }
  function H0() {}
  var G5 = x(() => {
    "use strict";
    he();
    $5.CycleException = H0;
    a($5, "topsort");
    a(H0, "CycleException");
    H0.prototype = new Error();
  });
  var XY = x(() => {
    "use strict";
    G5();
  });
  function aT(e, t, r) {
    Jt(t) || (t = [t]);
    var n = (e.isDirected() ? e.successors : e.neighbors).bind(e),
      i = [],
      s = {};
    return (
      rt(t, function (o) {
        if (!e.hasNode(o)) throw new Error("Graph does not have node: " + o);
        KY(e, o, r === "post", s, n, i);
      }),
      i
    );
  }
  function KY(e, t, r, n, i, s) {
    Object.prototype.hasOwnProperty.call(n, t) ||
      ((n[t] = !0),
      r || s.push(t),
      rt(i(t), function (o) {
        KY(e, o, r, n, i, s);
      }),
      r && s.push(t));
  }
  var V5 = x(() => {
    "use strict";
    he();
    a(aT, "dfs");
    a(KY, "doDfs");
  });
  function z5(e, t) {
    return aT(e, t, "post");
  }
  var QY = x(() => {
    "use strict";
    V5();
    a(z5, "postorder");
  });
  function W5(e, t) {
    return aT(e, t, "pre");
  }
  var ZY = x(() => {
    "use strict";
    V5();
    a(W5, "preorder");
  });
  var JY = x(() => {
    "use strict";
    P5();
    tT();
  });
  var tX = x(() => {
    "use strict";
    jY();
    B5();
    qY();
    HY();
    YY();
    XY();
    QY();
    ZY();
    JY();
    F5();
    G5();
  });
  function Gc(e) {
    ((e = AY(e)), q0(e));
    var t = sT(e);
    (j5(t), U5(t, e));
    for (var r, n; (r = iX(t)); ) ((n = sX(t, e, r)), aX(t, e, r, n));
  }
  function U5(e, t) {
    var r = z5(e, e.nodes());
    ((r = r.slice(0, r.length - 1)),
      rt(r, function (n) {
        wvt(e, t, n);
      }));
  }
  function wvt(e, t, r) {
    var n = e.node(r),
      i = n.parent;
    e.edge(r, i).cutvalue = rX(e, t, r);
  }
  function rX(e, t, r) {
    var n = e.node(r),
      i = n.parent,
      s = !0,
      o = t.edge(r, i),
      l = 0;
    return (
      o || ((s = !1), (o = t.edge(i, r))),
      (l = o.weight),
      rt(t.nodeEdges(r), function (u) {
        var h = u.v === r,
          f = h ? u.w : u.v;
        if (f !== i) {
          var d = h === s,
            p = t.edge(u).weight;
          if (((l += d ? p : -p), Evt(e, r, f))) {
            var m = e.edge(r, f).cutvalue;
            l += d ? -m : m;
          }
        }
      }),
      l
    );
  }
  function j5(e, t) {
    (arguments.length < 2 && (t = e.nodes()[0]), nX(e, {}, 1, t));
  }
  function nX(e, t, r, n, i) {
    var s = r,
      o = e.node(n);
    return (
      (t[n] = !0),
      rt(e.neighbors(n), function (l) {
        Object.prototype.hasOwnProperty.call(t, l) || (r = nX(e, t, r, l, n));
      }),
      (o.low = s),
      (o.lim = r++),
      i ? (o.parent = i) : delete o.parent,
      r
    );
  }
  function iX(e) {
    return Gi(e.edges(), function (t) {
      return e.edge(t).cutvalue < 0;
    });
  }
  function sX(e, t, r) {
    var n = r.v,
      i = r.w;
    t.hasEdge(n, i) || ((n = r.w), (i = r.v));
    var s = e.node(n),
      o = e.node(i),
      l = s,
      u = !1;
    s.lim > o.lim && ((l = o), (u = !0));
    var h = pr(t.edges(), function (f) {
      return u === eX(e, e.node(f.v), l) && u !== eX(e, e.node(f.w), l);
    });
    return lh(h, function (f) {
      return fh(t, f);
    });
  }
  function aX(e, t, r, n) {
    var i = r.v,
      s = r.w;
    (e.removeEdge(i, s), e.setEdge(n.v, n.w, {}), j5(e), U5(e, t), vvt(e, t));
  }
  function vvt(e, t) {
    var r = Gi(e.nodes(), function (i) {
        return !t.node(i).parent;
      }),
      n = W5(e, r);
    ((n = n.slice(1)),
      rt(n, function (i) {
        var s = e.node(i).parent,
          o = t.edge(i, s),
          l = !1;
        (o || ((o = t.edge(s, i)), (l = !0)),
          (t.node(i).rank = t.node(s).rank + (l ? o.minlen : -o.minlen)));
      }));
  }
  function Evt(e, t, r) {
    return e.hasEdge(t, r);
  }
  function eX(e, t, r) {
    return r.low <= t.lim && t.lim <= r.lim;
  }
  var oX = x(() => {
    "use strict";
    he();
    tX();
    Do();
    O5();
    iT();
    Gc.initLowLimValues = j5;
    Gc.initCutValues = U5;
    Gc.calcCutValue = rX;
    Gc.leaveEdge = iX;
    Gc.enterEdge = sX;
    Gc.exchangeEdges = aX;
    a(Gc, "networkSimplex");
    a(U5, "initCutValues");
    a(wvt, "assignCutValue");
    a(rX, "calcCutValue");
    a(j5, "initLowLimValues");
    a(nX, "dfsAssignLowLim");
    a(iX, "leaveEdge");
    a(sX, "enterEdge");
    a(aX, "exchangeEdges");
    a(vvt, "updateRanks");
    a(Evt, "isTreeEdge");
    a(eX, "isDescendant");
  });
  function q5(e) {
    switch (e.graph().ranker) {
      case "network-simplex":
        lX(e);
        break;
      case "tight-tree":
        Lvt(e);
        break;
      case "longest-path":
        Avt(e);
        break;
      default:
        lX(e);
    }
  }
  function Lvt(e) {
    (q0(e), sT(e));
  }
  function lX(e) {
    Gc(e);
  }
  var Avt,
    H5 = x(() => {
      "use strict";
      O5();
      oX();
      iT();
      a(q5, "rank");
      Avt = q0;
      a(Lvt, "tightTreeRanker");
      a(lX, "networkSimplexRanker");
    });
  function cX(e) {
    var t = Ro(e, "root", {}, "_root"),
      r = Rvt(e),
      n = ds(We(r)) - 1,
      i = 2 * n + 1;
    ((e.graph().nestingRoot = t),
      rt(e.edges(), function (o) {
        e.edge(o).minlen *= i;
      }));
    var s = Dvt(e) + 1;
    (rt(e.children(), function (o) {
      uX(e, t, i, s, n, r, o);
    }),
      (e.graph().nodeRankFactor = i));
  }
  function uX(e, t, r, n, i, s, o) {
    var l = e.children(o);
    if (!l.length) {
      o !== t && e.setEdge(t, o, { weight: 0, minlen: r });
      return;
    }
    var u = R5(e, "_bt"),
      h = R5(e, "_bb"),
      f = e.node(o);
    (e.setParent(u, o),
      (f.borderTop = u),
      e.setParent(h, o),
      (f.borderBottom = h),
      rt(l, function (d) {
        uX(e, t, r, n, i, s, d);
        var p = e.node(d),
          m = p.borderTop ? p.borderTop : d,
          g = p.borderBottom ? p.borderBottom : d,
          y = p.borderTop ? n : 2 * n,
          b = m !== g ? 1 : i - s[o] + 1;
        (e.setEdge(u, m, { weight: y, minlen: b, nestingEdge: !0 }),
          e.setEdge(g, h, { weight: y, minlen: b, nestingEdge: !0 }));
      }),
      e.parent(o) || e.setEdge(t, u, { weight: 0, minlen: i + s[o] }));
  }
  function Rvt(e) {
    var t = {};
    function r(n, i) {
      var s = e.children(n);
      (s &&
        s.length &&
        rt(s, function (o) {
          r(o, i + 1);
        }),
        (t[n] = i));
    }
    return (
      a(r, "dfs"),
      rt(e.children(), function (n) {
        r(n, 1);
      }),
      t
    );
  }
  function Dvt(e) {
    return mr(
      e.edges(),
      function (t, r) {
        return t + e.edge(r).weight;
      },
      0,
    );
  }
  function hX(e) {
    var t = e.graph();
    (e.removeNode(t.nestingRoot),
      delete t.nestingRoot,
      rt(e.edges(), function (r) {
        var n = e.edge(r);
        n.nestingEdge && e.removeEdge(r);
      }));
  }
  var fX = x(() => {
    "use strict";
    he();
    Do();
    a(cX, "run");
    a(uX, "dfs");
    a(Rvt, "treeDepths");
    a(Dvt, "sumWeights");
    a(hX, "cleanup");
  });
  function dX(e, t, r) {
    var n = {},
      i;
    rt(r, function (s) {
      for (var o = e.parent(s), l, u; o; ) {
        if (
          ((l = e.parent(o)),
          l ? ((u = n[l]), (n[l] = o)) : ((u = i), (i = o)),
          u && u !== o)
        ) {
          t.setEdge(u, o);
          return;
        }
        o = l;
      }
    });
  }
  var pX = x(() => {
    "use strict";
    he();
    a(dX, "addSubgraphConstraints");
  });
  function mX(e, t, r) {
    var n = Ivt(e),
      i = new _r({ compound: !0 })
        .setGraph({ root: n })
        .setDefaultNodeLabel(function (s) {
          return e.node(s);
        });
    return (
      rt(e.nodes(), function (s) {
        var o = e.node(s),
          l = e.parent(s);
        (o.rank === t || (o.minRank <= t && t <= o.maxRank)) &&
          (i.setNode(s),
          i.setParent(s, l || n),
          rt(e[r](s), function (u) {
            var h = u.v === s ? u.w : u.v,
              f = i.edge(h, s),
              d = Fe(f) ? 0 : f.weight;
            i.setEdge(h, s, { weight: e.edge(u).weight + d });
          }),
          Object.prototype.hasOwnProperty.call(o, "minRank") &&
            i.setNode(s, {
              borderLeft: o.borderLeft[t],
              borderRight: o.borderRight[t],
            }));
      }),
      i
    );
  }
  function Ivt(e) {
    for (var t; e.hasNode((t = uh("_root"))); );
    return t;
  }
  var gX = x(() => {
    "use strict";
    he();
    aa();
    a(mX, "buildLayerGraph");
    a(Ivt, "createRootNode");
  });
  function yX(e, t) {
    for (var r = 0, n = 1; n < t.length; ++n) r += Mvt(e, t[n - 1], t[n]);
    return r;
  }
  function Mvt(e, t, r) {
    for (
      var n = Jk(
          r,
          Dt(r, function (h, f) {
            return f;
          }),
        ),
        i = dr(
          Dt(t, function (h) {
            return Lo(
              Dt(e.outEdges(h), function (f) {
                return { pos: n[f.w], weight: e.edge(f).weight };
              }),
              "pos",
            );
          }),
        ),
        s = 1;
      s < r.length;

    )
      s <<= 1;
    var o = 2 * s - 1;
    s -= 1;
    var l = Dt(new Array(o), function () {
        return 0;
      }),
      u = 0;
    return (
      rt(
        i.forEach(function (h) {
          var f = h.pos + s;
          l[f] += h.weight;
          for (var d = 0; f > 0; )
            (f % 2 && (d += l[f + 1]), (f = (f - 1) >> 1), (l[f] += h.weight));
          u += h.weight * d;
        }),
      ),
      u
    );
  }
  var xX = x(() => {
    "use strict";
    he();
    a(yX, "crossCount");
    a(Mvt, "twoLayerCrossCount");
  });
  function bX(e) {
    var t = {},
      r = pr(e.nodes(), function (l) {
        return !e.children(l).length;
      }),
      n = ds(
        Dt(r, function (l) {
          return e.node(l).rank;
        }),
      ),
      i = Dt(sa(n + 1), function () {
        return [];
      });
    function s(l) {
      if (!te(t, l)) {
        t[l] = !0;
        var u = e.node(l);
        (i[u.rank].push(l), rt(e.successors(l), s));
      }
    }
    a(s, "dfs");
    var o = Lo(r, function (l) {
      return e.node(l).rank;
    });
    return (rt(o, s), i);
  }
  var kX = x(() => {
    "use strict";
    he();
    a(bX, "initOrder");
  });
  function TX(e, t) {
    return Dt(t, function (r) {
      var n = e.inEdges(r);
      if (n.length) {
        var i = mr(
          n,
          function (s, o) {
            var l = e.edge(o),
              u = e.node(o.v);
            return {
              sum: s.sum + l.weight * u.order,
              weight: s.weight + l.weight,
            };
          },
          { sum: 0, weight: 0 },
        );
        return { v: r, barycenter: i.sum / i.weight, weight: i.weight };
      } else return { v: r };
    });
  }
  var SX = x(() => {
    "use strict";
    he();
    a(TX, "barycenter");
  });
  function _X(e, t) {
    var r = {};
    (rt(e, function (i, s) {
      var o = (r[i.v] = { indegree: 0, in: [], out: [], vs: [i.v], i: s });
      Fe(i.barycenter) ||
        ((o.barycenter = i.barycenter), (o.weight = i.weight));
    }),
      rt(t.edges(), function (i) {
        var s = r[i.v],
          o = r[i.w];
        !Fe(s) && !Fe(o) && (o.indegree++, s.out.push(r[i.w]));
      }));
    var n = pr(r, function (i) {
      return !i.indegree;
    });
    return Ovt(n);
  }
  function Ovt(e) {
    var t = [];
    function r(s) {
      return function (o) {
        o.merged ||
          ((Fe(o.barycenter) ||
            Fe(s.barycenter) ||
            o.barycenter >= s.barycenter) &&
            Pvt(s, o));
      };
    }
    a(r, "handleIn");
    function n(s) {
      return function (o) {
        (o.in.push(s), --o.indegree === 0 && e.push(o));
      };
    }
    for (a(n, "handleOut"); e.length; ) {
      var i = e.pop();
      (t.push(i), rt(i.in.reverse(), r(i)), rt(i.out, n(i)));
    }
    return Dt(
      pr(t, function (s) {
        return !s.merged;
      }),
      function (s) {
        return ch(s, ["vs", "i", "barycenter", "weight"]);
      },
    );
  }
  function Pvt(e, t) {
    var r = 0,
      n = 0;
    (e.weight && ((r += e.barycenter * e.weight), (n += e.weight)),
      t.weight && ((r += t.barycenter * t.weight), (n += t.weight)),
      (e.vs = t.vs.concat(e.vs)),
      (e.barycenter = r / n),
      (e.weight = n),
      (e.i = Math.min(t.i, e.i)),
      (t.merged = !0));
  }
  var CX = x(() => {
    "use strict";
    he();
    a(_X, "resolveConflicts");
    a(Ovt, "doResolveConflicts");
    a(Pvt, "mergeEntries");
  });
  function vX(e, t) {
    var r = DY(e, function (f) {
        return Object.prototype.hasOwnProperty.call(f, "barycenter");
      }),
      n = r.lhs,
      i = Lo(r.rhs, function (f) {
        return -f.i;
      }),
      s = [],
      o = 0,
      l = 0,
      u = 0;
    (n.sort(Bvt(!!t)),
      (u = wX(s, i, u)),
      rt(n, function (f) {
        ((u += f.vs.length),
          s.push(f.vs),
          (o += f.barycenter * f.weight),
          (l += f.weight),
          (u = wX(s, i, u)));
      }));
    var h = { vs: dr(s) };
    return (l && ((h.barycenter = o / l), (h.weight = l)), h);
  }
  function wX(e, t, r) {
    for (var n; t.length && (n = ai(t)).i <= r; ) (t.pop(), e.push(n.vs), r++);
    return r;
  }
  function Bvt(e) {
    return function (t, r) {
      return t.barycenter < r.barycenter
        ? -1
        : t.barycenter > r.barycenter
          ? 1
          : e
            ? r.i - t.i
            : t.i - r.i;
    };
  }
  var EX = x(() => {
    "use strict";
    he();
    Do();
    a(vX, "sort");
    a(wX, "consumeUnsortable");
    a(Bvt, "compareWithBias");
  });
  function Y5(e, t, r, n) {
    var i = e.children(t),
      s = e.node(t),
      o = s ? s.borderLeft : void 0,
      l = s ? s.borderRight : void 0,
      u = {};
    o &&
      (i = pr(i, function (g) {
        return g !== o && g !== l;
      }));
    var h = TX(e, i);
    rt(h, function (g) {
      if (e.children(g.v).length) {
        var y = Y5(e, g.v, r, n);
        ((u[g.v] = y),
          Object.prototype.hasOwnProperty.call(y, "barycenter") && $vt(g, y));
      }
    });
    var f = _X(h, r);
    Fvt(f, u);
    var d = vX(f, n);
    if (o && ((d.vs = dr([o, d.vs, l])), e.predecessors(o).length)) {
      var p = e.node(e.predecessors(o)[0]),
        m = e.node(e.predecessors(l)[0]);
      (Object.prototype.hasOwnProperty.call(d, "barycenter") ||
        ((d.barycenter = 0), (d.weight = 0)),
        (d.barycenter =
          (d.barycenter * d.weight + p.order + m.order) / (d.weight + 2)),
        (d.weight += 2));
    }
    return d;
  }
  function Fvt(e, t) {
    rt(e, function (r) {
      r.vs = dr(
        r.vs.map(function (n) {
          return t[n] ? t[n].vs : n;
        }),
      );
    });
  }
  function $vt(e, t) {
    Fe(e.barycenter)
      ? ((e.barycenter = t.barycenter), (e.weight = t.weight))
      : ((e.barycenter =
          (e.barycenter * e.weight + t.barycenter * t.weight) /
          (e.weight + t.weight)),
        (e.weight += t.weight));
  }
  var AX = x(() => {
    "use strict";
    he();
    SX();
    CX();
    EX();
    a(Y5, "sortSubgraph");
    a(Fvt, "expandSubgraphs");
    a($vt, "mergeBarycenters");
  });
  function DX(e) {
    var t = D5(e),
      r = LX(e, sa(1, t + 1), "inEdges"),
      n = LX(e, sa(t - 1, -1, -1), "outEdges"),
      i = bX(e);
    RX(e, i);
    for (var s = Number.POSITIVE_INFINITY, o, l = 0, u = 0; u < 4; ++l, ++u) {
      (Gvt(l % 2 ? r : n, l % 4 >= 2), (i = Fc(e)));
      var h = yX(e, i);
      h < s && ((u = 0), (o = ZA(i)), (s = h));
    }
    RX(e, o);
  }
  function LX(e, t, r) {
    return Dt(t, function (n) {
      return mX(e, n, r);
    });
  }
  function Gvt(e, t) {
    var r = new _r();
    rt(e, function (n) {
      var i = n.graph().root,
        s = Y5(n, i, r, t);
      (rt(s.vs, function (o, l) {
        n.node(o).order = l;
      }),
        dX(n, r, s.vs));
    });
  }
  function RX(e, t) {
    rt(t, function (r) {
      rt(r, function (n, i) {
        e.node(n).order = i;
      });
    });
  }
  var NX = x(() => {
    "use strict";
    he();
    aa();
    Do();
    pX();
    gX();
    xX();
    kX();
    AX();
    a(DX, "order");
    a(LX, "buildLayerGraphs");
    a(Gvt, "sweepLayerGraphs");
    a(RX, "assignOrder");
  });
  function IX(e) {
    var t = zvt(e);
    rt(e.graph().dummyChains, function (r) {
      for (
        var n = e.node(r),
          i = n.edgeObj,
          s = Vvt(e, t, i.v, i.w),
          o = s.path,
          l = s.lca,
          u = 0,
          h = o[u],
          f = !0;
        r !== i.w;

      ) {
        if (((n = e.node(r)), f)) {
          for (; (h = o[u]) !== l && e.node(h).maxRank < n.rank; ) u++;
          h === l && (f = !1);
        }
        if (!f) {
          for (; u < o.length - 1 && e.node((h = o[u + 1])).minRank <= n.rank; )
            u++;
          h = o[u];
        }
        (e.setParent(r, h), (r = e.successors(r)[0]));
      }
    });
  }
  function Vvt(e, t, r, n) {
    var i = [],
      s = [],
      o = Math.min(t[r].low, t[n].low),
      l = Math.max(t[r].lim, t[n].lim),
      u,
      h;
    u = r;
    do ((u = e.parent(u)), i.push(u));
    while (u && (t[u].low > o || l > t[u].lim));
    for (h = u, u = n; (u = e.parent(u)) !== h; ) s.push(u);
    return { path: i.concat(s.reverse()), lca: h };
  }
  function zvt(e) {
    var t = {},
      r = 0;
    function n(i) {
      var s = r;
      (rt(e.children(i), n), (t[i] = { low: s, lim: r++ }));
    }
    return (a(n, "dfs"), rt(e.children(), n), t);
  }
  var MX = x(() => {
    "use strict";
    he();
    a(IX, "parentDummyChains");
    a(Vvt, "findPath");
    a(zvt, "postorder");
  });
  function Wvt(e, t) {
    var r = {};
    function n(i, s) {
      var o = 0,
        l = 0,
        u = i.length,
        h = ai(s);
      return (
        rt(s, function (f, d) {
          var p = jvt(e, f),
            m = p ? e.node(p).order : u;
          (p || f === h) &&
            (rt(s.slice(l, d + 1), function (g) {
              rt(e.predecessors(g), function (y) {
                var b = e.node(y),
                  k = b.order;
                (k < o || m < k) &&
                  !(b.dummy && e.node(g).dummy) &&
                  OX(r, y, g);
              });
            }),
            (l = d + 1),
            (o = m));
        }),
        s
      );
    }
    return (a(n, "visitLayer"), mr(t, n), r);
  }
  function Uvt(e, t) {
    var r = {};
    function n(s, o, l, u, h) {
      var f;
      rt(sa(o, l), function (d) {
        ((f = s[d]),
          e.node(f).dummy &&
            rt(e.predecessors(f), function (p) {
              var m = e.node(p);
              m.dummy && (m.order < u || m.order > h) && OX(r, p, f);
            }));
      });
    }
    a(n, "scan");
    function i(s, o) {
      var l = -1,
        u,
        h = 0;
      return (
        rt(o, function (f, d) {
          if (e.node(f).dummy === "border") {
            var p = e.predecessors(f);
            p.length &&
              ((u = e.node(p[0]).order), n(o, h, d, l, u), (h = d), (l = u));
          }
          n(o, h, o.length, u, s.length);
        }),
        o
      );
    }
    return (a(i, "visitLayer"), mr(t, i), r);
  }
  function jvt(e, t) {
    if (e.node(t).dummy)
      return Gi(e.predecessors(t), function (r) {
        return e.node(r).dummy;
      });
  }
  function OX(e, t, r) {
    if (t > r) {
      var n = t;
      ((t = r), (r = n));
    }
    var i = e[t];
    (i || (e[t] = i = {}), (i[r] = !0));
  }
  function qvt(e, t, r) {
    if (t > r) {
      var n = t;
      ((t = r), (r = n));
    }
    return !!e[t] && Object.prototype.hasOwnProperty.call(e[t], r);
  }
  function Hvt(e, t, r, n) {
    var i = {},
      s = {},
      o = {};
    return (
      rt(t, function (l) {
        rt(l, function (u, h) {
          ((i[u] = u), (s[u] = u), (o[u] = h));
        });
      }),
      rt(t, function (l) {
        var u = -1;
        rt(l, function (h) {
          var f = n(h);
          if (f.length) {
            f = Lo(f, function (y) {
              return o[y];
            });
            for (
              var d = (f.length - 1) / 2, p = Math.floor(d), m = Math.ceil(d);
              p <= m;
              ++p
            ) {
              var g = f[p];
              s[h] === h &&
                u < o[g] &&
                !qvt(r, h, g) &&
                ((s[g] = h), (s[h] = i[h] = i[g]), (u = o[g]));
            }
          }
        });
      }),
      { root: i, align: s }
    );
  }
  function Yvt(e, t, r, n, i) {
    var s = {},
      o = Xvt(e, t, r, i),
      l = i ? "borderLeft" : "borderRight";
    function u(d, p) {
      for (var m = o.nodes(), g = m.pop(), y = {}; g; )
        (y[g] ? d(g) : ((y[g] = !0), m.push(g), (m = m.concat(p(g)))),
          (g = m.pop()));
    }
    a(u, "iterate");
    function h(d) {
      s[d] = o.inEdges(d).reduce(function (p, m) {
        return Math.max(p, s[m.v] + o.edge(m));
      }, 0);
    }
    a(h, "pass1");
    function f(d) {
      var p = o.outEdges(d).reduce(function (g, y) {
          return Math.min(g, s[y.w] - o.edge(y));
        }, Number.POSITIVE_INFINITY),
        m = e.node(d);
      p !== Number.POSITIVE_INFINITY &&
        m.borderType !== l &&
        (s[d] = Math.max(s[d], p));
    }
    return (
      a(f, "pass2"),
      u(h, o.predecessors.bind(o)),
      u(f, o.successors.bind(o)),
      rt(n, function (d) {
        s[d] = s[r[d]];
      }),
      s
    );
  }
  function Xvt(e, t, r, n) {
    var i = new _r(),
      s = e.graph(),
      o = Jvt(s.nodesep, s.edgesep, n);
    return (
      rt(t, function (l) {
        var u;
        rt(l, function (h) {
          var f = r[h];
          if ((i.setNode(f), u)) {
            var d = r[u],
              p = i.edge(d, f);
            i.setEdge(d, f, Math.max(o(e, h, u), p || 0));
          }
          u = h;
        });
      }),
      i
    );
  }
  function Kvt(e, t) {
    return lh(We(t), function (r) {
      var n = Number.NEGATIVE_INFINITY,
        i = Number.POSITIVE_INFINITY;
      return (
        d5(r, function (s, o) {
          var l = tEt(e, o) / 2;
          ((n = Math.max(s + l, n)), (i = Math.min(s - l, i)));
        }),
        n - i
      );
    });
  }
  function Qvt(e, t) {
    var r = We(t),
      n = Va(r),
      i = ds(r);
    rt(["u", "d"], function (s) {
      rt(["l", "r"], function (o) {
        var l = s + o,
          u = e[l],
          h;
        if (u !== t) {
          var f = We(u);
          ((h = o === "l" ? n - Va(f) : i - ds(f)),
            h &&
              (e[l] = oh(u, function (d) {
                return d + h;
              })));
        }
      });
    });
  }
  function Zvt(e, t) {
    return oh(e.ul, function (r, n) {
      if (t) return e[t.toLowerCase()][n];
      var i = Lo(Dt(e, n));
      return (i[1] + i[2]) / 2;
    });
  }
  function PX(e) {
    var t = Fc(e),
      r = kc(Wvt(e, t), Uvt(e, t)),
      n = {},
      i;
    rt(["u", "d"], function (o) {
      ((i = o === "u" ? t : We(t).reverse()),
        rt(["l", "r"], function (l) {
          l === "r" &&
            (i = Dt(i, function (d) {
              return We(d).reverse();
            }));
          var u = (o === "u" ? e.predecessors : e.successors).bind(e),
            h = Hvt(e, i, r, u),
            f = Yvt(e, i, h.root, h.align, l === "r");
          (l === "r" &&
            (f = oh(f, function (d) {
              return -d;
            })),
            (n[o + l] = f));
        }));
    });
    var s = Kvt(e, n);
    return (Qvt(n, s), Zvt(n, e.graph().align));
  }
  function Jvt(e, t, r) {
    return function (n, i, s) {
      var o = n.node(i),
        l = n.node(s),
        u = 0,
        h;
      if (
        ((u += o.width / 2),
        Object.prototype.hasOwnProperty.call(o, "labelpos"))
      )
        switch (o.labelpos.toLowerCase()) {
          case "l":
            h = -o.width / 2;
            break;
          case "r":
            h = o.width / 2;
            break;
        }
      if (
        (h && (u += r ? h : -h),
        (h = 0),
        (u += (o.dummy ? t : e) / 2),
        (u += (l.dummy ? t : e) / 2),
        (u += l.width / 2),
        Object.prototype.hasOwnProperty.call(l, "labelpos"))
      )
        switch (l.labelpos.toLowerCase()) {
          case "l":
            h = l.width / 2;
            break;
          case "r":
            h = -l.width / 2;
            break;
        }
      return (h && (u += r ? h : -h), (h = 0), u);
    };
  }
  function tEt(e, t) {
    return e.node(t).width;
  }
  var BX = x(() => {
    "use strict";
    he();
    aa();
    Do();
    a(Wvt, "findType1Conflicts");
    a(Uvt, "findType2Conflicts");
    a(jvt, "findOtherInnerSegmentNode");
    a(OX, "addConflict");
    a(qvt, "hasConflict");
    a(Hvt, "verticalAlignment");
    a(Yvt, "horizontalCompaction");
    a(Xvt, "buildBlockGraph");
    a(Kvt, "findSmallestWidthAlignment");
    a(Qvt, "alignCoordinates");
    a(Zvt, "balance");
    a(PX, "positionX");
    a(Jvt, "sep");
    a(tEt, "width");
  });
  function FX(e) {
    ((e = nT(e)),
      eEt(e),
      p5(PX(e), function (t, r) {
        e.node(r).x = t;
      }));
  }
  function eEt(e) {
    var t = Fc(e),
      r = e.graph().ranksep,
      n = 0;
    rt(t, function (i) {
      var s = ds(
        Dt(i, function (o) {
          return e.node(o).height;
        }),
      );
      (rt(i, function (o) {
        e.node(o).y = n + s / 2;
      }),
        (n += s + r));
    });
  }
  var $X = x(() => {
    "use strict";
    he();
    Do();
    BX();
    a(FX, "position");
    a(eEt, "positionY");
  });
  function Y0(e, t) {
    var r = t && t.debugTiming ? NY : IY;
    r("layout", () => {
      var n = r("  buildLayoutGraph", () => fEt(e));
      (r("  runLayout", () => rEt(n, r)),
        r("  updateInputGraph", () => nEt(e, n)));
    });
  }
  function rEt(e, t) {
    (t("    makeSpaceForEdgeLabels", () => dEt(e)),
      t("    removeSelfEdges", () => SEt(e)),
      t("    acyclic", () => wY(e)),
      t("    nestingGraph.run", () => cX(e)),
      t("    rank", () => q5(nT(e))),
      t("    injectEdgeLabelProxies", () => pEt(e)),
      t("    removeEmptyRanks", () => RY(e)),
      t("    nestingGraph.cleanup", () => hX(e)),
      t("    normalizeRanks", () => LY(e)),
      t("    assignRankMinMax", () => mEt(e)),
      t("    removeEdgeLabelProxies", () => gEt(e)),
      t("    normalize.run", () => zY(e)),
      t("    parentDummyChains", () => IX(e)),
      t("    addBorderSegments", () => OY(e)),
      t("    order", () => DX(e)),
      t("    insertSelfEdges", () => _Et(e)),
      t("    adjustCoordinateSystem", () => FY(e)),
      t("    position", () => FX(e)),
      t("    positionSelfEdges", () => CEt(e)),
      t("    removeBorderNodes", () => TEt(e)),
      t("    normalize.undo", () => WY(e)),
      t("    fixupEdgeLabelCoords", () => bEt(e)),
      t("    undoCoordinateSystem", () => $Y(e)),
      t("    translateGraph", () => yEt(e)),
      t("    assignNodeIntersects", () => xEt(e)),
      t("    reversePoints", () => kEt(e)),
      t("    acyclic.undo", () => vY(e)));
  }
  function nEt(e, t) {
    (rt(e.nodes(), function (r) {
      var n = e.node(r),
        i = t.node(r);
      n &&
        ((n.x = i.x),
        (n.y = i.y),
        t.children(r).length && ((n.width = i.width), (n.height = i.height)));
    }),
      rt(e.edges(), function (r) {
        var n = e.edge(r),
          i = t.edge(r);
        ((n.points = i.points),
          Object.prototype.hasOwnProperty.call(i, "x") &&
            ((n.x = i.x), (n.y = i.y)));
      }),
      (e.graph().width = t.graph().width),
      (e.graph().height = t.graph().height));
  }
  function fEt(e) {
    var t = new _r({ multigraph: !0, compound: !0 }),
      r = K5(e.graph());
    return (
      t.setGraph(kc({}, sEt, X5(r, iEt), ch(r, aEt))),
      rt(e.nodes(), function (n) {
        var i = K5(e.node(n));
        (t.setNode(n, Oc(X5(i, oEt), lEt)), t.setParent(n, e.parent(n)));
      }),
      rt(e.edges(), function (n) {
        var i = K5(e.edge(n));
        t.setEdge(n, kc({}, uEt, X5(i, cEt), ch(i, hEt)));
      }),
      t
    );
  }
  function dEt(e) {
    var t = e.graph();
    ((t.ranksep /= 2),
      rt(e.edges(), function (r) {
        var n = e.edge(r);
        ((n.minlen *= 2),
          n.labelpos.toLowerCase() !== "c" &&
            (t.rankdir === "TB" || t.rankdir === "BT"
              ? (n.width += n.labeloffset)
              : (n.height += n.labeloffset)));
      }));
  }
  function pEt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t);
      if (r.width && r.height) {
        var n = e.node(t.v),
          i = e.node(t.w),
          s = { rank: (i.rank - n.rank) / 2 + n.rank, e: t };
        Ro(e, "edge-proxy", s, "_ep");
      }
    });
  }
  function mEt(e) {
    var t = 0;
    (rt(e.nodes(), function (r) {
      var n = e.node(r);
      n.borderTop &&
        ((n.minRank = e.node(n.borderTop).rank),
        (n.maxRank = e.node(n.borderBottom).rank),
        (t = ds(t, n.maxRank)));
    }),
      (e.graph().maxRank = t));
  }
  function gEt(e) {
    rt(e.nodes(), function (t) {
      var r = e.node(t);
      r.dummy === "edge-proxy" &&
        ((e.edge(r.e).labelRank = r.rank), e.removeNode(t));
    });
  }
  function yEt(e) {
    var t = Number.POSITIVE_INFINITY,
      r = 0,
      n = Number.POSITIVE_INFINITY,
      i = 0,
      s = e.graph(),
      o = s.marginx || 0,
      l = s.marginy || 0;
    function u(h) {
      var f = h.x,
        d = h.y,
        p = h.width,
        m = h.height;
      ((t = Math.min(t, f - p / 2)),
        (r = Math.max(r, f + p / 2)),
        (n = Math.min(n, d - m / 2)),
        (i = Math.max(i, d + m / 2)));
    }
    (a(u, "getExtremes"),
      rt(e.nodes(), function (h) {
        u(e.node(h));
      }),
      rt(e.edges(), function (h) {
        var f = e.edge(h);
        Object.prototype.hasOwnProperty.call(f, "x") && u(f);
      }),
      (t -= o),
      (n -= l),
      rt(e.nodes(), function (h) {
        var f = e.node(h);
        ((f.x -= t), (f.y -= n));
      }),
      rt(e.edges(), function (h) {
        var f = e.edge(h);
        (rt(f.points, function (d) {
          ((d.x -= t), (d.y -= n));
        }),
          Object.prototype.hasOwnProperty.call(f, "x") && (f.x -= t),
          Object.prototype.hasOwnProperty.call(f, "y") && (f.y -= n));
      }),
      (s.width = r - t + o),
      (s.height = i - n + l));
  }
  function xEt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t),
        n = e.node(t.v),
        i = e.node(t.w),
        s,
        o;
      (r.points
        ? ((s = r.points[0]), (o = r.points[r.points.length - 1]))
        : ((r.points = []), (s = i), (o = n)),
        r.points.unshift(L5(n, s)),
        r.points.push(L5(i, o)));
    });
  }
  function bEt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t);
      if (Object.prototype.hasOwnProperty.call(r, "x"))
        switch (
          ((r.labelpos === "l" || r.labelpos === "r") &&
            (r.width -= r.labeloffset),
          r.labelpos)
        ) {
          case "l":
            r.x -= r.width / 2 + r.labeloffset;
            break;
          case "r":
            r.x += r.width / 2 + r.labeloffset;
            break;
        }
    });
  }
  function kEt(e) {
    rt(e.edges(), function (t) {
      var r = e.edge(t);
      r.reversed && r.points.reverse();
    });
  }
  function TEt(e) {
    (rt(e.nodes(), function (t) {
      if (e.children(t).length) {
        var r = e.node(t),
          n = e.node(r.borderTop),
          i = e.node(r.borderBottom),
          s = e.node(ai(r.borderLeft)),
          o = e.node(ai(r.borderRight));
        ((r.width = Math.abs(o.x - s.x)),
          (r.height = Math.abs(i.y - n.y)),
          (r.x = s.x + r.width / 2),
          (r.y = n.y + r.height / 2));
      }
    }),
      rt(e.nodes(), function (t) {
        e.node(t).dummy === "border" && e.removeNode(t);
      }));
  }
  function SEt(e) {
    rt(e.edges(), function (t) {
      if (t.v === t.w) {
        var r = e.node(t.v);
        (r.selfEdges || (r.selfEdges = []),
          r.selfEdges.push({ e: t, label: e.edge(t) }),
          e.removeEdge(t));
      }
    });
  }
  function _Et(e) {
    var t = Fc(e);
    rt(t, function (r) {
      var n = 0;
      rt(r, function (i, s) {
        var o = e.node(i);
        ((o.order = s + n),
          rt(o.selfEdges, function (l) {
            Ro(
              e,
              "selfedge",
              {
                width: l.label.width,
                height: l.label.height,
                rank: o.rank,
                order: s + ++n,
                e: l.e,
                label: l.label,
              },
              "_se",
            );
          }),
          delete o.selfEdges);
      });
    });
  }
  function CEt(e) {
    rt(e.nodes(), function (t) {
      var r = e.node(t);
      if (r.dummy === "selfedge") {
        var n = e.node(r.e.v),
          i = n.x + n.width / 2,
          s = n.y,
          o = r.x - i,
          l = n.height / 2;
        (e.setEdge(r.e, r.label),
          e.removeNode(t),
          (r.label.points = [
            { x: i + (2 * o) / 3, y: s - l },
            { x: i + (5 * o) / 6, y: s - l },
            { x: i + o, y: s },
            { x: i + (5 * o) / 6, y: s + l },
            { x: i + (2 * o) / 3, y: s + l },
          ]),
          (r.label.x = r.x),
          (r.label.y = r.y));
      }
    });
  }
  function X5(e, t) {
    return oh(ch(e, t), Number);
  }
  function K5(e) {
    var t = {};
    return (
      rt(e, function (r, n) {
        t[n.toLowerCase()] = r;
      }),
      t
    );
  }
  var iEt,
    sEt,
    aEt,
    oEt,
    lEt,
    cEt,
    uEt,
    hEt,
    GX = x(() => {
      "use strict";
      he();
      aa();
      PY();
      VY();
      A5();
      M5();
      H5();
      fX();
      NX();
      MX();
      $X();
      Do();
      a(Y0, "layout");
      a(rEt, "runLayout");
      a(nEt, "updateInputGraph");
      ((iEt = ["nodesep", "edgesep", "ranksep", "marginx", "marginy"]),
        (sEt = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: "tb" }),
        (aEt = ["acyclicer", "ranker", "rankdir", "align"]),
        (oEt = ["width", "height"]),
        (lEt = { width: 0, height: 0 }),
        (cEt = ["minlen", "weight", "width", "height", "labeloffset"]),
        (uEt = {
          minlen: 1,
          weight: 1,
          width: 0,
          height: 0,
          labeloffset: 10,
          labelpos: "r",
        }),
        (hEt = ["labelpos"]));
      a(fEt, "buildLayoutGraph");
      a(dEt, "makeSpaceForEdgeLabels");
      a(pEt, "injectEdgeLabelProxies");
      a(mEt, "assignRankMinMax");
      a(gEt, "removeEdgeLabelProxies");
      a(yEt, "translateGraph");
      a(xEt, "assignNodeIntersects");
      a(bEt, "fixupEdgeLabelCoords");
      a(kEt, "reversePointsForReversedEdges");
      a(TEt, "removeBorderNodes");
      a(SEt, "removeSelfEdges");
      a(_Et, "insertSelfEdges");
      a(CEt, "positionSelfEdges");
      a(X5, "selectNumberAttrs");
      a(K5, "canonicalize");
    });
  var Q5 = x(() => {
    "use strict";
    A5();
    GX();
    M5();
    H5();
  });
  function oa(e) {
    var t = {
      options: {
        directed: e.isDirected(),
        multigraph: e.isMultigraph(),
        compound: e.isCompound(),
      },
      nodes: wEt(e),
      edges: vEt(e),
    };
    return (Fe(e.graph()) || (t.value = Sr(e.graph())), t);
  }
  function wEt(e) {
    return Dt(e.nodes(), function (t) {
      var r = e.node(t),
        n = e.parent(t),
        i = { v: t };
      return (Fe(r) || (i.value = r), Fe(n) || (i.parent = n), i);
    });
  }
  function vEt(e) {
    return Dt(e.edges(), function (t) {
      var r = e.edge(t),
        n = { v: t.v, w: t.w };
      return (Fe(t.name) || (n.name = t.name), Fe(r) || (n.value = r), n);
    });
  }
  var Z5 = x(() => {
    "use strict";
    he();
    tT();
    a(oa, "write");
    a(wEt, "writeNodes");
    a(vEt, "writeEdges");
  });
  var Ue,
    dh,
    WX,
    UX,
    oT,
    EEt,
    jX,
    qX,
    AEt,
    Id,
    zX,
    HX,
    YX,
    XX,
    KX,
    QX = x(() => {
      "use strict";
      Vt();
      aa();
      Z5();
      ((Ue = new Map()),
        (dh = new Map()),
        (WX = new Map()),
        (UX = a(() => {
          (dh.clear(), WX.clear(), Ue.clear());
        }, "clear")),
        (oT = a((e, t) => {
          let r = dh.get(t) || [];
          return (
            P.trace("In isDescendant", t, " ", e, " = ", r.includes(e)),
            r.includes(e)
          );
        }, "isDescendant")),
        (EEt = a((e, t) => {
          let r = dh.get(t) || [];
          return (
            P.info("Descendants of ", t, " is ", r),
            P.info("Edge is ", e),
            e.v === t || e.w === t
              ? !1
              : r
                ? r.includes(e.v) || oT(e.v, t) || oT(e.w, t) || r.includes(e.w)
                : (P.debug("Tilt, ", t, ",not in descendants"), !1)
          );
        }, "edgeInCluster")),
        (jX = a((e, t, r, n) => {
          P.warn("Copying children of ", e, "root", n, "data", t.node(e), n);
          let i = t.children(e) || [];
          (e !== n && i.push(e),
            P.warn("Copying (nodes) clusterId", e, "nodes", i),
            i.forEach((s) => {
              if (t.children(s).length > 0) jX(s, t, r, n);
              else {
                let o = t.node(s);
                (P.info("cp ", s, " to ", n, " with parent ", e),
                  r.setNode(s, o),
                  n !== t.parent(s) &&
                    (P.warn("Setting parent", s, t.parent(s)),
                    r.setParent(s, t.parent(s))),
                  e !== n && s !== e
                    ? (P.debug("Setting parent", s, e), r.setParent(s, e))
                    : (P.info("In copy ", e, "root", n, "data", t.node(e), n),
                      P.debug(
                        "Not Setting parent for node=",
                        s,
                        "cluster!==rootId",
                        e !== n,
                        "node!==clusterId",
                        s !== e,
                      )));
                let l = t.edges(s);
                (P.debug("Copying Edges", l),
                  l.forEach((u) => {
                    P.info("Edge", u);
                    let h = t.edge(u.v, u.w, u.name);
                    P.info("Edge data", h, n);
                    try {
                      EEt(u, n)
                        ? (P.info("Copying as ", u.v, u.w, h, u.name),
                          r.setEdge(u.v, u.w, h, u.name),
                          P.info(
                            "newGraph edges ",
                            r.edges(),
                            r.edge(r.edges()[0]),
                          ))
                        : P.info(
                            "Skipping copy of edge ",
                            u.v,
                            "-->",
                            u.w,
                            " rootId: ",
                            n,
                            " clusterId:",
                            e,
                          );
                    } catch (f) {
                      P.error(f);
                    }
                  }));
              }
              (P.debug("Removing node", s), t.removeNode(s));
            }));
        }, "copy")),
        (qX = a((e, t) => {
          let r = t.children(e),
            n = [...r];
          for (let i of r) (WX.set(i, e), (n = [...n, ...qX(i, t)]));
          return n;
        }, "extractDescendants")),
        (AEt = a((e, t, r) => {
          let n = e.edges().filter((u) => u.v === t || u.w === t),
            i = e.edges().filter((u) => u.v === r || u.w === r),
            s = n.map((u) => ({
              v: u.v === t ? r : u.v,
              w: u.w === t ? t : u.w,
            })),
            o = i.map((u) => ({ v: u.v, w: u.w }));
          return s.filter((u) => o.some((h) => u.v === h.v && u.w === h.w));
        }, "findCommonEdges")),
        (Id = a((e, t, r) => {
          let n = t.children(e);
          if ((P.trace("Searching children of id ", e, n), n.length < 1))
            return e;
          let i;
          for (let s of n) {
            let o = Id(s, t, r),
              l = AEt(t, r, o);
            if (o)
              if (l.length > 0) i = o;
              else return o;
          }
          return i;
        }, "findNonClusterChild")),
        (zX = a(
          (e) =>
            !Ue.has(e) || !Ue.get(e).externalConnections
              ? e
              : Ue.has(e)
                ? Ue.get(e).id
                : e,
          "getAnchorId",
        )),
        (HX = a((e, t) => {
          if (!e || t > 10) {
            P.debug("Opting out, no graph ");
            return;
          } else P.debug("Opting in, graph ");
          (e.nodes().forEach(function (r) {
            e.children(r).length > 0 &&
              (P.warn(
                "Cluster identified",
                r,
                " Replacement id in edges: ",
                Id(r, e, r),
              ),
              dh.set(r, qX(r, e)),
              Ue.set(r, { id: Id(r, e, r), clusterData: e.node(r) }));
          }),
            e.nodes().forEach(function (r) {
              let n = e.children(r),
                i = e.edges();
              n.length > 0
                ? (P.debug("Cluster identified", r, dh),
                  i.forEach((s) => {
                    let o = oT(s.v, r),
                      l = oT(s.w, r);
                    o ^ l &&
                      (P.warn("Edge: ", s, " leaves cluster ", r),
                      P.warn("Descendants of XXX ", r, ": ", dh.get(r)),
                      (Ue.get(r).externalConnections = !0));
                  }))
                : P.debug("Not a cluster ", r, dh);
            }));
          for (let r of Ue.keys()) {
            let n = Ue.get(r).id,
              i = e.parent(n);
            i !== r &&
              Ue.has(i) &&
              !Ue.get(i).externalConnections &&
              (Ue.get(r).id = i);
          }
          (e.edges().forEach(function (r) {
            let n = e.edge(r);
            (P.warn("Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(r)),
              P.warn(
                "Edge " + r.v + " -> " + r.w + ": " + JSON.stringify(e.edge(r)),
              ));
            let i = r.v,
              s = r.w;
            if (
              (P.warn(
                "Fix XXX",
                Ue,
                "ids:",
                r.v,
                r.w,
                "Translating: ",
                Ue.get(r.v),
                " --- ",
                Ue.get(r.w),
              ),
              Ue.get(r.v) || Ue.get(r.w))
            ) {
              if (
                (P.warn("Fixing and trying - removing XXX", r.v, r.w, r.name),
                (i = zX(r.v)),
                (s = zX(r.w)),
                e.removeEdge(r.v, r.w, r.name),
                i !== r.v)
              ) {
                let o = e.parent(i);
                ((Ue.get(o).externalConnections = !0), (n.fromCluster = r.v));
              }
              if (s !== r.w) {
                let o = e.parent(s);
                ((Ue.get(o).externalConnections = !0), (n.toCluster = r.w));
              }
              (P.warn("Fix Replacing with XXX", i, s, r.name),
                e.setEdge(i, s, n, r.name));
            }
          }),
            P.warn("Adjusted Graph", oa(e)),
            YX(e, 0),
            P.trace(Ue));
        }, "adjustClustersAndEdges")),
        (YX = a((e, t) => {
          if ((P.warn("extractor - ", t, oa(e), e.children("D")), t > 10)) {
            P.error("Bailing out");
            return;
          }
          let r = e.nodes(),
            n = !1;
          for (let i of r) {
            let s = e.children(i);
            n = n || s.length > 0;
          }
          if (!n) {
            P.debug("Done, no node has children", e.nodes());
            return;
          }
          P.debug("Nodes = ", r, t);
          for (let i of r)
            if (
              (P.debug(
                "Extracting node",
                i,
                Ue,
                Ue.has(i) && !Ue.get(i).externalConnections,
                !e.parent(i),
                e.node(i),
                e.children("D"),
                " Depth ",
                t,
              ),
              !Ue.has(i))
            )
              P.debug("Not a cluster", i, t);
            else if (
              !Ue.get(i).externalConnections &&
              e.children(i) &&
              e.children(i).length > 0
            ) {
              P.warn(
                "Cluster without external connections, without a parent and with children",
                i,
                t,
              );
              let o = e.graph().rankdir === "TB" ? "LR" : "TB";
              Ue.get(i)?.clusterData?.dir &&
                ((o = Ue.get(i).clusterData.dir),
                P.warn("Fixing dir", Ue.get(i).clusterData.dir, o));
              let l = new _r({ multigraph: !0, compound: !0 })
                .setGraph({
                  rankdir: o,
                  nodesep: 50,
                  ranksep: 50,
                  marginx: 8,
                  marginy: 8,
                })
                .setDefaultEdgeLabel(function () {
                  return {};
                });
              (P.warn("Old graph before copy", oa(e)),
                jX(i, e, l, i),
                e.setNode(i, {
                  clusterNode: !0,
                  id: i,
                  clusterData: Ue.get(i).clusterData,
                  label: Ue.get(i).label,
                  graph: l,
                }),
                P.warn("New graph after copy node: (", i, ")", oa(l)),
                P.debug("Old graph after copy", oa(e)));
            } else
              (P.warn(
                "Cluster ** ",
                i,
                " **not meeting the criteria !externalConnections:",
                !Ue.get(i).externalConnections,
                " no parent: ",
                !e.parent(i),
                " children ",
                e.children(i) && e.children(i).length > 0,
                e.children("D"),
                t,
              ),
                P.debug(Ue));
          ((r = e.nodes()), P.warn("New list of nodes", r));
          for (let i of r) {
            let s = e.node(i);
            (P.warn(" Now next level", i, s),
              s?.clusterNode && YX(s.graph, t + 1));
          }
        }, "extractor")),
        (XX = a((e, t) => {
          if (t.length === 0) return [];
          let r = Object.assign([], t);
          return (
            t.forEach((n) => {
              let i = e.children(n),
                s = XX(e, i);
              r = [...r, ...s];
            }),
            r
          );
        }, "sorter")),
        (KX = a((e) => XX(e, e.children()), "sortNodesByHierarchy")));
    });
  var JX = {};
  Oe(JX, { render: () => LEt });
  var ZX,
    LEt,
    tK = x(() => {
      "use strict";
      Q5();
      Z5();
      aa();
      PA();
      Qt();
      QX();
      ik();
      Yb();
      OA();
      Vt();
      F0();
      pe();
      ((ZX = a(async (e, t, r, n, i, s) => {
        P.warn("Graph in recursive render:XAX", oa(t), i);
        let o = t.graph().rankdir;
        P.trace("Dir in recursive render - dir:", o);
        let l = e.insert("g").attr("class", "root");
        (t.nodes()
          ? P.info("Recursive render XXX", t.nodes())
          : P.info("No nodes found for", t),
          t.edges().length > 0 &&
            P.info("Recursive edges", t.edge(t.edges()[0])));
        let u = l.insert("g").attr("class", "clusters"),
          h = l.insert("g").attr("class", "edgePaths"),
          f = l.insert("g").attr("class", "edgeLabels"),
          d = l.insert("g").attr("class", "nodes");
        (await Promise.all(
          t.nodes().map(async function (y) {
            let b = t.node(y);
            if (i !== void 0) {
              let k = JSON.parse(JSON.stringify(i.clusterData));
              (P.trace(
                `Setting data for parent cluster XXX
 Node.id = `,
                y,
                `
 data=`,
                k.height,
                `
Parent cluster`,
                i.height,
              ),
                t.setNode(i.id, k),
                t.parent(y) ||
                  (P.trace("Setting parent", y, i.id),
                  t.setParent(y, i.id, k)));
            }
            if (
              (P.info(
                "(Insert) Node XXX" + y + ": " + JSON.stringify(t.node(y)),
              ),
              b?.clusterNode)
            ) {
              P.info("Cluster identified XBX", y, b.width, t.node(y));
              let { ranksep: k, nodesep: T } = t.graph();
              b.graph.setGraph({
                ...b.graph.graph(),
                ranksep: k + 25,
                nodesep: T,
              });
              let C = await ZX(d, b.graph, r, n, t.node(y), s),
                L = C.elem;
              (Ct(b, L),
                (b.diff = C.diff || 0),
                P.info(
                  "New compound node after recursive render XAX",
                  y,
                  "width",
                  b.width,
                  "height",
                  b.height,
                ),
                yU(L, b));
            } else
              t.children(y).length > 0
                ? (P.trace(
                    "Cluster - the non recursive path XBX",
                    y,
                    b.id,
                    b,
                    b.width,
                    "Graph:",
                    t,
                  ),
                  P.trace(Id(b.id, t)),
                  Ue.set(b.id, { id: Id(b.id, t), node: b }))
                : (P.trace(
                    "Node - the non recursive path XAX",
                    y,
                    d,
                    t.node(y),
                    o,
                  ),
                  await dd(d, t.node(y), { config: s, dir: o }));
          }),
        ),
          await a(async () => {
            let y = t.edges().map(async function (b) {
              let k = t.edge(b.v, b.w, b.name);
              (P.info("Edge " + b.v + " -> " + b.w + ": " + JSON.stringify(b)),
                P.info(
                  "Edge " + b.v + " -> " + b.w + ": ",
                  b,
                  " ",
                  JSON.stringify(t.edge(b)),
                ),
                P.info(
                  "Fix",
                  Ue,
                  "ids:",
                  b.v,
                  b.w,
                  "Translating: ",
                  Ue.get(b.v),
                  Ue.get(b.w),
                ),
                await Jb(f, k));
            });
            await Promise.all(y);
          }, "processEdges")(),
          P.info("Graph before layout:", JSON.stringify(oa(t))),
          P.info("############################################# XXX"),
          P.info("###                Layout                 ### XXX"),
          P.info("############################################# XXX"),
          Y0(t),
          P.info("Graph after layout:", JSON.stringify(oa(t))));
        let m = 0,
          { subGraphTitleTotalMargin: g } = Tl(s);
        return (
          await Promise.all(
            KX(t).map(async function (y) {
              let b = t.node(y);
              if (
                (P.info(
                  "Position XBX => " + y + ": (" + b.x,
                  "," + b.y,
                  ") width: ",
                  b.width,
                  " height: ",
                  b.height,
                ),
                b?.clusterNode)
              )
                ((b.y += g),
                  P.info(
                    "A tainted cluster node XBX1",
                    y,
                    b.id,
                    b.width,
                    b.height,
                    b.x,
                    b.y,
                    t.parent(y),
                  ),
                  (Ue.get(b.id).node = b),
                  G0(b));
              else if (t.children(y).length > 0) {
                (P.info(
                  "A pure cluster node XBX1",
                  y,
                  b.id,
                  b.x,
                  b.y,
                  b.width,
                  b.height,
                  t.parent(y),
                ),
                  (b.height += g),
                  t.node(b.parentId));
                let k = b?.padding / 2 || 0,
                  T = b?.labelBBox?.height || 0,
                  C = T - k || 0;
                (P.debug("OffsetY", C, "labelHeight", T, "halfPadding", k),
                  await fd(u, b),
                  (Ue.get(b.id).node = b));
              } else {
                let k = t.node(b.parentId);
                ((b.y += g / 2),
                  P.info(
                    "A regular node XBX1 - using the padding",
                    b.id,
                    "parent",
                    b.parentId,
                    b.width,
                    b.height,
                    b.x,
                    b.y,
                    "offsetY",
                    b.offsetY,
                    "parent",
                    k,
                    k?.offsetY,
                    b,
                  ),
                  G0(b));
              }
            }),
          ),
          t.edges().forEach(function (y) {
            let b = t.edge(y);
            (P.info("Edge " + y.v + " -> " + y.w + ": " + JSON.stringify(b), b),
              b.points.forEach((L) => (L.y += g / 2)));
            let k = t.node(y.v);
            var T = t.node(y.w);
            let C = ek(h, b, Ue, r, k, T, n);
            tk(b, C);
          }),
          t.nodes().forEach(function (y) {
            let b = t.node(y);
            (P.info(y, b.type, b.diff), b.isGroup && (m = b.diff));
          }),
          P.warn("Returning from recursive render XAX", l, m),
          { elem: l, diff: m }
        );
      }, "recursiveRender")),
        (LEt = a(async (e, t) => {
          let r = new _r({ multigraph: !0, compound: !0 })
              .setGraph({
                rankdir: e.direction,
                nodesep:
                  e.config?.nodeSpacing ||
                  e.config?.flowchart?.nodeSpacing ||
                  e.nodeSpacing,
                ranksep:
                  e.config?.rankSpacing ||
                  e.config?.flowchart?.rankSpacing ||
                  e.rankSpacing,
                marginx: 8,
                marginy: 8,
              })
              .setDefaultEdgeLabel(function () {
                return {};
              }),
            n = t.select("g");
          (rk(n, e.markers, e.type, e.diagramId),
            xU(),
            gU(),
            uU(),
            UX(),
            e.nodes.forEach((s) => {
              (r.setNode(s.id, { ...s }),
                s.parentId && r.setParent(s.id, s.parentId));
            }),
            P.debug("Edges:", e.edges),
            e.edges.forEach((s) => {
              if (s.start === s.end) {
                let o = s.start,
                  l = o + "---" + o + "---1",
                  u = o + "---" + o + "---2",
                  h = r.node(o);
                (r.setNode(l, {
                  domId: l,
                  id: l,
                  parentId: h.parentId,
                  labelStyle: "",
                  label: "",
                  padding: 0,
                  shape: "labelRect",
                  style: "",
                  width: 10,
                  height: 10,
                }),
                  r.setParent(l, h.parentId),
                  r.setNode(u, {
                    domId: u,
                    id: u,
                    parentId: h.parentId,
                    labelStyle: "",
                    padding: 0,
                    shape: "labelRect",
                    label: "",
                    style: "",
                    width: 10,
                    height: 10,
                  }),
                  r.setParent(u, h.parentId));
                let f = structuredClone(s),
                  d = structuredClone(s),
                  p = structuredClone(s);
                ((f.label = ""),
                  (f.arrowTypeEnd = "none"),
                  (f.id = o + "-cyclic-special-1"),
                  (d.arrowTypeStart = "none"),
                  (d.arrowTypeEnd = "none"),
                  (d.id = o + "-cyclic-special-mid"),
                  (p.label = ""),
                  h.isGroup && ((f.fromCluster = o), (p.toCluster = o)),
                  (p.id = o + "-cyclic-special-2"),
                  (p.arrowTypeStart = "none"),
                  r.setEdge(o, l, f, o + "-cyclic-special-0"),
                  r.setEdge(l, u, d, o + "-cyclic-special-1"),
                  r.setEdge(u, o, p, o + "-cyc<lic-special-2"));
              } else r.setEdge(s.start, s.end, { ...s }, s.id);
            }),
            P.warn("Graph at first:", JSON.stringify(oa(r))),
            HX(r),
            P.warn("Graph after XAX:", JSON.stringify(oa(r))));
          let i = K();
          await ZX(n, r, e.type, e.diagramId, void 0, i);
        }, "render")));
    });
  var X0,
    J5,
    REt,
    No,
    Vc,
    ph = x(() => {
      "use strict";
      kU();
      Vt();
      ((X0 = {}),
        (J5 = a((e) => {
          for (let t of e) X0[t.name] = t;
        }, "registerLayoutLoaders")),
        (REt = a(() => {
          J5([
            {
              name: "dagre",
              loader: a(
                async () => await Promise.resolve().then(() => (tK(), JX)),
                "loader",
              ),
            },
          ]);
        }, "registerDefaultLayoutLoaders")));
      REt();
      ((No = a(async (e, t) => {
        if (!(e.layoutAlgorithm in X0))
          throw new Error(`Unknown layout algorithm: ${e.layoutAlgorithm}`);
        let r = X0[e.layoutAlgorithm];
        return (await r.loader()).render(e, t, bU, { algorithm: r.algorithm });
      }, "render")),
        (Vc = a((e = "", { fallback: t = "dagre" } = {}) => {
          if (e in X0) return e;
          if (t in X0)
            return (
              P.warn(
                `Layout algorithm ${e} is not registered. Using ${t} as fallback.`,
              ),
              t
            );
          throw new Error(
            `Both layout algorithms ${e} and ${t} are not registered.`,
          );
        }, "getRegisteredLayoutAlgorithm")));
    });
  var la,
    DEt,
    NEt,
    mh = x(() => {
      "use strict";
      On();
      Vt();
      ((la = a((e, t, r, n) => {
        e.attr("class", r);
        let { width: i, height: s, x: o, y: l } = DEt(e, t);
        Ar(e, s, i, n);
        let u = NEt(o, l, i, s, t);
        (e.attr("viewBox", u),
          P.debug(`viewBox configured: ${u} with padding: ${t}`));
      }, "setupViewPortForSVG")),
        (DEt = a((e, t) => {
          let r = e.node()?.getBBox() || { width: 0, height: 0, x: 0, y: 0 };
          return {
            width: r.width + t * 2,
            height: r.height + t * 2,
            x: r.x,
            y: r.y,
          };
        }, "calculateDimensionsWithPadding")),
        (NEt = a(
          (e, t, r, n, i) => `${e - i} ${t - i} ${r} ${n}`,
          "createViewBox",
        )));
    });
  var IEt,
    MEt,
    eK,
    rK = x(() => {
      "use strict";
      Ge();
      pe();
      Vt();
      hd();
      ph();
      mh();
      _e();
      ((IEt = a(function (e, t) {
        return t.db.getClasses();
      }, "getClasses")),
        (MEt = a(async function (e, t, r, n) {
          (P.info("REF0:"), P.info("Drawing state diagram (v2)", t));
          let { securityLevel: i, flowchart: s, layout: o } = K(),
            l;
          i === "sandbox" && (l = xt("#i" + t));
          let u = i === "sandbox" ? l.nodes()[0].contentDocument : document;
          P.debug("Before getData: ");
          let h = n.db.getData();
          P.debug("Data: ", h);
          let f = _o(t, i),
            d = n.db.getDirection();
          ((h.type = n.type),
            (h.layoutAlgorithm = Vc(o)),
            h.layoutAlgorithm === "dagre" &&
              o === "elk" &&
              P.warn(
                "flowchart-elk was moved to an external package in Mermaid v11. Please refer [release notes](https://github.com/mermaid-js/mermaid/releases/tag/v11.0.0) for more details. This diagram will be rendered using `dagre` layout as a fallback.",
              ),
            (h.direction = d),
            (h.nodeSpacing = s?.nodeSpacing || 50),
            (h.rankSpacing = s?.rankSpacing || 50),
            (h.markers = ["point", "circle", "cross"]),
            (h.diagramId = t),
            P.debug("REF1:", h),
            await No(h, f));
          let p = h.config.flowchart?.diagramPadding ?? 8;
          (le.insertTitle(
            f,
            "flowchartTitleText",
            s?.titleTopMargin || 0,
            n.db.getDiagramTitle(),
          ),
            la(f, p, "flowchart", s?.useMaxWidth || !1));
          for (let m of h.nodes) {
            let g = xt(`#${t} [id="${m.id}"]`);
            if (!g || !m.link) continue;
            let y = u.createElementNS("http://www.w3.org/2000/svg", "a");
            (y.setAttributeNS(
              "http://www.w3.org/2000/svg",
              "class",
              m.cssClasses,
            ),
              y.setAttributeNS("http://www.w3.org/2000/svg", "rel", "noopener"),
              i === "sandbox"
                ? y.setAttributeNS(
                    "http://www.w3.org/2000/svg",
                    "target",
                    "_top",
                  )
                : m.linkTarget &&
                  y.setAttributeNS(
                    "http://www.w3.org/2000/svg",
                    "target",
                    m.linkTarget,
                  ));
            let b = g.insert(function () {
                return y;
              }, ":first-child"),
              k = g.select(".label-container");
            k &&
              b.append(function () {
                return k.node();
              });
            let T = g.select(".label");
            T &&
              b.append(function () {
                return T.node();
              });
          }
        }, "draw")),
        (eK = { getClasses: IEt, draw: MEt }));
    });
  var t6,
    e6,
    nK = x(() => {
      "use strict";
      t6 = (function () {
        var e = a(function (ka, ce, Ce, Ne) {
            for (Ce = Ce || {}, Ne = ka.length; Ne--; Ce[ka[Ne]] = ce);
            return Ce;
          }, "o"),
          t = [1, 4],
          r = [1, 3],
          n = [1, 5],
          i = [
            1, 8, 9, 10, 11, 27, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89,
            102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124,
          ],
          s = [2, 2],
          o = [1, 13],
          l = [1, 14],
          u = [1, 15],
          h = [1, 16],
          f = [1, 23],
          d = [1, 25],
          p = [1, 26],
          m = [1, 27],
          g = [1, 49],
          y = [1, 48],
          b = [1, 29],
          k = [1, 30],
          T = [1, 31],
          C = [1, 32],
          L = [1, 33],
          w = [1, 44],
          D = [1, 46],
          G = [1, 42],
          E = [1, 47],
          R = [1, 43],
          F = [1, 50],
          S = [1, 45],
          O = [1, 51],
          v = [1, 52],
          _ = [1, 34],
          A = [1, 35],
          N = [1, 36],
          B = [1, 37],
          M = [1, 57],
          I = [
            1, 8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89,
            102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124,
          ],
          V = [1, 61],
          $ = [1, 60],
          q = [1, 62],
          tt = [8, 9, 11, 75, 77, 78],
          ht = [1, 78],
          H = [1, 91],
          kt = [1, 96],
          ft = [1, 95],
          yt = [1, 92],
          ot = [1, 88],
          dt = [1, 94],
          nt = [1, 90],
          Q = [1, 97],
          et = [1, 93],
          X = [1, 98],
          st = [1, 89],
          U = [8, 9, 10, 11, 40, 75, 77, 78],
          gt = [8, 9, 10, 11, 40, 46, 75, 77, 78],
          z = [
            8, 9, 10, 11, 29, 40, 44, 46, 48, 50, 52, 54, 56, 58, 60, 63, 65,
            67, 68, 70, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115, 116,
          ],
          ge = [
            8, 9, 11, 44, 60, 75, 77, 78, 89, 102, 105, 106, 109, 111, 114, 115,
            116,
          ],
          lt = [44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116],
          jt = [1, 121],
          Me = [1, 122],
          se = [1, 124],
          Nt = [1, 123],
          At = [44, 60, 62, 74, 89, 102, 105, 106, 109, 111, 114, 115, 116],
          bt = [1, 133],
          ct = [1, 147],
          Lt = [1, 148],
          Z = [1, 149],
          Mt = [1, 150],
          W = [1, 135],
          Gt = [1, 137],
          j = [1, 141],
          Et = [1, 142],
          mt = [1, 143],
          Xt = [1, 144],
          Ft = [1, 145],
          _t = [1, 146],
          Qe = [1, 151],
          It = [1, 152],
          xr = [1, 131],
          Ze = [1, 132],
          mn = [1, 139],
          Ae = [1, 134],
          Te = [1, 138],
          Je = [1, 136],
          Se = [
            8, 9, 10, 11, 27, 32, 34, 36, 38, 44, 60, 84, 85, 86, 87, 88, 89,
            102, 105, 106, 109, 111, 114, 115, 116, 121, 122, 123, 124,
          ],
          hr = [1, 154],
          Sn = [1, 156],
          Ee = [8, 9, 11],
          $e = [
            8, 9, 10, 11, 14, 44, 60, 89, 105, 106, 109, 111, 114, 115, 116,
          ],
          Le = [1, 176],
          xe = [1, 172],
          fe = [1, 173],
          ye = [1, 177],
          be = [1, 174],
          Ht = [1, 175],
          Dn = [77, 116, 119],
          ne = [
            8, 9, 10, 11, 12, 14, 27, 29, 32, 44, 60, 75, 84, 85, 86, 87, 88,
            89, 90, 105, 109, 111, 114, 115, 116,
          ],
          Li = [10, 106],
          gn = [31, 49, 51, 53, 55, 57, 62, 64, 66, 67, 69, 71, 116, 117, 118],
          Br = [1, 247],
          Er = [1, 245],
          pi = [1, 249],
          Zt = [1, 243],
          it = [1, 244],
          $t = [1, 246],
          Kt = [1, 248],
          or = [1, 250],
          sn = [1, 268],
          _n = [8, 9, 11, 106],
          jr = [8, 9, 10, 11, 60, 84, 105, 106, 109, 110, 111, 112],
          Ji = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              graphConfig: 4,
              document: 5,
              line: 6,
              statement: 7,
              SEMI: 8,
              NEWLINE: 9,
              SPACE: 10,
              EOF: 11,
              GRAPH: 12,
              NODIR: 13,
              DIR: 14,
              FirstStmtSeparator: 15,
              ending: 16,
              endToken: 17,
              spaceList: 18,
              spaceListNewline: 19,
              vertexStatement: 20,
              separator: 21,
              styleStatement: 22,
              linkStyleStatement: 23,
              classDefStatement: 24,
              classStatement: 25,
              clickStatement: 26,
              subgraph: 27,
              textNoTags: 28,
              SQS: 29,
              text: 30,
              SQE: 31,
              end: 32,
              direction: 33,
              acc_title: 34,
              acc_title_value: 35,
              acc_descr: 36,
              acc_descr_value: 37,
              acc_descr_multiline_value: 38,
              shapeData: 39,
              SHAPE_DATA: 40,
              link: 41,
              node: 42,
              styledVertex: 43,
              AMP: 44,
              vertex: 45,
              STYLE_SEPARATOR: 46,
              idString: 47,
              DOUBLECIRCLESTART: 48,
              DOUBLECIRCLEEND: 49,
              PS: 50,
              PE: 51,
              "(-": 52,
              "-)": 53,
              STADIUMSTART: 54,
              STADIUMEND: 55,
              SUBROUTINESTART: 56,
              SUBROUTINEEND: 57,
              VERTEX_WITH_PROPS_START: 58,
              "NODE_STRING[field]": 59,
              COLON: 60,
              "NODE_STRING[value]": 61,
              PIPE: 62,
              CYLINDERSTART: 63,
              CYLINDEREND: 64,
              DIAMOND_START: 65,
              DIAMOND_STOP: 66,
              TAGEND: 67,
              TRAPSTART: 68,
              TRAPEND: 69,
              INVTRAPSTART: 70,
              INVTRAPEND: 71,
              linkStatement: 72,
              arrowText: 73,
              TESTSTR: 74,
              START_LINK: 75,
              edgeText: 76,
              LINK: 77,
              LINK_ID: 78,
              edgeTextToken: 79,
              STR: 80,
              MD_STR: 81,
              textToken: 82,
              keywords: 83,
              STYLE: 84,
              LINKSTYLE: 85,
              CLASSDEF: 86,
              CLASS: 87,
              CLICK: 88,
              DOWN: 89,
              UP: 90,
              textNoTagsToken: 91,
              stylesOpt: 92,
              "idString[vertex]": 93,
              "idString[class]": 94,
              CALLBACKNAME: 95,
              CALLBACKARGS: 96,
              HREF: 97,
              LINK_TARGET: 98,
              "STR[link]": 99,
              "STR[tooltip]": 100,
              alphaNum: 101,
              DEFAULT: 102,
              numList: 103,
              INTERPOLATE: 104,
              NUM: 105,
              COMMA: 106,
              style: 107,
              styleComponent: 108,
              NODE_STRING: 109,
              UNIT: 110,
              BRKT: 111,
              PCT: 112,
              idStringToken: 113,
              MINUS: 114,
              MULT: 115,
              UNICODE_TEXT: 116,
              TEXT: 117,
              TAGSTART: 118,
              EDGE_TEXT: 119,
              alphaNumToken: 120,
              direction_tb: 121,
              direction_bt: 122,
              direction_rl: 123,
              direction_lr: 124,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              8: "SEMI",
              9: "NEWLINE",
              10: "SPACE",
              11: "EOF",
              12: "GRAPH",
              13: "NODIR",
              14: "DIR",
              27: "subgraph",
              29: "SQS",
              31: "SQE",
              32: "end",
              34: "acc_title",
              35: "acc_title_value",
              36: "acc_descr",
              37: "acc_descr_value",
              38: "acc_descr_multiline_value",
              40: "SHAPE_DATA",
              44: "AMP",
              46: "STYLE_SEPARATOR",
              48: "DOUBLECIRCLESTART",
              49: "DOUBLECIRCLEEND",
              50: "PS",
              51: "PE",
              52: "(-",
              53: "-)",
              54: "STADIUMSTART",
              55: "STADIUMEND",
              56: "SUBROUTINESTART",
              57: "SUBROUTINEEND",
              58: "VERTEX_WITH_PROPS_START",
              59: "NODE_STRING[field]",
              60: "COLON",
              61: "NODE_STRING[value]",
              62: "PIPE",
              63: "CYLINDERSTART",
              64: "CYLINDEREND",
              65: "DIAMOND_START",
              66: "DIAMOND_STOP",
              67: "TAGEND",
              68: "TRAPSTART",
              69: "TRAPEND",
              70: "INVTRAPSTART",
              71: "INVTRAPEND",
              74: "TESTSTR",
              75: "START_LINK",
              77: "LINK",
              78: "LINK_ID",
              80: "STR",
              81: "MD_STR",
              84: "STYLE",
              85: "LINKSTYLE",
              86: "CLASSDEF",
              87: "CLASS",
              88: "CLICK",
              89: "DOWN",
              90: "UP",
              93: "idString[vertex]",
              94: "idString[class]",
              95: "CALLBACKNAME",
              96: "CALLBACKARGS",
              97: "HREF",
              98: "LINK_TARGET",
              99: "STR[link]",
              100: "STR[tooltip]",
              102: "DEFAULT",
              104: "INTERPOLATE",
              105: "NUM",
              106: "COMMA",
              109: "NODE_STRING",
              110: "UNIT",
              111: "BRKT",
              112: "PCT",
              114: "MINUS",
              115: "MULT",
              116: "UNICODE_TEXT",
              117: "TEXT",
              118: "TAGSTART",
              119: "EDGE_TEXT",
              121: "direction_tb",
              122: "direction_bt",
              123: "direction_rl",
              124: "direction_lr",
            },
            productions_: [
              0,
              [3, 2],
              [5, 0],
              [5, 2],
              [6, 1],
              [6, 1],
              [6, 1],
              [6, 1],
              [6, 1],
              [4, 2],
              [4, 2],
              [4, 2],
              [4, 3],
              [16, 2],
              [16, 1],
              [17, 1],
              [17, 1],
              [17, 1],
              [15, 1],
              [15, 1],
              [15, 2],
              [19, 2],
              [19, 2],
              [19, 1],
              [19, 1],
              [18, 2],
              [18, 1],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 9],
              [7, 6],
              [7, 4],
              [7, 1],
              [7, 2],
              [7, 2],
              [7, 1],
              [21, 1],
              [21, 1],
              [21, 1],
              [39, 2],
              [39, 1],
              [20, 4],
              [20, 3],
              [20, 4],
              [20, 2],
              [20, 2],
              [20, 1],
              [42, 1],
              [42, 6],
              [42, 5],
              [43, 1],
              [43, 3],
              [45, 4],
              [45, 4],
              [45, 6],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 8],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 6],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 4],
              [45, 1],
              [41, 2],
              [41, 3],
              [41, 3],
              [41, 1],
              [41, 3],
              [41, 4],
              [76, 1],
              [76, 2],
              [76, 1],
              [76, 1],
              [72, 1],
              [72, 2],
              [73, 3],
              [30, 1],
              [30, 2],
              [30, 1],
              [30, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [83, 1],
              [28, 1],
              [28, 2],
              [28, 1],
              [28, 1],
              [24, 5],
              [25, 5],
              [26, 2],
              [26, 4],
              [26, 3],
              [26, 5],
              [26, 3],
              [26, 5],
              [26, 5],
              [26, 7],
              [26, 2],
              [26, 4],
              [26, 2],
              [26, 4],
              [26, 4],
              [26, 6],
              [22, 5],
              [23, 5],
              [23, 5],
              [23, 9],
              [23, 9],
              [23, 7],
              [23, 7],
              [103, 1],
              [103, 3],
              [92, 1],
              [92, 3],
              [107, 1],
              [107, 2],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [108, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [113, 1],
              [82, 1],
              [82, 1],
              [82, 1],
              [82, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [91, 1],
              [79, 1],
              [79, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [120, 1],
              [47, 1],
              [47, 2],
              [101, 1],
              [101, 2],
              [33, 1],
              [33, 1],
              [33, 1],
              [33, 1],
            ],
            performAction: a(function (ce, Ce, Ne, Wt, Fr, Y, fu) {
              var J = Y.length - 1;
              switch (Fr) {
                case 2:
                  this.$ = [];
                  break;
                case 3:
                  ((!Array.isArray(Y[J]) || Y[J].length > 0) &&
                    Y[J - 1].push(Y[J]),
                    (this.$ = Y[J - 1]));
                  break;
                case 4:
                case 183:
                  this.$ = Y[J];
                  break;
                case 11:
                  (Wt.setDirection("TB"), (this.$ = "TB"));
                  break;
                case 12:
                  (Wt.setDirection(Y[J - 1]), (this.$ = Y[J - 1]));
                  break;
                case 27:
                  this.$ = Y[J - 1].nodes;
                  break;
                case 28:
                case 29:
                case 30:
                case 31:
                case 32:
                  this.$ = [];
                  break;
                case 33:
                  this.$ = Wt.addSubGraph(Y[J - 6], Y[J - 1], Y[J - 4]);
                  break;
                case 34:
                  this.$ = Wt.addSubGraph(Y[J - 3], Y[J - 1], Y[J - 3]);
                  break;
                case 35:
                  this.$ = Wt.addSubGraph(void 0, Y[J - 1], void 0);
                  break;
                case 37:
                  ((this.$ = Y[J].trim()), Wt.setAccTitle(this.$));
                  break;
                case 38:
                case 39:
                  ((this.$ = Y[J].trim()), Wt.setAccDescription(this.$));
                  break;
                case 43:
                  this.$ = Y[J - 1] + Y[J];
                  break;
                case 44:
                  this.$ = Y[J];
                  break;
                case 45:
                  (Wt.addVertex(
                    Y[J - 1][Y[J - 1].length - 1],
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    Y[J],
                  ),
                    Wt.addLink(Y[J - 3].stmt, Y[J - 1], Y[J - 2]),
                    (this.$ = {
                      stmt: Y[J - 1],
                      nodes: Y[J - 1].concat(Y[J - 3].nodes),
                    }));
                  break;
                case 46:
                  (Wt.addLink(Y[J - 2].stmt, Y[J], Y[J - 1]),
                    (this.$ = {
                      stmt: Y[J],
                      nodes: Y[J].concat(Y[J - 2].nodes),
                    }));
                  break;
                case 47:
                  (Wt.addLink(Y[J - 3].stmt, Y[J - 1], Y[J - 2]),
                    (this.$ = {
                      stmt: Y[J - 1],
                      nodes: Y[J - 1].concat(Y[J - 3].nodes),
                    }));
                  break;
                case 48:
                  this.$ = { stmt: Y[J - 1], nodes: Y[J - 1] };
                  break;
                case 49:
                  (Wt.addVertex(
                    Y[J - 1][Y[J - 1].length - 1],
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    Y[J],
                  ),
                    (this.$ = {
                      stmt: Y[J - 1],
                      nodes: Y[J - 1],
                      shapeData: Y[J],
                    }));
                  break;
                case 50:
                  this.$ = { stmt: Y[J], nodes: Y[J] };
                  break;
                case 51:
                  this.$ = [Y[J]];
                  break;
                case 52:
                  (Wt.addVertex(
                    Y[J - 5][Y[J - 5].length - 1],
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    void 0,
                    Y[J - 4],
                  ),
                    (this.$ = Y[J - 5].concat(Y[J])));
                  break;
                case 53:
                  this.$ = Y[J - 4].concat(Y[J]);
                  break;
                case 54:
                  this.$ = Y[J];
                  break;
                case 55:
                  ((this.$ = Y[J - 2]), Wt.setClass(Y[J - 2], Y[J]));
                  break;
                case 56:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "square"));
                  break;
                case 57:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "doublecircle"));
                  break;
                case 58:
                  ((this.$ = Y[J - 5]),
                    Wt.addVertex(Y[J - 5], Y[J - 2], "circle"));
                  break;
                case 59:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "ellipse"));
                  break;
                case 60:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "stadium"));
                  break;
                case 61:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "subroutine"));
                  break;
                case 62:
                  ((this.$ = Y[J - 7]),
                    Wt.addVertex(
                      Y[J - 7],
                      Y[J - 1],
                      "rect",
                      void 0,
                      void 0,
                      void 0,
                      Object.fromEntries([[Y[J - 5], Y[J - 3]]]),
                    ));
                  break;
                case 63:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "cylinder"));
                  break;
                case 64:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "round"));
                  break;
                case 65:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "diamond"));
                  break;
                case 66:
                  ((this.$ = Y[J - 5]),
                    Wt.addVertex(Y[J - 5], Y[J - 2], "hexagon"));
                  break;
                case 67:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "odd"));
                  break;
                case 68:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "trapezoid"));
                  break;
                case 69:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "inv_trapezoid"));
                  break;
                case 70:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "lean_right"));
                  break;
                case 71:
                  ((this.$ = Y[J - 3]),
                    Wt.addVertex(Y[J - 3], Y[J - 1], "lean_left"));
                  break;
                case 72:
                  ((this.$ = Y[J]), Wt.addVertex(Y[J]));
                  break;
                case 73:
                  ((Y[J - 1].text = Y[J]), (this.$ = Y[J - 1]));
                  break;
                case 74:
                case 75:
                  ((Y[J - 2].text = Y[J - 1]), (this.$ = Y[J - 2]));
                  break;
                case 76:
                  this.$ = Y[J];
                  break;
                case 77:
                  var Cn = Wt.destructLink(Y[J], Y[J - 2]);
                  this.$ = {
                    type: Cn.type,
                    stroke: Cn.stroke,
                    length: Cn.length,
                    text: Y[J - 1],
                  };
                  break;
                case 78:
                  var Cn = Wt.destructLink(Y[J], Y[J - 2]);
                  this.$ = {
                    type: Cn.type,
                    stroke: Cn.stroke,
                    length: Cn.length,
                    text: Y[J - 1],
                    id: Y[J - 3],
                  };
                  break;
                case 79:
                  this.$ = { text: Y[J], type: "text" };
                  break;
                case 80:
                  this.$ = {
                    text: Y[J - 1].text + "" + Y[J],
                    type: Y[J - 1].type,
                  };
                  break;
                case 81:
                  this.$ = { text: Y[J], type: "string" };
                  break;
                case 82:
                  this.$ = { text: Y[J], type: "markdown" };
                  break;
                case 83:
                  var Cn = Wt.destructLink(Y[J]);
                  this.$ = {
                    type: Cn.type,
                    stroke: Cn.stroke,
                    length: Cn.length,
                  };
                  break;
                case 84:
                  var Cn = Wt.destructLink(Y[J]);
                  this.$ = {
                    type: Cn.type,
                    stroke: Cn.stroke,
                    length: Cn.length,
                    id: Y[J - 1],
                  };
                  break;
                case 85:
                  this.$ = Y[J - 1];
                  break;
                case 86:
                  this.$ = { text: Y[J], type: "text" };
                  break;
                case 87:
                  this.$ = {
                    text: Y[J - 1].text + "" + Y[J],
                    type: Y[J - 1].type,
                  };
                  break;
                case 88:
                  this.$ = { text: Y[J], type: "string" };
                  break;
                case 89:
                case 104:
                  this.$ = { text: Y[J], type: "markdown" };
                  break;
                case 101:
                  this.$ = { text: Y[J], type: "text" };
                  break;
                case 102:
                  this.$ = {
                    text: Y[J - 1].text + "" + Y[J],
                    type: Y[J - 1].type,
                  };
                  break;
                case 103:
                  this.$ = { text: Y[J], type: "text" };
                  break;
                case 105:
                  ((this.$ = Y[J - 4]), Wt.addClass(Y[J - 2], Y[J]));
                  break;
                case 106:
                  ((this.$ = Y[J - 4]), Wt.setClass(Y[J - 2], Y[J]));
                  break;
                case 107:
                case 115:
                  ((this.$ = Y[J - 1]), Wt.setClickEvent(Y[J - 1], Y[J]));
                  break;
                case 108:
                case 116:
                  ((this.$ = Y[J - 3]),
                    Wt.setClickEvent(Y[J - 3], Y[J - 2]),
                    Wt.setTooltip(Y[J - 3], Y[J]));
                  break;
                case 109:
                  ((this.$ = Y[J - 2]),
                    Wt.setClickEvent(Y[J - 2], Y[J - 1], Y[J]));
                  break;
                case 110:
                  ((this.$ = Y[J - 4]),
                    Wt.setClickEvent(Y[J - 4], Y[J - 3], Y[J - 2]),
                    Wt.setTooltip(Y[J - 4], Y[J]));
                  break;
                case 111:
                  ((this.$ = Y[J - 2]), Wt.setLink(Y[J - 2], Y[J]));
                  break;
                case 112:
                  ((this.$ = Y[J - 4]),
                    Wt.setLink(Y[J - 4], Y[J - 2]),
                    Wt.setTooltip(Y[J - 4], Y[J]));
                  break;
                case 113:
                  ((this.$ = Y[J - 4]), Wt.setLink(Y[J - 4], Y[J - 2], Y[J]));
                  break;
                case 114:
                  ((this.$ = Y[J - 6]),
                    Wt.setLink(Y[J - 6], Y[J - 4], Y[J]),
                    Wt.setTooltip(Y[J - 6], Y[J - 2]));
                  break;
                case 117:
                  ((this.$ = Y[J - 1]), Wt.setLink(Y[J - 1], Y[J]));
                  break;
                case 118:
                  ((this.$ = Y[J - 3]),
                    Wt.setLink(Y[J - 3], Y[J - 2]),
                    Wt.setTooltip(Y[J - 3], Y[J]));
                  break;
                case 119:
                  ((this.$ = Y[J - 3]), Wt.setLink(Y[J - 3], Y[J - 2], Y[J]));
                  break;
                case 120:
                  ((this.$ = Y[J - 5]),
                    Wt.setLink(Y[J - 5], Y[J - 4], Y[J]),
                    Wt.setTooltip(Y[J - 5], Y[J - 2]));
                  break;
                case 121:
                  ((this.$ = Y[J - 4]),
                    Wt.addVertex(Y[J - 2], void 0, void 0, Y[J]));
                  break;
                case 122:
                  ((this.$ = Y[J - 4]), Wt.updateLink([Y[J - 2]], Y[J]));
                  break;
                case 123:
                  ((this.$ = Y[J - 4]), Wt.updateLink(Y[J - 2], Y[J]));
                  break;
                case 124:
                  ((this.$ = Y[J - 8]),
                    Wt.updateLinkInterpolate([Y[J - 6]], Y[J - 2]),
                    Wt.updateLink([Y[J - 6]], Y[J]));
                  break;
                case 125:
                  ((this.$ = Y[J - 8]),
                    Wt.updateLinkInterpolate(Y[J - 6], Y[J - 2]),
                    Wt.updateLink(Y[J - 6], Y[J]));
                  break;
                case 126:
                  ((this.$ = Y[J - 6]),
                    Wt.updateLinkInterpolate([Y[J - 4]], Y[J]));
                  break;
                case 127:
                  ((this.$ = Y[J - 6]),
                    Wt.updateLinkInterpolate(Y[J - 4], Y[J]));
                  break;
                case 128:
                case 130:
                  this.$ = [Y[J]];
                  break;
                case 129:
                case 131:
                  (Y[J - 2].push(Y[J]), (this.$ = Y[J - 2]));
                  break;
                case 133:
                  this.$ = Y[J - 1] + Y[J];
                  break;
                case 181:
                  this.$ = Y[J];
                  break;
                case 182:
                  this.$ = Y[J - 1] + "" + Y[J];
                  break;
                case 184:
                  this.$ = Y[J - 1] + "" + Y[J];
                  break;
                case 185:
                  this.$ = { stmt: "dir", value: "TB" };
                  break;
                case 186:
                  this.$ = { stmt: "dir", value: "BT" };
                  break;
                case 187:
                  this.$ = { stmt: "dir", value: "RL" };
                  break;
                case 188:
                  this.$ = { stmt: "dir", value: "LR" };
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: 2, 9: t, 10: r, 12: n },
              { 1: [3] },
              e(i, s, { 5: 6 }),
              { 4: 7, 9: t, 10: r, 12: n },
              { 4: 8, 9: t, 10: r, 12: n },
              { 13: [1, 9], 14: [1, 10] },
              {
                1: [2, 1],
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: L,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
                121: _,
                122: A,
                123: N,
                124: B,
              },
              e(i, [2, 9]),
              e(i, [2, 10]),
              e(i, [2, 11]),
              { 8: [1, 54], 9: [1, 55], 10: M, 15: 53, 18: 56 },
              e(I, [2, 3]),
              e(I, [2, 4]),
              e(I, [2, 5]),
              e(I, [2, 6]),
              e(I, [2, 7]),
              e(I, [2, 8]),
              {
                8: V,
                9: $,
                11: q,
                21: 58,
                41: 59,
                72: 63,
                75: [1, 64],
                77: [1, 66],
                78: [1, 65],
              },
              { 8: V, 9: $, 11: q, 21: 67 },
              { 8: V, 9: $, 11: q, 21: 68 },
              { 8: V, 9: $, 11: q, 21: 69 },
              { 8: V, 9: $, 11: q, 21: 70 },
              { 8: V, 9: $, 11: q, 21: 71 },
              { 8: V, 9: $, 10: [1, 72], 11: q, 21: 73 },
              e(I, [2, 36]),
              { 35: [1, 74] },
              { 37: [1, 75] },
              e(I, [2, 39]),
              e(tt, [2, 50], { 18: 76, 39: 77, 10: M, 40: ht }),
              { 10: [1, 79] },
              { 10: [1, 80] },
              { 10: [1, 81] },
              { 10: [1, 82] },
              {
                14: H,
                44: kt,
                60: ft,
                80: [1, 86],
                89: yt,
                95: [1, 83],
                97: [1, 84],
                101: 85,
                105: ot,
                106: dt,
                109: nt,
                111: Q,
                114: et,
                115: X,
                116: st,
                120: 87,
              },
              e(I, [2, 185]),
              e(I, [2, 186]),
              e(I, [2, 187]),
              e(I, [2, 188]),
              e(U, [2, 51]),
              e(U, [2, 54], { 46: [1, 99] }),
              e(gt, [2, 72], {
                113: 112,
                29: [1, 100],
                44: g,
                48: [1, 101],
                50: [1, 102],
                52: [1, 103],
                54: [1, 104],
                56: [1, 105],
                58: [1, 106],
                60: y,
                63: [1, 107],
                65: [1, 108],
                67: [1, 109],
                68: [1, 110],
                70: [1, 111],
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                114: S,
                115: O,
                116: v,
              }),
              e(z, [2, 181]),
              e(z, [2, 142]),
              e(z, [2, 143]),
              e(z, [2, 144]),
              e(z, [2, 145]),
              e(z, [2, 146]),
              e(z, [2, 147]),
              e(z, [2, 148]),
              e(z, [2, 149]),
              e(z, [2, 150]),
              e(z, [2, 151]),
              e(z, [2, 152]),
              e(i, [2, 12]),
              e(i, [2, 18]),
              e(i, [2, 19]),
              { 9: [1, 113] },
              e(ge, [2, 26], { 18: 114, 10: M }),
              e(I, [2, 27]),
              {
                42: 115,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              e(I, [2, 40]),
              e(I, [2, 41]),
              e(I, [2, 42]),
              e(lt, [2, 76], { 73: 116, 62: [1, 118], 74: [1, 117] }),
              { 76: 119, 79: 120, 80: jt, 81: Me, 116: se, 119: Nt },
              { 75: [1, 125], 77: [1, 126] },
              e(At, [2, 83]),
              e(I, [2, 28]),
              e(I, [2, 29]),
              e(I, [2, 30]),
              e(I, [2, 31]),
              e(I, [2, 32]),
              {
                10: bt,
                12: ct,
                14: Lt,
                27: Z,
                28: 127,
                32: Mt,
                44: W,
                60: Gt,
                75: j,
                80: [1, 129],
                81: [1, 130],
                83: 140,
                84: Et,
                85: mt,
                86: Xt,
                87: Ft,
                88: _t,
                89: Qe,
                90: It,
                91: 128,
                105: xr,
                109: Ze,
                111: mn,
                114: Ae,
                115: Te,
                116: Je,
              },
              e(Se, s, { 5: 153 }),
              e(I, [2, 37]),
              e(I, [2, 38]),
              e(tt, [2, 48], { 44: hr }),
              e(tt, [2, 49], { 18: 155, 10: M, 40: Sn }),
              e(U, [2, 44]),
              {
                44: g,
                47: 157,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              { 102: [1, 158], 103: 159, 105: [1, 160] },
              {
                44: g,
                47: 161,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              {
                44: g,
                47: 162,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              e(Ee, [2, 107], { 10: [1, 163], 96: [1, 164] }),
              { 80: [1, 165] },
              e(Ee, [2, 115], {
                120: 167,
                10: [1, 166],
                14: H,
                44: kt,
                60: ft,
                89: yt,
                105: ot,
                106: dt,
                109: nt,
                111: Q,
                114: et,
                115: X,
                116: st,
              }),
              e(Ee, [2, 117], { 10: [1, 168] }),
              e($e, [2, 183]),
              e($e, [2, 170]),
              e($e, [2, 171]),
              e($e, [2, 172]),
              e($e, [2, 173]),
              e($e, [2, 174]),
              e($e, [2, 175]),
              e($e, [2, 176]),
              e($e, [2, 177]),
              e($e, [2, 178]),
              e($e, [2, 179]),
              e($e, [2, 180]),
              {
                44: g,
                47: 169,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              {
                30: 170,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 178,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 180,
                50: [1, 179],
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 181,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 182,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 183,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              { 109: [1, 184] },
              {
                30: 185,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 186,
                65: [1, 187],
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 188,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 189,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                30: 190,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              e(z, [2, 182]),
              e(i, [2, 20]),
              e(ge, [2, 25]),
              e(tt, [2, 46], { 39: 191, 18: 192, 10: M, 40: ht }),
              e(lt, [2, 73], { 10: [1, 193] }),
              { 10: [1, 194] },
              {
                30: 195,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              { 77: [1, 196], 79: 197, 116: se, 119: Nt },
              e(Dn, [2, 79]),
              e(Dn, [2, 81]),
              e(Dn, [2, 82]),
              e(Dn, [2, 168]),
              e(Dn, [2, 169]),
              { 76: 198, 79: 120, 80: jt, 81: Me, 116: se, 119: Nt },
              e(At, [2, 84]),
              {
                8: V,
                9: $,
                10: bt,
                11: q,
                12: ct,
                14: Lt,
                21: 200,
                27: Z,
                29: [1, 199],
                32: Mt,
                44: W,
                60: Gt,
                75: j,
                83: 140,
                84: Et,
                85: mt,
                86: Xt,
                87: Ft,
                88: _t,
                89: Qe,
                90: It,
                91: 201,
                105: xr,
                109: Ze,
                111: mn,
                114: Ae,
                115: Te,
                116: Je,
              },
              e(ne, [2, 101]),
              e(ne, [2, 103]),
              e(ne, [2, 104]),
              e(ne, [2, 157]),
              e(ne, [2, 158]),
              e(ne, [2, 159]),
              e(ne, [2, 160]),
              e(ne, [2, 161]),
              e(ne, [2, 162]),
              e(ne, [2, 163]),
              e(ne, [2, 164]),
              e(ne, [2, 165]),
              e(ne, [2, 166]),
              e(ne, [2, 167]),
              e(ne, [2, 90]),
              e(ne, [2, 91]),
              e(ne, [2, 92]),
              e(ne, [2, 93]),
              e(ne, [2, 94]),
              e(ne, [2, 95]),
              e(ne, [2, 96]),
              e(ne, [2, 97]),
              e(ne, [2, 98]),
              e(ne, [2, 99]),
              e(ne, [2, 100]),
              {
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                32: [1, 202],
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: L,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
                121: _,
                122: A,
                123: N,
                124: B,
              },
              { 10: M, 18: 203 },
              { 44: [1, 204] },
              e(U, [2, 43]),
              {
                10: [1, 205],
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 112,
                114: S,
                115: O,
                116: v,
              },
              { 10: [1, 206] },
              { 10: [1, 207], 106: [1, 208] },
              e(Li, [2, 128]),
              {
                10: [1, 209],
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 112,
                114: S,
                115: O,
                116: v,
              },
              {
                10: [1, 210],
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 112,
                114: S,
                115: O,
                116: v,
              },
              { 80: [1, 211] },
              e(Ee, [2, 109], { 10: [1, 212] }),
              e(Ee, [2, 111], { 10: [1, 213] }),
              { 80: [1, 214] },
              e($e, [2, 184]),
              { 80: [1, 215], 98: [1, 216] },
              e(U, [2, 55], {
                113: 112,
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                114: S,
                115: O,
                116: v,
              }),
              { 31: [1, 217], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(gn, [2, 86]),
              e(gn, [2, 88]),
              e(gn, [2, 89]),
              e(gn, [2, 153]),
              e(gn, [2, 154]),
              e(gn, [2, 155]),
              e(gn, [2, 156]),
              { 49: [1, 219], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              {
                30: 220,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              { 51: [1, 221], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 53: [1, 222], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 55: [1, 223], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 57: [1, 224], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 60: [1, 225] },
              { 64: [1, 226], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              { 66: [1, 227], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              {
                30: 228,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              { 31: [1, 229], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              {
                67: Le,
                69: [1, 230],
                71: [1, 231],
                82: 218,
                116: ye,
                117: be,
                118: Ht,
              },
              {
                67: Le,
                69: [1, 233],
                71: [1, 232],
                82: 218,
                116: ye,
                117: be,
                118: Ht,
              },
              e(tt, [2, 45], { 18: 155, 10: M, 40: Sn }),
              e(tt, [2, 47], { 44: hr }),
              e(lt, [2, 75]),
              e(lt, [2, 74]),
              { 62: [1, 234], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(lt, [2, 77]),
              e(Dn, [2, 80]),
              { 77: [1, 235], 79: 197, 116: se, 119: Nt },
              {
                30: 236,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              e(Se, s, { 5: 237 }),
              e(ne, [2, 102]),
              e(I, [2, 35]),
              {
                43: 238,
                44: g,
                45: 39,
                47: 40,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              { 10: M, 18: 239 },
              {
                10: Br,
                60: Er,
                84: pi,
                92: 240,
                105: Zt,
                107: 241,
                108: 242,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              },
              {
                10: Br,
                60: Er,
                84: pi,
                92: 251,
                104: [1, 252],
                105: Zt,
                107: 241,
                108: 242,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              },
              {
                10: Br,
                60: Er,
                84: pi,
                92: 253,
                104: [1, 254],
                105: Zt,
                107: 241,
                108: 242,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              },
              { 105: [1, 255] },
              {
                10: Br,
                60: Er,
                84: pi,
                92: 256,
                105: Zt,
                107: 241,
                108: 242,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              },
              {
                44: g,
                47: 257,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              e(Ee, [2, 108]),
              { 80: [1, 258] },
              { 80: [1, 259], 98: [1, 260] },
              e(Ee, [2, 116]),
              e(Ee, [2, 118], { 10: [1, 261] }),
              e(Ee, [2, 119]),
              e(gt, [2, 56]),
              e(gn, [2, 87]),
              e(gt, [2, 57]),
              { 51: [1, 262], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(gt, [2, 64]),
              e(gt, [2, 59]),
              e(gt, [2, 60]),
              e(gt, [2, 61]),
              { 109: [1, 263] },
              e(gt, [2, 63]),
              e(gt, [2, 65]),
              { 66: [1, 264], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              e(gt, [2, 67]),
              e(gt, [2, 68]),
              e(gt, [2, 70]),
              e(gt, [2, 69]),
              e(gt, [2, 71]),
              e(
                [10, 44, 60, 89, 102, 105, 106, 109, 111, 114, 115, 116],
                [2, 85],
              ),
              e(lt, [2, 78]),
              { 31: [1, 265], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              {
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                32: [1, 266],
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: L,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
                121: _,
                122: A,
                123: N,
                124: B,
              },
              e(U, [2, 53]),
              {
                43: 267,
                44: g,
                45: 39,
                47: 40,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
              },
              e(Ee, [2, 121], { 106: sn }),
              e(_n, [2, 130], {
                108: 269,
                10: Br,
                60: Er,
                84: pi,
                105: Zt,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              }),
              e(jr, [2, 132]),
              e(jr, [2, 134]),
              e(jr, [2, 135]),
              e(jr, [2, 136]),
              e(jr, [2, 137]),
              e(jr, [2, 138]),
              e(jr, [2, 139]),
              e(jr, [2, 140]),
              e(jr, [2, 141]),
              e(Ee, [2, 122], { 106: sn }),
              { 10: [1, 270] },
              e(Ee, [2, 123], { 106: sn }),
              { 10: [1, 271] },
              e(Li, [2, 129]),
              e(Ee, [2, 105], { 106: sn }),
              e(Ee, [2, 106], {
                113: 112,
                44: g,
                60: y,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                114: S,
                115: O,
                116: v,
              }),
              e(Ee, [2, 110]),
              e(Ee, [2, 112], { 10: [1, 272] }),
              e(Ee, [2, 113]),
              { 98: [1, 273] },
              { 51: [1, 274] },
              { 62: [1, 275] },
              { 66: [1, 276] },
              { 8: V, 9: $, 11: q, 21: 277 },
              e(I, [2, 34]),
              e(U, [2, 52]),
              {
                10: Br,
                60: Er,
                84: pi,
                105: Zt,
                107: 278,
                108: 242,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              },
              e(jr, [2, 133]),
              {
                14: H,
                44: kt,
                60: ft,
                89: yt,
                101: 279,
                105: ot,
                106: dt,
                109: nt,
                111: Q,
                114: et,
                115: X,
                116: st,
                120: 87,
              },
              {
                14: H,
                44: kt,
                60: ft,
                89: yt,
                101: 280,
                105: ot,
                106: dt,
                109: nt,
                111: Q,
                114: et,
                115: X,
                116: st,
                120: 87,
              },
              { 98: [1, 281] },
              e(Ee, [2, 120]),
              e(gt, [2, 58]),
              {
                30: 282,
                67: Le,
                80: xe,
                81: fe,
                82: 171,
                116: ye,
                117: be,
                118: Ht,
              },
              e(gt, [2, 66]),
              e(Se, s, { 5: 283 }),
              e(_n, [2, 131], {
                108: 269,
                10: Br,
                60: Er,
                84: pi,
                105: Zt,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              }),
              e(Ee, [2, 126], {
                120: 167,
                10: [1, 284],
                14: H,
                44: kt,
                60: ft,
                89: yt,
                105: ot,
                106: dt,
                109: nt,
                111: Q,
                114: et,
                115: X,
                116: st,
              }),
              e(Ee, [2, 127], {
                120: 167,
                10: [1, 285],
                14: H,
                44: kt,
                60: ft,
                89: yt,
                105: ot,
                106: dt,
                109: nt,
                111: Q,
                114: et,
                115: X,
                116: st,
              }),
              e(Ee, [2, 114]),
              { 31: [1, 286], 67: Le, 82: 218, 116: ye, 117: be, 118: Ht },
              {
                6: 11,
                7: 12,
                8: o,
                9: l,
                10: u,
                11: h,
                20: 17,
                22: 18,
                23: 19,
                24: 20,
                25: 21,
                26: 22,
                27: f,
                32: [1, 287],
                33: 24,
                34: d,
                36: p,
                38: m,
                42: 28,
                43: 38,
                44: g,
                45: 39,
                47: 40,
                60: y,
                84: b,
                85: k,
                86: T,
                87: C,
                88: L,
                89: w,
                102: D,
                105: G,
                106: E,
                109: R,
                111: F,
                113: 41,
                114: S,
                115: O,
                116: v,
                121: _,
                122: A,
                123: N,
                124: B,
              },
              {
                10: Br,
                60: Er,
                84: pi,
                92: 288,
                105: Zt,
                107: 241,
                108: 242,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              },
              {
                10: Br,
                60: Er,
                84: pi,
                92: 289,
                105: Zt,
                107: 241,
                108: 242,
                109: it,
                110: $t,
                111: Kt,
                112: or,
              },
              e(gt, [2, 62]),
              e(I, [2, 33]),
              e(Ee, [2, 124], { 106: sn }),
              e(Ee, [2, 125], { 106: sn }),
            ],
            defaultActions: {},
            parseError: a(function (ce, Ce) {
              if (Ce.recoverable) this.trace(ce);
              else {
                var Ne = new Error(ce);
                throw ((Ne.hash = Ce), Ne);
              }
            }, "parseError"),
            parse: a(function (ce) {
              var Ce = this,
                Ne = [0],
                Wt = [],
                Fr = [null],
                Y = [],
                fu = this.table,
                J = "",
                Cn = 0,
                V8 = 0,
                z8 = 0,
                qlt = 2,
                W8 = 1,
                Hlt = Y.slice.call(arguments, 1),
                Vn = Object.create(this.lexer),
                du = { yy: {} };
              for (var vC in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, vC) &&
                  (du.yy[vC] = this.yy[vC]);
              (Vn.setInput(ce, du.yy),
                (du.yy.lexer = Vn),
                (du.yy.parser = this),
                typeof Vn.yylloc > "u" && (Vn.yylloc = {}));
              var EC = Vn.yylloc;
              Y.push(EC);
              var Ylt = Vn.options && Vn.options.ranges;
              typeof du.yy.parseError == "function"
                ? (this.parseError = du.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function $Mt(ks) {
                ((Ne.length = Ne.length - 2 * ks),
                  (Fr.length = Fr.length - ks),
                  (Y.length = Y.length - ks));
              }
              a($Mt, "popStack");
              function Xlt() {
                var ks;
                return (
                  (ks = Wt.pop() || Vn.lex() || W8),
                  typeof ks != "number" &&
                    (ks instanceof Array && ((Wt = ks), (ks = Wt.pop())),
                    (ks = Ce.symbols_[ks] || ks)),
                  ks
                );
              }
              a(Xlt, "lex");
              for (var Ri, AC, pu, zs, GMt, LC, sf = {}, rx, Ko, U8, nx; ; ) {
                if (
                  ((pu = Ne[Ne.length - 1]),
                  this.defaultActions[pu]
                    ? (zs = this.defaultActions[pu])
                    : ((Ri === null || typeof Ri > "u") && (Ri = Xlt()),
                      (zs = fu[pu] && fu[pu][Ri])),
                  typeof zs > "u" || !zs.length || !zs[0])
                ) {
                  var RC = "";
                  nx = [];
                  for (rx in fu[pu])
                    this.terminals_[rx] &&
                      rx > qlt &&
                      nx.push("'" + this.terminals_[rx] + "'");
                  (Vn.showPosition
                    ? (RC =
                        "Parse error on line " +
                        (Cn + 1) +
                        `:
` +
                        Vn.showPosition() +
                        `
Expecting ` +
                        nx.join(", ") +
                        ", got '" +
                        (this.terminals_[Ri] || Ri) +
                        "'")
                    : (RC =
                        "Parse error on line " +
                        (Cn + 1) +
                        ": Unexpected " +
                        (Ri == W8
                          ? "end of input"
                          : "'" + (this.terminals_[Ri] || Ri) + "'")),
                    this.parseError(RC, {
                      text: Vn.match,
                      token: this.terminals_[Ri] || Ri,
                      line: Vn.yylineno,
                      loc: EC,
                      expected: nx,
                    }));
                }
                if (zs[0] instanceof Array && zs.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      pu +
                      ", token: " +
                      Ri,
                  );
                switch (zs[0]) {
                  case 1:
                    (Ne.push(Ri),
                      Fr.push(Vn.yytext),
                      Y.push(Vn.yylloc),
                      Ne.push(zs[1]),
                      (Ri = null),
                      AC
                        ? ((Ri = AC), (AC = null))
                        : ((V8 = Vn.yyleng),
                          (J = Vn.yytext),
                          (Cn = Vn.yylineno),
                          (EC = Vn.yylloc),
                          z8 > 0 && z8--));
                    break;
                  case 2:
                    if (
                      ((Ko = this.productions_[zs[1]][1]),
                      (sf.$ = Fr[Fr.length - Ko]),
                      (sf._$ = {
                        first_line: Y[Y.length - (Ko || 1)].first_line,
                        last_line: Y[Y.length - 1].last_line,
                        first_column: Y[Y.length - (Ko || 1)].first_column,
                        last_column: Y[Y.length - 1].last_column,
                      }),
                      Ylt &&
                        (sf._$.range = [
                          Y[Y.length - (Ko || 1)].range[0],
                          Y[Y.length - 1].range[1],
                        ]),
                      (LC = this.performAction.apply(
                        sf,
                        [J, V8, Cn, du.yy, zs[1], Fr, Y].concat(Hlt),
                      )),
                      typeof LC < "u")
                    )
                      return LC;
                    (Ko &&
                      ((Ne = Ne.slice(0, -1 * Ko * 2)),
                      (Fr = Fr.slice(0, -1 * Ko)),
                      (Y = Y.slice(0, -1 * Ko))),
                      Ne.push(this.productions_[zs[1]][0]),
                      Fr.push(sf.$),
                      Y.push(sf._$),
                      (U8 = fu[Ne[Ne.length - 2]][Ne[Ne.length - 1]]),
                      Ne.push(U8));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          hu = (function () {
            var ka = {
              EOF: 1,
              parseError: a(function (Ce, Ne) {
                if (this.yy.parser) this.yy.parser.parseError(Ce, Ne);
                else throw new Error(Ce);
              }, "parseError"),
              setInput: a(function (ce, Ce) {
                return (
                  (this.yy = Ce || this.yy || {}),
                  (this._input = ce),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var ce = this._input[0];
                ((this.yytext += ce),
                  this.yyleng++,
                  this.offset++,
                  (this.match += ce),
                  (this.matched += ce));
                var Ce = ce.match(/(?:\r\n?|\n).*/g);
                return (
                  Ce
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  ce
                );
              }, "input"),
              unput: a(function (ce) {
                var Ce = ce.length,
                  Ne = ce.split(/(?:\r\n?|\n)/g);
                ((this._input = ce + this._input),
                  (this.yytext = this.yytext.substr(
                    0,
                    this.yytext.length - Ce,
                  )),
                  (this.offset -= Ce));
                var Wt = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  Ne.length - 1 && (this.yylineno -= Ne.length - 1));
                var Fr = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: Ne
                      ? (Ne.length === Wt.length
                          ? this.yylloc.first_column
                          : 0) +
                        Wt[Wt.length - Ne.length].length -
                        Ne[0].length
                      : this.yylloc.first_column - Ce,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [Fr[0], Fr[0] + this.yyleng - Ce]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (ce) {
                this.unput(this.match.slice(ce));
              }, "less"),
              pastInput: a(function () {
                var ce = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (ce.length > 20 ? "..." : "") +
                  ce.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var ce = this.match;
                return (
                  ce.length < 20 &&
                    (ce += this._input.substr(0, 20 - ce.length)),
                  (ce.substr(0, 20) + (ce.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var ce = this.pastInput(),
                  Ce = new Array(ce.length + 1).join("-");
                return (
                  ce +
                  this.upcomingInput() +
                  `
` +
                  Ce +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (ce, Ce) {
                var Ne, Wt, Fr;
                if (
                  (this.options.backtrack_lexer &&
                    ((Fr = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (Fr.yylloc.range = this.yylloc.range.slice(0))),
                  (Wt = ce[0].match(/(?:\r\n?|\n).*/g)),
                  Wt && (this.yylineno += Wt.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: Wt
                      ? Wt[Wt.length - 1].length -
                        Wt[Wt.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + ce[0].length,
                  }),
                  (this.yytext += ce[0]),
                  (this.match += ce[0]),
                  (this.matches = ce),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(ce[0].length)),
                  (this.matched += ce[0]),
                  (Ne = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    Ce,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  Ne)
                )
                  return Ne;
                if (this._backtrack) {
                  for (var Y in Fr) this[Y] = Fr[Y];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var ce, Ce, Ne, Wt;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var Fr = this._currentRules(), Y = 0; Y < Fr.length; Y++)
                  if (
                    ((Ne = this._input.match(this.rules[Fr[Y]])),
                    Ne && (!Ce || Ne[0].length > Ce[0].length))
                  ) {
                    if (((Ce = Ne), (Wt = Y), this.options.backtrack_lexer)) {
                      if (((ce = this.test_match(Ne, Fr[Y])), ce !== !1))
                        return ce;
                      if (this._backtrack) {
                        Ce = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return Ce
                  ? ((ce = this.test_match(Ce, Fr[Wt])), ce !== !1 ? ce : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var Ce = this.next();
                return Ce || this.lex();
              }, "lex"),
              begin: a(function (Ce) {
                this.conditionStack.push(Ce);
              }, "begin"),
              popState: a(function () {
                var Ce = this.conditionStack.length - 1;
                return Ce > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (Ce) {
                return (
                  (Ce = this.conditionStack.length - 1 - Math.abs(Ce || 0)),
                  Ce >= 0 ? this.conditionStack[Ce] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (Ce) {
                this.begin(Ce);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: {},
              performAction: a(function (Ce, Ne, Wt, Fr) {
                var Y = Fr;
                switch (Wt) {
                  case 0:
                    return (this.begin("acc_title"), 34);
                    break;
                  case 1:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 2:
                    return (this.begin("acc_descr"), 36);
                    break;
                  case 3:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 4:
                    this.begin("acc_descr_multiline");
                    break;
                  case 5:
                    this.popState();
                    break;
                  case 6:
                    return "acc_descr_multiline_value";
                  case 7:
                    return (this.pushState("shapeData"), (Ne.yytext = ""), 40);
                    break;
                  case 8:
                    return (this.pushState("shapeDataStr"), 40);
                    break;
                  case 9:
                    return (this.popState(), 40);
                    break;
                  case 10:
                    let fu = /\n\s*/g;
                    return ((Ne.yytext = Ne.yytext.replace(fu, "<br/>")), 40);
                    break;
                  case 11:
                    return 40;
                  case 12:
                    this.popState();
                    break;
                  case 13:
                    this.begin("callbackname");
                    break;
                  case 14:
                    this.popState();
                    break;
                  case 15:
                    (this.popState(), this.begin("callbackargs"));
                    break;
                  case 16:
                    return 95;
                  case 17:
                    this.popState();
                    break;
                  case 18:
                    return 96;
                  case 19:
                    return "MD_STR";
                  case 20:
                    this.popState();
                    break;
                  case 21:
                    this.begin("md_string");
                    break;
                  case 22:
                    return "STR";
                  case 23:
                    this.popState();
                    break;
                  case 24:
                    this.pushState("string");
                    break;
                  case 25:
                    return 84;
                  case 26:
                    return 102;
                  case 27:
                    return 85;
                  case 28:
                    return 104;
                  case 29:
                    return 86;
                  case 30:
                    return 87;
                  case 31:
                    return 97;
                  case 32:
                    this.begin("click");
                    break;
                  case 33:
                    this.popState();
                    break;
                  case 34:
                    return 88;
                  case 35:
                    return (Ce.lex.firstGraph() && this.begin("dir"), 12);
                    break;
                  case 36:
                    return (Ce.lex.firstGraph() && this.begin("dir"), 12);
                    break;
                  case 37:
                    return (Ce.lex.firstGraph() && this.begin("dir"), 12);
                    break;
                  case 38:
                    return 27;
                  case 39:
                    return 32;
                  case 40:
                    return 98;
                  case 41:
                    return 98;
                  case 42:
                    return 98;
                  case 43:
                    return 98;
                  case 44:
                    return (this.popState(), 13);
                    break;
                  case 45:
                    return (this.popState(), 14);
                    break;
                  case 46:
                    return (this.popState(), 14);
                    break;
                  case 47:
                    return (this.popState(), 14);
                    break;
                  case 48:
                    return (this.popState(), 14);
                    break;
                  case 49:
                    return (this.popState(), 14);
                    break;
                  case 50:
                    return (this.popState(), 14);
                    break;
                  case 51:
                    return (this.popState(), 14);
                    break;
                  case 52:
                    return (this.popState(), 14);
                    break;
                  case 53:
                    return (this.popState(), 14);
                    break;
                  case 54:
                    return (this.popState(), 14);
                    break;
                  case 55:
                    return 121;
                  case 56:
                    return 122;
                  case 57:
                    return 123;
                  case 58:
                    return 124;
                  case 59:
                    return 78;
                  case 60:
                    return 105;
                  case 61:
                    return 111;
                  case 62:
                    return 46;
                  case 63:
                    return 60;
                  case 64:
                    return 44;
                  case 65:
                    return 8;
                  case 66:
                    return 106;
                  case 67:
                    return 115;
                  case 68:
                    return (this.popState(), 77);
                    break;
                  case 69:
                    return (this.pushState("edgeText"), 75);
                    break;
                  case 70:
                    return 119;
                  case 71:
                    return (this.popState(), 77);
                    break;
                  case 72:
                    return (this.pushState("thickEdgeText"), 75);
                    break;
                  case 73:
                    return 119;
                  case 74:
                    return (this.popState(), 77);
                    break;
                  case 75:
                    return (this.pushState("dottedEdgeText"), 75);
                    break;
                  case 76:
                    return 119;
                  case 77:
                    return 77;
                  case 78:
                    return (this.popState(), 53);
                    break;
                  case 79:
                    return "TEXT";
                  case 80:
                    return (this.pushState("ellipseText"), 52);
                    break;
                  case 81:
                    return (this.popState(), 55);
                    break;
                  case 82:
                    return (this.pushState("text"), 54);
                    break;
                  case 83:
                    return (this.popState(), 57);
                    break;
                  case 84:
                    return (this.pushState("text"), 56);
                    break;
                  case 85:
                    return 58;
                  case 86:
                    return (this.pushState("text"), 67);
                    break;
                  case 87:
                    return (this.popState(), 64);
                    break;
                  case 88:
                    return (this.pushState("text"), 63);
                    break;
                  case 89:
                    return (this.popState(), 49);
                    break;
                  case 90:
                    return (this.pushState("text"), 48);
                    break;
                  case 91:
                    return (this.popState(), 69);
                    break;
                  case 92:
                    return (this.popState(), 71);
                    break;
                  case 93:
                    return 117;
                  case 94:
                    return (this.pushState("trapText"), 68);
                    break;
                  case 95:
                    return (this.pushState("trapText"), 70);
                    break;
                  case 96:
                    return 118;
                  case 97:
                    return 67;
                  case 98:
                    return 90;
                  case 99:
                    return "SEP";
                  case 100:
                    return 89;
                  case 101:
                    return 115;
                  case 102:
                    return 111;
                  case 103:
                    return 44;
                  case 104:
                    return 109;
                  case 105:
                    return 114;
                  case 106:
                    return 116;
                  case 107:
                    return (this.popState(), 62);
                    break;
                  case 108:
                    return (this.pushState("text"), 62);
                    break;
                  case 109:
                    return (this.popState(), 51);
                    break;
                  case 110:
                    return (this.pushState("text"), 50);
                    break;
                  case 111:
                    return (this.popState(), 31);
                    break;
                  case 112:
                    return (this.pushState("text"), 29);
                    break;
                  case 113:
                    return (this.popState(), 66);
                    break;
                  case 114:
                    return (this.pushState("text"), 65);
                    break;
                  case 115:
                    return "TEXT";
                  case 116:
                    return "QUOTE";
                  case 117:
                    return 9;
                  case 118:
                    return 10;
                  case 119:
                    return 11;
                }
              }, "anonymous"),
              rules: [
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:@\{)/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^\"]+)/,
                /^(?:[^}^"]+)/,
                /^(?:\})/,
                /^(?:call[\s]+)/,
                /^(?:\([\s]*\))/,
                /^(?:\()/,
                /^(?:[^(]*)/,
                /^(?:\))/,
                /^(?:[^)]*)/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["][`])/,
                /^(?:[^"]+)/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:style\b)/,
                /^(?:default\b)/,
                /^(?:linkStyle\b)/,
                /^(?:interpolate\b)/,
                /^(?:classDef\b)/,
                /^(?:class\b)/,
                /^(?:href[\s])/,
                /^(?:click[\s]+)/,
                /^(?:[\s\n])/,
                /^(?:[^\s\n]*)/,
                /^(?:flowchart-elk\b)/,
                /^(?:graph\b)/,
                /^(?:flowchart\b)/,
                /^(?:subgraph\b)/,
                /^(?:end\b\s*)/,
                /^(?:_self\b)/,
                /^(?:_blank\b)/,
                /^(?:_parent\b)/,
                /^(?:_top\b)/,
                /^(?:(\r?\n)*\s*\n)/,
                /^(?:\s*LR\b)/,
                /^(?:\s*RL\b)/,
                /^(?:\s*TB\b)/,
                /^(?:\s*BT\b)/,
                /^(?:\s*TD\b)/,
                /^(?:\s*BR\b)/,
                /^(?:\s*<)/,
                /^(?:\s*>)/,
                /^(?:\s*\^)/,
                /^(?:\s*v\b)/,
                /^(?:.*direction\s+TB[^\n]*)/,
                /^(?:.*direction\s+BT[^\n]*)/,
                /^(?:.*direction\s+RL[^\n]*)/,
                /^(?:.*direction\s+LR[^\n]*)/,
                /^(?:[^\s\"]+@(?=[^\{\"]))/,
                /^(?:[0-9]+)/,
                /^(?:#)/,
                /^(?::::)/,
                /^(?::)/,
                /^(?:&)/,
                /^(?:;)/,
                /^(?:,)/,
                /^(?:\*)/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?--\s*)/,
                /^(?:[^-]|-(?!-)+)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?==\s*)/,
                /^(?:[^=]|=(?!))/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?:\s*[xo<]?-\.\s*)/,
                /^(?:[^\.]|\.(?!))/,
                /^(?:\s*~~[\~]+\s*)/,
                /^(?:[-/\)][\)])/,
                /^(?:[^\(\)\[\]\{\}]|!\)+)/,
                /^(?:\(-)/,
                /^(?:\]\))/,
                /^(?:\(\[)/,
                /^(?:\]\])/,
                /^(?:\[\[)/,
                /^(?:\[\|)/,
                /^(?:>)/,
                /^(?:\)\])/,
                /^(?:\[\()/,
                /^(?:\)\)\))/,
                /^(?:\(\(\()/,
                /^(?:[\\(?=\])][\]])/,
                /^(?:\/(?=\])\])/,
                /^(?:\/(?!\])|\\(?!\])|[^\\\[\]\(\)\{\}\/]+)/,
                /^(?:\[\/)/,
                /^(?:\[\\)/,
                /^(?:<)/,
                /^(?:>)/,
                /^(?:\^)/,
                /^(?:\\\|)/,
                /^(?:v\b)/,
                /^(?:\*)/,
                /^(?:#)/,
                /^(?:&)/,
                /^(?:([A-Za-z0-9!"\#$%&'*+\.`?\\_\/]|-(?=[^\>\-\.])|(?!))+)/,
                /^(?:-)/,
                /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,
                /^(?:\|)/,
                /^(?:\|)/,
                /^(?:\))/,
                /^(?:\()/,
                /^(?:\])/,
                /^(?:\[)/,
                /^(?:(\}))/,
                /^(?:\{)/,
                /^(?:[^\[\]\(\)\{\}\|\"]+)/,
                /^(?:")/,
                /^(?:(\r?\n)+)/,
                /^(?:\s)/,
                /^(?:$)/,
              ],
              conditions: {
                shapeDataEndBracket: {
                  rules: [
                    21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114,
                  ],
                  inclusive: !1,
                },
                shapeDataStr: {
                  rules: [
                    9, 10, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                shapeData: {
                  rules: [
                    8, 11, 12, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                callbackargs: {
                  rules: [
                    17, 18, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                callbackname: {
                  rules: [
                    14, 15, 16, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108,
                    110, 112, 114,
                  ],
                  inclusive: !1,
                },
                href: {
                  rules: [
                    21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114,
                  ],
                  inclusive: !1,
                },
                click: {
                  rules: [
                    21, 24, 33, 34, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                dottedEdgeText: {
                  rules: [
                    21, 24, 74, 76, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                thickEdgeText: {
                  rules: [
                    21, 24, 71, 73, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                edgeText: {
                  rules: [
                    21, 24, 68, 70, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                trapText: {
                  rules: [
                    21, 24, 77, 80, 82, 84, 88, 90, 91, 92, 93, 94, 95, 108,
                    110, 112, 114,
                  ],
                  inclusive: !1,
                },
                ellipseText: {
                  rules: [
                    21, 24, 77, 78, 79, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                text: {
                  rules: [
                    21, 24, 77, 80, 81, 82, 83, 84, 87, 88, 89, 90, 94, 95, 107,
                    108, 109, 110, 111, 112, 113, 114, 115,
                  ],
                  inclusive: !1,
                },
                vertex: {
                  rules: [
                    21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112, 114,
                  ],
                  inclusive: !1,
                },
                dir: {
                  rules: [
                    21, 24, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 77, 80,
                    82, 84, 88, 90, 94, 95, 108, 110, 112, 114,
                  ],
                  inclusive: !1,
                },
                acc_descr_multiline: {
                  rules: [
                    5, 6, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112,
                    114,
                  ],
                  inclusive: !1,
                },
                acc_descr: {
                  rules: [
                    3, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112,
                    114,
                  ],
                  inclusive: !1,
                },
                acc_title: {
                  rules: [
                    1, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110, 112,
                    114,
                  ],
                  inclusive: !1,
                },
                md_string: {
                  rules: [
                    19, 20, 21, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                string: {
                  rules: [
                    21, 22, 23, 24, 77, 80, 82, 84, 88, 90, 94, 95, 108, 110,
                    112, 114,
                  ],
                  inclusive: !1,
                },
                INITIAL: {
                  rules: [
                    0, 2, 4, 7, 13, 21, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35,
                    36, 37, 38, 39, 40, 41, 42, 43, 55, 56, 57, 58, 59, 60, 61,
                    62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 74, 75, 77, 80, 82,
                    84, 85, 86, 88, 90, 94, 95, 96, 97, 98, 99, 100, 101, 102,
                    103, 104, 105, 106, 108, 110, 112, 114, 116, 117, 118, 119,
                  ],
                  inclusive: !0,
                },
              },
            };
            return ka;
          })();
        Ji.lexer = hu;
        function Nn() {
          this.yy = {};
        }
        return (
          a(Nn, "Parser"),
          (Nn.prototype = Ji),
          (Ji.Parser = Nn),
          new Nn()
        );
      })();
      t6.parser = t6;
      e6 = t6;
    });
  var iK,
    sK,
    aK = x(() => {
      "use strict";
      nK();
      iK = Object.assign({}, e6);
      iK.parse = (e) => {
        let t = e.replace(
          /}\s*\n/g,
          `}
`,
        );
        return e6.parse(t);
      };
      sK = iK;
    });
  var Io,
    Md = x(() => {
      "use strict";
      Io = a(
        () => `
  /* Font Awesome icon styling - consolidated */
  .label-icon {
    display: inline-block;
    height: 1em;
    overflow: visible;
    vertical-align: -0.125em;
  }
  
  .node .label-icon path {
    fill: currentColor;
    stroke: revert;
    stroke-width: revert;
  }
`,
        "getIconStyles",
      );
    });
  var OEt,
    PEt,
    oK,
    lK = x(() => {
      "use strict";
      Us();
      Md();
      ((OEt = a((e, t) => {
        let r = gu,
          n = r(e, "r"),
          i = r(e, "g"),
          s = r(e, "b");
        return Di(n, i, s, t);
      }, "fade")),
        (PEt = a(
          (e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span {
    color: ${e.titleColor};
  }
  .cluster-label span p {
    background-color: transparent;
  }

  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .rough-node .label text , .node .label text, .image-shape .label, .icon-shape .label {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .katex path {
    fill: #000;
    stroke: #000;
    stroke-width: 1px;
  }

  .rough-node .label,.node .label, .image-shape .label, .icon-shape .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }


  .root .anchor path {
    fill: ${e.lineColor} !important;
    stroke-width: 0;
    stroke: ${e.lineColor};
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${OEt(e.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .cluster rect {
    fill: ${e.clusterBkg};
    stroke: ${e.clusterBorder};
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }

  rect.text {
    fill: none;
    stroke-width: 0;
  }

  .icon-shape, .image-shape {
    background-color: ${e.edgeLabelBackground};
    p {
      background-color: ${e.edgeLabelBackground};
      padding: 2px;
    }
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }
  ${Io()}
`,
          "getStyles",
        )),
        (oK = PEt));
    });
  var r6 = {};
  Oe(r6, { diagram: () => BEt });
  var BEt,
    n6 = x(() => {
      "use strict";
      pe();
      oU();
      rK();
      aK();
      lK();
      BEt = {
        parser: sK,
        get db() {
          return new Hb();
        },
        renderer: eK,
        styles: oK,
        init: a((e) => {
          (e.flowchart || (e.flowchart = {}),
            e.layout && og({ layout: e.layout }),
            (e.flowchart.arrowMarkerAbsolute = e.arrowMarkerAbsolute),
            og({ flowchart: { arrowMarkerAbsolute: e.arrowMarkerAbsolute } }));
        }, "init"),
      };
    });
  var i6,
    dK,
    pK = x(() => {
      "use strict";
      i6 = (function () {
        var e = a(function (Q, et, X, st) {
            for (X = X || {}, st = Q.length; st--; X[Q[st]] = et);
            return X;
          }, "o"),
          t = [6, 8, 10, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 43, 44, 50],
          r = [1, 10],
          n = [1, 11],
          i = [1, 12],
          s = [1, 13],
          o = [1, 20],
          l = [1, 21],
          u = [1, 22],
          h = [1, 23],
          f = [1, 24],
          d = [1, 19],
          p = [1, 25],
          m = [1, 26],
          g = [1, 18],
          y = [1, 33],
          b = [1, 34],
          k = [1, 35],
          T = [1, 36],
          C = [1, 37],
          L = [
            6, 8, 10, 13, 15, 17, 20, 21, 22, 24, 26, 28, 33, 34, 35, 36, 37,
            40, 43, 44, 50, 63, 64, 65, 66, 67,
          ],
          w = [1, 42],
          D = [1, 43],
          G = [1, 52],
          E = [40, 50, 68, 69],
          R = [1, 63],
          F = [1, 61],
          S = [1, 58],
          O = [1, 62],
          v = [1, 64],
          _ = [
            6, 8, 10, 13, 17, 22, 24, 26, 28, 33, 34, 35, 36, 37, 40, 41, 42,
            43, 44, 48, 49, 50, 63, 64, 65, 66, 67,
          ],
          A = [63, 64, 65, 66, 67],
          N = [1, 81],
          B = [1, 80],
          M = [1, 78],
          I = [1, 79],
          V = [6, 10, 42, 47],
          $ = [6, 10, 13, 41, 42, 47, 48, 49],
          q = [1, 89],
          tt = [1, 88],
          ht = [1, 87],
          H = [19, 56],
          kt = [1, 98],
          ft = [1, 97],
          yt = [19, 56, 58, 60],
          ot = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              ER_DIAGRAM: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NEWLINE: 10,
              entityName: 11,
              relSpec: 12,
              COLON: 13,
              role: 14,
              STYLE_SEPARATOR: 15,
              idList: 16,
              BLOCK_START: 17,
              attributes: 18,
              BLOCK_STOP: 19,
              SQS: 20,
              SQE: 21,
              title: 22,
              title_value: 23,
              acc_title: 24,
              acc_title_value: 25,
              acc_descr: 26,
              acc_descr_value: 27,
              acc_descr_multiline_value: 28,
              direction: 29,
              classDefStatement: 30,
              classStatement: 31,
              styleStatement: 32,
              direction_tb: 33,
              direction_bt: 34,
              direction_rl: 35,
              direction_lr: 36,
              CLASSDEF: 37,
              stylesOpt: 38,
              separator: 39,
              UNICODE_TEXT: 40,
              STYLE_TEXT: 41,
              COMMA: 42,
              CLASS: 43,
              STYLE: 44,
              style: 45,
              styleComponent: 46,
              SEMI: 47,
              NUM: 48,
              BRKT: 49,
              ENTITY_NAME: 50,
              attribute: 51,
              attributeType: 52,
              attributeName: 53,
              attributeKeyTypeList: 54,
              attributeComment: 55,
              ATTRIBUTE_WORD: 56,
              attributeKeyType: 57,
              ",": 58,
              ATTRIBUTE_KEY: 59,
              COMMENT: 60,
              cardinality: 61,
              relType: 62,
              ZERO_OR_ONE: 63,
              ZERO_OR_MORE: 64,
              ONE_OR_MORE: 65,
              ONLY_ONE: 66,
              MD_PARENT: 67,
              NON_IDENTIFYING: 68,
              IDENTIFYING: 69,
              WORD: 70,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "ER_DIAGRAM",
              6: "EOF",
              8: "SPACE",
              10: "NEWLINE",
              13: "COLON",
              15: "STYLE_SEPARATOR",
              17: "BLOCK_START",
              19: "BLOCK_STOP",
              20: "SQS",
              21: "SQE",
              22: "title",
              23: "title_value",
              24: "acc_title",
              25: "acc_title_value",
              26: "acc_descr",
              27: "acc_descr_value",
              28: "acc_descr_multiline_value",
              33: "direction_tb",
              34: "direction_bt",
              35: "direction_rl",
              36: "direction_lr",
              37: "CLASSDEF",
              40: "UNICODE_TEXT",
              41: "STYLE_TEXT",
              42: "COMMA",
              43: "CLASS",
              44: "STYLE",
              47: "SEMI",
              48: "NUM",
              49: "BRKT",
              50: "ENTITY_NAME",
              56: "ATTRIBUTE_WORD",
              58: ",",
              59: "ATTRIBUTE_KEY",
              60: "COMMENT",
              63: "ZERO_OR_ONE",
              64: "ZERO_OR_MORE",
              65: "ONE_OR_MORE",
              66: "ONLY_ONE",
              67: "MD_PARENT",
              68: "NON_IDENTIFYING",
              69: "IDENTIFYING",
              70: "WORD",
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [9, 5],
              [9, 9],
              [9, 7],
              [9, 7],
              [9, 4],
              [9, 6],
              [9, 3],
              [9, 5],
              [9, 1],
              [9, 3],
              [9, 7],
              [9, 9],
              [9, 6],
              [9, 8],
              [9, 4],
              [9, 6],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [29, 1],
              [29, 1],
              [29, 1],
              [29, 1],
              [30, 4],
              [16, 1],
              [16, 1],
              [16, 3],
              [16, 3],
              [31, 3],
              [32, 4],
              [38, 1],
              [38, 3],
              [45, 1],
              [45, 2],
              [39, 1],
              [39, 1],
              [39, 1],
              [46, 1],
              [46, 1],
              [46, 1],
              [46, 1],
              [11, 1],
              [11, 1],
              [18, 1],
              [18, 2],
              [51, 2],
              [51, 3],
              [51, 3],
              [51, 4],
              [52, 1],
              [53, 1],
              [54, 1],
              [54, 3],
              [57, 1],
              [55, 1],
              [12, 3],
              [61, 1],
              [61, 1],
              [61, 1],
              [61, 1],
              [61, 1],
              [62, 1],
              [62, 1],
              [14, 1],
              [14, 1],
              [14, 1],
            ],
            performAction: a(function (et, X, st, U, gt, z, ge) {
              var lt = z.length - 1;
              switch (gt) {
                case 1:
                  break;
                case 2:
                  this.$ = [];
                  break;
                case 3:
                  (z[lt - 1].push(z[lt]), (this.$ = z[lt - 1]));
                  break;
                case 4:
                case 5:
                  this.$ = z[lt];
                  break;
                case 6:
                case 7:
                  this.$ = [];
                  break;
                case 8:
                  (U.addEntity(z[lt - 4]),
                    U.addEntity(z[lt - 2]),
                    U.addRelationship(z[lt - 4], z[lt], z[lt - 2], z[lt - 3]));
                  break;
                case 9:
                  (U.addEntity(z[lt - 8]),
                    U.addEntity(z[lt - 4]),
                    U.addRelationship(z[lt - 8], z[lt], z[lt - 4], z[lt - 5]),
                    U.setClass([z[lt - 8]], z[lt - 6]),
                    U.setClass([z[lt - 4]], z[lt - 2]));
                  break;
                case 10:
                  (U.addEntity(z[lt - 6]),
                    U.addEntity(z[lt - 2]),
                    U.addRelationship(z[lt - 6], z[lt], z[lt - 2], z[lt - 3]),
                    U.setClass([z[lt - 6]], z[lt - 4]));
                  break;
                case 11:
                  (U.addEntity(z[lt - 6]),
                    U.addEntity(z[lt - 4]),
                    U.addRelationship(z[lt - 6], z[lt], z[lt - 4], z[lt - 5]),
                    U.setClass([z[lt - 4]], z[lt - 2]));
                  break;
                case 12:
                  (U.addEntity(z[lt - 3]),
                    U.addAttributes(z[lt - 3], z[lt - 1]));
                  break;
                case 13:
                  (U.addEntity(z[lt - 5]),
                    U.addAttributes(z[lt - 5], z[lt - 1]),
                    U.setClass([z[lt - 5]], z[lt - 3]));
                  break;
                case 14:
                  U.addEntity(z[lt - 2]);
                  break;
                case 15:
                  (U.addEntity(z[lt - 4]), U.setClass([z[lt - 4]], z[lt - 2]));
                  break;
                case 16:
                  U.addEntity(z[lt]);
                  break;
                case 17:
                  (U.addEntity(z[lt - 2]), U.setClass([z[lt - 2]], z[lt]));
                  break;
                case 18:
                  (U.addEntity(z[lt - 6], z[lt - 4]),
                    U.addAttributes(z[lt - 6], z[lt - 1]));
                  break;
                case 19:
                  (U.addEntity(z[lt - 8], z[lt - 6]),
                    U.addAttributes(z[lt - 8], z[lt - 1]),
                    U.setClass([z[lt - 8]], z[lt - 3]));
                  break;
                case 20:
                  U.addEntity(z[lt - 5], z[lt - 3]);
                  break;
                case 21:
                  (U.addEntity(z[lt - 7], z[lt - 5]),
                    U.setClass([z[lt - 7]], z[lt - 2]));
                  break;
                case 22:
                  U.addEntity(z[lt - 3], z[lt - 1]);
                  break;
                case 23:
                  (U.addEntity(z[lt - 5], z[lt - 3]),
                    U.setClass([z[lt - 5]], z[lt]));
                  break;
                case 24:
                case 25:
                  ((this.$ = z[lt].trim()), U.setAccTitle(this.$));
                  break;
                case 26:
                case 27:
                  ((this.$ = z[lt].trim()), U.setAccDescription(this.$));
                  break;
                case 32:
                  U.setDirection("TB");
                  break;
                case 33:
                  U.setDirection("BT");
                  break;
                case 34:
                  U.setDirection("RL");
                  break;
                case 35:
                  U.setDirection("LR");
                  break;
                case 36:
                  ((this.$ = z[lt - 3]), U.addClass(z[lt - 2], z[lt - 1]));
                  break;
                case 37:
                case 38:
                case 56:
                case 64:
                  this.$ = [z[lt]];
                  break;
                case 39:
                case 40:
                  this.$ = z[lt - 2].concat([z[lt]]);
                  break;
                case 41:
                  ((this.$ = z[lt - 2]), U.setClass(z[lt - 1], z[lt]));
                  break;
                case 42:
                  ((this.$ = z[lt - 3]), U.addCssStyles(z[lt - 2], z[lt - 1]));
                  break;
                case 43:
                  this.$ = [z[lt]];
                  break;
                case 44:
                  (z[lt - 2].push(z[lt]), (this.$ = z[lt - 2]));
                  break;
                case 46:
                  this.$ = z[lt - 1] + z[lt];
                  break;
                case 54:
                case 76:
                case 77:
                  this.$ = z[lt].replace(/"/g, "");
                  break;
                case 55:
                case 78:
                  this.$ = z[lt];
                  break;
                case 57:
                  (z[lt].push(z[lt - 1]), (this.$ = z[lt]));
                  break;
                case 58:
                  this.$ = { type: z[lt - 1], name: z[lt] };
                  break;
                case 59:
                  this.$ = { type: z[lt - 2], name: z[lt - 1], keys: z[lt] };
                  break;
                case 60:
                  this.$ = { type: z[lt - 2], name: z[lt - 1], comment: z[lt] };
                  break;
                case 61:
                  this.$ = {
                    type: z[lt - 3],
                    name: z[lt - 2],
                    keys: z[lt - 1],
                    comment: z[lt],
                  };
                  break;
                case 62:
                case 63:
                case 66:
                  this.$ = z[lt];
                  break;
                case 65:
                  (z[lt - 2].push(z[lt]), (this.$ = z[lt - 2]));
                  break;
                case 67:
                  this.$ = z[lt].replace(/"/g, "");
                  break;
                case 68:
                  this.$ = {
                    cardA: z[lt],
                    relType: z[lt - 1],
                    cardB: z[lt - 2],
                  };
                  break;
                case 69:
                  this.$ = U.Cardinality.ZERO_OR_ONE;
                  break;
                case 70:
                  this.$ = U.Cardinality.ZERO_OR_MORE;
                  break;
                case 71:
                  this.$ = U.Cardinality.ONE_OR_MORE;
                  break;
                case 72:
                  this.$ = U.Cardinality.ONLY_ONE;
                  break;
                case 73:
                  this.$ = U.Cardinality.MD_PARENT;
                  break;
                case 74:
                  this.$ = U.Identification.NON_IDENTIFYING;
                  break;
                case 75:
                  this.$ = U.Identification.IDENTIFYING;
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              {
                6: [1, 4],
                7: 5,
                8: [1, 6],
                9: 7,
                10: [1, 8],
                11: 9,
                22: r,
                24: n,
                26: i,
                28: s,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: o,
                34: l,
                35: u,
                36: h,
                37: f,
                40: d,
                43: p,
                44: m,
                50: g,
              },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              {
                9: 27,
                11: 9,
                22: r,
                24: n,
                26: i,
                28: s,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: o,
                34: l,
                35: u,
                36: h,
                37: f,
                40: d,
                43: p,
                44: m,
                50: g,
              },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 16], {
                12: 28,
                61: 32,
                15: [1, 29],
                17: [1, 30],
                20: [1, 31],
                63: y,
                64: b,
                65: k,
                66: T,
                67: C,
              }),
              { 23: [1, 38] },
              { 25: [1, 39] },
              { 27: [1, 40] },
              e(t, [2, 27]),
              e(t, [2, 28]),
              e(t, [2, 29]),
              e(t, [2, 30]),
              e(t, [2, 31]),
              e(L, [2, 54]),
              e(L, [2, 55]),
              e(t, [2, 32]),
              e(t, [2, 33]),
              e(t, [2, 34]),
              e(t, [2, 35]),
              { 16: 41, 40: w, 41: D },
              { 16: 44, 40: w, 41: D },
              { 16: 45, 40: w, 41: D },
              e(t, [2, 4]),
              { 11: 46, 40: d, 50: g },
              { 16: 47, 40: w, 41: D },
              { 18: 48, 19: [1, 49], 51: 50, 52: 51, 56: G },
              { 11: 53, 40: d, 50: g },
              { 62: 54, 68: [1, 55], 69: [1, 56] },
              e(E, [2, 69]),
              e(E, [2, 70]),
              e(E, [2, 71]),
              e(E, [2, 72]),
              e(E, [2, 73]),
              e(t, [2, 24]),
              e(t, [2, 25]),
              e(t, [2, 26]),
              { 13: R, 38: 57, 41: F, 42: S, 45: 59, 46: 60, 48: O, 49: v },
              e(_, [2, 37]),
              e(_, [2, 38]),
              { 16: 65, 40: w, 41: D, 42: S },
              { 13: R, 38: 66, 41: F, 42: S, 45: 59, 46: 60, 48: O, 49: v },
              { 13: [1, 67], 15: [1, 68] },
              e(t, [2, 17], {
                61: 32,
                12: 69,
                17: [1, 70],
                42: S,
                63: y,
                64: b,
                65: k,
                66: T,
                67: C,
              }),
              { 19: [1, 71] },
              e(t, [2, 14]),
              { 18: 72, 19: [2, 56], 51: 50, 52: 51, 56: G },
              { 53: 73, 56: [1, 74] },
              { 56: [2, 62] },
              { 21: [1, 75] },
              { 61: 76, 63: y, 64: b, 65: k, 66: T, 67: C },
              e(A, [2, 74]),
              e(A, [2, 75]),
              { 6: N, 10: B, 39: 77, 42: M, 47: I },
              { 40: [1, 82], 41: [1, 83] },
              e(V, [2, 43], { 46: 84, 13: R, 41: F, 48: O, 49: v }),
              e($, [2, 45]),
              e($, [2, 50]),
              e($, [2, 51]),
              e($, [2, 52]),
              e($, [2, 53]),
              e(t, [2, 41], { 42: S }),
              { 6: N, 10: B, 39: 85, 42: M, 47: I },
              { 14: 86, 40: q, 50: tt, 70: ht },
              { 16: 90, 40: w, 41: D },
              { 11: 91, 40: d, 50: g },
              { 18: 92, 19: [1, 93], 51: 50, 52: 51, 56: G },
              e(t, [2, 12]),
              { 19: [2, 57] },
              e(H, [2, 58], { 54: 94, 55: 95, 57: 96, 59: kt, 60: ft }),
              e([19, 56, 59, 60], [2, 63]),
              e(t, [2, 22], { 15: [1, 100], 17: [1, 99] }),
              e([40, 50], [2, 68]),
              e(t, [2, 36]),
              { 13: R, 41: F, 45: 101, 46: 60, 48: O, 49: v },
              e(t, [2, 47]),
              e(t, [2, 48]),
              e(t, [2, 49]),
              e(_, [2, 39]),
              e(_, [2, 40]),
              e($, [2, 46]),
              e(t, [2, 42]),
              e(t, [2, 8]),
              e(t, [2, 76]),
              e(t, [2, 77]),
              e(t, [2, 78]),
              { 13: [1, 102], 42: S },
              { 13: [1, 104], 15: [1, 103] },
              { 19: [1, 105] },
              e(t, [2, 15]),
              e(H, [2, 59], { 55: 106, 58: [1, 107], 60: ft }),
              e(H, [2, 60]),
              e(yt, [2, 64]),
              e(H, [2, 67]),
              e(yt, [2, 66]),
              { 18: 108, 19: [1, 109], 51: 50, 52: 51, 56: G },
              { 16: 110, 40: w, 41: D },
              e(V, [2, 44], { 46: 84, 13: R, 41: F, 48: O, 49: v }),
              { 14: 111, 40: q, 50: tt, 70: ht },
              { 16: 112, 40: w, 41: D },
              { 14: 113, 40: q, 50: tt, 70: ht },
              e(t, [2, 13]),
              e(H, [2, 61]),
              { 57: 114, 59: kt },
              { 19: [1, 115] },
              e(t, [2, 20]),
              e(t, [2, 23], { 17: [1, 116], 42: S }),
              e(t, [2, 11]),
              { 13: [1, 117], 42: S },
              e(t, [2, 10]),
              e(yt, [2, 65]),
              e(t, [2, 18]),
              { 18: 118, 19: [1, 119], 51: 50, 52: 51, 56: G },
              { 14: 120, 40: q, 50: tt, 70: ht },
              { 19: [1, 121] },
              e(t, [2, 21]),
              e(t, [2, 9]),
              e(t, [2, 19]),
            ],
            defaultActions: { 52: [2, 62], 72: [2, 57] },
            parseError: a(function (et, X) {
              if (X.recoverable) this.trace(et);
              else {
                var st = new Error(et);
                throw ((st.hash = X), st);
              }
            }, "parseError"),
            parse: a(function (et) {
              var X = this,
                st = [0],
                U = [],
                gt = [null],
                z = [],
                ge = this.table,
                lt = "",
                jt = 0,
                Me = 0,
                se = 0,
                Nt = 2,
                At = 1,
                bt = z.slice.call(arguments, 1),
                ct = Object.create(this.lexer),
                Lt = { yy: {} };
              for (var Z in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, Z) &&
                  (Lt.yy[Z] = this.yy[Z]);
              (ct.setInput(et, Lt.yy),
                (Lt.yy.lexer = ct),
                (Lt.yy.parser = this),
                typeof ct.yylloc > "u" && (ct.yylloc = {}));
              var Mt = ct.yylloc;
              z.push(Mt);
              var W = ct.options && ct.options.ranges;
              typeof Lt.yy.parseError == "function"
                ? (this.parseError = Lt.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function Gt(Je) {
                ((st.length = st.length - 2 * Je),
                  (gt.length = gt.length - Je),
                  (z.length = z.length - Je));
              }
              a(Gt, "popStack");
              function j() {
                var Je;
                return (
                  (Je = U.pop() || ct.lex() || At),
                  typeof Je != "number" &&
                    (Je instanceof Array && ((U = Je), (Je = U.pop())),
                    (Je = X.symbols_[Je] || Je)),
                  Je
                );
              }
              a(j, "lex");
              for (var Et, mt, Xt, Ft, _t, Qe, It = {}, xr, Ze, mn, Ae; ; ) {
                if (
                  ((Xt = st[st.length - 1]),
                  this.defaultActions[Xt]
                    ? (Ft = this.defaultActions[Xt])
                    : ((Et === null || typeof Et > "u") && (Et = j()),
                      (Ft = ge[Xt] && ge[Xt][Et])),
                  typeof Ft > "u" || !Ft.length || !Ft[0])
                ) {
                  var Te = "";
                  Ae = [];
                  for (xr in ge[Xt])
                    this.terminals_[xr] &&
                      xr > Nt &&
                      Ae.push("'" + this.terminals_[xr] + "'");
                  (ct.showPosition
                    ? (Te =
                        "Parse error on line " +
                        (jt + 1) +
                        `:
` +
                        ct.showPosition() +
                        `
Expecting ` +
                        Ae.join(", ") +
                        ", got '" +
                        (this.terminals_[Et] || Et) +
                        "'")
                    : (Te =
                        "Parse error on line " +
                        (jt + 1) +
                        ": Unexpected " +
                        (Et == At
                          ? "end of input"
                          : "'" + (this.terminals_[Et] || Et) + "'")),
                    this.parseError(Te, {
                      text: ct.match,
                      token: this.terminals_[Et] || Et,
                      line: ct.yylineno,
                      loc: Mt,
                      expected: Ae,
                    }));
                }
                if (Ft[0] instanceof Array && Ft.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      Xt +
                      ", token: " +
                      Et,
                  );
                switch (Ft[0]) {
                  case 1:
                    (st.push(Et),
                      gt.push(ct.yytext),
                      z.push(ct.yylloc),
                      st.push(Ft[1]),
                      (Et = null),
                      mt
                        ? ((Et = mt), (mt = null))
                        : ((Me = ct.yyleng),
                          (lt = ct.yytext),
                          (jt = ct.yylineno),
                          (Mt = ct.yylloc),
                          se > 0 && se--));
                    break;
                  case 2:
                    if (
                      ((Ze = this.productions_[Ft[1]][1]),
                      (It.$ = gt[gt.length - Ze]),
                      (It._$ = {
                        first_line: z[z.length - (Ze || 1)].first_line,
                        last_line: z[z.length - 1].last_line,
                        first_column: z[z.length - (Ze || 1)].first_column,
                        last_column: z[z.length - 1].last_column,
                      }),
                      W &&
                        (It._$.range = [
                          z[z.length - (Ze || 1)].range[0],
                          z[z.length - 1].range[1],
                        ]),
                      (Qe = this.performAction.apply(
                        It,
                        [lt, Me, jt, Lt.yy, Ft[1], gt, z].concat(bt),
                      )),
                      typeof Qe < "u")
                    )
                      return Qe;
                    (Ze &&
                      ((st = st.slice(0, -1 * Ze * 2)),
                      (gt = gt.slice(0, -1 * Ze)),
                      (z = z.slice(0, -1 * Ze))),
                      st.push(this.productions_[Ft[1]][0]),
                      gt.push(It.$),
                      z.push(It._$),
                      (mn = ge[st[st.length - 2]][st[st.length - 1]]),
                      st.push(mn));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          dt = (function () {
            var Q = {
              EOF: 1,
              parseError: a(function (X, st) {
                if (this.yy.parser) this.yy.parser.parseError(X, st);
                else throw new Error(X);
              }, "parseError"),
              setInput: a(function (et, X) {
                return (
                  (this.yy = X || this.yy || {}),
                  (this._input = et),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var et = this._input[0];
                ((this.yytext += et),
                  this.yyleng++,
                  this.offset++,
                  (this.match += et),
                  (this.matched += et));
                var X = et.match(/(?:\r\n?|\n).*/g);
                return (
                  X
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  et
                );
              }, "input"),
              unput: a(function (et) {
                var X = et.length,
                  st = et.split(/(?:\r\n?|\n)/g);
                ((this._input = et + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - X)),
                  (this.offset -= X));
                var U = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  st.length - 1 && (this.yylineno -= st.length - 1));
                var gt = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: st
                      ? (st.length === U.length
                          ? this.yylloc.first_column
                          : 0) +
                        U[U.length - st.length].length -
                        st[0].length
                      : this.yylloc.first_column - X,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [gt[0], gt[0] + this.yyleng - X]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (et) {
                this.unput(this.match.slice(et));
              }, "less"),
              pastInput: a(function () {
                var et = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (et.length > 20 ? "..." : "") +
                  et.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var et = this.match;
                return (
                  et.length < 20 &&
                    (et += this._input.substr(0, 20 - et.length)),
                  (et.substr(0, 20) + (et.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var et = this.pastInput(),
                  X = new Array(et.length + 1).join("-");
                return (
                  et +
                  this.upcomingInput() +
                  `
` +
                  X +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (et, X) {
                var st, U, gt;
                if (
                  (this.options.backtrack_lexer &&
                    ((gt = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (gt.yylloc.range = this.yylloc.range.slice(0))),
                  (U = et[0].match(/(?:\r\n?|\n).*/g)),
                  U && (this.yylineno += U.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: U
                      ? U[U.length - 1].length -
                        U[U.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + et[0].length,
                  }),
                  (this.yytext += et[0]),
                  (this.match += et[0]),
                  (this.matches = et),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(et[0].length)),
                  (this.matched += et[0]),
                  (st = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    X,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  st)
                )
                  return st;
                if (this._backtrack) {
                  for (var z in gt) this[z] = gt[z];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var et, X, st, U;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var gt = this._currentRules(), z = 0; z < gt.length; z++)
                  if (
                    ((st = this._input.match(this.rules[gt[z]])),
                    st && (!X || st[0].length > X[0].length))
                  ) {
                    if (((X = st), (U = z), this.options.backtrack_lexer)) {
                      if (((et = this.test_match(st, gt[z])), et !== !1))
                        return et;
                      if (this._backtrack) {
                        X = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return X
                  ? ((et = this.test_match(X, gt[U])), et !== !1 ? et : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var X = this.next();
                return X || this.lex();
              }, "lex"),
              begin: a(function (X) {
                this.conditionStack.push(X);
              }, "begin"),
              popState: a(function () {
                var X = this.conditionStack.length - 1;
                return X > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (X) {
                return (
                  (X = this.conditionStack.length - 1 - Math.abs(X || 0)),
                  X >= 0 ? this.conditionStack[X] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (X) {
                this.begin(X);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (X, st, U, gt) {
                var z = gt;
                switch (U) {
                  case 0:
                    return (this.begin("acc_title"), 24);
                    break;
                  case 1:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 2:
                    return (this.begin("acc_descr"), 26);
                    break;
                  case 3:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 4:
                    this.begin("acc_descr_multiline");
                    break;
                  case 5:
                    this.popState();
                    break;
                  case 6:
                    return "acc_descr_multiline_value";
                  case 7:
                    return 33;
                  case 8:
                    return 34;
                  case 9:
                    return 35;
                  case 10:
                    return 36;
                  case 11:
                    return 10;
                  case 12:
                    break;
                  case 13:
                    return 8;
                  case 14:
                    return 50;
                  case 15:
                    return 70;
                  case 16:
                    return 4;
                  case 17:
                    return (this.begin("block"), 17);
                    break;
                  case 18:
                    return 49;
                  case 19:
                    return 49;
                  case 20:
                    return 42;
                  case 21:
                    return 15;
                  case 22:
                    return 13;
                  case 23:
                    break;
                  case 24:
                    return 59;
                  case 25:
                    return 56;
                  case 26:
                    return 56;
                  case 27:
                    return 60;
                  case 28:
                    break;
                  case 29:
                    return (this.popState(), 19);
                    break;
                  case 30:
                    return st.yytext[0];
                  case 31:
                    return 20;
                  case 32:
                    return 21;
                  case 33:
                    return (this.begin("style"), 44);
                    break;
                  case 34:
                    return (this.popState(), 10);
                    break;
                  case 35:
                    break;
                  case 36:
                    return 13;
                  case 37:
                    return 42;
                  case 38:
                    return 49;
                  case 39:
                    return (this.begin("style"), 37);
                    break;
                  case 40:
                    return 43;
                  case 41:
                    return 63;
                  case 42:
                    return 65;
                  case 43:
                    return 65;
                  case 44:
                    return 65;
                  case 45:
                    return 63;
                  case 46:
                    return 63;
                  case 47:
                    return 64;
                  case 48:
                    return 64;
                  case 49:
                    return 64;
                  case 50:
                    return 64;
                  case 51:
                    return 64;
                  case 52:
                    return 65;
                  case 53:
                    return 64;
                  case 54:
                    return 65;
                  case 55:
                    return 66;
                  case 56:
                    return 66;
                  case 57:
                    return 66;
                  case 58:
                    return 66;
                  case 59:
                    return 63;
                  case 60:
                    return 64;
                  case 61:
                    return 65;
                  case 62:
                    return 67;
                  case 63:
                    return 68;
                  case 64:
                    return 69;
                  case 65:
                    return 69;
                  case 66:
                    return 68;
                  case 67:
                    return 68;
                  case 68:
                    return 68;
                  case 69:
                    return 41;
                  case 70:
                    return 47;
                  case 71:
                    return 40;
                  case 72:
                    return 48;
                  case 73:
                    return st.yytext[0];
                  case 74:
                    return 6;
                }
              }, "anonymous"),
              rules: [
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:[\s]+)/i,
                /^(?:"[^"%\r\n\v\b\\]+")/i,
                /^(?:"[^"]*")/i,
                /^(?:erDiagram\b)/i,
                /^(?:\{)/i,
                /^(?:#)/i,
                /^(?:#)/i,
                /^(?:,)/i,
                /^(?::::)/i,
                /^(?::)/i,
                /^(?:\s+)/i,
                /^(?:\b((?:PK)|(?:FK)|(?:UK))\b)/i,
                /^(?:([^\s]*)[~].*[~]([^\s]*))/i,
                /^(?:([\*A-Za-z_\u00C0-\uFFFF][A-Za-z0-9\-\_\[\]\(\)\u00C0-\uFFFF\*]*))/i,
                /^(?:"[^"]*")/i,
                /^(?:[\n]+)/i,
                /^(?:\})/i,
                /^(?:.)/i,
                /^(?:\[)/i,
                /^(?:\])/i,
                /^(?:style\b)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?::)/i,
                /^(?:,)/i,
                /^(?:#)/i,
                /^(?:classDef\b)/i,
                /^(?:class\b)/i,
                /^(?:one or zero\b)/i,
                /^(?:one or more\b)/i,
                /^(?:one or many\b)/i,
                /^(?:1\+)/i,
                /^(?:\|o\b)/i,
                /^(?:zero or one\b)/i,
                /^(?:zero or more\b)/i,
                /^(?:zero or many\b)/i,
                /^(?:0\+)/i,
                /^(?:\}o\b)/i,
                /^(?:many\(0\))/i,
                /^(?:many\(1\))/i,
                /^(?:many\b)/i,
                /^(?:\}\|)/i,
                /^(?:one\b)/i,
                /^(?:only one\b)/i,
                /^(?:1\b)/i,
                /^(?:\|\|)/i,
                /^(?:o\|)/i,
                /^(?:o\{)/i,
                /^(?:\|\{)/i,
                /^(?:\s*u\b)/i,
                /^(?:\.\.)/i,
                /^(?:--)/i,
                /^(?:to\b)/i,
                /^(?:optionally to\b)/i,
                /^(?:\.-)/i,
                /^(?:-\.)/i,
                /^(?:([^\x00-\x7F]|\w|-|\*)+)/i,
                /^(?:;)/i,
                /^(?:([^\x00-\x7F]|\w|-|\*)+)/i,
                /^(?:[0-9])/i,
                /^(?:.)/i,
                /^(?:$)/i,
              ],
              conditions: {
                style: { rules: [34, 35, 36, 37, 38, 69, 70], inclusive: !1 },
                acc_descr_multiline: { rules: [5, 6], inclusive: !1 },
                acc_descr: { rules: [3], inclusive: !1 },
                acc_title: { rules: [1], inclusive: !1 },
                block: {
                  rules: [23, 24, 25, 26, 27, 28, 29, 30],
                  inclusive: !1,
                },
                INITIAL: {
                  rules: [
                    0, 2, 4, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 31, 32, 33, 39, 40, 41, 42, 43, 44, 45, 46, 47,
                    48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62,
                    63, 64, 65, 66, 67, 68, 71, 72, 73, 74,
                  ],
                  inclusive: !0,
                },
              },
            };
            return Q;
          })();
        ot.lexer = dt;
        function nt() {
          this.yy = {};
        }
        return (
          a(nt, "Parser"),
          (nt.prototype = ot),
          (ot.Parser = nt),
          new nt()
        );
      })();
      i6.parser = i6;
      dK = i6;
    });
  var lT,
    mK = x(() => {
      "use strict";
      Vt();
      pe();
      yn();
      _e();
      lT = class {
        constructor() {
          this.entities = new Map();
          this.relationships = [];
          this.classes = new Map();
          this.direction = "TB";
          this.Cardinality = {
            ZERO_OR_ONE: "ZERO_OR_ONE",
            ZERO_OR_MORE: "ZERO_OR_MORE",
            ONE_OR_MORE: "ONE_OR_MORE",
            ONLY_ONE: "ONLY_ONE",
            MD_PARENT: "MD_PARENT",
          };
          this.Identification = {
            NON_IDENTIFYING: "NON_IDENTIFYING",
            IDENTIFYING: "IDENTIFYING",
          };
          this.setAccTitle = Xe;
          this.getAccTitle = tr;
          this.setAccDescription = er;
          this.getAccDescription = rr;
          this.setDiagramTitle = lr;
          this.getDiagramTitle = nr;
          this.getConfig = a(() => K().er, "getConfig");
          (this.clear(),
            (this.addEntity = this.addEntity.bind(this)),
            (this.addAttributes = this.addAttributes.bind(this)),
            (this.addRelationship = this.addRelationship.bind(this)),
            (this.setDirection = this.setDirection.bind(this)),
            (this.addCssStyles = this.addCssStyles.bind(this)),
            (this.addClass = this.addClass.bind(this)),
            (this.setClass = this.setClass.bind(this)),
            (this.setAccTitle = this.setAccTitle.bind(this)),
            (this.setAccDescription = this.setAccDescription.bind(this)));
        }
        static {
          a(this, "ErDB");
        }
        addEntity(t, r = "") {
          return (
            this.entities.has(t)
              ? !this.entities.get(t)?.alias &&
                r &&
                ((this.entities.get(t).alias = r),
                P.info(`Add alias '${r}' to entity '${t}'`))
              : (this.entities.set(t, {
                  id: `entity-${t}-${this.entities.size}`,
                  label: t,
                  attributes: [],
                  alias: r,
                  shape: "erBox",
                  look: K().look ?? "default",
                  cssClasses: "default",
                  cssStyles: [],
                }),
                P.info("Added new entity :", t)),
            this.entities.get(t)
          );
        }
        getEntity(t) {
          return this.entities.get(t);
        }
        getEntities() {
          return this.entities;
        }
        getClasses() {
          return this.classes;
        }
        addAttributes(t, r) {
          let n = this.addEntity(t),
            i;
          for (i = r.length - 1; i >= 0; i--)
            (r[i].keys || (r[i].keys = []),
              r[i].comment || (r[i].comment = ""),
              n.attributes.push(r[i]),
              P.debug("Added attribute ", r[i].name));
        }
        addRelationship(t, r, n, i) {
          let s = this.entities.get(t),
            o = this.entities.get(n);
          if (!s || !o) return;
          let l = { entityA: s.id, roleA: r, entityB: o.id, relSpec: i };
          (this.relationships.push(l), P.debug("Added new relationship :", l));
        }
        getRelationships() {
          return this.relationships;
        }
        getDirection() {
          return this.direction;
        }
        setDirection(t) {
          this.direction = t;
        }
        getCompiledStyles(t) {
          let r = [];
          for (let n of t) {
            let i = this.classes.get(n);
            (i?.styles &&
              (r = [...r, ...(i.styles ?? [])].map((s) => s.trim())),
              i?.textStyles &&
                (r = [...r, ...(i.textStyles ?? [])].map((s) => s.trim())));
          }
          return r;
        }
        addCssStyles(t, r) {
          for (let n of t) {
            let i = this.entities.get(n);
            if (!r || !i) return;
            for (let s of r) i.cssStyles.push(s);
          }
        }
        addClass(t, r) {
          t.forEach((n) => {
            let i = this.classes.get(n);
            (i === void 0 &&
              ((i = { id: n, styles: [], textStyles: [] }),
              this.classes.set(n, i)),
              r &&
                r.forEach(function (s) {
                  if (/color/.exec(s)) {
                    let o = s.replace("fill", "bgFill");
                    i.textStyles.push(o);
                  }
                  i.styles.push(s);
                }));
          });
        }
        setClass(t, r) {
          for (let n of t) {
            let i = this.entities.get(n);
            if (i) for (let s of r) i.cssClasses += " " + s;
          }
        }
        clear() {
          ((this.entities = new Map()),
            (this.classes = new Map()),
            (this.relationships = []),
            Ye());
        }
        getData() {
          let t = [],
            r = [],
            n = K();
          for (let s of this.entities.keys()) {
            let o = this.entities.get(s);
            o &&
              ((o.cssCompiledStyles = this.getCompiledStyles(
                o.cssClasses.split(" "),
              )),
              t.push(o));
          }
          let i = 0;
          for (let s of this.relationships) {
            let o = {
              id: Tc(s.entityA, s.entityB, { prefix: "id", counter: i++ }),
              type: "normal",
              curve: "basis",
              start: s.entityA,
              end: s.entityB,
              label: s.roleA,
              labelpos: "c",
              thickness: "normal",
              classes: "relationshipLine",
              arrowTypeStart: s.relSpec.cardB.toLowerCase(),
              arrowTypeEnd: s.relSpec.cardA.toLowerCase(),
              pattern: s.relSpec.relType == "IDENTIFYING" ? "solid" : "dashed",
              look: n.look,
            };
            r.push(o);
          }
          return { nodes: t, edges: r, other: {}, config: n, direction: "TB" };
        }
      };
    });
  var s6 = {};
  Oe(s6, { draw: () => UEt });
  var UEt,
    gK = x(() => {
      "use strict";
      pe();
      Vt();
      hd();
      ph();
      mh();
      _e();
      Ge();
      UEt = a(async function (e, t, r, n) {
        (P.info("REF0:"), P.info("Drawing er diagram (unified)", t));
        let { securityLevel: i, er: s, layout: o } = K(),
          l = n.db.getData(),
          u = _o(t, i);
        ((l.type = n.type),
          (l.layoutAlgorithm = Vc(o)),
          (l.config.flowchart.nodeSpacing = s?.nodeSpacing || 140),
          (l.config.flowchart.rankSpacing = s?.rankSpacing || 80),
          (l.direction = n.db.getDirection()),
          (l.markers = [
            "only_one",
            "zero_or_one",
            "one_or_more",
            "zero_or_more",
          ]),
          (l.diagramId = t),
          await No(l, u),
          l.layoutAlgorithm === "elk" && u.select(".edges").lower());
        let h = u.selectAll('[id*="-background"]');
        Array.from(h).length > 0 &&
          h.each(function () {
            let d = xt(this),
              m = d.attr("id").replace("-background", ""),
              g = u.select(`#${CSS.escape(m)}`);
            if (!g.empty()) {
              let y = g.attr("transform");
              d.attr("transform", y);
            }
          });
        let f = 8;
        (le.insertTitle(
          u,
          "erDiagramTitleText",
          s?.titleTopMargin ?? 25,
          n.db.getDiagramTitle(),
        ),
          la(u, f, "erDiagram", s?.useMaxWidth ?? !0));
      }, "draw");
    });
  var jEt,
    qEt,
    yK,
    xK = x(() => {
      "use strict";
      Us();
      ((jEt = a((e, t) => {
        let r = gu,
          n = r(e, "r"),
          i = r(e, "g"),
          s = r(e, "b");
        return Di(n, i, s, t);
      }, "fade")),
        (qEt = a(
          (e) => `
  .entityBox {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
  }

  .relationshipLabelBox {
    fill: ${e.tertiaryColor};
    opacity: 0.7;
    background-color: ${e.tertiaryColor};
      rect {
        opacity: 0.5;
      }
  }

  .labelBkg {
    background-color: ${jEt(e.tertiaryColor, 0.5)};
  }

  .edgeLabel .label {
    fill: ${e.nodeBorder};
    font-size: 14px;
  }

  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }

  .edge-pattern-dashed {
    stroke-dasharray: 8,8;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon
  {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .relationshipLine {
    stroke: ${e.lineColor};
    stroke-width: 1;
    fill: none;
  }

  .marker {
    fill: none !important;
    stroke: ${e.lineColor} !important;
    stroke-width: 1;
  }
`,
          "getStyles",
        )),
        (yK = qEt));
    });
  var bK = {};
  Oe(bK, { diagram: () => HEt });
  var HEt,
    kK = x(() => {
      "use strict";
      pK();
      mK();
      gK();
      xK();
      HEt = {
        parser: dK,
        get db() {
          return new lT();
        },
        renderer: s6,
        styles: yK,
      };
    });
  function cn(e) {
    return typeof e == "object" && e !== null && typeof e.$type == "string";
  }
  function li(e) {
    return typeof e == "object" && e !== null && typeof e.$refText == "string";
  }
  function a6(e) {
    return (
      typeof e == "object" &&
      e !== null &&
      typeof e.name == "string" &&
      typeof e.type == "string" &&
      typeof e.path == "string"
    );
  }
  function yh(e) {
    return (
      typeof e == "object" &&
      e !== null &&
      cn(e.container) &&
      li(e.reference) &&
      typeof e.message == "string"
    );
  }
  function za(e) {
    return typeof e == "object" && e !== null && Array.isArray(e.content);
  }
  function zc(e) {
    return typeof e == "object" && e !== null && typeof e.tokenType == "object";
  }
  function K0(e) {
    return za(e) && typeof e.fullText == "string";
  }
  var gh,
    Wa = x(() => {
      "use strict";
      a(cn, "isAstNode");
      a(li, "isReference");
      a(a6, "isAstNodeDescription");
      a(yh, "isLinkingError");
      gh = class {
        static {
          a(this, "AbstractAstReflection");
        }
        constructor() {
          ((this.subtypes = {}), (this.allSubtypes = {}));
        }
        isInstance(t, r) {
          return cn(t) && this.isSubtype(t.$type, r);
        }
        isSubtype(t, r) {
          if (t === r) return !0;
          let n = this.subtypes[t];
          n || (n = this.subtypes[t] = {});
          let i = n[r];
          if (i !== void 0) return i;
          {
            let s = this.computeIsSubtype(t, r);
            return ((n[r] = s), s);
          }
        }
        getAllSubTypes(t) {
          let r = this.allSubtypes[t];
          if (r) return r;
          {
            let n = this.getAllTypes(),
              i = [];
            for (let s of n) this.isSubtype(s, t) && i.push(s);
            return ((this.allSubtypes[t] = i), i);
          }
        }
      };
      a(za, "isCompositeCstNode");
      a(zc, "isLeafCstNode");
      a(K0, "isRootCstNode");
    });
  function QEt(e) {
    return typeof e == "string"
      ? e
      : typeof e > "u"
        ? "undefined"
        : typeof e.toString == "function"
          ? e.toString()
          : Object.prototype.toString.call(e);
  }
  function cT(e) {
    return !!e && typeof e[Symbol.iterator] == "function";
  }
  function kr(...e) {
    if (e.length === 1) {
      let t = e[0];
      if (t instanceof Ns) return t;
      if (cT(t))
        return new Ns(
          () => t[Symbol.iterator](),
          (r) => r.next(),
        );
      if (typeof t.length == "number")
        return new Ns(
          () => ({ index: 0 }),
          (r) => (r.index < t.length ? { done: !1, value: t[r.index++] } : ki),
        );
    }
    return e.length > 1
      ? new Ns(
          () => ({ collIndex: 0, arrIndex: 0 }),
          (t) => {
            do {
              if (t.iterator) {
                let r = t.iterator.next();
                if (!r.done) return r;
                t.iterator = void 0;
              }
              if (t.array) {
                if (t.arrIndex < t.array.length)
                  return { done: !1, value: t.array[t.arrIndex++] };
                ((t.array = void 0), (t.arrIndex = 0));
              }
              if (t.collIndex < e.length) {
                let r = e[t.collIndex++];
                cT(r)
                  ? (t.iterator = r[Symbol.iterator]())
                  : r && typeof r.length == "number" && (t.array = r);
              }
            } while (t.iterator || t.array || t.collIndex < e.length);
            return ki;
          },
        )
      : Q0;
  }
  var Ns,
    Q0,
    ki,
    Mo,
    Od,
    ms = x(() => {
      "use strict";
      Ns = class e {
        static {
          a(this, "StreamImpl");
        }
        constructor(t, r) {
          ((this.startFn = t), (this.nextFn = r));
        }
        iterator() {
          let t = {
            state: this.startFn(),
            next: a(() => this.nextFn(t.state), "next"),
            [Symbol.iterator]: () => t,
          };
          return t;
        }
        [Symbol.iterator]() {
          return this.iterator();
        }
        isEmpty() {
          return !!this.iterator().next().done;
        }
        count() {
          let t = this.iterator(),
            r = 0,
            n = t.next();
          for (; !n.done; ) (r++, (n = t.next()));
          return r;
        }
        toArray() {
          let t = [],
            r = this.iterator(),
            n;
          do ((n = r.next()), n.value !== void 0 && t.push(n.value));
          while (!n.done);
          return t;
        }
        toSet() {
          return new Set(this);
        }
        toMap(t, r) {
          let n = this.map((i) => [t ? t(i) : i, r ? r(i) : i]);
          return new Map(n);
        }
        toString() {
          return this.join();
        }
        concat(t) {
          return new e(
            () => ({
              first: this.startFn(),
              firstDone: !1,
              iterator: t[Symbol.iterator](),
            }),
            (r) => {
              let n;
              if (!r.firstDone) {
                do if (((n = this.nextFn(r.first)), !n.done)) return n;
                while (!n.done);
                r.firstDone = !0;
              }
              do if (((n = r.iterator.next()), !n.done)) return n;
              while (!n.done);
              return ki;
            },
          );
        }
        join(t = ",") {
          let r = this.iterator(),
            n = "",
            i,
            s = !1;
          do
            ((i = r.next()),
              i.done || (s && (n += t), (n += QEt(i.value))),
              (s = !0));
          while (!i.done);
          return n;
        }
        indexOf(t, r = 0) {
          let n = this.iterator(),
            i = 0,
            s = n.next();
          for (; !s.done; ) {
            if (i >= r && s.value === t) return i;
            ((s = n.next()), i++);
          }
          return -1;
        }
        every(t) {
          let r = this.iterator(),
            n = r.next();
          for (; !n.done; ) {
            if (!t(n.value)) return !1;
            n = r.next();
          }
          return !0;
        }
        some(t) {
          let r = this.iterator(),
            n = r.next();
          for (; !n.done; ) {
            if (t(n.value)) return !0;
            n = r.next();
          }
          return !1;
        }
        forEach(t) {
          let r = this.iterator(),
            n = 0,
            i = r.next();
          for (; !i.done; ) (t(i.value, n), (i = r.next()), n++);
        }
        map(t) {
          return new e(this.startFn, (r) => {
            let { done: n, value: i } = this.nextFn(r);
            return n ? ki : { done: !1, value: t(i) };
          });
        }
        filter(t) {
          return new e(this.startFn, (r) => {
            let n;
            do if (((n = this.nextFn(r)), !n.done && t(n.value))) return n;
            while (!n.done);
            return ki;
          });
        }
        nonNullable() {
          return this.filter((t) => t != null);
        }
        reduce(t, r) {
          let n = this.iterator(),
            i = r,
            s = n.next();
          for (; !s.done; )
            (i === void 0 ? (i = s.value) : (i = t(i, s.value)),
              (s = n.next()));
          return i;
        }
        reduceRight(t, r) {
          return this.recursiveReduce(this.iterator(), t, r);
        }
        recursiveReduce(t, r, n) {
          let i = t.next();
          if (i.done) return n;
          let s = this.recursiveReduce(t, r, n);
          return s === void 0 ? i.value : r(s, i.value);
        }
        find(t) {
          let r = this.iterator(),
            n = r.next();
          for (; !n.done; ) {
            if (t(n.value)) return n.value;
            n = r.next();
          }
        }
        findIndex(t) {
          let r = this.iterator(),
            n = 0,
            i = r.next();
          for (; !i.done; ) {
            if (t(i.value)) return n;
            ((i = r.next()), n++);
          }
          return -1;
        }
        includes(t) {
          let r = this.iterator(),
            n = r.next();
          for (; !n.done; ) {
            if (n.value === t) return !0;
            n = r.next();
          }
          return !1;
        }
        flatMap(t) {
          return new e(
            () => ({ this: this.startFn() }),
            (r) => {
              do {
                if (r.iterator) {
                  let s = r.iterator.next();
                  if (s.done) r.iterator = void 0;
                  else return s;
                }
                let { done: n, value: i } = this.nextFn(r.this);
                if (!n) {
                  let s = t(i);
                  if (cT(s)) r.iterator = s[Symbol.iterator]();
                  else return { done: !1, value: s };
                }
              } while (r.iterator);
              return ki;
            },
          );
        }
        flat(t) {
          if ((t === void 0 && (t = 1), t <= 0)) return this;
          let r = t > 1 ? this.flat(t - 1) : this;
          return new e(
            () => ({ this: r.startFn() }),
            (n) => {
              do {
                if (n.iterator) {
                  let o = n.iterator.next();
                  if (o.done) n.iterator = void 0;
                  else return o;
                }
                let { done: i, value: s } = r.nextFn(n.this);
                if (!i)
                  if (cT(s)) n.iterator = s[Symbol.iterator]();
                  else return { done: !1, value: s };
              } while (n.iterator);
              return ki;
            },
          );
        }
        head() {
          let r = this.iterator().next();
          if (!r.done) return r.value;
        }
        tail(t = 1) {
          return new e(() => {
            let r = this.startFn();
            for (let n = 0; n < t; n++) if (this.nextFn(r).done) return r;
            return r;
          }, this.nextFn);
        }
        limit(t) {
          return new e(
            () => ({ size: 0, state: this.startFn() }),
            (r) => (r.size++, r.size > t ? ki : this.nextFn(r.state)),
          );
        }
        distinct(t) {
          return new e(
            () => ({ set: new Set(), internalState: this.startFn() }),
            (r) => {
              let n;
              do
                if (((n = this.nextFn(r.internalState)), !n.done)) {
                  let i = t ? t(n.value) : n.value;
                  if (!r.set.has(i)) return (r.set.add(i), n);
                }
              while (!n.done);
              return ki;
            },
          );
        }
        exclude(t, r) {
          let n = new Set();
          for (let i of t) {
            let s = r ? r(i) : i;
            n.add(s);
          }
          return this.filter((i) => {
            let s = r ? r(i) : i;
            return !n.has(s);
          });
        }
      };
      a(QEt, "toString");
      a(cT, "isIterable");
      ((Q0 = new Ns(
        () => {},
        () => ki,
      )),
        (ki = Object.freeze({ done: !0, value: void 0 })));
      a(kr, "stream");
      Mo = class extends Ns {
        static {
          a(this, "TreeStreamImpl");
        }
        constructor(t, r, n) {
          super(
            () => ({
              iterators: n?.includeRoot
                ? [[t][Symbol.iterator]()]
                : [r(t)[Symbol.iterator]()],
              pruned: !1,
            }),
            (i) => {
              for (
                i.pruned && (i.iterators.pop(), (i.pruned = !1));
                i.iterators.length > 0;

              ) {
                let o = i.iterators[i.iterators.length - 1].next();
                if (o.done) i.iterators.pop();
                else
                  return (i.iterators.push(r(o.value)[Symbol.iterator]()), o);
              }
              return ki;
            },
          );
        }
        iterator() {
          let t = {
            state: this.startFn(),
            next: a(() => this.nextFn(t.state), "next"),
            prune: a(() => {
              t.state.pruned = !0;
            }, "prune"),
            [Symbol.iterator]: () => t,
          };
          return t;
        }
      };
      (function (e) {
        function t(s) {
          return s.reduce((o, l) => o + l, 0);
        }
        (a(t, "sum"), (e.sum = t));
        function r(s) {
          return s.reduce((o, l) => o * l, 0);
        }
        (a(r, "product"), (e.product = r));
        function n(s) {
          return s.reduce((o, l) => Math.min(o, l));
        }
        (a(n, "min"), (e.min = n));
        function i(s) {
          return s.reduce((o, l) => Math.max(o, l));
        }
        (a(i, "max"), (e.max = i));
      })(Od || (Od = {}));
    });
  var hT = {};
  Oe(hT, {
    DefaultNameRegexp: () => uT,
    RangeComparison: () => Oo,
    compareRange: () => CK,
    findCommentNode: () => u6,
    findDeclarationNodeAtOffset: () => JEt,
    findLeafNodeAtOffset: () => h6,
    findLeafNodeBeforeOffset: () => wK,
    flattenCst: () => ZEt,
    getInteriorNodes: () => r3t,
    getNextNode: () => t3t,
    getPreviousNode: () => EK,
    getStartlineNode: () => e3t,
    inRange: () => c6,
    isChildNode: () => l6,
    isCommentNode: () => o6,
    streamCst: () => xh,
    toDocumentSegment: () => bh,
    tokenToRange: () => Pd,
  });
  function xh(e) {
    return new Mo(e, (t) => (za(t) ? t.content : []), { includeRoot: !0 });
  }
  function ZEt(e) {
    return xh(e).filter(zc);
  }
  function l6(e, t) {
    for (; e.container; ) if (((e = e.container), e === t)) return !0;
    return !1;
  }
  function Pd(e) {
    return {
      start: { character: e.startColumn - 1, line: e.startLine - 1 },
      end: { character: e.endColumn, line: e.endLine - 1 },
    };
  }
  function bh(e) {
    if (!e) return;
    let { offset: t, end: r, range: n } = e;
    return { range: n, offset: t, end: r, length: r - t };
  }
  function CK(e, t) {
    if (
      e.end.line < t.start.line ||
      (e.end.line === t.start.line && e.end.character <= t.start.character)
    )
      return Oo.Before;
    if (
      e.start.line > t.end.line ||
      (e.start.line === t.end.line && e.start.character >= t.end.character)
    )
      return Oo.After;
    let r =
        e.start.line > t.start.line ||
        (e.start.line === t.start.line &&
          e.start.character >= t.start.character),
      n =
        e.end.line < t.end.line ||
        (e.end.line === t.end.line && e.end.character <= t.end.character);
    return r && n
      ? Oo.Inside
      : r
        ? Oo.OverlapBack
        : n
          ? Oo.OverlapFront
          : Oo.Outside;
  }
  function c6(e, t) {
    return CK(e, t) > Oo.After;
  }
  function JEt(e, t, r = uT) {
    if (e) {
      if (t > 0) {
        let n = t - e.offset,
          i = e.text.charAt(n);
        r.test(i) || t--;
      }
      return h6(e, t);
    }
  }
  function u6(e, t) {
    if (e) {
      let r = EK(e, !0);
      if (r && o6(r, t)) return r;
      if (K0(e)) {
        let n = e.content.findIndex((i) => !i.hidden);
        for (let i = n - 1; i >= 0; i--) {
          let s = e.content[i];
          if (o6(s, t)) return s;
        }
      }
    }
  }
  function o6(e, t) {
    return zc(e) && t.includes(e.tokenType.name);
  }
  function h6(e, t) {
    if (zc(e)) return e;
    if (za(e)) {
      let r = vK(e, t, !1);
      if (r) return h6(r, t);
    }
  }
  function wK(e, t) {
    if (zc(e)) return e;
    if (za(e)) {
      let r = vK(e, t, !0);
      if (r) return wK(r, t);
    }
  }
  function vK(e, t, r) {
    let n = 0,
      i = e.content.length - 1,
      s;
    for (; n <= i; ) {
      let o = Math.floor((n + i) / 2),
        l = e.content[o];
      if (l.offset <= t && l.end > t) return l;
      l.end <= t ? ((s = r ? l : void 0), (n = o + 1)) : (i = o - 1);
    }
    return s;
  }
  function EK(e, t = !0) {
    for (; e.container; ) {
      let r = e.container,
        n = r.content.indexOf(e);
      for (; n > 0; ) {
        n--;
        let i = r.content[n];
        if (t || !i.hidden) return i;
      }
      e = r;
    }
  }
  function t3t(e, t = !0) {
    for (; e.container; ) {
      let r = e.container,
        n = r.content.indexOf(e),
        i = r.content.length - 1;
      for (; n < i; ) {
        n++;
        let s = r.content[n];
        if (t || !s.hidden) return s;
      }
      e = r;
    }
  }
  function e3t(e) {
    if (e.range.start.character === 0) return e;
    let t = e.range.start.line,
      r = e,
      n;
    for (; e.container; ) {
      let i = e.container,
        s = n ?? i.content.indexOf(e);
      if (
        (s === 0 ? ((e = i), (n = void 0)) : ((n = s - 1), (e = i.content[n])),
        e.range.start.line !== t)
      )
        break;
      r = e;
    }
    return r;
  }
  function r3t(e, t) {
    let r = n3t(e, t);
    return r ? r.parent.content.slice(r.a + 1, r.b) : [];
  }
  function n3t(e, t) {
    let r = _K(e),
      n = _K(t),
      i;
    for (let s = 0; s < r.length && s < n.length; s++) {
      let o = r[s],
        l = n[s];
      if (o.parent === l.parent)
        i = { parent: o.parent, a: o.index, b: l.index };
      else break;
    }
    return i;
  }
  function _K(e) {
    let t = [];
    for (; e.container; ) {
      let r = e.container,
        n = r.content.indexOf(e);
      (t.push({ parent: r, index: n }), (e = r));
    }
    return t.reverse();
  }
  var Oo,
    uT,
    Ua = x(() => {
      "use strict";
      Wa();
      ms();
      a(xh, "streamCst");
      a(ZEt, "flattenCst");
      a(l6, "isChildNode");
      a(Pd, "tokenToRange");
      a(bh, "toDocumentSegment");
      (function (e) {
        ((e[(e.Before = 0)] = "Before"),
          (e[(e.After = 1)] = "After"),
          (e[(e.OverlapFront = 2)] = "OverlapFront"),
          (e[(e.OverlapBack = 3)] = "OverlapBack"),
          (e[(e.Inside = 4)] = "Inside"),
          (e[(e.Outside = 5)] = "Outside"));
      })(Oo || (Oo = {}));
      a(CK, "compareRange");
      a(c6, "inRange");
      uT = /^[\w\p{L}]$/u;
      a(JEt, "findDeclarationNodeAtOffset");
      a(u6, "findCommentNode");
      a(o6, "isCommentNode");
      a(h6, "findLeafNodeAtOffset");
      a(wK, "findLeafNodeBeforeOffset");
      a(vK, "binarySearch");
      a(EK, "getPreviousNode");
      a(t3t, "getNextNode");
      a(e3t, "getStartlineNode");
      a(r3t, "getInteriorNodes");
      a(n3t, "getCommonParent");
      a(_K, "getParentChain");
    });
  function Po(e) {
    throw new Error("Error! The input value was not handled.");
  }
  var kh,
    fT = x(() => {
      "use strict";
      kh = class extends Error {
        static {
          a(this, "ErrorWithLocation");
        }
        constructor(t, r) {
          super(
            t ? `${r} at ${t.range.start.line}:${t.range.start.character}` : r,
          );
        }
      };
      a(Po, "assertUnreachable");
    });
  var a1 = {};
  Oe(a1, {
    AbstractElement: () => $d,
    AbstractRule: () => Bd,
    AbstractType: () => Fd,
    Action: () => ip,
    Alternatives: () => sp,
    ArrayLiteral: () => Gd,
    ArrayType: () => Vd,
    Assignment: () => ap,
    BooleanLiteral: () => zd,
    CharacterRange: () => op,
    Condition: () => Z0,
    Conjunction: () => Wd,
    CrossReference: () => lp,
    Disjunction: () => Ud,
    EndOfFile: () => cp,
    Grammar: () => jd,
    GrammarImport: () => t1,
    Group: () => up,
    InferredType: () => qd,
    Interface: () => Hd,
    Keyword: () => hp,
    LangiumGrammarAstReflection: () => Tp,
    LangiumGrammarTerminals: () => i3t,
    NamedArgument: () => e1,
    NegatedToken: () => fp,
    Negation: () => Yd,
    NumberLiteral: () => Xd,
    Parameter: () => Kd,
    ParameterReference: () => Qd,
    ParserRule: () => Zd,
    ReferenceType: () => Jd,
    RegexToken: () => dp,
    ReturnType: () => r1,
    RuleCall: () => pp,
    SimpleType: () => tp,
    StringLiteral: () => ep,
    TerminalAlternatives: () => mp,
    TerminalGroup: () => gp,
    TerminalRule: () => Th,
    TerminalRuleCall: () => yp,
    Type: () => rp,
    TypeAttribute: () => n1,
    TypeDefinition: () => dT,
    UnionType: () => np,
    UnorderedGroup: () => xp,
    UntilToken: () => bp,
    ValueLiteral: () => J0,
    Wildcard: () => kp,
    isAbstractElement: () => i1,
    isAbstractRule: () => s3t,
    isAbstractType: () => a3t,
    isAction: () => _l,
    isAlternatives: () => yT,
    isArrayLiteral: () => h3t,
    isArrayType: () => f6,
    isAssignment: () => ja,
    isBooleanLiteral: () => d6,
    isCharacterRange: () => T6,
    isCondition: () => o3t,
    isConjunction: () => p6,
    isCrossReference: () => Sh,
    isDisjunction: () => m6,
    isEndOfFile: () => S6,
    isFeatureName: () => l3t,
    isGrammar: () => f3t,
    isGrammarImport: () => d3t,
    isGroup: () => Wc,
    isInferredType: () => pT,
    isInterface: () => mT,
    isKeyword: () => ca,
    isNamedArgument: () => p3t,
    isNegatedToken: () => _6,
    isNegation: () => g6,
    isNumberLiteral: () => m3t,
    isParameter: () => g3t,
    isParameterReference: () => y6,
    isParserRule: () => Ti,
    isPrimitiveType: () => AK,
    isReferenceType: () => x6,
    isRegexToken: () => C6,
    isReturnType: () => b6,
    isRuleCall: () => qa,
    isSimpleType: () => gT,
    isStringLiteral: () => y3t,
    isTerminalAlternatives: () => w6,
    isTerminalGroup: () => v6,
    isTerminalRule: () => Is,
    isTerminalRuleCall: () => xT,
    isType: () => s1,
    isTypeAttribute: () => x3t,
    isTypeDefinition: () => c3t,
    isUnionType: () => k6,
    isUnorderedGroup: () => bT,
    isUntilToken: () => E6,
    isValueLiteral: () => u3t,
    isWildcard: () => A6,
    reflection: () => Re,
  });
  function s3t(e) {
    return Re.isInstance(e, Bd);
  }
  function a3t(e) {
    return Re.isInstance(e, Fd);
  }
  function o3t(e) {
    return Re.isInstance(e, Z0);
  }
  function l3t(e) {
    return (
      AK(e) ||
      e === "current" ||
      e === "entry" ||
      e === "extends" ||
      e === "false" ||
      e === "fragment" ||
      e === "grammar" ||
      e === "hidden" ||
      e === "import" ||
      e === "interface" ||
      e === "returns" ||
      e === "terminal" ||
      e === "true" ||
      e === "type" ||
      e === "infer" ||
      e === "infers" ||
      e === "with" ||
      (typeof e == "string" && /\^?[_a-zA-Z][\w_]*/.test(e))
    );
  }
  function AK(e) {
    return (
      e === "string" ||
      e === "number" ||
      e === "boolean" ||
      e === "Date" ||
      e === "bigint"
    );
  }
  function c3t(e) {
    return Re.isInstance(e, dT);
  }
  function u3t(e) {
    return Re.isInstance(e, J0);
  }
  function i1(e) {
    return Re.isInstance(e, $d);
  }
  function h3t(e) {
    return Re.isInstance(e, Gd);
  }
  function f6(e) {
    return Re.isInstance(e, Vd);
  }
  function d6(e) {
    return Re.isInstance(e, zd);
  }
  function p6(e) {
    return Re.isInstance(e, Wd);
  }
  function m6(e) {
    return Re.isInstance(e, Ud);
  }
  function f3t(e) {
    return Re.isInstance(e, jd);
  }
  function d3t(e) {
    return Re.isInstance(e, t1);
  }
  function pT(e) {
    return Re.isInstance(e, qd);
  }
  function mT(e) {
    return Re.isInstance(e, Hd);
  }
  function p3t(e) {
    return Re.isInstance(e, e1);
  }
  function g6(e) {
    return Re.isInstance(e, Yd);
  }
  function m3t(e) {
    return Re.isInstance(e, Xd);
  }
  function g3t(e) {
    return Re.isInstance(e, Kd);
  }
  function y6(e) {
    return Re.isInstance(e, Qd);
  }
  function Ti(e) {
    return Re.isInstance(e, Zd);
  }
  function x6(e) {
    return Re.isInstance(e, Jd);
  }
  function b6(e) {
    return Re.isInstance(e, r1);
  }
  function gT(e) {
    return Re.isInstance(e, tp);
  }
  function y3t(e) {
    return Re.isInstance(e, ep);
  }
  function Is(e) {
    return Re.isInstance(e, Th);
  }
  function s1(e) {
    return Re.isInstance(e, rp);
  }
  function x3t(e) {
    return Re.isInstance(e, n1);
  }
  function k6(e) {
    return Re.isInstance(e, np);
  }
  function _l(e) {
    return Re.isInstance(e, ip);
  }
  function yT(e) {
    return Re.isInstance(e, sp);
  }
  function ja(e) {
    return Re.isInstance(e, ap);
  }
  function T6(e) {
    return Re.isInstance(e, op);
  }
  function Sh(e) {
    return Re.isInstance(e, lp);
  }
  function S6(e) {
    return Re.isInstance(e, cp);
  }
  function Wc(e) {
    return Re.isInstance(e, up);
  }
  function ca(e) {
    return Re.isInstance(e, hp);
  }
  function _6(e) {
    return Re.isInstance(e, fp);
  }
  function C6(e) {
    return Re.isInstance(e, dp);
  }
  function qa(e) {
    return Re.isInstance(e, pp);
  }
  function w6(e) {
    return Re.isInstance(e, mp);
  }
  function v6(e) {
    return Re.isInstance(e, gp);
  }
  function xT(e) {
    return Re.isInstance(e, yp);
  }
  function bT(e) {
    return Re.isInstance(e, xp);
  }
  function E6(e) {
    return Re.isInstance(e, bp);
  }
  function A6(e) {
    return Re.isInstance(e, kp);
  }
  var i3t,
    Bd,
    Fd,
    Z0,
    dT,
    J0,
    $d,
    Gd,
    Vd,
    zd,
    Wd,
    Ud,
    jd,
    t1,
    qd,
    Hd,
    e1,
    Yd,
    Xd,
    Kd,
    Qd,
    Zd,
    Jd,
    r1,
    tp,
    ep,
    Th,
    rp,
    n1,
    np,
    ip,
    sp,
    ap,
    op,
    lp,
    cp,
    up,
    hp,
    fp,
    dp,
    pp,
    mp,
    gp,
    yp,
    xp,
    bp,
    kp,
    Tp,
    Re,
    Bo = x(() => {
      "use strict";
      Wa();
      ((i3t = {
        ID: /\^?[_a-zA-Z][\w_]*/,
        STRING: /"(\\.|[^"\\])*"|'(\\.|[^'\\])*'/,
        NUMBER: /NaN|-?((\d*\.\d+|\d+)([Ee][+-]?\d+)?|Infinity)/,
        RegexLiteral:
          /\/(?![*+?])(?:[^\r\n\[/\\]|\\.|\[(?:[^\r\n\]\\]|\\.)*\])+\/[a-z]*/,
        WS: /\s+/,
        ML_COMMENT: /\/\*[\s\S]*?\*\//,
        SL_COMMENT: /\/\/[^\n\r]*/,
      }),
        (Bd = "AbstractRule"));
      a(s3t, "isAbstractRule");
      Fd = "AbstractType";
      a(a3t, "isAbstractType");
      Z0 = "Condition";
      a(o3t, "isCondition");
      a(l3t, "isFeatureName");
      a(AK, "isPrimitiveType");
      dT = "TypeDefinition";
      a(c3t, "isTypeDefinition");
      J0 = "ValueLiteral";
      a(u3t, "isValueLiteral");
      $d = "AbstractElement";
      a(i1, "isAbstractElement");
      Gd = "ArrayLiteral";
      a(h3t, "isArrayLiteral");
      Vd = "ArrayType";
      a(f6, "isArrayType");
      zd = "BooleanLiteral";
      a(d6, "isBooleanLiteral");
      Wd = "Conjunction";
      a(p6, "isConjunction");
      Ud = "Disjunction";
      a(m6, "isDisjunction");
      jd = "Grammar";
      a(f3t, "isGrammar");
      t1 = "GrammarImport";
      a(d3t, "isGrammarImport");
      qd = "InferredType";
      a(pT, "isInferredType");
      Hd = "Interface";
      a(mT, "isInterface");
      e1 = "NamedArgument";
      a(p3t, "isNamedArgument");
      Yd = "Negation";
      a(g6, "isNegation");
      Xd = "NumberLiteral";
      a(m3t, "isNumberLiteral");
      Kd = "Parameter";
      a(g3t, "isParameter");
      Qd = "ParameterReference";
      a(y6, "isParameterReference");
      Zd = "ParserRule";
      a(Ti, "isParserRule");
      Jd = "ReferenceType";
      a(x6, "isReferenceType");
      r1 = "ReturnType";
      a(b6, "isReturnType");
      tp = "SimpleType";
      a(gT, "isSimpleType");
      ep = "StringLiteral";
      a(y3t, "isStringLiteral");
      Th = "TerminalRule";
      a(Is, "isTerminalRule");
      rp = "Type";
      a(s1, "isType");
      n1 = "TypeAttribute";
      a(x3t, "isTypeAttribute");
      np = "UnionType";
      a(k6, "isUnionType");
      ip = "Action";
      a(_l, "isAction");
      sp = "Alternatives";
      a(yT, "isAlternatives");
      ap = "Assignment";
      a(ja, "isAssignment");
      op = "CharacterRange";
      a(T6, "isCharacterRange");
      lp = "CrossReference";
      a(Sh, "isCrossReference");
      cp = "EndOfFile";
      a(S6, "isEndOfFile");
      up = "Group";
      a(Wc, "isGroup");
      hp = "Keyword";
      a(ca, "isKeyword");
      fp = "NegatedToken";
      a(_6, "isNegatedToken");
      dp = "RegexToken";
      a(C6, "isRegexToken");
      pp = "RuleCall";
      a(qa, "isRuleCall");
      mp = "TerminalAlternatives";
      a(w6, "isTerminalAlternatives");
      gp = "TerminalGroup";
      a(v6, "isTerminalGroup");
      yp = "TerminalRuleCall";
      a(xT, "isTerminalRuleCall");
      xp = "UnorderedGroup";
      a(bT, "isUnorderedGroup");
      bp = "UntilToken";
      a(E6, "isUntilToken");
      kp = "Wildcard";
      a(A6, "isWildcard");
      ((Tp = class extends gh {
        static {
          a(this, "LangiumGrammarAstReflection");
        }
        getAllTypes() {
          return [
            $d,
            Bd,
            Fd,
            ip,
            sp,
            Gd,
            Vd,
            ap,
            zd,
            op,
            Z0,
            Wd,
            lp,
            Ud,
            cp,
            jd,
            t1,
            up,
            qd,
            Hd,
            hp,
            e1,
            fp,
            Yd,
            Xd,
            Kd,
            Qd,
            Zd,
            Jd,
            dp,
            r1,
            pp,
            tp,
            ep,
            mp,
            gp,
            Th,
            yp,
            rp,
            n1,
            dT,
            np,
            xp,
            bp,
            J0,
            kp,
          ];
        }
        computeIsSubtype(t, r) {
          switch (t) {
            case ip:
            case sp:
            case ap:
            case op:
            case lp:
            case cp:
            case up:
            case hp:
            case fp:
            case dp:
            case pp:
            case mp:
            case gp:
            case yp:
            case xp:
            case bp:
            case kp:
              return this.isSubtype($d, r);
            case Gd:
            case Xd:
            case ep:
              return this.isSubtype(J0, r);
            case Vd:
            case Jd:
            case tp:
            case np:
              return this.isSubtype(dT, r);
            case zd:
              return this.isSubtype(Z0, r) || this.isSubtype(J0, r);
            case Wd:
            case Ud:
            case Yd:
            case Qd:
              return this.isSubtype(Z0, r);
            case qd:
            case Hd:
            case rp:
              return this.isSubtype(Fd, r);
            case Zd:
              return this.isSubtype(Bd, r) || this.isSubtype(Fd, r);
            case Th:
              return this.isSubtype(Bd, r);
            default:
              return !1;
          }
        }
        getReferenceType(t) {
          let r = `${t.container.$type}:${t.property}`;
          switch (r) {
            case "Action:type":
            case "CrossReference:type":
            case "Interface:superTypes":
            case "ParserRule:returnType":
            case "SimpleType:typeRef":
              return Fd;
            case "Grammar:hiddenTokens":
            case "ParserRule:hiddenTokens":
            case "RuleCall:rule":
              return Bd;
            case "Grammar:usedGrammars":
              return jd;
            case "NamedArgument:parameter":
            case "ParameterReference:parameter":
              return Kd;
            case "TerminalRuleCall:rule":
              return Th;
            default:
              throw new Error(`${r} is not a valid reference id.`);
          }
        }
        getTypeMetaData(t) {
          switch (t) {
            case $d:
              return {
                name: $d,
                properties: [{ name: "cardinality" }, { name: "lookahead" }],
              };
            case Gd:
              return {
                name: Gd,
                properties: [{ name: "elements", defaultValue: [] }],
              };
            case Vd:
              return { name: Vd, properties: [{ name: "elementType" }] };
            case zd:
              return {
                name: zd,
                properties: [{ name: "true", defaultValue: !1 }],
              };
            case Wd:
              return {
                name: Wd,
                properties: [{ name: "left" }, { name: "right" }],
              };
            case Ud:
              return {
                name: Ud,
                properties: [{ name: "left" }, { name: "right" }],
              };
            case jd:
              return {
                name: jd,
                properties: [
                  { name: "definesHiddenTokens", defaultValue: !1 },
                  { name: "hiddenTokens", defaultValue: [] },
                  { name: "imports", defaultValue: [] },
                  { name: "interfaces", defaultValue: [] },
                  { name: "isDeclared", defaultValue: !1 },
                  { name: "name" },
                  { name: "rules", defaultValue: [] },
                  { name: "types", defaultValue: [] },
                  { name: "usedGrammars", defaultValue: [] },
                ],
              };
            case t1:
              return { name: t1, properties: [{ name: "path" }] };
            case qd:
              return { name: qd, properties: [{ name: "name" }] };
            case Hd:
              return {
                name: Hd,
                properties: [
                  { name: "attributes", defaultValue: [] },
                  { name: "name" },
                  { name: "superTypes", defaultValue: [] },
                ],
              };
            case e1:
              return {
                name: e1,
                properties: [
                  { name: "calledByName", defaultValue: !1 },
                  { name: "parameter" },
                  { name: "value" },
                ],
              };
            case Yd:
              return { name: Yd, properties: [{ name: "value" }] };
            case Xd:
              return { name: Xd, properties: [{ name: "value" }] };
            case Kd:
              return { name: Kd, properties: [{ name: "name" }] };
            case Qd:
              return { name: Qd, properties: [{ name: "parameter" }] };
            case Zd:
              return {
                name: Zd,
                properties: [
                  { name: "dataType" },
                  { name: "definesHiddenTokens", defaultValue: !1 },
                  { name: "definition" },
                  { name: "entry", defaultValue: !1 },
                  { name: "fragment", defaultValue: !1 },
                  { name: "hiddenTokens", defaultValue: [] },
                  { name: "inferredType" },
                  { name: "name" },
                  { name: "parameters", defaultValue: [] },
                  { name: "returnType" },
                  { name: "wildcard", defaultValue: !1 },
                ],
              };
            case Jd:
              return { name: Jd, properties: [{ name: "referenceType" }] };
            case r1:
              return { name: r1, properties: [{ name: "name" }] };
            case tp:
              return {
                name: tp,
                properties: [
                  { name: "primitiveType" },
                  { name: "stringType" },
                  { name: "typeRef" },
                ],
              };
            case ep:
              return { name: ep, properties: [{ name: "value" }] };
            case Th:
              return {
                name: Th,
                properties: [
                  { name: "definition" },
                  { name: "fragment", defaultValue: !1 },
                  { name: "hidden", defaultValue: !1 },
                  { name: "name" },
                  { name: "type" },
                ],
              };
            case rp:
              return {
                name: rp,
                properties: [{ name: "name" }, { name: "type" }],
              };
            case n1:
              return {
                name: n1,
                properties: [
                  { name: "defaultValue" },
                  { name: "isOptional", defaultValue: !1 },
                  { name: "name" },
                  { name: "type" },
                ],
              };
            case np:
              return {
                name: np,
                properties: [{ name: "types", defaultValue: [] }],
              };
            case ip:
              return {
                name: ip,
                properties: [
                  { name: "cardinality" },
                  { name: "feature" },
                  { name: "inferredType" },
                  { name: "lookahead" },
                  { name: "operator" },
                  { name: "type" },
                ],
              };
            case sp:
              return {
                name: sp,
                properties: [
                  { name: "cardinality" },
                  { name: "elements", defaultValue: [] },
                  { name: "lookahead" },
                ],
              };
            case ap:
              return {
                name: ap,
                properties: [
                  { name: "cardinality" },
                  { name: "feature" },
                  { name: "lookahead" },
                  { name: "operator" },
                  { name: "terminal" },
                ],
              };
            case op:
              return {
                name: op,
                properties: [
                  { name: "cardinality" },
                  { name: "left" },
                  { name: "lookahead" },
                  { name: "right" },
                ],
              };
            case lp:
              return {
                name: lp,
                properties: [
                  { name: "cardinality" },
                  { name: "deprecatedSyntax", defaultValue: !1 },
                  { name: "lookahead" },
                  { name: "terminal" },
                  { name: "type" },
                ],
              };
            case cp:
              return {
                name: cp,
                properties: [{ name: "cardinality" }, { name: "lookahead" }],
              };
            case up:
              return {
                name: up,
                properties: [
                  { name: "cardinality" },
                  { name: "elements", defaultValue: [] },
                  { name: "guardCondition" },
                  { name: "lookahead" },
                ],
              };
            case hp:
              return {
                name: hp,
                properties: [
                  { name: "cardinality" },
                  { name: "lookahead" },
                  { name: "value" },
                ],
              };
            case fp:
              return {
                name: fp,
                properties: [
                  { name: "cardinality" },
                  { name: "lookahead" },
                  { name: "terminal" },
                ],
              };
            case dp:
              return {
                name: dp,
                properties: [
                  { name: "cardinality" },
                  { name: "lookahead" },
                  { name: "regex" },
                ],
              };
            case pp:
              return {
                name: pp,
                properties: [
                  { name: "arguments", defaultValue: [] },
                  { name: "cardinality" },
                  { name: "lookahead" },
                  { name: "rule" },
                ],
              };
            case mp:
              return {
                name: mp,
                properties: [
                  { name: "cardinality" },
                  { name: "elements", defaultValue: [] },
                  { name: "lookahead" },
                ],
              };
            case gp:
              return {
                name: gp,
                properties: [
                  { name: "cardinality" },
                  { name: "elements", defaultValue: [] },
                  { name: "lookahead" },
                ],
              };
            case yp:
              return {
                name: yp,
                properties: [
                  { name: "cardinality" },
                  { name: "lookahead" },
                  { name: "rule" },
                ],
              };
            case xp:
              return {
                name: xp,
                properties: [
                  { name: "cardinality" },
                  { name: "elements", defaultValue: [] },
                  { name: "lookahead" },
                ],
              };
            case bp:
              return {
                name: bp,
                properties: [
                  { name: "cardinality" },
                  { name: "lookahead" },
                  { name: "terminal" },
                ],
              };
            case kp:
              return {
                name: kp,
                properties: [{ name: "cardinality" }, { name: "lookahead" }],
              };
            default:
              return { name: t, properties: [] };
          }
        }
      }),
        (Re = new Tp()));
    });
  var TT = {};
  Oe(TT, {
    assignMandatoryProperties: () => D6,
    copyAstNode: () => R6,
    findLocalReferences: () => k3t,
    findRootNode: () => o1,
    getContainerOfType: () => _h,
    getDocument: () => Si,
    hasContainerOfType: () => b3t,
    linkContentToContainer: () => kT,
    streamAllContents: () => Fo,
    streamAst: () => ua,
    streamContents: () => l1,
    streamReferences: () => Sp,
  });
  function kT(e) {
    for (let [t, r] of Object.entries(e))
      t.startsWith("$") ||
        (Array.isArray(r)
          ? r.forEach((n, i) => {
              cn(n) &&
                ((n.$container = e),
                (n.$containerProperty = t),
                (n.$containerIndex = i));
            })
          : cn(r) && ((r.$container = e), (r.$containerProperty = t)));
  }
  function _h(e, t) {
    let r = e;
    for (; r; ) {
      if (t(r)) return r;
      r = r.$container;
    }
  }
  function b3t(e, t) {
    let r = e;
    for (; r; ) {
      if (t(r)) return !0;
      r = r.$container;
    }
    return !1;
  }
  function Si(e) {
    let r = o1(e).$document;
    if (!r) throw new Error("AST node has no document.");
    return r;
  }
  function o1(e) {
    for (; e.$container; ) e = e.$container;
    return e;
  }
  function l1(e, t) {
    if (!e) throw new Error("Node must be an AstNode.");
    let r = t?.range;
    return new Ns(
      () => ({ keys: Object.keys(e), keyIndex: 0, arrayIndex: 0 }),
      (n) => {
        for (; n.keyIndex < n.keys.length; ) {
          let i = n.keys[n.keyIndex];
          if (!i.startsWith("$")) {
            let s = e[i];
            if (cn(s)) {
              if ((n.keyIndex++, L6(s, r))) return { done: !1, value: s };
            } else if (Array.isArray(s)) {
              for (; n.arrayIndex < s.length; ) {
                let o = n.arrayIndex++,
                  l = s[o];
                if (cn(l) && L6(l, r)) return { done: !1, value: l };
              }
              n.arrayIndex = 0;
            }
          }
          n.keyIndex++;
        }
        return ki;
      },
    );
  }
  function Fo(e, t) {
    if (!e) throw new Error("Root node must be an AstNode.");
    return new Mo(e, (r) => l1(r, t));
  }
  function ua(e, t) {
    if (e) {
      if (t?.range && !L6(e, t.range)) return new Mo(e, () => []);
    } else throw new Error("Root node must be an AstNode.");
    return new Mo(e, (r) => l1(r, t), { includeRoot: !0 });
  }
  function L6(e, t) {
    var r;
    if (!t) return !0;
    let n = (r = e.$cstNode) === null || r === void 0 ? void 0 : r.range;
    return n ? c6(n, t) : !1;
  }
  function Sp(e) {
    return new Ns(
      () => ({ keys: Object.keys(e), keyIndex: 0, arrayIndex: 0 }),
      (t) => {
        for (; t.keyIndex < t.keys.length; ) {
          let r = t.keys[t.keyIndex];
          if (!r.startsWith("$")) {
            let n = e[r];
            if (li(n))
              return (
                t.keyIndex++,
                { done: !1, value: { reference: n, container: e, property: r } }
              );
            if (Array.isArray(n)) {
              for (; t.arrayIndex < n.length; ) {
                let i = t.arrayIndex++,
                  s = n[i];
                if (li(s))
                  return {
                    done: !1,
                    value: {
                      reference: s,
                      container: e,
                      property: r,
                      index: i,
                    },
                  };
              }
              t.arrayIndex = 0;
            }
          }
          t.keyIndex++;
        }
        return ki;
      },
    );
  }
  function k3t(e, t = Si(e).parseResult.value) {
    let r = [];
    return (
      ua(t).forEach((n) => {
        Sp(n).forEach((i) => {
          i.reference.ref === e && r.push(i.reference);
        });
      }),
      kr(r)
    );
  }
  function D6(e, t) {
    let r = e.getTypeMetaData(t.$type),
      n = t;
    for (let i of r.properties)
      i.defaultValue !== void 0 &&
        n[i.name] === void 0 &&
        (n[i.name] = LK(i.defaultValue));
  }
  function LK(e) {
    return Array.isArray(e) ? [...e.map(LK)] : e;
  }
  function R6(e, t) {
    let r = { $type: e.$type };
    for (let [n, i] of Object.entries(e))
      if (!n.startsWith("$"))
        if (cn(i)) r[n] = R6(i, t);
        else if (li(i)) r[n] = t(r, n, i.$refNode, i.$refText);
        else if (Array.isArray(i)) {
          let s = [];
          for (let o of i)
            cn(o)
              ? s.push(R6(o, t))
              : li(o)
                ? s.push(t(r, n, o.$refNode, o.$refText))
                : s.push(o);
          r[n] = s;
        } else r[n] = i;
    return (kT(r), r);
  }
  var Vi = x(() => {
    "use strict";
    Wa();
    ms();
    Ua();
    a(kT, "linkContentToContainer");
    a(_h, "getContainerOfType");
    a(b3t, "hasContainerOfType");
    a(Si, "getDocument");
    a(o1, "findRootNode");
    a(l1, "streamContents");
    a(Fo, "streamAllContents");
    a(ua, "streamAst");
    a(L6, "isAstNodeInRange");
    a(Sp, "streamReferences");
    a(k3t, "findLocalReferences");
    a(D6, "assignMandatoryProperties");
    a(LK, "copyDefaultValue");
    a(R6, "copyAstNode");
  });
  function ve(e) {
    return e.charCodeAt(0);
  }
  function ST(e, t) {
    Array.isArray(e)
      ? e.forEach(function (r) {
          t.push(r);
        })
      : t.push(e);
  }
  function _p(e, t) {
    if (e[t] === !0) throw "duplicate flag " + t;
    let r = e[t];
    e[t] = !0;
  }
  function Ch(e) {
    if (e === void 0) throw Error("Internal Error - Should never get here!");
    return !0;
  }
  function c1() {
    throw Error("Internal Error - Should never get here!");
  }
  function N6(e) {
    return e.type === "Character";
  }
  var I6 = x(() => {
    "use strict";
    a(ve, "cc");
    a(ST, "insertToSet");
    a(_p, "addFlag");
    a(Ch, "ASSERT_EXISTS");
    a(c1, "ASSERT_NEVER_REACH_HERE");
    a(N6, "isCharacter");
  });
  var u1,
    h1,
    M6,
    RK = x(() => {
      "use strict";
      I6();
      u1 = [];
      for (let e = ve("0"); e <= ve("9"); e++) u1.push(e);
      h1 = [ve("_")].concat(u1);
      for (let e = ve("a"); e <= ve("z"); e++) h1.push(e);
      for (let e = ve("A"); e <= ve("Z"); e++) h1.push(e);
      M6 = [
        ve(" "),
        ve("\f"),
        ve(`
`),
        ve("\r"),
        ve("	"),
        ve("\v"),
        ve("	"),
        ve("\xA0"),
        ve("\u1680"),
        ve("\u2000"),
        ve("\u2001"),
        ve("\u2002"),
        ve("\u2003"),
        ve("\u2004"),
        ve("\u2005"),
        ve("\u2006"),
        ve("\u2007"),
        ve("\u2008"),
        ve("\u2009"),
        ve("\u200A"),
        ve("\u2028"),
        ve("\u2029"),
        ve("\u202F"),
        ve("\u205F"),
        ve("\u3000"),
        ve("\uFEFF"),
      ];
    });
  var T3t,
    _T,
    S3t,
    wh,
    DK = x(() => {
      "use strict";
      I6();
      RK();
      ((T3t = /[0-9a-fA-F]/),
        (_T = /[0-9]/),
        (S3t = /[1-9]/),
        (wh = class {
          static {
            a(this, "RegExpParser");
          }
          constructor() {
            ((this.idx = 0), (this.input = ""), (this.groupIdx = 0));
          }
          saveState() {
            return {
              idx: this.idx,
              input: this.input,
              groupIdx: this.groupIdx,
            };
          }
          restoreState(t) {
            ((this.idx = t.idx),
              (this.input = t.input),
              (this.groupIdx = t.groupIdx));
          }
          pattern(t) {
            ((this.idx = 0),
              (this.input = t),
              (this.groupIdx = 0),
              this.consumeChar("/"));
            let r = this.disjunction();
            this.consumeChar("/");
            let n = {
              type: "Flags",
              loc: { begin: this.idx, end: t.length },
              global: !1,
              ignoreCase: !1,
              multiLine: !1,
              unicode: !1,
              sticky: !1,
            };
            for (; this.isRegExpFlag(); )
              switch (this.popChar()) {
                case "g":
                  _p(n, "global");
                  break;
                case "i":
                  _p(n, "ignoreCase");
                  break;
                case "m":
                  _p(n, "multiLine");
                  break;
                case "u":
                  _p(n, "unicode");
                  break;
                case "y":
                  _p(n, "sticky");
                  break;
              }
            if (this.idx !== this.input.length)
              throw Error("Redundant input: " + this.input.substring(this.idx));
            return { type: "Pattern", flags: n, value: r, loc: this.loc(0) };
          }
          disjunction() {
            let t = [],
              r = this.idx;
            for (t.push(this.alternative()); this.peekChar() === "|"; )
              (this.consumeChar("|"), t.push(this.alternative()));
            return { type: "Disjunction", value: t, loc: this.loc(r) };
          }
          alternative() {
            let t = [],
              r = this.idx;
            for (; this.isTerm(); ) t.push(this.term());
            return { type: "Alternative", value: t, loc: this.loc(r) };
          }
          term() {
            return this.isAssertion() ? this.assertion() : this.atom();
          }
          assertion() {
            let t = this.idx;
            switch (this.popChar()) {
              case "^":
                return { type: "StartAnchor", loc: this.loc(t) };
              case "$":
                return { type: "EndAnchor", loc: this.loc(t) };
              case "\\":
                switch (this.popChar()) {
                  case "b":
                    return { type: "WordBoundary", loc: this.loc(t) };
                  case "B":
                    return { type: "NonWordBoundary", loc: this.loc(t) };
                }
                throw Error("Invalid Assertion Escape");
              case "(":
                this.consumeChar("?");
                let r;
                switch (this.popChar()) {
                  case "=":
                    r = "Lookahead";
                    break;
                  case "!":
                    r = "NegativeLookahead";
                    break;
                }
                Ch(r);
                let n = this.disjunction();
                return (
                  this.consumeChar(")"),
                  { type: r, value: n, loc: this.loc(t) }
                );
            }
            return c1();
          }
          quantifier(t = !1) {
            let r,
              n = this.idx;
            switch (this.popChar()) {
              case "*":
                r = { atLeast: 0, atMost: 1 / 0 };
                break;
              case "+":
                r = { atLeast: 1, atMost: 1 / 0 };
                break;
              case "?":
                r = { atLeast: 0, atMost: 1 };
                break;
              case "{":
                let i = this.integerIncludingZero();
                switch (this.popChar()) {
                  case "}":
                    r = { atLeast: i, atMost: i };
                    break;
                  case ",":
                    let s;
                    (this.isDigit()
                      ? ((s = this.integerIncludingZero()),
                        (r = { atLeast: i, atMost: s }))
                      : (r = { atLeast: i, atMost: 1 / 0 }),
                      this.consumeChar("}"));
                    break;
                }
                if (t === !0 && r === void 0) return;
                Ch(r);
                break;
            }
            if (!(t === !0 && r === void 0) && Ch(r))
              return (
                this.peekChar(0) === "?"
                  ? (this.consumeChar("?"), (r.greedy = !1))
                  : (r.greedy = !0),
                (r.type = "Quantifier"),
                (r.loc = this.loc(n)),
                r
              );
          }
          atom() {
            let t,
              r = this.idx;
            switch (this.peekChar()) {
              case ".":
                t = this.dotAll();
                break;
              case "\\":
                t = this.atomEscape();
                break;
              case "[":
                t = this.characterClass();
                break;
              case "(":
                t = this.group();
                break;
            }
            return (
              t === void 0 &&
                this.isPatternCharacter() &&
                (t = this.patternCharacter()),
              Ch(t)
                ? ((t.loc = this.loc(r)),
                  this.isQuantifier() && (t.quantifier = this.quantifier()),
                  t)
                : c1()
            );
          }
          dotAll() {
            return (
              this.consumeChar("."),
              {
                type: "Set",
                complement: !0,
                value: [
                  ve(`
`),
                  ve("\r"),
                  ve("\u2028"),
                  ve("\u2029"),
                ],
              }
            );
          }
          atomEscape() {
            switch ((this.consumeChar("\\"), this.peekChar())) {
              case "1":
              case "2":
              case "3":
              case "4":
              case "5":
              case "6":
              case "7":
              case "8":
              case "9":
                return this.decimalEscapeAtom();
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          }
          decimalEscapeAtom() {
            return {
              type: "GroupBackReference",
              value: this.positiveInteger(),
            };
          }
          characterClassEscape() {
            let t,
              r = !1;
            switch (this.popChar()) {
              case "d":
                t = u1;
                break;
              case "D":
                ((t = u1), (r = !0));
                break;
              case "s":
                t = M6;
                break;
              case "S":
                ((t = M6), (r = !0));
                break;
              case "w":
                t = h1;
                break;
              case "W":
                ((t = h1), (r = !0));
                break;
            }
            return Ch(t) ? { type: "Set", value: t, complement: r } : c1();
          }
          controlEscapeAtom() {
            let t;
            switch (this.popChar()) {
              case "f":
                t = ve("\f");
                break;
              case "n":
                t = ve(`
`);
                break;
              case "r":
                t = ve("\r");
                break;
              case "t":
                t = ve("	");
                break;
              case "v":
                t = ve("\v");
                break;
            }
            return Ch(t) ? { type: "Character", value: t } : c1();
          }
          controlLetterEscapeAtom() {
            this.consumeChar("c");
            let t = this.popChar();
            if (/[a-zA-Z]/.test(t) === !1) throw Error("Invalid ");
            return {
              type: "Character",
              value: t.toUpperCase().charCodeAt(0) - 64,
            };
          }
          nulCharacterAtom() {
            return (
              this.consumeChar("0"),
              { type: "Character", value: ve("\0") }
            );
          }
          hexEscapeSequenceAtom() {
            return (this.consumeChar("x"), this.parseHexDigits(2));
          }
          regExpUnicodeEscapeSequenceAtom() {
            return (this.consumeChar("u"), this.parseHexDigits(4));
          }
          identityEscapeAtom() {
            let t = this.popChar();
            return { type: "Character", value: ve(t) };
          }
          classPatternCharacterAtom() {
            switch (this.peekChar()) {
              case `
`:
              case "\r":
              case "\u2028":
              case "\u2029":
              case "\\":
              case "]":
                throw Error("TBD");
              default:
                let t = this.popChar();
                return { type: "Character", value: ve(t) };
            }
          }
          characterClass() {
            let t = [],
              r = !1;
            for (
              this.consumeChar("["),
                this.peekChar(0) === "^" && (this.consumeChar("^"), (r = !0));
              this.isClassAtom();

            ) {
              let n = this.classAtom(),
                i = n.type === "Character";
              if (N6(n) && this.isRangeDash()) {
                this.consumeChar("-");
                let s = this.classAtom(),
                  o = s.type === "Character";
                if (N6(s)) {
                  if (s.value < n.value)
                    throw Error("Range out of order in character class");
                  t.push({ from: n.value, to: s.value });
                } else (ST(n.value, t), t.push(ve("-")), ST(s.value, t));
              } else ST(n.value, t);
            }
            return (
              this.consumeChar("]"),
              { type: "Set", complement: r, value: t }
            );
          }
          classAtom() {
            switch (this.peekChar()) {
              case "]":
              case `
`:
              case "\r":
              case "\u2028":
              case "\u2029":
                throw Error("TBD");
              case "\\":
                return this.classEscape();
              default:
                return this.classPatternCharacterAtom();
            }
          }
          classEscape() {
            switch ((this.consumeChar("\\"), this.peekChar())) {
              case "b":
                return (
                  this.consumeChar("b"),
                  { type: "Character", value: ve("\b") }
                );
              case "d":
              case "D":
              case "s":
              case "S":
              case "w":
              case "W":
                return this.characterClassEscape();
              case "f":
              case "n":
              case "r":
              case "t":
              case "v":
                return this.controlEscapeAtom();
              case "c":
                return this.controlLetterEscapeAtom();
              case "0":
                return this.nulCharacterAtom();
              case "x":
                return this.hexEscapeSequenceAtom();
              case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
              default:
                return this.identityEscapeAtom();
            }
          }
          group() {
            let t = !0;
            switch ((this.consumeChar("("), this.peekChar(0))) {
              case "?":
                (this.consumeChar("?"), this.consumeChar(":"), (t = !1));
                break;
              default:
                this.groupIdx++;
                break;
            }
            let r = this.disjunction();
            this.consumeChar(")");
            let n = { type: "Group", capturing: t, value: r };
            return (t && (n.idx = this.groupIdx), n);
          }
          positiveInteger() {
            let t = this.popChar();
            if (S3t.test(t) === !1) throw Error("Expecting a positive integer");
            for (; _T.test(this.peekChar(0)); ) t += this.popChar();
            return parseInt(t, 10);
          }
          integerIncludingZero() {
            let t = this.popChar();
            if (_T.test(t) === !1) throw Error("Expecting an integer");
            for (; _T.test(this.peekChar(0)); ) t += this.popChar();
            return parseInt(t, 10);
          }
          patternCharacter() {
            let t = this.popChar();
            switch (t) {
              case `
`:
              case "\r":
              case "\u2028":
              case "\u2029":
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
                throw Error("TBD");
              default:
                return { type: "Character", value: ve(t) };
            }
          }
          isRegExpFlag() {
            switch (this.peekChar(0)) {
              case "g":
              case "i":
              case "m":
              case "u":
              case "y":
                return !0;
              default:
                return !1;
            }
          }
          isRangeDash() {
            return this.peekChar() === "-" && this.isClassAtom(1);
          }
          isDigit() {
            return _T.test(this.peekChar(0));
          }
          isClassAtom(t = 0) {
            switch (this.peekChar(t)) {
              case "]":
              case `
`:
              case "\r":
              case "\u2028":
              case "\u2029":
                return !1;
              default:
                return !0;
            }
          }
          isTerm() {
            return this.isAtom() || this.isAssertion();
          }
          isAtom() {
            if (this.isPatternCharacter()) return !0;
            switch (this.peekChar(0)) {
              case ".":
              case "\\":
              case "[":
              case "(":
                return !0;
              default:
                return !1;
            }
          }
          isAssertion() {
            switch (this.peekChar(0)) {
              case "^":
              case "$":
                return !0;
              case "\\":
                switch (this.peekChar(1)) {
                  case "b":
                  case "B":
                    return !0;
                  default:
                    return !1;
                }
              case "(":
                return (
                  this.peekChar(1) === "?" &&
                  (this.peekChar(2) === "=" || this.peekChar(2) === "!")
                );
              default:
                return !1;
            }
          }
          isQuantifier() {
            let t = this.saveState();
            try {
              return this.quantifier(!0) !== void 0;
            } catch {
              return !1;
            } finally {
              this.restoreState(t);
            }
          }
          isPatternCharacter() {
            switch (this.peekChar()) {
              case "^":
              case "$":
              case "\\":
              case ".":
              case "*":
              case "+":
              case "?":
              case "(":
              case ")":
              case "[":
              case "|":
              case "/":
              case `
`:
              case "\r":
              case "\u2028":
              case "\u2029":
                return !1;
              default:
                return !0;
            }
          }
          parseHexDigits(t) {
            let r = "";
            for (let i = 0; i < t; i++) {
              let s = this.popChar();
              if (T3t.test(s) === !1)
                throw Error("Expecting a HexDecimal digits");
              r += s;
            }
            return { type: "Character", value: parseInt(r, 16) };
          }
          peekChar(t = 0) {
            return this.input[this.idx + t];
          }
          popChar() {
            let t = this.peekChar(0);
            return (this.consumeChar(void 0), t);
          }
          consumeChar(t) {
            if (t !== void 0 && this.input[this.idx] !== t)
              throw Error(
                "Expected: '" +
                  t +
                  "' but found: '" +
                  this.input[this.idx] +
                  "' at offset: " +
                  this.idx,
              );
            if (this.idx >= this.input.length)
              throw Error("Unexpected end of input");
            this.idx++;
          }
          loc(t) {
            return { begin: t, end: this.idx };
          }
        }));
    });
  var $o,
    NK = x(() => {
      "use strict";
      $o = class {
        static {
          a(this, "BaseRegExpVisitor");
        }
        visitChildren(t) {
          for (let r in t) {
            let n = t[r];
            t.hasOwnProperty(r) &&
              (n.type !== void 0
                ? this.visit(n)
                : Array.isArray(n) &&
                  n.forEach((i) => {
                    this.visit(i);
                  }, this));
          }
        }
        visit(t) {
          switch (t.type) {
            case "Pattern":
              this.visitPattern(t);
              break;
            case "Flags":
              this.visitFlags(t);
              break;
            case "Disjunction":
              this.visitDisjunction(t);
              break;
            case "Alternative":
              this.visitAlternative(t);
              break;
            case "StartAnchor":
              this.visitStartAnchor(t);
              break;
            case "EndAnchor":
              this.visitEndAnchor(t);
              break;
            case "WordBoundary":
              this.visitWordBoundary(t);
              break;
            case "NonWordBoundary":
              this.visitNonWordBoundary(t);
              break;
            case "Lookahead":
              this.visitLookahead(t);
              break;
            case "NegativeLookahead":
              this.visitNegativeLookahead(t);
              break;
            case "Character":
              this.visitCharacter(t);
              break;
            case "Set":
              this.visitSet(t);
              break;
            case "Group":
              this.visitGroup(t);
              break;
            case "GroupBackReference":
              this.visitGroupBackReference(t);
              break;
            case "Quantifier":
              this.visitQuantifier(t);
              break;
          }
          this.visitChildren(t);
        }
        visitPattern(t) {}
        visitFlags(t) {}
        visitDisjunction(t) {}
        visitAlternative(t) {}
        visitStartAnchor(t) {}
        visitEndAnchor(t) {}
        visitWordBoundary(t) {}
        visitNonWordBoundary(t) {}
        visitLookahead(t) {}
        visitNegativeLookahead(t) {}
        visitCharacter(t) {}
        visitSet(t) {}
        visitGroup(t) {}
        visitGroupBackReference(t) {}
        visitQuantifier(t) {}
      };
    });
  var f1 = x(() => {
    "use strict";
    DK();
    NK();
  });
  var CT = {};
  Oe(CT, {
    NEWLINE_REGEXP: () => P6,
    escapeRegExp: () => Eh,
    getCaseInsensitivePattern: () => F6,
    getTerminalParts: () => _3t,
    isMultilineComment: () => B6,
    isWhitespace: () => Cp,
    partialMatches: () => $6,
    partialRegExp: () => OK,
    whitespaceCharacters: () => MK,
  });
  function _3t(e) {
    try {
      (typeof e != "string" && (e = e.source), (e = `/${e}/`));
      let t = IK.pattern(e),
        r = [];
      for (let n of t.value.value)
        (vh.reset(e),
          vh.visit(n),
          r.push({ start: vh.startRegexp, end: vh.endRegex }));
      return r;
    } catch {
      return [];
    }
  }
  function B6(e) {
    try {
      return (
        typeof e == "string" && (e = new RegExp(e)),
        (e = e.toString()),
        vh.reset(e),
        vh.visit(IK.pattern(e)),
        vh.multiline
      );
    } catch {
      return !1;
    }
  }
  function Cp(e) {
    let t = typeof e == "string" ? new RegExp(e) : e;
    return MK.some((r) => t.test(r));
  }
  function Eh(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  function F6(e) {
    return Array.prototype.map
      .call(e, (t) =>
        /\w/.test(t) ? `[${t.toLowerCase()}${t.toUpperCase()}]` : Eh(t),
      )
      .join("");
  }
  function $6(e, t) {
    let r = OK(e),
      n = t.match(r);
    return !!n && n[0].length > 0;
  }
  function OK(e) {
    typeof e == "string" && (e = new RegExp(e));
    let t = e,
      r = e.source,
      n = 0;
    function i() {
      let s = "",
        o;
      function l(h) {
        ((s += r.substr(n, h)), (n += h));
      }
      a(l, "appendRaw");
      function u(h) {
        ((s += "(?:" + r.substr(n, h) + "|$)"), (n += h));
      }
      for (a(u, "appendOptional"); n < r.length; )
        switch (r[n]) {
          case "\\":
            switch (r[n + 1]) {
              case "c":
                u(3);
                break;
              case "x":
                u(4);
                break;
              case "u":
                t.unicode
                  ? r[n + 2] === "{"
                    ? u(r.indexOf("}", n) - n + 1)
                    : u(6)
                  : u(2);
                break;
              case "p":
              case "P":
                t.unicode ? u(r.indexOf("}", n) - n + 1) : u(2);
                break;
              case "k":
                u(r.indexOf(">", n) - n + 1);
                break;
              default:
                u(2);
                break;
            }
            break;
          case "[":
            ((o = /\[(?:\\.|.)*?\]/g),
              (o.lastIndex = n),
              (o = o.exec(r) || []),
              u(o[0].length));
            break;
          case "|":
          case "^":
          case "$":
          case "*":
          case "+":
          case "?":
            l(1);
            break;
          case "{":
            ((o = /\{\d+,?\d*\}/g),
              (o.lastIndex = n),
              (o = o.exec(r)),
              o ? l(o[0].length) : u(1));
            break;
          case "(":
            if (r[n + 1] === "?")
              switch (r[n + 2]) {
                case ":":
                  ((s += "(?:"), (n += 3), (s += i() + "|$)"));
                  break;
                case "=":
                  ((s += "(?="), (n += 3), (s += i() + ")"));
                  break;
                case "!":
                  ((o = n), (n += 3), i(), (s += r.substr(o, n - o)));
                  break;
                case "<":
                  switch (r[n + 3]) {
                    case "=":
                    case "!":
                      ((o = n), (n += 4), i(), (s += r.substr(o, n - o)));
                      break;
                    default:
                      (l(r.indexOf(">", n) - n + 1), (s += i() + "|$)"));
                      break;
                  }
                  break;
              }
            else (l(1), (s += i() + "|$)"));
            break;
          case ")":
            return (++n, s);
          default:
            u(1);
            break;
        }
      return s;
    }
    return (a(i, "process"), new RegExp(i(), e.flags));
  }
  var P6,
    IK,
    O6,
    vh,
    MK,
    wp = x(() => {
      "use strict";
      f1();
      ((P6 = /\r?\n/gm),
        (IK = new wh()),
        (O6 = class extends $o {
          static {
            a(this, "TerminalRegExpVisitor");
          }
          constructor() {
            (super(...arguments),
              (this.isStarting = !0),
              (this.endRegexpStack = []),
              (this.multiline = !1));
          }
          get endRegex() {
            return this.endRegexpStack.join("");
          }
          reset(t) {
            ((this.multiline = !1),
              (this.regex = t),
              (this.startRegexp = ""),
              (this.isStarting = !0),
              (this.endRegexpStack = []));
          }
          visitGroup(t) {
            t.quantifier &&
              ((this.isStarting = !1), (this.endRegexpStack = []));
          }
          visitCharacter(t) {
            let r = String.fromCharCode(t.value);
            if (
              (!this.multiline &&
                r ===
                  `
` &&
                (this.multiline = !0),
              t.quantifier)
            )
              ((this.isStarting = !1), (this.endRegexpStack = []));
            else {
              let n = Eh(r);
              (this.endRegexpStack.push(n),
                this.isStarting && (this.startRegexp += n));
            }
          }
          visitSet(t) {
            if (!this.multiline) {
              let r = this.regex.substring(t.loc.begin, t.loc.end),
                n = new RegExp(r);
              this.multiline = !!`
`.match(n);
            }
            if (t.quantifier)
              ((this.isStarting = !1), (this.endRegexpStack = []));
            else {
              let r = this.regex.substring(t.loc.begin, t.loc.end);
              (this.endRegexpStack.push(r),
                this.isStarting && (this.startRegexp += r));
            }
          }
          visitChildren(t) {
            (t.type === "Group" && t.quantifier) || super.visitChildren(t);
          }
        }),
        (vh = new O6()));
      a(_3t, "getTerminalParts");
      a(B6, "isMultilineComment");
      MK = `\f
\r	\v \xA0\u1680\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u2028\u2029\u202F\u205F\u3000\uFEFF`.split(
        "",
      );
      a(Cp, "isWhitespace");
      a(Eh, "escapeRegExp");
      a(F6, "getCaseInsensitivePattern");
      a($6, "partialMatches");
      a(OK, "partialRegExp");
    });
  var vT = {};
  Oe(vT, {
    findAssignment: () => Y6,
    findNameAssignment: () => wT,
    findNodeForKeyword: () => q6,
    findNodeForProperty: () => p1,
    findNodesForKeyword: () => C3t,
    findNodesForKeywordInternal: () => H6,
    findNodesForProperty: () => U6,
    getActionAtElement: () => GK,
    getActionType: () => zK,
    getAllReachableRules: () => d1,
    getCrossReferenceTerminal: () => z6,
    getEntryRule: () => PK,
    getExplicitRuleType: () => vp,
    getHiddenRules: () => BK,
    getRuleType: () => X6,
    getRuleTypeName: () => L3t,
    getTypeName: () => g1,
    isArrayCardinality: () => v3t,
    isArrayOperator: () => E3t,
    isCommentTerminal: () => W6,
    isDataType: () => A3t,
    isDataTypeRule: () => m1,
    isOptionalCardinality: () => w3t,
    terminalRegex: () => Ep,
  });
  function PK(e) {
    return e.rules.find((t) => Ti(t) && t.entry);
  }
  function BK(e) {
    return e.rules.filter((t) => Is(t) && t.hidden);
  }
  function d1(e, t) {
    let r = new Set(),
      n = PK(e);
    if (!n) return new Set(e.rules);
    let i = [n].concat(BK(e));
    for (let o of i) FK(o, r, t);
    let s = new Set();
    for (let o of e.rules) (r.has(o.name) || (Is(o) && o.hidden)) && s.add(o);
    return s;
  }
  function FK(e, t, r) {
    (t.add(e.name),
      Fo(e).forEach((n) => {
        if (qa(n) || (r && xT(n))) {
          let i = n.rule.ref;
          i && !t.has(i.name) && FK(i, t, r);
        }
      }));
  }
  function z6(e) {
    if (e.terminal) return e.terminal;
    if (e.type.ref) {
      let t = wT(e.type.ref);
      return t?.terminal;
    }
  }
  function W6(e) {
    return e.hidden && !Cp(Ep(e));
  }
  function U6(e, t) {
    return !e || !t ? [] : j6(e, t, e.astNode, !0);
  }
  function p1(e, t, r) {
    if (!e || !t) return;
    let n = j6(e, t, e.astNode, !0);
    if (n.length !== 0)
      return (
        r !== void 0 ? (r = Math.max(0, Math.min(r, n.length - 1))) : (r = 0),
        n[r]
      );
  }
  function j6(e, t, r, n) {
    if (!n) {
      let i = _h(e.grammarSource, ja);
      if (i && i.feature === t) return [e];
    }
    return za(e) && e.astNode === r
      ? e.content.flatMap((i) => j6(i, t, r, !1))
      : [];
  }
  function C3t(e, t) {
    return e ? H6(e, t, e?.astNode) : [];
  }
  function q6(e, t, r) {
    if (!e) return;
    let n = H6(e, t, e?.astNode);
    if (n.length !== 0)
      return (
        r !== void 0 ? (r = Math.max(0, Math.min(r, n.length - 1))) : (r = 0),
        n[r]
      );
  }
  function H6(e, t, r) {
    if (e.astNode !== r) return [];
    if (ca(e.grammarSource) && e.grammarSource.value === t) return [e];
    let n = xh(e).iterator(),
      i,
      s = [];
    do
      if (((i = n.next()), !i.done)) {
        let o = i.value;
        o.astNode === r
          ? ca(o.grammarSource) && o.grammarSource.value === t && s.push(o)
          : n.prune();
      }
    while (!i.done);
    return s;
  }
  function Y6(e) {
    var t;
    let r = e.astNode;
    for (
      ;
      r === ((t = e.container) === null || t === void 0 ? void 0 : t.astNode);

    ) {
      let n = _h(e.grammarSource, ja);
      if (n) return n;
      e = e.container;
    }
  }
  function wT(e) {
    let t = e;
    return (
      pT(t) &&
        (_l(t.$container)
          ? (t = t.$container.$container)
          : Ti(t.$container)
            ? (t = t.$container)
            : Po(t.$container)),
      $K(e, t, new Map())
    );
  }
  function $K(e, t, r) {
    var n;
    function i(s, o) {
      let l;
      return (_h(s, ja) || (l = $K(o, o, r)), r.set(e, l), l);
    }
    if ((a(i, "go"), r.has(e))) return r.get(e);
    r.set(e, void 0);
    for (let s of Fo(t)) {
      if (ja(s) && s.feature.toLowerCase() === "name") return (r.set(e, s), s);
      if (qa(s) && Ti(s.rule.ref)) return i(s, s.rule.ref);
      if (gT(s) && !((n = s.typeRef) === null || n === void 0) && n.ref)
        return i(s, s.typeRef.ref);
    }
  }
  function GK(e) {
    let t = e.$container;
    if (Wc(t)) {
      let r = t.elements,
        n = r.indexOf(e);
      for (let i = n - 1; i >= 0; i--) {
        let s = r[i];
        if (_l(s)) return s;
        {
          let o = Fo(r[i]).find(_l);
          if (o) return o;
        }
      }
    }
    if (i1(t)) return GK(t);
  }
  function w3t(e, t) {
    return e === "?" || e === "*" || (Wc(t) && !!t.guardCondition);
  }
  function v3t(e) {
    return e === "*" || e === "+";
  }
  function E3t(e) {
    return e === "+=";
  }
  function m1(e) {
    return VK(e, new Set());
  }
  function VK(e, t) {
    if (t.has(e)) return !0;
    t.add(e);
    for (let r of Fo(e))
      if (qa(r)) {
        if (!r.rule.ref || (Ti(r.rule.ref) && !VK(r.rule.ref, t))) return !1;
      } else {
        if (ja(r)) return !1;
        if (_l(r)) return !1;
      }
    return !!e.definition;
  }
  function A3t(e) {
    return V6(e.type, new Set());
  }
  function V6(e, t) {
    if (t.has(e)) return !0;
    if ((t.add(e), f6(e))) return !1;
    if (x6(e)) return !1;
    if (k6(e)) return e.types.every((r) => V6(r, t));
    if (gT(e)) {
      if (e.primitiveType !== void 0) return !0;
      if (e.stringType !== void 0) return !0;
      if (e.typeRef !== void 0) {
        let r = e.typeRef.ref;
        return s1(r) ? V6(r.type, t) : !1;
      } else return !1;
    } else return !1;
  }
  function vp(e) {
    if (e.inferredType) return e.inferredType.name;
    if (e.dataType) return e.dataType;
    if (e.returnType) {
      let t = e.returnType.ref;
      if (t) {
        if (Ti(t)) return t.name;
        if (mT(t) || s1(t)) return t.name;
      }
    }
  }
  function g1(e) {
    var t;
    if (Ti(e))
      return m1(e) ? e.name : (t = vp(e)) !== null && t !== void 0 ? t : e.name;
    if (mT(e) || s1(e) || b6(e)) return e.name;
    if (_l(e)) {
      let r = zK(e);
      if (r) return r;
    } else if (pT(e)) return e.name;
    throw new Error("Cannot get name of Unknown Type");
  }
  function zK(e) {
    var t;
    if (e.inferredType) return e.inferredType.name;
    if (!((t = e.type) === null || t === void 0) && t.ref)
      return g1(e.type.ref);
  }
  function L3t(e) {
    var t, r, n;
    return Is(e)
      ? (r = (t = e.type) === null || t === void 0 ? void 0 : t.name) !==
          null && r !== void 0
        ? r
        : "string"
      : m1(e)
        ? e.name
        : (n = vp(e)) !== null && n !== void 0
          ? n
          : e.name;
  }
  function X6(e) {
    var t, r, n;
    return Is(e)
      ? (r = (t = e.type) === null || t === void 0 ? void 0 : t.name) !==
          null && r !== void 0
        ? r
        : "string"
      : (n = vp(e)) !== null && n !== void 0
        ? n
        : e.name;
  }
  function Ep(e) {
    let t = { s: !1, i: !1, u: !1 },
      r = Ap(e.definition, t),
      n = Object.entries(t)
        .filter(([, i]) => i)
        .map(([i]) => i)
        .join("");
    return new RegExp(r, n);
  }
  function Ap(e, t) {
    if (w6(e)) return R3t(e);
    if (v6(e)) return D3t(e);
    if (T6(e)) return M3t(e);
    if (xT(e)) {
      let r = e.rule.ref;
      if (!r) throw new Error("Missing rule reference.");
      return Cl(Ap(r.definition), {
        cardinality: e.cardinality,
        lookahead: e.lookahead,
      });
    } else {
      if (_6(e)) return I3t(e);
      if (E6(e)) return N3t(e);
      if (C6(e)) {
        let r = e.regex.lastIndexOf("/"),
          n = e.regex.substring(1, r),
          i = e.regex.substring(r + 1);
        return (
          t &&
            ((t.i = i.includes("i")),
            (t.s = i.includes("s")),
            (t.u = i.includes("u"))),
          Cl(n, {
            cardinality: e.cardinality,
            lookahead: e.lookahead,
            wrap: !1,
          })
        );
      } else {
        if (A6(e))
          return Cl(K6, { cardinality: e.cardinality, lookahead: e.lookahead });
        throw new Error(`Invalid terminal element: ${e?.$type}`);
      }
    }
  }
  function R3t(e) {
    return Cl(e.elements.map((t) => Ap(t)).join("|"), {
      cardinality: e.cardinality,
      lookahead: e.lookahead,
    });
  }
  function D3t(e) {
    return Cl(e.elements.map((t) => Ap(t)).join(""), {
      cardinality: e.cardinality,
      lookahead: e.lookahead,
    });
  }
  function N3t(e) {
    return Cl(`${K6}*?${Ap(e.terminal)}`, {
      cardinality: e.cardinality,
      lookahead: e.lookahead,
    });
  }
  function I3t(e) {
    return Cl(`(?!${Ap(e.terminal)})${K6}*?`, {
      cardinality: e.cardinality,
      lookahead: e.lookahead,
    });
  }
  function M3t(e) {
    return e.right
      ? Cl(`[${G6(e.left)}-${G6(e.right)}]`, {
          cardinality: e.cardinality,
          lookahead: e.lookahead,
          wrap: !1,
        })
      : Cl(G6(e.left), {
          cardinality: e.cardinality,
          lookahead: e.lookahead,
          wrap: !1,
        });
  }
  function G6(e) {
    return Eh(e.value);
  }
  function Cl(e, t) {
    var r;
    return (
      (t.wrap !== !1 || t.lookahead) &&
        (e = `(${(r = t.lookahead) !== null && r !== void 0 ? r : ""}${e})`),
      t.cardinality ? `${e}${t.cardinality}` : e
    );
  }
  var K6,
    Ha = x(() => {
      "use strict";
      fT();
      Bo();
      Wa();
      Vi();
      Ua();
      wp();
      a(PK, "getEntryRule");
      a(BK, "getHiddenRules");
      a(d1, "getAllReachableRules");
      a(FK, "ruleDfs");
      a(z6, "getCrossReferenceTerminal");
      a(W6, "isCommentTerminal");
      a(U6, "findNodesForProperty");
      a(p1, "findNodeForProperty");
      a(j6, "findNodesForPropertyInternal");
      a(C3t, "findNodesForKeyword");
      a(q6, "findNodeForKeyword");
      a(H6, "findNodesForKeywordInternal");
      a(Y6, "findAssignment");
      a(wT, "findNameAssignment");
      a($K, "findNameAssignmentInternal");
      a(GK, "getActionAtElement");
      a(w3t, "isOptionalCardinality");
      a(v3t, "isArrayCardinality");
      a(E3t, "isArrayOperator");
      a(m1, "isDataTypeRule");
      a(VK, "isDataTypeRuleInternal");
      a(A3t, "isDataType");
      a(V6, "isDataTypeInternal");
      a(vp, "getExplicitRuleType");
      a(g1, "getTypeName");
      a(zK, "getActionType");
      a(L3t, "getRuleTypeName");
      a(X6, "getRuleType");
      a(Ep, "terminalRegex");
      K6 = /[\s\S]/.source;
      a(Ap, "abstractElementToRegex");
      a(R3t, "terminalAlternativesToRegex");
      a(D3t, "terminalGroupToRegex");
      a(N3t, "untilTokenToRegex");
      a(I3t, "negateTokenToRegex");
      a(M3t, "characterRangeToRegex");
      a(G6, "keywordToRegex");
      a(Cl, "withCardinality");
    });
  function Q6(e) {
    let t = [],
      r = e.Grammar;
    for (let n of r.rules) Is(n) && W6(n) && B6(Ep(n)) && t.push(n.name);
    return { multilineCommentRules: t, nameRegexp: uT };
  }
  var Z6 = x(() => {
    "use strict";
    Ua();
    Ha();
    wp();
    Bo();
    a(Q6, "createGrammarConfig");
  });
  var J6 = x(() => {
    "use strict";
  });
  function Lp(e) {
    console && console.error && console.error(`Error: ${e}`);
  }
  function y1(e) {
    console && console.warn && console.warn(`Warning: ${e}`);
  }
  var WK = x(() => {
    "use strict";
    a(Lp, "PRINT_ERROR");
    a(y1, "PRINT_WARNING");
  });
  function x1(e) {
    let t = new Date().getTime(),
      r = e();
    return { time: new Date().getTime() - t, value: r };
  }
  var UK = x(() => {
    "use strict";
    a(x1, "timer");
  });
  function b1(e) {
    function t() {}
    (a(t, "FakeConstructor"), (t.prototype = e));
    let r = new t();
    function n() {
      return typeof r.bar;
    }
    return (a(n, "fakeAccess"), n(), n(), e);
    (0, eval)(e);
  }
  var jK = x(() => {
    "use strict";
    a(b1, "toFastProperties");
  });
  var Rp = x(() => {
    "use strict";
    WK();
    UK();
    jK();
  });
  function O3t(e) {
    return P3t(e) ? e.LABEL : e.name;
  }
  function P3t(e) {
    return bn(e.LABEL) && e.LABEL !== "";
  }
  function ET(e) {
    return Dt(e, Dp);
  }
  function Dp(e) {
    function t(r) {
      return Dt(r, Dp);
    }
    if ((a(t, "convertDefinition"), e instanceof Cr)) {
      let r = { type: "NonTerminal", name: e.nonTerminalName, idx: e.idx };
      return (bn(e.label) && (r.label = e.label), r);
    } else {
      if (e instanceof Vr)
        return { type: "Alternative", definition: t(e.definition) };
      if (e instanceof wr)
        return { type: "Option", idx: e.idx, definition: t(e.definition) };
      if (e instanceof zr)
        return {
          type: "RepetitionMandatory",
          idx: e.idx,
          definition: t(e.definition),
        };
      if (e instanceof Wr)
        return {
          type: "RepetitionMandatoryWithSeparator",
          idx: e.idx,
          separator: Dp(new je({ terminalType: e.separator })),
          definition: t(e.definition),
        };
      if (e instanceof Mr)
        return {
          type: "RepetitionWithSeparator",
          idx: e.idx,
          separator: Dp(new je({ terminalType: e.separator })),
          definition: t(e.definition),
        };
      if (e instanceof ir)
        return { type: "Repetition", idx: e.idx, definition: t(e.definition) };
      if (e instanceof Or)
        return { type: "Alternation", idx: e.idx, definition: t(e.definition) };
      if (e instanceof je) {
        let r = {
          type: "Terminal",
          name: e.terminalType.name,
          label: O3t(e.terminalType),
          idx: e.idx,
        };
        bn(e.label) && (r.terminalLabel = e.label);
        let n = e.terminalType.PATTERN;
        return (
          e.terminalType.PATTERN && (r.pattern = ia(n) ? n.source : n),
          r
        );
      } else {
        if (e instanceof zi)
          return {
            type: "Rule",
            name: e.name,
            orgText: e.orgText,
            definition: t(e.definition),
          };
        throw Error("non exhaustive match");
      }
    }
  }
  var Ms,
    Cr,
    zi,
    Vr,
    wr,
    zr,
    Wr,
    ir,
    Mr,
    Or,
    je,
    AT = x(() => {
      "use strict";
      he();
      a(O3t, "tokenLabel");
      a(P3t, "hasTokenLabel");
      ((Ms = class {
        static {
          a(this, "AbstractProduction");
        }
        get definition() {
          return this._definition;
        }
        set definition(t) {
          this._definition = t;
        }
        constructor(t) {
          this._definition = t;
        }
        accept(t) {
          (t.visit(this),
            rt(this.definition, (r) => {
              r.accept(t);
            }));
        }
      }),
        (Cr = class extends Ms {
          static {
            a(this, "NonTerminal");
          }
          constructor(t) {
            (super([]),
              (this.idx = 1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
          set definition(t) {}
          get definition() {
            return this.referencedRule !== void 0
              ? this.referencedRule.definition
              : [];
          }
          accept(t) {
            t.visit(this);
          }
        }),
        (zi = class extends Ms {
          static {
            a(this, "Rule");
          }
          constructor(t) {
            (super(t.definition),
              (this.orgText = ""),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (Vr = class extends Ms {
          static {
            a(this, "Alternative");
          }
          constructor(t) {
            (super(t.definition),
              (this.ignoreAmbiguities = !1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (wr = class extends Ms {
          static {
            a(this, "Option");
          }
          constructor(t) {
            (super(t.definition),
              (this.idx = 1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (zr = class extends Ms {
          static {
            a(this, "RepetitionMandatory");
          }
          constructor(t) {
            (super(t.definition),
              (this.idx = 1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (Wr = class extends Ms {
          static {
            a(this, "RepetitionMandatoryWithSeparator");
          }
          constructor(t) {
            (super(t.definition),
              (this.idx = 1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (ir = class extends Ms {
          static {
            a(this, "Repetition");
          }
          constructor(t) {
            (super(t.definition),
              (this.idx = 1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (Mr = class extends Ms {
          static {
            a(this, "RepetitionWithSeparator");
          }
          constructor(t) {
            (super(t.definition),
              (this.idx = 1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (Or = class extends Ms {
          static {
            a(this, "Alternation");
          }
          get definition() {
            return this._definition;
          }
          set definition(t) {
            this._definition = t;
          }
          constructor(t) {
            (super(t.definition),
              (this.idx = 1),
              (this.ignoreAmbiguities = !1),
              (this.hasPredicates = !1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
        }),
        (je = class {
          static {
            a(this, "Terminal");
          }
          constructor(t) {
            ((this.idx = 1),
              si(
                this,
                ps(t, (r) => r !== void 0),
              ));
          }
          accept(t) {
            t.visit(this);
          }
        }));
      a(ET, "serializeGrammar");
      a(Dp, "serializeProduction");
    });
  var Wi,
    qK = x(() => {
      "use strict";
      AT();
      Wi = class {
        static {
          a(this, "GAstVisitor");
        }
        visit(t) {
          let r = t;
          switch (r.constructor) {
            case Cr:
              return this.visitNonTerminal(r);
            case Vr:
              return this.visitAlternative(r);
            case wr:
              return this.visitOption(r);
            case zr:
              return this.visitRepetitionMandatory(r);
            case Wr:
              return this.visitRepetitionMandatoryWithSeparator(r);
            case Mr:
              return this.visitRepetitionWithSeparator(r);
            case ir:
              return this.visitRepetition(r);
            case Or:
              return this.visitAlternation(r);
            case je:
              return this.visitTerminal(r);
            case zi:
              return this.visitRule(r);
            default:
              throw Error("non exhaustive match");
          }
        }
        visitNonTerminal(t) {}
        visitAlternative(t) {}
        visitOption(t) {}
        visitRepetition(t) {}
        visitRepetitionMandatory(t) {}
        visitRepetitionMandatoryWithSeparator(t) {}
        visitRepetitionWithSeparator(t) {}
        visitAlternation(t) {}
        visitTerminal(t) {}
        visitRule(t) {}
      };
    });
  function tL(e) {
    return (
      e instanceof Vr ||
      e instanceof wr ||
      e instanceof ir ||
      e instanceof zr ||
      e instanceof Wr ||
      e instanceof Mr ||
      e instanceof je ||
      e instanceof zi
    );
  }
  function Ah(e, t = []) {
    return e instanceof wr || e instanceof ir || e instanceof Mr
      ? !0
      : e instanceof Or
        ? U0(e.definition, (n) => Ah(n, t))
        : e instanceof Cr && Zr(t, e)
          ? !1
          : e instanceof Ms
            ? (e instanceof Cr && t.push(e), bi(e.definition, (n) => Ah(n, t)))
            : !1;
  }
  function eL(e) {
    return e instanceof Or;
  }
  function gs(e) {
    if (e instanceof Cr) return "SUBRULE";
    if (e instanceof wr) return "OPTION";
    if (e instanceof Or) return "OR";
    if (e instanceof zr) return "AT_LEAST_ONE";
    if (e instanceof Wr) return "AT_LEAST_ONE_SEP";
    if (e instanceof Mr) return "MANY_SEP";
    if (e instanceof ir) return "MANY";
    if (e instanceof je) return "CONSUME";
    throw Error("non exhaustive match");
  }
  var HK = x(() => {
    "use strict";
    he();
    AT();
    a(tL, "isSequenceProd");
    a(Ah, "isOptionalProd");
    a(eL, "isBranchingProd");
    a(gs, "getProductionDslName");
  });
  var Ui = x(() => {
    "use strict";
    AT();
    qK();
    HK();
  });
  function YK(e, t, r) {
    return [
      new wr({
        definition: [new je({ terminalType: e.separator })].concat(
          e.definition,
        ),
      }),
    ].concat(t, r);
  }
  var wl,
    LT = x(() => {
      "use strict";
      he();
      Ui();
      wl = class {
        static {
          a(this, "RestWalker");
        }
        walk(t, r = []) {
          rt(t.definition, (n, i) => {
            let s = xn(t.definition, i + 1);
            if (n instanceof Cr) this.walkProdRef(n, s, r);
            else if (n instanceof je) this.walkTerminal(n, s, r);
            else if (n instanceof Vr) this.walkFlat(n, s, r);
            else if (n instanceof wr) this.walkOption(n, s, r);
            else if (n instanceof zr) this.walkAtLeastOne(n, s, r);
            else if (n instanceof Wr) this.walkAtLeastOneSep(n, s, r);
            else if (n instanceof Mr) this.walkManySep(n, s, r);
            else if (n instanceof ir) this.walkMany(n, s, r);
            else if (n instanceof Or) this.walkOr(n, s, r);
            else throw Error("non exhaustive match");
          });
        }
        walkTerminal(t, r, n) {}
        walkProdRef(t, r, n) {}
        walkFlat(t, r, n) {
          let i = r.concat(n);
          this.walk(t, i);
        }
        walkOption(t, r, n) {
          let i = r.concat(n);
          this.walk(t, i);
        }
        walkAtLeastOne(t, r, n) {
          let i = [new wr({ definition: t.definition })].concat(r, n);
          this.walk(t, i);
        }
        walkAtLeastOneSep(t, r, n) {
          let i = YK(t, r, n);
          this.walk(t, i);
        }
        walkMany(t, r, n) {
          let i = [new wr({ definition: t.definition })].concat(r, n);
          this.walk(t, i);
        }
        walkManySep(t, r, n) {
          let i = YK(t, r, n);
          this.walk(t, i);
        }
        walkOr(t, r, n) {
          let i = r.concat(n);
          rt(t.definition, (s) => {
            let o = new Vr({ definition: [s] });
            this.walk(o, i);
          });
        }
      };
      a(YK, "restForRepetitionWithSeparator");
    });
  function Lh(e) {
    if (e instanceof Cr) return Lh(e.referencedRule);
    if (e instanceof je) return $3t(e);
    if (tL(e)) return B3t(e);
    if (eL(e)) return F3t(e);
    throw Error("non exhaustive match");
  }
  function B3t(e) {
    let t = [],
      r = e.definition,
      n = 0,
      i = r.length > n,
      s,
      o = !0;
    for (; i && o; )
      ((s = r[n]),
        (o = Ah(s)),
        (t = t.concat(Lh(s))),
        (n = n + 1),
        (i = r.length > n));
    return Nd(t);
  }
  function F3t(e) {
    let t = Dt(e.definition, (r) => Lh(r));
    return Nd(dr(t));
  }
  function $3t(e) {
    return [e.terminalType];
  }
  var rL = x(() => {
    "use strict";
    he();
    Ui();
    a(Lh, "first");
    a(B3t, "firstForSequence");
    a(F3t, "firstForBranching");
    a($3t, "firstForTerminal");
  });
  var RT,
    nL = x(() => {
      "use strict";
      RT = "_~IN~_";
    });
  function XK(e) {
    let t = {};
    return (
      rt(e, (r) => {
        let n = new iL(r).startWalking();
        si(t, n);
      }),
      t
    );
  }
  function G3t(e, t) {
    return e.name + t + RT;
  }
  var iL,
    KK = x(() => {
      "use strict";
      LT();
      rL();
      he();
      nL();
      Ui();
      iL = class extends wl {
        static {
          a(this, "ResyncFollowsWalker");
        }
        constructor(t) {
          (super(), (this.topProd = t), (this.follows = {}));
        }
        startWalking() {
          return (this.walk(this.topProd), this.follows);
        }
        walkTerminal(t, r, n) {}
        walkProdRef(t, r, n) {
          let i = G3t(t.referencedRule, t.idx) + this.topProd.name,
            s = r.concat(n),
            o = new Vr({ definition: s }),
            l = Lh(o);
          this.follows[i] = l;
        }
      };
      a(XK, "computeAllProdsFollows");
      a(G3t, "buildBetweenProdsFollowPrefix");
    });
  function Np(e) {
    let t = e.toString();
    if (DT.hasOwnProperty(t)) return DT[t];
    {
      let r = V3t.pattern(t);
      return ((DT[t] = r), r);
    }
  }
  function QK() {
    DT = {};
  }
  var DT,
    V3t,
    NT = x(() => {
      "use strict";
      f1();
      ((DT = {}), (V3t = new wh()));
      a(Np, "getRegExpAst");
      a(QK, "clearRegExpParserCache");
    });
  function tQ(e, t = !1) {
    try {
      let r = Np(e);
      return sL(r.value, {}, r.flags.ignoreCase);
    } catch (r) {
      if (r.message === JK)
        t &&
          y1(`${k1}	Unable to optimize: < ${e.toString()} >
	Complement Sets cannot be automatically optimized.
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#COMPLEMENT for details.`);
      else {
        let n = "";
        (t &&
          (n = `
	This will disable the lexer's first char optimizations.
	See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#REGEXP_PARSING for details.`),
          Lp(
            `${k1}
	Failed parsing: < ${e.toString()} >
	Using the @chevrotain/regexp-to-ast library
	Please open an issue at: https://github.com/chevrotain/chevrotain/issues` + n,
          ));
      }
    }
    return [];
  }
  function sL(e, t, r) {
    switch (e.type) {
      case "Disjunction":
        for (let i = 0; i < e.value.length; i++) sL(e.value[i], t, r);
        break;
      case "Alternative":
        let n = e.value;
        for (let i = 0; i < n.length; i++) {
          let s = n[i];
          switch (s.type) {
            case "EndAnchor":
            case "GroupBackReference":
            case "Lookahead":
            case "NegativeLookahead":
            case "StartAnchor":
            case "WordBoundary":
            case "NonWordBoundary":
              continue;
          }
          let o = s;
          switch (o.type) {
            case "Character":
              IT(o.value, t, r);
              break;
            case "Set":
              if (o.complement === !0) throw Error(JK);
              rt(o.value, (u) => {
                if (typeof u == "number") IT(u, t, r);
                else {
                  let h = u;
                  if (r === !0)
                    for (let f = h.from; f <= h.to; f++) IT(f, t, r);
                  else {
                    for (let f = h.from; f <= h.to && f < Ip; f++) IT(f, t, r);
                    if (h.to >= Ip) {
                      let f = h.from >= Ip ? h.from : Ip,
                        d = h.to,
                        p = Go(f),
                        m = Go(d);
                      for (let g = p; g <= m; g++) t[g] = g;
                    }
                  }
                }
              });
              break;
            case "Group":
              sL(o.value, t, r);
              break;
            default:
              throw Error("Non Exhaustive Match");
          }
          let l = o.quantifier !== void 0 && o.quantifier.atLeast === 0;
          if (
            (o.type === "Group" && aL(o) === !1) ||
            (o.type !== "Group" && l === !1)
          )
            break;
        }
        break;
      default:
        throw Error("non exhaustive match!");
    }
    return We(t);
  }
  function IT(e, t, r) {
    let n = Go(e);
    ((t[n] = n), r === !0 && z3t(e, t));
  }
  function z3t(e, t) {
    let r = String.fromCharCode(e),
      n = r.toUpperCase();
    if (n !== r) {
      let i = Go(n.charCodeAt(0));
      t[i] = i;
    } else {
      let i = r.toLowerCase();
      if (i !== r) {
        let s = Go(i.charCodeAt(0));
        t[s] = s;
      }
    }
  }
  function ZK(e, t) {
    return Gi(e.value, (r) => {
      if (typeof r == "number") return Zr(t, r);
      {
        let n = r;
        return Gi(t, (i) => n.from <= i && i <= n.to) !== void 0;
      }
    });
  }
  function aL(e) {
    let t = e.quantifier;
    return t && t.atLeast === 0
      ? !0
      : e.value
        ? Jt(e.value)
          ? bi(e.value, aL)
          : aL(e.value)
        : !1;
  }
  function MT(e, t) {
    if (t instanceof RegExp) {
      let r = Np(t),
        n = new oL(e);
      return (n.visit(r), n.found);
    } else return Gi(t, (r) => Zr(e, r.charCodeAt(0))) !== void 0;
  }
  var JK,
    k1,
    oL,
    eQ = x(() => {
      "use strict";
      f1();
      he();
      Rp();
      NT();
      lL();
      ((JK = "Complement Sets are not supported for first char optimization"),
        (k1 = `Unable to use "first char" lexer optimizations:
`));
      a(tQ, "getOptimizedStartCodesIndices");
      a(sL, "firstCharOptimizedIndices");
      a(IT, "addOptimizedIdxToResult");
      a(z3t, "handleIgnoreCase");
      a(ZK, "findCode");
      a(aL, "isWholeOptional");
      oL = class extends $o {
        static {
          a(this, "CharCodeFinder");
        }
        constructor(t) {
          (super(), (this.targetCharCodes = t), (this.found = !1));
        }
        visitChildren(t) {
          if (this.found !== !0) {
            switch (t.type) {
              case "Lookahead":
                this.visitLookahead(t);
                return;
              case "NegativeLookahead":
                this.visitNegativeLookahead(t);
                return;
            }
            super.visitChildren(t);
          }
        }
        visitCharacter(t) {
          Zr(this.targetCharCodes, t.value) && (this.found = !0);
        }
        visitSet(t) {
          t.complement
            ? ZK(t, this.targetCharCodes) === void 0 && (this.found = !0)
            : ZK(t, this.targetCharCodes) !== void 0 && (this.found = !0);
        }
      };
      a(MT, "canMatchCharCode");
    });
  function iQ(e, t) {
    t = Oc(t, {
      useSticky: uL,
      debug: !1,
      safeMode: !1,
      positionTracking: "full",
      lineTerminatorCharacters: [
        "\r",
        `
`,
      ],
      tracer: a((T, C) => C(), "tracer"),
    });
    let r = t.tracer;
    r("initCharCodeToOptimizedIndexMap", () => {
      a4t();
    });
    let n;
    r("Reject Lexer.NA", () => {
      n = Bc(e, (T) => T[Rh] === tn.NA);
    });
    let i = !1,
      s;
    r("Transform Patterns", () => {
      ((i = !1),
        (s = Dt(n, (T) => {
          let C = T[Rh];
          if (ia(C)) {
            let L = C.source;
            return L.length === 1 &&
              L !== "^" &&
              L !== "$" &&
              L !== "." &&
              !C.ignoreCase
              ? L
              : L.length === 2 &&
                  L[0] === "\\" &&
                  !Zr(
                    [
                      "d",
                      "D",
                      "s",
                      "S",
                      "t",
                      "r",
                      "n",
                      "t",
                      "0",
                      "c",
                      "b",
                      "B",
                      "f",
                      "v",
                      "w",
                      "W",
                    ],
                    L[1],
                  )
                ? L[1]
                : t.useSticky
                  ? nQ(C)
                  : rQ(C);
          } else {
            if (vn(C)) return ((i = !0), { exec: C });
            if (typeof C == "object") return ((i = !0), C);
            if (typeof C == "string") {
              if (C.length === 1) return C;
              {
                let L = C.replace(/[\\^$.*+?()[\]{}|]/g, "\\$&"),
                  w = new RegExp(L);
                return t.useSticky ? nQ(w) : rQ(w);
              }
            } else throw Error("non exhaustive match");
          }
        })));
    });
    let o, l, u, h, f;
    r("misc mapping", () => {
      ((o = Dt(n, (T) => T.tokenTypeIdx)),
        (l = Dt(n, (T) => {
          let C = T.GROUP;
          if (C !== tn.SKIPPED) {
            if (bn(C)) return C;
            if (Fe(C)) return !1;
            throw Error("non exhaustive match");
          }
        })),
        (u = Dt(n, (T) => {
          let C = T.LONGER_ALT;
          if (C) return Jt(C) ? Dt(C, (w) => Hk(n, w)) : [Hk(n, C)];
        })),
        (h = Dt(n, (T) => T.PUSH_MODE)),
        (f = Dt(n, (T) => te(T, "POP_MODE"))));
    });
    let d;
    r("Line Terminator Handling", () => {
      let T = fQ(t.lineTerminatorCharacters);
      ((d = Dt(n, (C) => !1)),
        t.positionTracking !== "onlyOffset" &&
          (d = Dt(n, (C) =>
            te(C, "LINE_BREAKS")
              ? !!C.LINE_BREAKS
              : hQ(C, T) === !1 && MT(T, C.PATTERN),
          )));
    });
    let p, m, g, y;
    r("Misc Mapping #2", () => {
      ((p = Dt(n, cQ)),
        (m = Dt(s, i4t)),
        (g = mr(
          n,
          (T, C) => {
            let L = C.GROUP;
            return (bn(L) && L !== tn.SKIPPED && (T[L] = []), T);
          },
          {},
        )),
        (y = Dt(s, (T, C) => ({
          pattern: s[C],
          longerAlt: u[C],
          canLineTerminator: d[C],
          isCustom: p[C],
          short: m[C],
          group: l[C],
          push: h[C],
          pop: f[C],
          tokenTypeIdx: o[C],
          tokenType: n[C],
        }))));
    });
    let b = !0,
      k = [];
    return (
      t.safeMode ||
        r("First Char Optimization", () => {
          k = mr(
            n,
            (T, C, L) => {
              if (typeof C.PATTERN == "string") {
                let w = C.PATTERN.charCodeAt(0),
                  D = Go(w);
                cL(T, D, y[L]);
              } else if (Jt(C.START_CHARS_HINT)) {
                let w;
                rt(C.START_CHARS_HINT, (D) => {
                  let G = typeof D == "string" ? D.charCodeAt(0) : D,
                    E = Go(G);
                  w !== E && ((w = E), cL(T, E, y[L]));
                });
              } else if (ia(C.PATTERN))
                if (C.PATTERN.unicode)
                  ((b = !1),
                    t.ensureOptimizations &&
                      Lp(`${k1}	Unable to analyze < ${C.PATTERN.toString()} > pattern.
	The regexp unicode flag is not currently supported by the regexp-to-ast library.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNICODE_OPTIMIZE`));
                else {
                  let w = tQ(C.PATTERN, t.ensureOptimizations);
                  (De(w) && (b = !1),
                    rt(w, (D) => {
                      cL(T, D, y[L]);
                    }));
                }
              else
                (t.ensureOptimizations &&
                  Lp(`${k1}	TokenType: <${C.name}> is using a custom token pattern without providing <start_chars_hint> parameter.
	This will disable the lexer's first char optimizations.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_OPTIMIZE`),
                  (b = !1));
              return T;
            },
            [],
          );
        }),
      {
        emptyGroups: g,
        patternIdxToConfig: y,
        charCodeToPatternIdxToConfig: k,
        hasCustom: i,
        canBeOptimized: b,
      }
    );
  }
  function sQ(e, t) {
    let r = [],
      n = U3t(e);
    r = r.concat(n.errors);
    let i = j3t(n.valid),
      s = i.valid;
    return (
      (r = r.concat(i.errors)),
      (r = r.concat(W3t(s))),
      (r = r.concat(J3t(s))),
      (r = r.concat(t4t(s, t))),
      (r = r.concat(e4t(s))),
      r
    );
  }
  function W3t(e) {
    let t = [],
      r = pr(e, (n) => ia(n[Rh]));
    return (
      (t = t.concat(H3t(r))),
      (t = t.concat(K3t(r))),
      (t = t.concat(Q3t(r))),
      (t = t.concat(Z3t(r))),
      (t = t.concat(Y3t(r))),
      t
    );
  }
  function U3t(e) {
    let t = pr(e, (i) => !te(i, Rh)),
      r = Dt(t, (i) => ({
        message:
          "Token Type: ->" + i.name + "<- missing static 'PATTERN' property",
        type: Jr.MISSING_PATTERN,
        tokenTypes: [i],
      })),
      n = Pc(e, t);
    return { errors: r, valid: n };
  }
  function j3t(e) {
    let t = pr(e, (i) => {
        let s = i[Rh];
        return !ia(s) && !vn(s) && !te(s, "exec") && !bn(s);
      }),
      r = Dt(t, (i) => ({
        message:
          "Token Type: ->" +
          i.name +
          "<- static 'PATTERN' can only be a RegExp, a Function matching the {CustomPatternMatcherFunc} type or an Object matching the {ICustomPattern} interface.",
        type: Jr.INVALID_PATTERN,
        tokenTypes: [i],
      })),
      n = Pc(e, t);
    return { errors: r, valid: n };
  }
  function H3t(e) {
    class t extends $o {
      static {
        a(this, "EndAnchorFinder");
      }
      constructor() {
        (super(...arguments), (this.found = !1));
      }
      visitEndAnchor(s) {
        this.found = !0;
      }
    }
    let r = pr(e, (i) => {
      let s = i.PATTERN;
      try {
        let o = Np(s),
          l = new t();
        return (l.visit(o), l.found);
      } catch {
        return q3t.test(s.source);
      }
    });
    return Dt(r, (i) => ({
      message:
        `Unexpected RegExp Anchor Error:
	Token Type: ->` +
        i.name +
        `<- static 'PATTERN' cannot contain end of input anchor '$'
	See chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
      type: Jr.EOI_ANCHOR_FOUND,
      tokenTypes: [i],
    }));
  }
  function Y3t(e) {
    let t = pr(e, (n) => n.PATTERN.test(""));
    return Dt(t, (n) => ({
      message:
        "Token Type: ->" +
        n.name +
        "<- static 'PATTERN' must not match an empty string",
      type: Jr.EMPTY_MATCH_PATTERN,
      tokenTypes: [n],
    }));
  }
  function K3t(e) {
    class t extends $o {
      static {
        a(this, "StartAnchorFinder");
      }
      constructor() {
        (super(...arguments), (this.found = !1));
      }
      visitStartAnchor(s) {
        this.found = !0;
      }
    }
    let r = pr(e, (i) => {
      let s = i.PATTERN;
      try {
        let o = Np(s),
          l = new t();
        return (l.visit(o), l.found);
      } catch {
        return X3t.test(s.source);
      }
    });
    return Dt(r, (i) => ({
      message:
        `Unexpected RegExp Anchor Error:
	Token Type: ->` +
        i.name +
        `<- static 'PATTERN' cannot contain start of input anchor '^'
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#ANCHORS	for details.`,
      type: Jr.SOI_ANCHOR_FOUND,
      tokenTypes: [i],
    }));
  }
  function Q3t(e) {
    let t = pr(e, (n) => {
      let i = n[Rh];
      return i instanceof RegExp && (i.multiline || i.global);
    });
    return Dt(t, (n) => ({
      message:
        "Token Type: ->" +
        n.name +
        "<- static 'PATTERN' may NOT contain global('g') or multiline('m')",
      type: Jr.UNSUPPORTED_FLAGS_FOUND,
      tokenTypes: [n],
    }));
  }
  function Z3t(e) {
    let t = [],
      r = Dt(e, (s) =>
        mr(
          e,
          (o, l) => (
            s.PATTERN.source === l.PATTERN.source &&
              !Zr(t, l) &&
              l.PATTERN !== tn.NA &&
              (t.push(l), o.push(l)),
            o
          ),
          [],
        ),
      );
    r = Ao(r);
    let n = pr(r, (s) => s.length > 1);
    return Dt(n, (s) => {
      let o = Dt(s, (u) => u.name);
      return {
        message: `The same RegExp pattern ->${Qn(s).PATTERN}<-has been used in all of the following Token Types: ${o.join(", ")} <-`,
        type: Jr.DUPLICATE_PATTERNS_FOUND,
        tokenTypes: s,
      };
    });
  }
  function J3t(e) {
    let t = pr(e, (n) => {
      if (!te(n, "GROUP")) return !1;
      let i = n.GROUP;
      return i !== tn.SKIPPED && i !== tn.NA && !bn(i);
    });
    return Dt(t, (n) => ({
      message:
        "Token Type: ->" +
        n.name +
        "<- static 'GROUP' can only be Lexer.SKIPPED/Lexer.NA/A String",
      type: Jr.INVALID_GROUP_TYPE_FOUND,
      tokenTypes: [n],
    }));
  }
  function t4t(e, t) {
    let r = pr(e, (i) => i.PUSH_MODE !== void 0 && !Zr(t, i.PUSH_MODE));
    return Dt(r, (i) => ({
      message: `Token Type: ->${i.name}<- static 'PUSH_MODE' value cannot refer to a Lexer Mode ->${i.PUSH_MODE}<-which does not exist`,
      type: Jr.PUSH_MODE_DOES_NOT_EXIST,
      tokenTypes: [i],
    }));
  }
  function e4t(e) {
    let t = [],
      r = mr(
        e,
        (n, i, s) => {
          let o = i.PATTERN;
          return (
            o === tn.NA ||
              (bn(o)
                ? n.push({ str: o, idx: s, tokenType: i })
                : ia(o) &&
                  n4t(o) &&
                  n.push({ str: o.source, idx: s, tokenType: i })),
            n
          );
        },
        [],
      );
    return (
      rt(e, (n, i) => {
        rt(r, ({ str: s, idx: o, tokenType: l }) => {
          if (i < o && r4t(s, n.PATTERN)) {
            let u = `Token: ->${l.name}<- can never be matched.
Because it appears AFTER the Token Type ->${n.name}<-in the lexer's definition.
See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#UNREACHABLE`;
            t.push({
              message: u,
              type: Jr.UNREACHABLE_PATTERN,
              tokenTypes: [n, l],
            });
          }
        });
      }),
      t
    );
  }
  function r4t(e, t) {
    if (ia(t)) {
      let r = t.exec(e);
      return r !== null && r.index === 0;
    } else {
      if (vn(t)) return t(e, 0, [], {});
      if (te(t, "exec")) return t.exec(e, 0, [], {});
      if (typeof t == "string") return t === e;
      throw Error("non exhaustive match");
    }
  }
  function n4t(e) {
    return (
      Gi(
        [".", "\\", "[", "]", "|", "^", "$", "(", ")", "?", "*", "+", "{"],
        (r) => e.source.indexOf(r) !== -1,
      ) === void 0
    );
  }
  function rQ(e) {
    let t = e.ignoreCase ? "i" : "";
    return new RegExp(`^(?:${e.source})`, t);
  }
  function nQ(e) {
    let t = e.ignoreCase ? "iy" : "y";
    return new RegExp(`${e.source}`, t);
  }
  function aQ(e, t, r) {
    let n = [];
    return (
      te(e, Mp) ||
        n.push({
          message:
            "A MultiMode Lexer cannot be initialized without a <" +
            Mp +
            `> property in its definition
`,
          type: Jr.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE,
        }),
      te(e, OT) ||
        n.push({
          message:
            "A MultiMode Lexer cannot be initialized without a <" +
            OT +
            `> property in its definition
`,
          type: Jr.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY,
        }),
      te(e, OT) &&
        te(e, Mp) &&
        !te(e.modes, e.defaultMode) &&
        n.push({
          message: `A MultiMode Lexer cannot be initialized with a ${Mp}: <${e.defaultMode}>which does not exist
`,
          type: Jr.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST,
        }),
      te(e, OT) &&
        rt(e.modes, (i, s) => {
          rt(i, (o, l) => {
            if (Fe(o))
              n.push({
                message: `A Lexer cannot be initialized using an undefined Token Type. Mode:<${s}> at index: <${l}>
`,
                type: Jr.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED,
              });
            else if (te(o, "LONGER_ALT")) {
              let u = Jt(o.LONGER_ALT) ? o.LONGER_ALT : [o.LONGER_ALT];
              rt(u, (h) => {
                !Fe(h) &&
                  !Zr(i, h) &&
                  n.push({
                    message: `A MultiMode Lexer cannot be initialized with a longer_alt <${h.name}> on token <${o.name}> outside of mode <${s}>
`,
                    type: Jr.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE,
                  });
              });
            }
          });
        }),
      n
    );
  }
  function oQ(e, t, r) {
    let n = [],
      i = !1,
      s = Ao(dr(We(e.modes))),
      o = Bc(s, (u) => u[Rh] === tn.NA),
      l = fQ(r);
    return (
      t &&
        rt(o, (u) => {
          let h = hQ(u, l);
          if (h !== !1) {
            let d = { message: s4t(u, h), type: h.issue, tokenType: u };
            n.push(d);
          } else
            te(u, "LINE_BREAKS")
              ? u.LINE_BREAKS === !0 && (i = !0)
              : MT(l, u.PATTERN) && (i = !0);
        }),
      t &&
        !i &&
        n.push({
          message: `Warning: No LINE_BREAKS Found.
	This Lexer has been defined to track line and column information,
	But none of the Token Types can be identified as matching a line terminator.
	See https://chevrotain.io/docs/guide/resolving_lexer_errors.html#LINE_BREAKS 
	for details.`,
          type: Jr.NO_LINE_BREAKS_FLAGS,
        }),
      n
    );
  }
  function lQ(e) {
    let t = {},
      r = cr(e);
    return (
      rt(r, (n) => {
        let i = e[n];
        if (Jt(i)) t[n] = [];
        else throw Error("non exhaustive match");
      }),
      t
    );
  }
  function cQ(e) {
    let t = e.PATTERN;
    if (ia(t)) return !1;
    if (vn(t)) return !0;
    if (te(t, "exec")) return !0;
    if (bn(t)) return !1;
    throw Error("non exhaustive match");
  }
  function i4t(e) {
    return bn(e) && e.length === 1 ? e.charCodeAt(0) : !1;
  }
  function hQ(e, t) {
    if (te(e, "LINE_BREAKS")) return !1;
    if (ia(e.PATTERN)) {
      try {
        MT(t, e.PATTERN);
      } catch (r) {
        return { issue: Jr.IDENTIFY_TERMINATOR, errMsg: r.message };
      }
      return !1;
    } else {
      if (bn(e.PATTERN)) return !1;
      if (cQ(e)) return { issue: Jr.CUSTOM_LINE_BREAK };
      throw Error("non exhaustive match");
    }
  }
  function s4t(e, t) {
    if (t.issue === Jr.IDENTIFY_TERMINATOR)
      return `Warning: unable to identify line terminator usage in pattern.
	The problem is in the <${e.name}> Token Type
	 Root cause: ${t.errMsg}.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#IDENTIFY_TERMINATOR`;
    if (t.issue === Jr.CUSTOM_LINE_BREAK)
      return `Warning: A Custom Token Pattern should specify the <line_breaks> option.
	The problem is in the <${e.name}> Token Type
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#CUSTOM_LINE_BREAK`;
    throw Error("non exhaustive match");
  }
  function fQ(e) {
    return Dt(e, (r) => (bn(r) ? r.charCodeAt(0) : r));
  }
  function cL(e, t, r) {
    e[t] === void 0 ? (e[t] = [r]) : e[t].push(r);
  }
  function Go(e) {
    return e < Ip ? e : PT[e];
  }
  function a4t() {
    if (De(PT)) {
      PT = new Array(65536);
      for (let e = 0; e < 65536; e++) PT[e] = e > 255 ? 255 + ~~(e / 255) : e;
    }
  }
  var Rh,
    Mp,
    OT,
    uL,
    q3t,
    X3t,
    uQ,
    Ip,
    PT,
    lL = x(() => {
      "use strict";
      f1();
      T1();
      he();
      Rp();
      eQ();
      NT();
      ((Rh = "PATTERN"),
        (Mp = "defaultMode"),
        (OT = "modes"),
        (uL = typeof new RegExp("(?:)").sticky == "boolean"));
      a(iQ, "analyzeTokenTypes");
      a(sQ, "validatePatterns");
      a(W3t, "validateRegExpPattern");
      a(U3t, "findMissingPatterns");
      a(j3t, "findInvalidPatterns");
      q3t = /[^\\][$]/;
      a(H3t, "findEndOfInputAnchor");
      a(Y3t, "findEmptyMatchRegExps");
      X3t = /[^\\[][\^]|^\^/;
      a(K3t, "findStartOfInputAnchor");
      a(Q3t, "findUnsupportedFlags");
      a(Z3t, "findDuplicatePatterns");
      a(J3t, "findInvalidGroupType");
      a(t4t, "findModesThatDoNotExist");
      a(e4t, "findUnreachablePatterns");
      a(r4t, "testTokenType");
      a(n4t, "noMetaChar");
      a(rQ, "addStartOfInput");
      a(nQ, "addStickyFlag");
      a(aQ, "performRuntimeChecks");
      a(oQ, "performWarningRuntimeChecks");
      a(lQ, "cloneEmptyGroups");
      a(cQ, "isCustomPattern");
      a(i4t, "isShortPattern");
      uQ = {
        test: a(function (e) {
          let t = e.length;
          for (let r = this.lastIndex; r < t; r++) {
            let n = e.charCodeAt(r);
            if (n === 10) return ((this.lastIndex = r + 1), !0);
            if (n === 13)
              return (
                e.charCodeAt(r + 1) === 10
                  ? (this.lastIndex = r + 2)
                  : (this.lastIndex = r + 1),
                !0
              );
          }
          return !1;
        }, "test"),
        lastIndex: 0,
      };
      a(hQ, "checkLineBreaksIssues");
      a(s4t, "buildLineBreakIssueMessage");
      a(fQ, "getCharCodes");
      a(cL, "addToMapOfArrays");
      ((Ip = 256), (PT = []));
      a(Go, "charCodeToOptimizedIndex");
      a(a4t, "initCharCodeToOptimizedIndexMap");
    });
  function vl(e, t) {
    let r = e.tokenTypeIdx;
    return r === t.tokenTypeIdx
      ? !0
      : t.isParent === !0 && t.categoryMatchesMap[r] === !0;
  }
  function Op(e, t) {
    return e.tokenTypeIdx === t.tokenTypeIdx;
  }
  function El(e) {
    let t = o4t(e);
    (l4t(t),
      u4t(t),
      c4t(t),
      rt(t, (r) => {
        r.isParent = r.categoryMatches.length > 0;
      }));
  }
  function o4t(e) {
    let t = Sr(e),
      r = e,
      n = !0;
    for (; n; ) {
      r = Ao(dr(Dt(r, (s) => s.CATEGORIES)));
      let i = Pc(r, t);
      ((t = t.concat(i)), De(i) ? (n = !1) : (r = i));
    }
    return t;
  }
  function l4t(e) {
    rt(e, (t) => {
      (hL(t) || ((mQ[dQ] = t), (t.tokenTypeIdx = dQ++)),
        pQ(t) && !Jt(t.CATEGORIES) && (t.CATEGORIES = [t.CATEGORIES]),
        pQ(t) || (t.CATEGORIES = []),
        h4t(t) || (t.categoryMatches = []),
        f4t(t) || (t.categoryMatchesMap = {}));
    });
  }
  function c4t(e) {
    rt(e, (t) => {
      ((t.categoryMatches = []),
        rt(t.categoryMatchesMap, (r, n) => {
          t.categoryMatches.push(mQ[n].tokenTypeIdx);
        }));
    });
  }
  function u4t(e) {
    rt(e, (t) => {
      gQ([], t);
    });
  }
  function gQ(e, t) {
    (rt(e, (r) => {
      t.categoryMatchesMap[r.tokenTypeIdx] = !0;
    }),
      rt(t.CATEGORIES, (r) => {
        let n = e.concat(t);
        Zr(n, r) || gQ(n, r);
      }));
  }
  function hL(e) {
    return te(e, "tokenTypeIdx");
  }
  function pQ(e) {
    return te(e, "CATEGORIES");
  }
  function h4t(e) {
    return te(e, "categoryMatches");
  }
  function f4t(e) {
    return te(e, "categoryMatchesMap");
  }
  function yQ(e) {
    return te(e, "tokenTypeIdx");
  }
  var dQ,
    mQ,
    Dh = x(() => {
      "use strict";
      he();
      a(vl, "tokenStructuredMatcher");
      a(Op, "tokenStructuredMatcherNoCategories");
      ((dQ = 1), (mQ = {}));
      a(El, "augmentTokenTypes");
      a(o4t, "expandCategories");
      a(l4t, "assignTokenDefaultProps");
      a(c4t, "assignCategoriesTokensProp");
      a(u4t, "assignCategoriesMapProp");
      a(gQ, "singleAssignCategoriesToksMap");
      a(hL, "hasShortKeyProperty");
      a(pQ, "hasCategoriesProperty");
      a(h4t, "hasExtendingTokensTypesProperty");
      a(f4t, "hasExtendingTokensTypesMapProperty");
      a(yQ, "isTokenType");
    });
  var Pp,
    fL = x(() => {
      "use strict";
      Pp = {
        buildUnableToPopLexerModeMessage(e) {
          return `Unable to pop Lexer Mode after encountering Token ->${e.image}<- The Mode Stack is empty`;
        },
        buildUnexpectedCharactersMessage(e, t, r, n, i) {
          return `unexpected character: ->${e.charAt(t)}<- at offset: ${t}, skipped ${r} characters.`;
        },
      };
    });
  var Jr,
    S1,
    tn,
    T1 = x(() => {
      "use strict";
      lL();
      he();
      Rp();
      Dh();
      fL();
      NT();
      (function (e) {
        ((e[(e.MISSING_PATTERN = 0)] = "MISSING_PATTERN"),
          (e[(e.INVALID_PATTERN = 1)] = "INVALID_PATTERN"),
          (e[(e.EOI_ANCHOR_FOUND = 2)] = "EOI_ANCHOR_FOUND"),
          (e[(e.UNSUPPORTED_FLAGS_FOUND = 3)] = "UNSUPPORTED_FLAGS_FOUND"),
          (e[(e.DUPLICATE_PATTERNS_FOUND = 4)] = "DUPLICATE_PATTERNS_FOUND"),
          (e[(e.INVALID_GROUP_TYPE_FOUND = 5)] = "INVALID_GROUP_TYPE_FOUND"),
          (e[(e.PUSH_MODE_DOES_NOT_EXIST = 6)] = "PUSH_MODE_DOES_NOT_EXIST"),
          (e[(e.MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE = 7)] =
            "MULTI_MODE_LEXER_WITHOUT_DEFAULT_MODE"),
          (e[(e.MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY = 8)] =
            "MULTI_MODE_LEXER_WITHOUT_MODES_PROPERTY"),
          (e[(e.MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST = 9)] =
            "MULTI_MODE_LEXER_DEFAULT_MODE_VALUE_DOES_NOT_EXIST"),
          (e[(e.LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED = 10)] =
            "LEXER_DEFINITION_CANNOT_CONTAIN_UNDEFINED"),
          (e[(e.SOI_ANCHOR_FOUND = 11)] = "SOI_ANCHOR_FOUND"),
          (e[(e.EMPTY_MATCH_PATTERN = 12)] = "EMPTY_MATCH_PATTERN"),
          (e[(e.NO_LINE_BREAKS_FLAGS = 13)] = "NO_LINE_BREAKS_FLAGS"),
          (e[(e.UNREACHABLE_PATTERN = 14)] = "UNREACHABLE_PATTERN"),
          (e[(e.IDENTIFY_TERMINATOR = 15)] = "IDENTIFY_TERMINATOR"),
          (e[(e.CUSTOM_LINE_BREAK = 16)] = "CUSTOM_LINE_BREAK"),
          (e[(e.MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE = 17)] =
            "MULTI_MODE_LEXER_LONGER_ALT_NOT_IN_CURRENT_MODE"));
      })(Jr || (Jr = {}));
      S1 = {
        deferDefinitionErrorsHandling: !1,
        positionTracking: "full",
        lineTerminatorsPattern: /\n|\r\n?/g,
        lineTerminatorCharacters: [
          `
`,
          "\r",
        ],
        ensureOptimizations: !1,
        safeMode: !1,
        errorMessageProvider: Pp,
        traceInitPerf: !1,
        skipValidations: !1,
        recoveryEnabled: !0,
      };
      Object.freeze(S1);
      tn = class {
        static {
          a(this, "Lexer");
        }
        constructor(t, r = S1) {
          if (
            ((this.lexerDefinition = t),
            (this.lexerDefinitionErrors = []),
            (this.lexerDefinitionWarning = []),
            (this.patternIdxToConfig = {}),
            (this.charCodeToPatternIdxToConfig = {}),
            (this.modes = []),
            (this.emptyGroups = {}),
            (this.trackStartLines = !0),
            (this.trackEndLines = !0),
            (this.hasCustom = !1),
            (this.canModeBeOptimized = {}),
            (this.TRACE_INIT = (i, s) => {
              if (this.traceInitPerf === !0) {
                this.traceInitIndent++;
                let o = new Array(this.traceInitIndent + 1).join("	");
                this.traceInitIndent < this.traceInitMaxIdent &&
                  console.log(`${o}--> <${i}>`);
                let { time: l, value: u } = x1(s),
                  h = l > 10 ? console.warn : console.log;
                return (
                  this.traceInitIndent < this.traceInitMaxIdent &&
                    h(`${o}<-- <${i}> time: ${l}ms`),
                  this.traceInitIndent--,
                  u
                );
              } else return s();
            }),
            typeof r == "boolean")
          )
            throw Error(`The second argument to the Lexer constructor is now an ILexerConfig Object.
a boolean 2nd argument is no longer supported`);
          this.config = si({}, S1, r);
          let n = this.config.traceInitPerf;
          (n === !0
            ? ((this.traceInitMaxIdent = 1 / 0), (this.traceInitPerf = !0))
            : typeof n == "number" &&
              ((this.traceInitMaxIdent = n), (this.traceInitPerf = !0)),
            (this.traceInitIndent = -1),
            this.TRACE_INIT("Lexer Constructor", () => {
              let i,
                s = !0;
              (this.TRACE_INIT("Lexer Config handling", () => {
                if (
                  this.config.lineTerminatorsPattern ===
                  S1.lineTerminatorsPattern
                )
                  this.config.lineTerminatorsPattern = uQ;
                else if (
                  this.config.lineTerminatorCharacters ===
                  S1.lineTerminatorCharacters
                )
                  throw Error(`Error: Missing <lineTerminatorCharacters> property on the Lexer config.
	For details See: https://chevrotain.io/docs/guide/resolving_lexer_errors.html#MISSING_LINE_TERM_CHARS`);
                if (r.safeMode && r.ensureOptimizations)
                  throw Error(
                    '"safeMode" and "ensureOptimizations" flags are mutually exclusive.',
                  );
                ((this.trackStartLines = /full|onlyStart/i.test(
                  this.config.positionTracking,
                )),
                  (this.trackEndLines = /full/i.test(
                    this.config.positionTracking,
                  )),
                  Jt(t)
                    ? (i = { modes: { defaultMode: Sr(t) }, defaultMode: Mp })
                    : ((s = !1), (i = Sr(t))));
              }),
                this.config.skipValidations === !1 &&
                  (this.TRACE_INIT("performRuntimeChecks", () => {
                    this.lexerDefinitionErrors =
                      this.lexerDefinitionErrors.concat(
                        aQ(
                          i,
                          this.trackStartLines,
                          this.config.lineTerminatorCharacters,
                        ),
                      );
                  }),
                  this.TRACE_INIT("performWarningRuntimeChecks", () => {
                    this.lexerDefinitionWarning =
                      this.lexerDefinitionWarning.concat(
                        oQ(
                          i,
                          this.trackStartLines,
                          this.config.lineTerminatorCharacters,
                        ),
                      );
                  })),
                (i.modes = i.modes ? i.modes : {}),
                rt(i.modes, (l, u) => {
                  i.modes[u] = Bc(l, (h) => Fe(h));
                }));
              let o = cr(i.modes);
              if (
                (rt(i.modes, (l, u) => {
                  this.TRACE_INIT(`Mode: <${u}> processing`, () => {
                    if (
                      (this.modes.push(u),
                      this.config.skipValidations === !1 &&
                        this.TRACE_INIT("validatePatterns", () => {
                          this.lexerDefinitionErrors =
                            this.lexerDefinitionErrors.concat(sQ(l, o));
                        }),
                      De(this.lexerDefinitionErrors))
                    ) {
                      El(l);
                      let h;
                      (this.TRACE_INIT("analyzeTokenTypes", () => {
                        h = iQ(l, {
                          lineTerminatorCharacters:
                            this.config.lineTerminatorCharacters,
                          positionTracking: r.positionTracking,
                          ensureOptimizations: r.ensureOptimizations,
                          safeMode: r.safeMode,
                          tracer: this.TRACE_INIT,
                        });
                      }),
                        (this.patternIdxToConfig[u] = h.patternIdxToConfig),
                        (this.charCodeToPatternIdxToConfig[u] =
                          h.charCodeToPatternIdxToConfig),
                        (this.emptyGroups = si(
                          {},
                          this.emptyGroups,
                          h.emptyGroups,
                        )),
                        (this.hasCustom = h.hasCustom || this.hasCustom),
                        (this.canModeBeOptimized[u] = h.canBeOptimized));
                    }
                  });
                }),
                (this.defaultMode = i.defaultMode),
                !De(this.lexerDefinitionErrors) &&
                  !this.config.deferDefinitionErrorsHandling)
              ) {
                let u = Dt(this.lexerDefinitionErrors, (h) => h.message)
                  .join(`-----------------------
`);
                throw new Error(
                  `Errors detected in definition of Lexer:
` + u,
                );
              }
              (rt(this.lexerDefinitionWarning, (l) => {
                y1(l.message);
              }),
                this.TRACE_INIT("Choosing sub-methods implementations", () => {
                  if (
                    (uL
                      ? ((this.chopInput = Hn),
                        (this.match = this.matchWithTest))
                      : ((this.updateLastIndex = ln),
                        (this.match = this.matchWithExec)),
                    s && (this.handleModes = ln),
                    this.trackStartLines === !1 && (this.computeNewColumn = Hn),
                    this.trackEndLines === !1 &&
                      (this.updateTokenEndLineColumnLocation = ln),
                    /full/i.test(this.config.positionTracking))
                  )
                    this.createTokenInstance = this.createFullToken;
                  else if (/onlyStart/i.test(this.config.positionTracking))
                    this.createTokenInstance = this.createStartOnlyToken;
                  else if (/onlyOffset/i.test(this.config.positionTracking))
                    this.createTokenInstance = this.createOffsetOnlyToken;
                  else
                    throw Error(
                      `Invalid <positionTracking> config option: "${this.config.positionTracking}"`,
                    );
                  this.hasCustom
                    ? ((this.addToken = this.addTokenUsingPush),
                      (this.handlePayload = this.handlePayloadWithCustom))
                    : ((this.addToken = this.addTokenUsingMemberAccess),
                      (this.handlePayload = this.handlePayloadNoCustom));
                }),
                this.TRACE_INIT("Failed Optimization Warnings", () => {
                  let l = mr(
                    this.canModeBeOptimized,
                    (u, h, f) => (h === !1 && u.push(f), u),
                    [],
                  );
                  if (r.ensureOptimizations && !De(l))
                    throw Error(`Lexer Modes: < ${l.join(", ")} > cannot be optimized.
	 Disable the "ensureOptimizations" lexer config flag to silently ignore this and run the lexer in an un-optimized mode.
	 Or inspect the console log for details on how to resolve these issues.`);
                }),
                this.TRACE_INIT("clearRegExpParserCache", () => {
                  QK();
                }),
                this.TRACE_INIT("toFastProperties", () => {
                  b1(this);
                }));
            }));
        }
        tokenize(t, r = this.defaultMode) {
          if (!De(this.lexerDefinitionErrors)) {
            let i = Dt(this.lexerDefinitionErrors, (s) => s.message)
              .join(`-----------------------
`);
            throw new Error(
              `Unable to Tokenize because Errors detected in definition of Lexer:
` + i,
            );
          }
          return this.tokenizeInternal(t, r);
        }
        tokenizeInternal(t, r) {
          let n,
            i,
            s,
            o,
            l,
            u,
            h,
            f,
            d,
            p,
            m,
            g,
            y,
            b,
            k,
            T,
            C = t,
            L = C.length,
            w = 0,
            D = 0,
            G = this.hasCustom ? 0 : Math.floor(t.length / 10),
            E = new Array(G),
            R = [],
            F = this.trackStartLines ? 1 : void 0,
            S = this.trackStartLines ? 1 : void 0,
            O = lQ(this.emptyGroups),
            v = this.trackStartLines,
            _ = this.config.lineTerminatorsPattern,
            A = 0,
            N = [],
            B = [],
            M = [],
            I = [];
          Object.freeze(I);
          let V;
          function $() {
            return N;
          }
          a($, "getPossiblePatternsSlow");
          function q(ft) {
            let yt = Go(ft),
              ot = B[yt];
            return ot === void 0 ? I : ot;
          }
          a(q, "getPossiblePatternsOptimized");
          let tt = a((ft) => {
            if (M.length === 1 && ft.tokenType.PUSH_MODE === void 0) {
              let yt =
                this.config.errorMessageProvider.buildUnableToPopLexerModeMessage(
                  ft,
                );
              R.push({
                offset: ft.startOffset,
                line: ft.startLine,
                column: ft.startColumn,
                length: ft.image.length,
                message: yt,
              });
            } else {
              M.pop();
              let yt = ai(M);
              ((N = this.patternIdxToConfig[yt]),
                (B = this.charCodeToPatternIdxToConfig[yt]),
                (A = N.length));
              let ot =
                this.canModeBeOptimized[yt] && this.config.safeMode === !1;
              B && ot ? (V = q) : (V = $);
            }
          }, "pop_mode");
          function ht(ft) {
            (M.push(ft),
              (B = this.charCodeToPatternIdxToConfig[ft]),
              (N = this.patternIdxToConfig[ft]),
              (A = N.length),
              (A = N.length));
            let yt = this.canModeBeOptimized[ft] && this.config.safeMode === !1;
            B && yt ? (V = q) : (V = $);
          }
          (a(ht, "push_mode"), ht.call(this, r));
          let H,
            kt = this.config.recoveryEnabled;
          for (; w < L; ) {
            u = null;
            let ft = C.charCodeAt(w),
              yt = V(ft),
              ot = yt.length;
            for (n = 0; n < ot; n++) {
              H = yt[n];
              let dt = H.pattern;
              h = null;
              let nt = H.short;
              if (
                (nt !== !1
                  ? ft === nt && (u = dt)
                  : H.isCustom === !0
                    ? ((T = dt.exec(C, w, E, O)),
                      T !== null
                        ? ((u = T[0]), T.payload !== void 0 && (h = T.payload))
                        : (u = null))
                    : (this.updateLastIndex(dt, w), (u = this.match(dt, t, w))),
                u !== null)
              ) {
                if (((l = H.longerAlt), l !== void 0)) {
                  let Q = l.length;
                  for (s = 0; s < Q; s++) {
                    let et = N[l[s]],
                      X = et.pattern;
                    if (
                      ((f = null),
                      et.isCustom === !0
                        ? ((T = X.exec(C, w, E, O)),
                          T !== null
                            ? ((o = T[0]),
                              T.payload !== void 0 && (f = T.payload))
                            : (o = null))
                        : (this.updateLastIndex(X, w),
                          (o = this.match(X, t, w))),
                      o && o.length > u.length)
                    ) {
                      ((u = o), (h = f), (H = et));
                      break;
                    }
                  }
                }
                break;
              }
            }
            if (u !== null) {
              if (
                ((d = u.length),
                (p = H.group),
                p !== void 0 &&
                  ((m = H.tokenTypeIdx),
                  (g = this.createTokenInstance(u, w, m, H.tokenType, F, S, d)),
                  this.handlePayload(g, h),
                  p === !1 ? (D = this.addToken(E, D, g)) : O[p].push(g)),
                (t = this.chopInput(t, d)),
                (w = w + d),
                (S = this.computeNewColumn(S, d)),
                v === !0 && H.canLineTerminator === !0)
              ) {
                let dt = 0,
                  nt,
                  Q;
                _.lastIndex = 0;
                do
                  ((nt = _.test(u)),
                    nt === !0 && ((Q = _.lastIndex - 1), dt++));
                while (nt === !0);
                dt !== 0 &&
                  ((F = F + dt),
                  (S = d - Q),
                  this.updateTokenEndLineColumnLocation(g, p, Q, dt, F, S, d));
              }
              this.handleModes(H, tt, ht, g);
            } else {
              let dt = w,
                nt = F,
                Q = S,
                et = kt === !1;
              for (; et === !1 && w < L; )
                for (t = this.chopInput(t, 1), w++, i = 0; i < A; i++) {
                  let X = N[i],
                    st = X.pattern,
                    U = X.short;
                  if (
                    (U !== !1
                      ? C.charCodeAt(w) === U && (et = !0)
                      : X.isCustom === !0
                        ? (et = st.exec(C, w, E, O) !== null)
                        : (this.updateLastIndex(st, w),
                          (et = st.exec(t) !== null)),
                    et === !0)
                  )
                    break;
                }
              if (
                ((y = w - dt),
                (S = this.computeNewColumn(S, y)),
                (k =
                  this.config.errorMessageProvider.buildUnexpectedCharactersMessage(
                    C,
                    dt,
                    y,
                    nt,
                    Q,
                  )),
                R.push({
                  offset: dt,
                  line: nt,
                  column: Q,
                  length: y,
                  message: k,
                }),
                kt === !1)
              )
                break;
            }
          }
          return (
            this.hasCustom || (E.length = D),
            { tokens: E, groups: O, errors: R }
          );
        }
        handleModes(t, r, n, i) {
          if (t.pop === !0) {
            let s = t.push;
            (r(i), s !== void 0 && n.call(this, s));
          } else t.push !== void 0 && n.call(this, t.push);
        }
        chopInput(t, r) {
          return t.substring(r);
        }
        updateLastIndex(t, r) {
          t.lastIndex = r;
        }
        updateTokenEndLineColumnLocation(t, r, n, i, s, o, l) {
          let u, h;
          r !== void 0 &&
            ((u = n === l - 1),
            (h = u ? -1 : 0),
            (i === 1 && u === !0) ||
              ((t.endLine = s + h), (t.endColumn = o - 1 + -h)));
        }
        computeNewColumn(t, r) {
          return t + r;
        }
        createOffsetOnlyToken(t, r, n, i) {
          return { image: t, startOffset: r, tokenTypeIdx: n, tokenType: i };
        }
        createStartOnlyToken(t, r, n, i, s, o) {
          return {
            image: t,
            startOffset: r,
            startLine: s,
            startColumn: o,
            tokenTypeIdx: n,
            tokenType: i,
          };
        }
        createFullToken(t, r, n, i, s, o, l) {
          return {
            image: t,
            startOffset: r,
            endOffset: r + l - 1,
            startLine: s,
            endLine: s,
            startColumn: o,
            endColumn: o + l - 1,
            tokenTypeIdx: n,
            tokenType: i,
          };
        }
        addTokenUsingPush(t, r, n) {
          return (t.push(n), r);
        }
        addTokenUsingMemberAccess(t, r, n) {
          return ((t[r] = n), r++, r);
        }
        handlePayloadNoCustom(t, r) {}
        handlePayloadWithCustom(t, r) {
          r !== null && (t.payload = r);
        }
        matchWithTest(t, r, n) {
          return t.test(r) === !0 ? r.substring(n, t.lastIndex) : null;
        }
        matchWithExec(t, r) {
          let n = t.exec(r);
          return n !== null ? n[0] : null;
        }
      };
      tn.SKIPPED =
        "This marks a skipped Token pattern, this means each token identified by it willbe consumed and then thrown into oblivion, this can be used to for example to completely ignore whitespace.";
      tn.NA = /NOT_APPLICABLE/;
    });
  function Al(e) {
    return dL(e) ? e.LABEL : e.name;
  }
  function dL(e) {
    return bn(e.LABEL) && e.LABEL !== "";
  }
  function Uc(e) {
    return p4t(e);
  }
  function p4t(e) {
    let t = e.pattern,
      r = {};
    if (((r.name = e.name), Fe(t) || (r.PATTERN = t), te(e, d4t)))
      throw `The parent property is no longer supported.
See: https://github.com/chevrotain/chevrotain/issues/564#issuecomment-349062346 for details.`;
    return (
      te(e, xQ) && (r.CATEGORIES = e[xQ]),
      El([r]),
      te(e, bQ) && (r.LABEL = e[bQ]),
      te(e, kQ) && (r.GROUP = e[kQ]),
      te(e, SQ) && (r.POP_MODE = e[SQ]),
      te(e, TQ) && (r.PUSH_MODE = e[TQ]),
      te(e, _Q) && (r.LONGER_ALT = e[_Q]),
      te(e, CQ) && (r.LINE_BREAKS = e[CQ]),
      te(e, wQ) && (r.START_CHARS_HINT = e[wQ]),
      r
    );
  }
  function Ll(e, t, r, n, i, s, o, l) {
    return {
      image: t,
      startOffset: r,
      endOffset: n,
      startLine: i,
      endLine: s,
      startColumn: o,
      endColumn: l,
      tokenTypeIdx: e.tokenTypeIdx,
      tokenType: e,
    };
  }
  function _1(e, t) {
    return vl(e, t);
  }
  var d4t,
    xQ,
    bQ,
    kQ,
    TQ,
    SQ,
    _Q,
    CQ,
    wQ,
    Os,
    Nh = x(() => {
      "use strict";
      he();
      T1();
      Dh();
      a(Al, "tokenLabel");
      a(dL, "hasTokenLabel");
      ((d4t = "parent"),
        (xQ = "categories"),
        (bQ = "label"),
        (kQ = "group"),
        (TQ = "push_mode"),
        (SQ = "pop_mode"),
        (_Q = "longer_alt"),
        (CQ = "line_breaks"),
        (wQ = "start_chars_hint"));
      a(Uc, "createToken");
      a(p4t, "createTokenInternal");
      Os = Uc({ name: "EOF", pattern: tn.NA });
      El([Os]);
      a(Ll, "createTokenInstance");
      a(_1, "tokenMatcher");
    });
  var Rl,
    vQ,
    Ya,
    Bp = x(() => {
      "use strict";
      Nh();
      he();
      Ui();
      Rl = {
        buildMismatchTokenMessage({
          expected: e,
          actual: t,
          previous: r,
          ruleName: n,
        }) {
          return `Expecting ${dL(e) ? `--> ${Al(e)} <--` : `token of type --> ${e.name} <--`} but found --> '${t.image}' <--`;
        },
        buildNotAllInputParsedMessage({ firstRedundant: e, ruleName: t }) {
          return "Redundant input, expecting EOF but found: " + e.image;
        },
        buildNoViableAltMessage({
          expectedPathsPerAlt: e,
          actual: t,
          previous: r,
          customUserDescription: n,
          ruleName: i,
        }) {
          let s = "Expecting: ",
            l =
              `
but found: '` +
              Qn(t).image +
              "'";
          if (n) return s + n + l;
          {
            let u = mr(e, (p, m) => p.concat(m), []),
              h = Dt(u, (p) => `[${Dt(p, (m) => Al(m)).join(", ")}]`),
              d = `one of these possible Token sequences:
${Dt(h, (p, m) => `  ${m + 1}. ${p}`).join(`
`)}`;
            return s + d + l;
          }
        },
        buildEarlyExitMessage({
          expectedIterationPaths: e,
          actual: t,
          customUserDescription: r,
          ruleName: n,
        }) {
          let i = "Expecting: ",
            o =
              `
but found: '` +
              Qn(t).image +
              "'";
          if (r) return i + r + o;
          {
            let u = `expecting at least one iteration which starts with one of these possible Token sequences::
  <${Dt(e, (h) => `[${Dt(h, (f) => Al(f)).join(",")}]`).join(" ,")}>`;
            return i + u + o;
          }
        },
      };
      Object.freeze(Rl);
      ((vQ = {
        buildRuleNotFoundError(e, t) {
          return (
            "Invalid grammar, reference to a rule which is not defined: ->" +
            t.nonTerminalName +
            `<-
inside top level rule: ->` +
            e.name +
            "<-"
          );
        },
      }),
        (Ya = {
          buildDuplicateFoundError(e, t) {
            function r(f) {
              return f instanceof je
                ? f.terminalType.name
                : f instanceof Cr
                  ? f.nonTerminalName
                  : "";
            }
            a(r, "getExtraProductionArgument");
            let n = e.name,
              i = Qn(t),
              s = i.idx,
              o = gs(i),
              l = r(i),
              u = s > 0,
              h = `->${o}${u ? s : ""}<- ${l ? `with argument: ->${l}<-` : ""}
                  appears more than once (${t.length} times) in the top level rule: ->${n}<-.                  
                  For further details see: https://chevrotain.io/docs/FAQ.html#NUMERICAL_SUFFIXES 
                  `;
            return (
              (h = h.replace(/[ \t]+/g, " ")),
              (h = h.replace(
                /\s\s+/g,
                `
`,
              )),
              h
            );
          },
          buildNamespaceConflictError(e) {
            return `Namespace conflict found in grammar.
The grammar has both a Terminal(Token) and a Non-Terminal(Rule) named: <${e.name}>.
To resolve this make sure each Terminal and Non-Terminal names are unique
This is easy to accomplish by using the convention that Terminal names start with an uppercase letter
and Non-Terminal names start with a lower case letter.`;
          },
          buildAlternationPrefixAmbiguityError(e) {
            let t = Dt(e.prefixPath, (i) => Al(i)).join(", "),
              r = e.alternation.idx === 0 ? "" : e.alternation.idx;
            return `Ambiguous alternatives: <${e.ambiguityIndices.join(" ,")}> due to common lookahead prefix
in <OR${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#COMMON_PREFIX
For Further details.`;
          },
          buildAlternationAmbiguityError(e) {
            let t = Dt(e.prefixPath, (i) => Al(i)).join(", "),
              r = e.alternation.idx === 0 ? "" : e.alternation.idx,
              n = `Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(" ,")}> in <OR${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
`;
            return (
              (n =
                n +
                `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`),
              n
            );
          },
          buildEmptyRepetitionError(e) {
            let t = gs(e.repetition);
            return (
              e.repetition.idx !== 0 && (t += e.repetition.idx),
              `The repetition <${t}> within Rule <${e.topLevelRule.name}> can never consume any tokens.
This could lead to an infinite loop.`
            );
          },
          buildTokenNameError(e) {
            return "deprecated";
          },
          buildEmptyAlternationError(e) {
            return `Ambiguous empty alternative: <${e.emptyChoiceIdx + 1}> in <OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
Only the last alternative may be an empty alternative.`;
          },
          buildTooManyAlternativesError(e) {
            return `An Alternation cannot have more than 256 alternatives:
<OR${e.alternation.idx}> inside <${e.topLevelRule.name}> Rule.
 has ${e.alternation.definition.length + 1} alternatives.`;
          },
          buildLeftRecursionError(e) {
            let t = e.topLevelRule.name,
              r = Dt(e.leftRecursionPath, (s) => s.name),
              n = `${t} --> ${r.concat([t]).join(" --> ")}`;
            return `Left Recursion found in grammar.
rule: <${t}> can be invoked from itself (directly or indirectly)
without consuming any Tokens. The grammar path that causes this is: 
 ${n}
 To fix this refactor your grammar to remove the left recursion.
see: https://en.wikipedia.org/wiki/LL_parser#Left_factoring.`;
          },
          buildInvalidRuleNameError(e) {
            return "deprecated";
          },
          buildDuplicateRuleNameError(e) {
            let t;
            return (
              e.topLevelRule instanceof zi
                ? (t = e.topLevelRule.name)
                : (t = e.topLevelRule),
              `Duplicate definition, rule: ->${t}<- is already defined in the grammar: ->${e.grammarName}<-`
            );
          },
        }));
    });
  function EQ(e, t) {
    let r = new pL(e, t);
    return (r.resolveRefs(), r.errors);
  }
  var pL,
    AQ = x(() => {
      "use strict";
      ys();
      he();
      Ui();
      a(EQ, "resolveGrammar");
      pL = class extends Wi {
        static {
          a(this, "GastRefResolverVisitor");
        }
        constructor(t, r) {
          (super(),
            (this.nameToTopRule = t),
            (this.errMsgProvider = r),
            (this.errors = []));
        }
        resolveRefs() {
          rt(We(this.nameToTopRule), (t) => {
            ((this.currTopLevel = t), t.accept(this));
          });
        }
        visitNonTerminal(t) {
          let r = this.nameToTopRule[t.nonTerminalName];
          if (r) t.referencedRule = r;
          else {
            let n = this.errMsgProvider.buildRuleNotFoundError(
              this.currTopLevel,
              t,
            );
            this.errors.push({
              message: n,
              type: Fn.UNRESOLVED_SUBRULE_REF,
              ruleName: this.currTopLevel.name,
              unresolvedRefName: t.nonTerminalName,
            });
          }
        }
      };
    });
  function GT(e, t, r = []) {
    r = Sr(r);
    let n = [],
      i = 0;
    function s(l) {
      return l.concat(xn(e, i + 1));
    }
    a(s, "remainingPathWith");
    function o(l) {
      let u = GT(s(l), t, r);
      return n.concat(u);
    }
    for (a(o, "getAlternativesForProd"); r.length < t && i < e.length; ) {
      let l = e[i];
      if (l instanceof Vr) return o(l.definition);
      if (l instanceof Cr) return o(l.definition);
      if (l instanceof wr) n = o(l.definition);
      else if (l instanceof zr) {
        let u = l.definition.concat([new ir({ definition: l.definition })]);
        return o(u);
      } else if (l instanceof Wr) {
        let u = [
          new Vr({ definition: l.definition }),
          new ir({
            definition: [new je({ terminalType: l.separator })].concat(
              l.definition,
            ),
          }),
        ];
        return o(u);
      } else if (l instanceof Mr) {
        let u = l.definition.concat([
          new ir({
            definition: [new je({ terminalType: l.separator })].concat(
              l.definition,
            ),
          }),
        ]);
        n = o(u);
      } else if (l instanceof ir) {
        let u = l.definition.concat([new ir({ definition: l.definition })]);
        n = o(u);
      } else {
        if (l instanceof Or)
          return (
            rt(l.definition, (u) => {
              De(u.definition) === !1 && (n = o(u.definition));
            }),
            n
          );
        if (l instanceof je) r.push(l.terminalType);
        else throw Error("non exhaustive match");
      }
      i++;
    }
    return (n.push({ partialPath: r, suffixDef: xn(e, i) }), n);
  }
  function VT(e, t, r, n) {
    let i = "EXIT_NONE_TERMINAL",
      s = [i],
      o = "EXIT_ALTERNATIVE",
      l = !1,
      u = t.length,
      h = u - n - 1,
      f = [],
      d = [];
    for (
      d.push({ idx: -1, def: e, ruleStack: [], occurrenceStack: [] });
      !De(d);

    ) {
      let p = d.pop();
      if (p === o) {
        l && ai(d).idx <= h && d.pop();
        continue;
      }
      let m = p.def,
        g = p.idx,
        y = p.ruleStack,
        b = p.occurrenceStack;
      if (De(m)) continue;
      let k = m[0];
      if (k === i) {
        let T = {
          idx: g,
          def: xn(m),
          ruleStack: Sl(y),
          occurrenceStack: Sl(b),
        };
        d.push(T);
      } else if (k instanceof je)
        if (g < u - 1) {
          let T = g + 1,
            C = t[T];
          if (r(C, k.terminalType)) {
            let L = { idx: T, def: xn(m), ruleStack: y, occurrenceStack: b };
            d.push(L);
          }
        } else if (g === u - 1)
          (f.push({
            nextTokenType: k.terminalType,
            nextTokenOccurrence: k.idx,
            ruleStack: y,
            occurrenceStack: b,
          }),
            (l = !0));
        else throw Error("non exhaustive match");
      else if (k instanceof Cr) {
        let T = Sr(y);
        T.push(k.nonTerminalName);
        let C = Sr(b);
        C.push(k.idx);
        let L = {
          idx: g,
          def: k.definition.concat(s, xn(m)),
          ruleStack: T,
          occurrenceStack: C,
        };
        d.push(L);
      } else if (k instanceof wr) {
        let T = { idx: g, def: xn(m), ruleStack: y, occurrenceStack: b };
        (d.push(T), d.push(o));
        let C = {
          idx: g,
          def: k.definition.concat(xn(m)),
          ruleStack: y,
          occurrenceStack: b,
        };
        d.push(C);
      } else if (k instanceof zr) {
        let T = new ir({ definition: k.definition, idx: k.idx }),
          C = k.definition.concat([T], xn(m)),
          L = { idx: g, def: C, ruleStack: y, occurrenceStack: b };
        d.push(L);
      } else if (k instanceof Wr) {
        let T = new je({ terminalType: k.separator }),
          C = new ir({ definition: [T].concat(k.definition), idx: k.idx }),
          L = k.definition.concat([C], xn(m)),
          w = { idx: g, def: L, ruleStack: y, occurrenceStack: b };
        d.push(w);
      } else if (k instanceof Mr) {
        let T = { idx: g, def: xn(m), ruleStack: y, occurrenceStack: b };
        (d.push(T), d.push(o));
        let C = new je({ terminalType: k.separator }),
          L = new ir({ definition: [C].concat(k.definition), idx: k.idx }),
          w = k.definition.concat([L], xn(m)),
          D = { idx: g, def: w, ruleStack: y, occurrenceStack: b };
        d.push(D);
      } else if (k instanceof ir) {
        let T = { idx: g, def: xn(m), ruleStack: y, occurrenceStack: b };
        (d.push(T), d.push(o));
        let C = new ir({ definition: k.definition, idx: k.idx }),
          L = k.definition.concat([C], xn(m)),
          w = { idx: g, def: L, ruleStack: y, occurrenceStack: b };
        d.push(w);
      } else if (k instanceof Or)
        for (let T = k.definition.length - 1; T >= 0; T--) {
          let C = k.definition[T],
            L = {
              idx: g,
              def: C.definition.concat(xn(m)),
              ruleStack: y,
              occurrenceStack: b,
            };
          (d.push(L), d.push(o));
        }
      else if (k instanceof Vr)
        d.push({
          idx: g,
          def: k.definition.concat(xn(m)),
          ruleStack: y,
          occurrenceStack: b,
        });
      else if (k instanceof zi) d.push(m4t(k, g, y, b));
      else throw Error("non exhaustive match");
    }
    return f;
  }
  function m4t(e, t, r, n) {
    let i = Sr(r);
    i.push(e.name);
    let s = Sr(n);
    return (
      s.push(1),
      { idx: t, def: e.definition, ruleStack: i, occurrenceStack: s }
    );
  }
  var mL,
    BT,
    Fp,
    FT,
    C1,
    $T,
    w1,
    v1 = x(() => {
      "use strict";
      he();
      rL();
      LT();
      Ui();
      ((mL = class extends wl {
        static {
          a(this, "AbstractNextPossibleTokensWalker");
        }
        constructor(t, r) {
          (super(),
            (this.topProd = t),
            (this.path = r),
            (this.possibleTokTypes = []),
            (this.nextProductionName = ""),
            (this.nextProductionOccurrence = 0),
            (this.found = !1),
            (this.isAtEndOfPath = !1));
        }
        startWalking() {
          if (((this.found = !1), this.path.ruleStack[0] !== this.topProd.name))
            throw Error("The path does not start with the walker's top Rule!");
          return (
            (this.ruleStack = Sr(this.path.ruleStack).reverse()),
            (this.occurrenceStack = Sr(this.path.occurrenceStack).reverse()),
            this.ruleStack.pop(),
            this.occurrenceStack.pop(),
            this.updateExpectedNext(),
            this.walk(this.topProd),
            this.possibleTokTypes
          );
        }
        walk(t, r = []) {
          this.found || super.walk(t, r);
        }
        walkProdRef(t, r, n) {
          if (
            t.referencedRule.name === this.nextProductionName &&
            t.idx === this.nextProductionOccurrence
          ) {
            let i = r.concat(n);
            (this.updateExpectedNext(), this.walk(t.referencedRule, i));
          }
        }
        updateExpectedNext() {
          De(this.ruleStack)
            ? ((this.nextProductionName = ""),
              (this.nextProductionOccurrence = 0),
              (this.isAtEndOfPath = !0))
            : ((this.nextProductionName = this.ruleStack.pop()),
              (this.nextProductionOccurrence = this.occurrenceStack.pop()));
        }
      }),
        (BT = class extends mL {
          static {
            a(this, "NextAfterTokenWalker");
          }
          constructor(t, r) {
            (super(t, r),
              (this.path = r),
              (this.nextTerminalName = ""),
              (this.nextTerminalOccurrence = 0),
              (this.nextTerminalName = this.path.lastTok.name),
              (this.nextTerminalOccurrence = this.path.lastTokOccurrence));
          }
          walkTerminal(t, r, n) {
            if (
              this.isAtEndOfPath &&
              t.terminalType.name === this.nextTerminalName &&
              t.idx === this.nextTerminalOccurrence &&
              !this.found
            ) {
              let i = r.concat(n),
                s = new Vr({ definition: i });
              ((this.possibleTokTypes = Lh(s)), (this.found = !0));
            }
          }
        }),
        (Fp = class extends wl {
          static {
            a(this, "AbstractNextTerminalAfterProductionWalker");
          }
          constructor(t, r) {
            (super(),
              (this.topRule = t),
              (this.occurrence = r),
              (this.result = {
                token: void 0,
                occurrence: void 0,
                isEndOfRule: void 0,
              }));
          }
          startWalking() {
            return (this.walk(this.topRule), this.result);
          }
        }),
        (FT = class extends Fp {
          static {
            a(this, "NextTerminalAfterManyWalker");
          }
          walkMany(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n));
              ((this.result.isEndOfRule = i === void 0),
                i instanceof je &&
                  ((this.result.token = i.terminalType),
                  (this.result.occurrence = i.idx)));
            } else super.walkMany(t, r, n);
          }
        }),
        (C1 = class extends Fp {
          static {
            a(this, "NextTerminalAfterManySepWalker");
          }
          walkManySep(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n));
              ((this.result.isEndOfRule = i === void 0),
                i instanceof je &&
                  ((this.result.token = i.terminalType),
                  (this.result.occurrence = i.idx)));
            } else super.walkManySep(t, r, n);
          }
        }),
        ($T = class extends Fp {
          static {
            a(this, "NextTerminalAfterAtLeastOneWalker");
          }
          walkAtLeastOne(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n));
              ((this.result.isEndOfRule = i === void 0),
                i instanceof je &&
                  ((this.result.token = i.terminalType),
                  (this.result.occurrence = i.idx)));
            } else super.walkAtLeastOne(t, r, n);
          }
        }),
        (w1 = class extends Fp {
          static {
            a(this, "NextTerminalAfterAtLeastOneSepWalker");
          }
          walkAtLeastOneSep(t, r, n) {
            if (t.idx === this.occurrence) {
              let i = Qn(r.concat(n));
              ((this.result.isEndOfRule = i === void 0),
                i instanceof je &&
                  ((this.result.token = i.terminalType),
                  (this.result.occurrence = i.idx)));
            } else super.walkAtLeastOneSep(t, r, n);
          }
        }));
      a(GT, "possiblePathsFrom");
      a(VT, "nextPossibleTokensAfter");
      a(m4t, "expandTopLevelRule");
    });
  function E1(e) {
    if (e instanceof wr || e === "Option") return en.OPTION;
    if (e instanceof ir || e === "Repetition") return en.REPETITION;
    if (e instanceof zr || e === "RepetitionMandatory")
      return en.REPETITION_MANDATORY;
    if (e instanceof Wr || e === "RepetitionMandatoryWithSeparator")
      return en.REPETITION_MANDATORY_WITH_SEPARATOR;
    if (e instanceof Mr || e === "RepetitionWithSeparator")
      return en.REPETITION_WITH_SEPARATOR;
    if (e instanceof Or || e === "Alternation") return en.ALTERNATION;
    throw Error("non exhaustive match");
  }
  function WT(e) {
    let { occurrence: t, rule: r, prodType: n, maxLookahead: i } = e,
      s = E1(n);
    return s === en.ALTERNATION ? $p(t, r, i) : Gp(t, r, s, i);
  }
  function RQ(e, t, r, n, i, s) {
    let o = $p(e, t, r),
      l = PQ(o) ? Op : vl;
    return s(o, n, l, i);
  }
  function DQ(e, t, r, n, i, s) {
    let o = Gp(e, t, i, r),
      l = PQ(o) ? Op : vl;
    return s(o[0], l, n);
  }
  function NQ(e, t, r, n) {
    let i = e.length,
      s = bi(e, (o) => bi(o, (l) => l.length === 1));
    if (t)
      return function (o) {
        let l = Dt(o, (u) => u.GATE);
        for (let u = 0; u < i; u++) {
          let h = e[u],
            f = h.length,
            d = l[u];
          if (!(d !== void 0 && d.call(this) === !1))
            t: for (let p = 0; p < f; p++) {
              let m = h[p],
                g = m.length;
              for (let y = 0; y < g; y++) {
                let b = this.LA(y + 1);
                if (r(b, m[y]) === !1) continue t;
              }
              return u;
            }
        }
      };
    if (s && !n) {
      let o = Dt(e, (u) => dr(u)),
        l = mr(
          o,
          (u, h, f) => (
            rt(h, (d) => {
              (te(u, d.tokenTypeIdx) || (u[d.tokenTypeIdx] = f),
                rt(d.categoryMatches, (p) => {
                  te(u, p) || (u[p] = f);
                }));
            }),
            u
          ),
          {},
        );
      return function () {
        let u = this.LA(1);
        return l[u.tokenTypeIdx];
      };
    } else
      return function () {
        for (let o = 0; o < i; o++) {
          let l = e[o],
            u = l.length;
          t: for (let h = 0; h < u; h++) {
            let f = l[h],
              d = f.length;
            for (let p = 0; p < d; p++) {
              let m = this.LA(p + 1);
              if (r(m, f[p]) === !1) continue t;
            }
            return o;
          }
        }
      };
  }
  function IQ(e, t, r) {
    let n = bi(e, (s) => s.length === 1),
      i = e.length;
    if (n && !r) {
      let s = dr(e);
      if (s.length === 1 && De(s[0].categoryMatches)) {
        let l = s[0].tokenTypeIdx;
        return function () {
          return this.LA(1).tokenTypeIdx === l;
        };
      } else {
        let o = mr(
          s,
          (l, u, h) => (
            (l[u.tokenTypeIdx] = !0),
            rt(u.categoryMatches, (f) => {
              l[f] = !0;
            }),
            l
          ),
          [],
        );
        return function () {
          let l = this.LA(1);
          return o[l.tokenTypeIdx] === !0;
        };
      }
    } else
      return function () {
        t: for (let s = 0; s < i; s++) {
          let o = e[s],
            l = o.length;
          for (let u = 0; u < l; u++) {
            let h = this.LA(u + 1);
            if (t(h, o[u]) === !1) continue t;
          }
          return !0;
        }
        return !1;
      };
  }
  function LQ(e) {
    let t = new Array(e);
    for (let r = 0; r < e; r++) t[r] = [];
    return t;
  }
  function gL(e) {
    let t = [""];
    for (let r = 0; r < e.length; r++) {
      let n = e[r],
        i = [];
      for (let s = 0; s < t.length; s++) {
        let o = t[s];
        i.push(o + "_" + n.tokenTypeIdx);
        for (let l = 0; l < n.categoryMatches.length; l++) {
          let u = "_" + n.categoryMatches[l];
          i.push(o + u);
        }
      }
      t = i;
    }
    return t;
  }
  function g4t(e, t, r) {
    for (let n = 0; n < e.length; n++) {
      if (n === r) continue;
      let i = e[n];
      for (let s = 0; s < t.length; s++) {
        let o = t[s];
        if (i[o] === !0) return !1;
      }
    }
    return !0;
  }
  function MQ(e, t) {
    let r = Dt(e, (o) => GT([o], 1)),
      n = LQ(r.length),
      i = Dt(r, (o) => {
        let l = {};
        return (
          rt(o, (u) => {
            let h = gL(u.partialPath);
            rt(h, (f) => {
              l[f] = !0;
            });
          }),
          l
        );
      }),
      s = r;
    for (let o = 1; o <= t; o++) {
      let l = s;
      s = LQ(l.length);
      for (let u = 0; u < l.length; u++) {
        let h = l[u];
        for (let f = 0; f < h.length; f++) {
          let d = h[f].partialPath,
            p = h[f].suffixDef,
            m = gL(d);
          if (g4t(i, m, u) || De(p) || d.length === t) {
            let y = n[u];
            if (UT(y, d) === !1) {
              y.push(d);
              for (let b = 0; b < m.length; b++) {
                let k = m[b];
                i[u][k] = !0;
              }
            }
          } else {
            let y = GT(p, o + 1, d);
            ((s[u] = s[u].concat(y)),
              rt(y, (b) => {
                let k = gL(b.partialPath);
                rt(k, (T) => {
                  i[u][T] = !0;
                });
              }));
          }
        }
      }
    }
    return n;
  }
  function $p(e, t, r, n) {
    let i = new zT(e, en.ALTERNATION, n);
    return (t.accept(i), MQ(i.result, r));
  }
  function Gp(e, t, r, n) {
    let i = new zT(e, r);
    t.accept(i);
    let s = i.result,
      l = new yL(t, e, r).startWalking(),
      u = new Vr({ definition: s }),
      h = new Vr({ definition: l });
    return MQ([u, h], n);
  }
  function UT(e, t) {
    t: for (let r = 0; r < e.length; r++) {
      let n = e[r];
      if (n.length === t.length) {
        for (let i = 0; i < n.length; i++) {
          let s = t[i],
            o = n[i];
          if (
            (s === o || o.categoryMatchesMap[s.tokenTypeIdx] !== void 0) === !1
          )
            continue t;
        }
        return !0;
      }
    }
    return !1;
  }
  function OQ(e, t) {
    return (
      e.length < t.length &&
      bi(e, (r, n) => {
        let i = t[n];
        return r === i || i.categoryMatchesMap[r.tokenTypeIdx];
      })
    );
  }
  function PQ(e) {
    return bi(e, (t) => bi(t, (r) => bi(r, (n) => De(n.categoryMatches))));
  }
  var en,
    yL,
    zT,
    Vp = x(() => {
      "use strict";
      he();
      v1();
      LT();
      Dh();
      Ui();
      (function (e) {
        ((e[(e.OPTION = 0)] = "OPTION"),
          (e[(e.REPETITION = 1)] = "REPETITION"),
          (e[(e.REPETITION_MANDATORY = 2)] = "REPETITION_MANDATORY"),
          (e[(e.REPETITION_MANDATORY_WITH_SEPARATOR = 3)] =
            "REPETITION_MANDATORY_WITH_SEPARATOR"),
          (e[(e.REPETITION_WITH_SEPARATOR = 4)] = "REPETITION_WITH_SEPARATOR"),
          (e[(e.ALTERNATION = 5)] = "ALTERNATION"));
      })(en || (en = {}));
      a(E1, "getProdType");
      a(WT, "getLookaheadPaths");
      a(RQ, "buildLookaheadFuncForOr");
      a(DQ, "buildLookaheadFuncForOptionalProd");
      a(NQ, "buildAlternativesLookAheadFunc");
      a(IQ, "buildSingleAlternativeLookaheadFunction");
      ((yL = class extends wl {
        static {
          a(this, "RestDefinitionFinderWalker");
        }
        constructor(t, r, n) {
          (super(),
            (this.topProd = t),
            (this.targetOccurrence = r),
            (this.targetProdType = n));
        }
        startWalking() {
          return (this.walk(this.topProd), this.restDef);
        }
        checkIsTarget(t, r, n, i) {
          return t.idx === this.targetOccurrence && this.targetProdType === r
            ? ((this.restDef = n.concat(i)), !0)
            : !1;
        }
        walkOption(t, r, n) {
          this.checkIsTarget(t, en.OPTION, r, n) || super.walkOption(t, r, n);
        }
        walkAtLeastOne(t, r, n) {
          this.checkIsTarget(t, en.REPETITION_MANDATORY, r, n) ||
            super.walkOption(t, r, n);
        }
        walkAtLeastOneSep(t, r, n) {
          this.checkIsTarget(t, en.REPETITION_MANDATORY_WITH_SEPARATOR, r, n) ||
            super.walkOption(t, r, n);
        }
        walkMany(t, r, n) {
          this.checkIsTarget(t, en.REPETITION, r, n) ||
            super.walkOption(t, r, n);
        }
        walkManySep(t, r, n) {
          this.checkIsTarget(t, en.REPETITION_WITH_SEPARATOR, r, n) ||
            super.walkOption(t, r, n);
        }
      }),
        (zT = class extends Wi {
          static {
            a(this, "InsideDefinitionFinderVisitor");
          }
          constructor(t, r, n) {
            (super(),
              (this.targetOccurrence = t),
              (this.targetProdType = r),
              (this.targetRef = n),
              (this.result = []));
          }
          checkIsTarget(t, r) {
            t.idx === this.targetOccurrence &&
              this.targetProdType === r &&
              (this.targetRef === void 0 || t === this.targetRef) &&
              (this.result = t.definition);
          }
          visitOption(t) {
            this.checkIsTarget(t, en.OPTION);
          }
          visitRepetition(t) {
            this.checkIsTarget(t, en.REPETITION);
          }
          visitRepetitionMandatory(t) {
            this.checkIsTarget(t, en.REPETITION_MANDATORY);
          }
          visitRepetitionMandatoryWithSeparator(t) {
            this.checkIsTarget(t, en.REPETITION_MANDATORY_WITH_SEPARATOR);
          }
          visitRepetitionWithSeparator(t) {
            this.checkIsTarget(t, en.REPETITION_WITH_SEPARATOR);
          }
          visitAlternation(t) {
            this.checkIsTarget(t, en.ALTERNATION);
          }
        }));
      a(LQ, "initializeArrayOfArrays");
      a(gL, "pathToHashKeys");
      a(g4t, "isUniquePrefixHash");
      a(MQ, "lookAheadSequenceFromAlternatives");
      a($p, "getLookaheadPathsForOr");
      a(Gp, "getLookaheadPathsForOptionalProd");
      a(UT, "containsPath");
      a(OQ, "isStrictPrefixOfPath");
      a(PQ, "areTokenCategoriesNotUsed");
    });
  function BQ(e) {
    let t = e.lookaheadStrategy.validate({
      rules: e.rules,
      tokenTypes: e.tokenTypes,
      grammarName: e.grammarName,
    });
    return Dt(t, (r) =>
      Object.assign({ type: Fn.CUSTOM_LOOKAHEAD_VALIDATION }, r),
    );
  }
  function FQ(e, t, r, n) {
    let i = oi(e, (u) => y4t(u, r)),
      s = _4t(e, t, r),
      o = oi(e, (u) => k4t(u, r)),
      l = oi(e, (u) => b4t(u, e, n, r));
    return i.concat(s, o, l);
  }
  function y4t(e, t) {
    let r = new xL();
    e.accept(r);
    let n = r.allProductions,
      i = m5(n, x4t),
      s = ps(i, (l) => l.length > 1);
    return Dt(We(s), (l) => {
      let u = Qn(l),
        h = t.buildDuplicateFoundError(e, l),
        f = gs(u),
        d = {
          message: h,
          type: Fn.DUPLICATE_PRODUCTIONS,
          ruleName: e.name,
          dslName: f,
          occurrence: u.idx,
        },
        p = $Q(u);
      return (p && (d.parameter = p), d);
    });
  }
  function x4t(e) {
    return `${gs(e)}_#_${e.idx}_#_${$Q(e)}`;
  }
  function $Q(e) {
    return e instanceof je
      ? e.terminalType.name
      : e instanceof Cr
        ? e.nonTerminalName
        : "";
  }
  function b4t(e, t, r, n) {
    let i = [];
    if (mr(t, (o, l) => (l.name === e.name ? o + 1 : o), 0) > 1) {
      let o = n.buildDuplicateRuleNameError({
        topLevelRule: e,
        grammarName: r,
      });
      i.push({ message: o, type: Fn.DUPLICATE_RULE_NAME, ruleName: e.name });
    }
    return i;
  }
  function GQ(e, t, r) {
    let n = [],
      i;
    return (
      Zr(t, e) ||
        ((i = `Invalid rule override, rule: ->${e}<- cannot be overridden in the grammar: ->${r}<-as it is not defined in any of the super grammars `),
        n.push({ message: i, type: Fn.INVALID_RULE_OVERRIDE, ruleName: e })),
      n
    );
  }
  function kL(e, t, r, n = []) {
    let i = [],
      s = jT(t.definition);
    if (De(s)) return [];
    {
      let o = e.name;
      Zr(s, e) &&
        i.push({
          message: r.buildLeftRecursionError({
            topLevelRule: e,
            leftRecursionPath: n,
          }),
          type: Fn.LEFT_RECURSION,
          ruleName: o,
        });
      let u = Pc(s, n.concat([e])),
        h = oi(u, (f) => {
          let d = Sr(n);
          return (d.push(f), kL(e, f, r, d));
        });
      return i.concat(h);
    }
  }
  function jT(e) {
    let t = [];
    if (De(e)) return t;
    let r = Qn(e);
    if (r instanceof Cr) t.push(r.referencedRule);
    else if (
      r instanceof Vr ||
      r instanceof wr ||
      r instanceof zr ||
      r instanceof Wr ||
      r instanceof Mr ||
      r instanceof ir
    )
      t = t.concat(jT(r.definition));
    else if (r instanceof Or) t = dr(Dt(r.definition, (s) => jT(s.definition)));
    else if (!(r instanceof je)) throw Error("non exhaustive match");
    let n = Ah(r),
      i = e.length > 1;
    if (n && i) {
      let s = xn(e);
      return t.concat(jT(s));
    } else return t;
  }
  function VQ(e, t) {
    let r = new A1();
    e.accept(r);
    let n = r.alternations;
    return oi(n, (s) => {
      let o = Sl(s.definition);
      return oi(o, (l, u) => {
        let h = VT([l], [], vl, 1);
        return De(h)
          ? [
              {
                message: t.buildEmptyAlternationError({
                  topLevelRule: e,
                  alternation: s,
                  emptyChoiceIdx: u,
                }),
                type: Fn.NONE_LAST_EMPTY_ALT,
                ruleName: e.name,
                occurrence: s.idx,
                alternative: u + 1,
              },
            ]
          : [];
      });
    });
  }
  function zQ(e, t, r) {
    let n = new A1();
    e.accept(n);
    let i = n.alternations;
    return (
      (i = Bc(i, (o) => o.ignoreAmbiguities === !0)),
      oi(i, (o) => {
        let l = o.idx,
          u = o.maxLookahead || t,
          h = $p(l, e, u, o),
          f = T4t(h, o, e, r),
          d = S4t(h, o, e, r);
        return f.concat(d);
      })
    );
  }
  function k4t(e, t) {
    let r = new A1();
    e.accept(r);
    let n = r.alternations;
    return oi(n, (s) =>
      s.definition.length > 255
        ? [
            {
              message: t.buildTooManyAlternativesError({
                topLevelRule: e,
                alternation: s,
              }),
              type: Fn.TOO_MANY_ALTS,
              ruleName: e.name,
              occurrence: s.idx,
            },
          ]
        : [],
    );
  }
  function WQ(e, t, r) {
    let n = [];
    return (
      rt(e, (i) => {
        let s = new bL();
        i.accept(s);
        let o = s.allProductions;
        rt(o, (l) => {
          let u = E1(l),
            h = l.maxLookahead || t,
            f = l.idx,
            p = Gp(f, i, u, h)[0];
          if (De(dr(p))) {
            let m = r.buildEmptyRepetitionError({
              topLevelRule: i,
              repetition: l,
            });
            n.push({
              message: m,
              type: Fn.NO_NON_EMPTY_LOOKAHEAD,
              ruleName: i.name,
            });
          }
        });
      }),
      n
    );
  }
  function T4t(e, t, r, n) {
    let i = [],
      s = mr(
        e,
        (l, u, h) => (
          t.definition[h].ignoreAmbiguities === !0 ||
            rt(u, (f) => {
              let d = [h];
              (rt(e, (p, m) => {
                h !== m &&
                  UT(p, f) &&
                  t.definition[m].ignoreAmbiguities !== !0 &&
                  d.push(m);
              }),
                d.length > 1 &&
                  !UT(i, f) &&
                  (i.push(f), l.push({ alts: d, path: f })));
            }),
          l
        ),
        [],
      );
    return Dt(s, (l) => {
      let u = Dt(l.alts, (f) => f + 1);
      return {
        message: n.buildAlternationAmbiguityError({
          topLevelRule: r,
          alternation: t,
          ambiguityIndices: u,
          prefixPath: l.path,
        }),
        type: Fn.AMBIGUOUS_ALTS,
        ruleName: r.name,
        occurrence: t.idx,
        alternatives: l.alts,
      };
    });
  }
  function S4t(e, t, r, n) {
    let i = mr(
      e,
      (o, l, u) => {
        let h = Dt(l, (f) => ({ idx: u, path: f }));
        return o.concat(h);
      },
      [],
    );
    return Ao(
      oi(i, (o) => {
        if (t.definition[o.idx].ignoreAmbiguities === !0) return [];
        let u = o.idx,
          h = o.path,
          f = pr(
            i,
            (p) =>
              t.definition[p.idx].ignoreAmbiguities !== !0 &&
              p.idx < u &&
              OQ(p.path, h),
          );
        return Dt(f, (p) => {
          let m = [p.idx + 1, u + 1],
            g = t.idx === 0 ? "" : t.idx;
          return {
            message: n.buildAlternationPrefixAmbiguityError({
              topLevelRule: r,
              alternation: t,
              ambiguityIndices: m,
              prefixPath: p.path,
            }),
            type: Fn.AMBIGUOUS_PREFIX_ALTS,
            ruleName: r.name,
            occurrence: g,
            alternatives: m,
          };
        });
      }),
    );
  }
  function _4t(e, t, r) {
    let n = [],
      i = Dt(t, (s) => s.name);
    return (
      rt(e, (s) => {
        let o = s.name;
        if (Zr(i, o)) {
          let l = r.buildNamespaceConflictError(s);
          n.push({
            message: l,
            type: Fn.CONFLICT_TOKENS_RULES_NAMESPACE,
            ruleName: o,
          });
        }
      }),
      n
    );
  }
  var xL,
    A1,
    bL,
    L1 = x(() => {
      "use strict";
      he();
      ys();
      Ui();
      Vp();
      v1();
      Dh();
      a(BQ, "validateLookahead");
      a(FQ, "validateGrammar");
      a(y4t, "validateDuplicateProductions");
      a(x4t, "identifyProductionForDuplicates");
      a($Q, "getExtraProductionArgument");
      xL = class extends Wi {
        static {
          a(this, "OccurrenceValidationCollector");
        }
        constructor() {
          (super(...arguments), (this.allProductions = []));
        }
        visitNonTerminal(t) {
          this.allProductions.push(t);
        }
        visitOption(t) {
          this.allProductions.push(t);
        }
        visitRepetitionWithSeparator(t) {
          this.allProductions.push(t);
        }
        visitRepetitionMandatory(t) {
          this.allProductions.push(t);
        }
        visitRepetitionMandatoryWithSeparator(t) {
          this.allProductions.push(t);
        }
        visitRepetition(t) {
          this.allProductions.push(t);
        }
        visitAlternation(t) {
          this.allProductions.push(t);
        }
        visitTerminal(t) {
          this.allProductions.push(t);
        }
      };
      a(b4t, "validateRuleDoesNotAlreadyExist");
      a(GQ, "validateRuleIsOverridden");
      a(kL, "validateNoLeftRecursion");
      a(jT, "getFirstNoneTerminal");
      A1 = class extends Wi {
        static {
          a(this, "OrCollector");
        }
        constructor() {
          (super(...arguments), (this.alternations = []));
        }
        visitAlternation(t) {
          this.alternations.push(t);
        }
      };
      a(VQ, "validateEmptyOrAlternative");
      a(zQ, "validateAmbiguousAlternationAlternatives");
      bL = class extends Wi {
        static {
          a(this, "RepetitionCollector");
        }
        constructor() {
          (super(...arguments), (this.allProductions = []));
        }
        visitRepetitionWithSeparator(t) {
          this.allProductions.push(t);
        }
        visitRepetitionMandatory(t) {
          this.allProductions.push(t);
        }
        visitRepetitionMandatoryWithSeparator(t) {
          this.allProductions.push(t);
        }
        visitRepetition(t) {
          this.allProductions.push(t);
        }
      };
      a(k4t, "validateTooManyAlts");
      a(WQ, "validateSomeNonEmptyLookaheadPath");
      a(T4t, "checkAlternativesAmbiguities");
      a(S4t, "checkPrefixAlternativesAmbiguities");
      a(_4t, "checkTerminalAndNoneTerminalsNameSpace");
    });
  function UQ(e) {
    let t = Oc(e, { errMsgProvider: vQ }),
      r = {};
    return (
      rt(e.rules, (n) => {
        r[n.name] = n;
      }),
      EQ(r, t.errMsgProvider)
    );
  }
  function jQ(e) {
    return (
      (e = Oc(e, { errMsgProvider: Ya })),
      FQ(e.rules, e.tokenTypes, e.errMsgProvider, e.grammarName)
    );
  }
  var qQ = x(() => {
    "use strict";
    he();
    AQ();
    L1();
    Bp();
    a(UQ, "resolveGrammar");
    a(jQ, "validateGrammar");
  });
  function jc(e) {
    return Zr(QQ, e.name);
  }
  var HQ,
    YQ,
    XQ,
    KQ,
    QQ,
    zp,
    Ih,
    R1,
    D1,
    N1,
    Wp = x(() => {
      "use strict";
      he();
      ((HQ = "MismatchedTokenException"),
        (YQ = "NoViableAltException"),
        (XQ = "EarlyExitException"),
        (KQ = "NotAllInputParsedException"),
        (QQ = [HQ, YQ, XQ, KQ]));
      Object.freeze(QQ);
      a(jc, "isRecognitionException");
      ((zp = class extends Error {
        static {
          a(this, "RecognitionException");
        }
        constructor(t, r) {
          (super(t),
            (this.token = r),
            (this.resyncedTokens = []),
            Object.setPrototypeOf(this, new.target.prototype),
            Error.captureStackTrace &&
              Error.captureStackTrace(this, this.constructor));
        }
      }),
        (Ih = class extends zp {
          static {
            a(this, "MismatchedTokenException");
          }
          constructor(t, r, n) {
            (super(t, r), (this.previousToken = n), (this.name = HQ));
          }
        }),
        (R1 = class extends zp {
          static {
            a(this, "NoViableAltException");
          }
          constructor(t, r, n) {
            (super(t, r), (this.previousToken = n), (this.name = YQ));
          }
        }),
        (D1 = class extends zp {
          static {
            a(this, "NotAllInputParsedException");
          }
          constructor(t, r) {
            (super(t, r), (this.name = KQ));
          }
        }),
        (N1 = class extends zp {
          static {
            a(this, "EarlyExitException");
          }
          constructor(t, r, n) {
            (super(t, r), (this.previousToken = n), (this.name = XQ));
          }
        }));
    });
  function C4t(e, t, r, n, i, s, o) {
    let l = this.getKeyForAutomaticLookahead(n, i),
      u = this.firstAfterRepMap[l];
    if (u === void 0) {
      let p = this.getCurrRuleFullName(),
        m = this.getGAstProductions()[p];
      ((u = new s(m, i).startWalking()), (this.firstAfterRepMap[l] = u));
    }
    let h = u.token,
      f = u.occurrence,
      d = u.isEndOfRule;
    (this.RULE_STACK.length === 1 && d && h === void 0 && ((h = Os), (f = 1)),
      !(h === void 0 || f === void 0) &&
        this.shouldInRepetitionRecoveryBeTried(h, f, o) &&
        this.tryInRepetitionRecovery(e, t, r, h));
  }
  var TL,
    _L,
    SL,
    qT,
    CL = x(() => {
      "use strict";
      Nh();
      he();
      Wp();
      nL();
      ys();
      ((TL = {}),
        (_L = "InRuleRecoveryException"),
        (SL = class extends Error {
          static {
            a(this, "InRuleRecoveryException");
          }
          constructor(t) {
            (super(t), (this.name = _L));
          }
        }),
        (qT = class {
          static {
            a(this, "Recoverable");
          }
          initRecoverable(t) {
            ((this.firstAfterRepMap = {}),
              (this.resyncFollows = {}),
              (this.recoveryEnabled = te(t, "recoveryEnabled")
                ? t.recoveryEnabled
                : ji.recoveryEnabled),
              this.recoveryEnabled && (this.attemptInRepetitionRecovery = C4t));
          }
          getTokenToInsert(t) {
            let r = Ll(t, "", NaN, NaN, NaN, NaN, NaN, NaN);
            return ((r.isInsertedInRecovery = !0), r);
          }
          canTokenTypeBeInsertedInRecovery(t) {
            return !0;
          }
          canTokenTypeBeDeletedInRecovery(t) {
            return !0;
          }
          tryInRepetitionRecovery(t, r, n, i) {
            let s = this.findReSyncTokenType(),
              o = this.exportLexerState(),
              l = [],
              u = !1,
              h = this.LA(1),
              f = this.LA(1),
              d = a(() => {
                let p = this.LA(0),
                  m = this.errorMessageProvider.buildMismatchTokenMessage({
                    expected: i,
                    actual: h,
                    previous: p,
                    ruleName: this.getCurrRuleFullName(),
                  }),
                  g = new Ih(m, h, this.LA(0));
                ((g.resyncedTokens = Sl(l)), this.SAVE_ERROR(g));
              }, "generateErrorMessage");
            for (; !u; )
              if (this.tokenMatcher(f, i)) {
                d();
                return;
              } else if (n.call(this)) {
                (d(), t.apply(this, r));
                return;
              } else
                this.tokenMatcher(f, s)
                  ? (u = !0)
                  : ((f = this.SKIP_TOKEN()), this.addToResyncTokens(f, l));
            this.importLexerState(o);
          }
          shouldInRepetitionRecoveryBeTried(t, r, n) {
            return !(
              n === !1 ||
              this.tokenMatcher(this.LA(1), t) ||
              this.isBackTracking() ||
              this.canPerformInRuleRecovery(
                t,
                this.getFollowsForInRuleRecovery(t, r),
              )
            );
          }
          getFollowsForInRuleRecovery(t, r) {
            let n = this.getCurrentGrammarPath(t, r);
            return this.getNextPossibleTokenTypes(n);
          }
          tryInRuleRecovery(t, r) {
            if (this.canRecoverWithSingleTokenInsertion(t, r))
              return this.getTokenToInsert(t);
            if (this.canRecoverWithSingleTokenDeletion(t)) {
              let n = this.SKIP_TOKEN();
              return (this.consumeToken(), n);
            }
            throw new SL("sad sad panda");
          }
          canPerformInRuleRecovery(t, r) {
            return (
              this.canRecoverWithSingleTokenInsertion(t, r) ||
              this.canRecoverWithSingleTokenDeletion(t)
            );
          }
          canRecoverWithSingleTokenInsertion(t, r) {
            if (!this.canTokenTypeBeInsertedInRecovery(t) || De(r)) return !1;
            let n = this.LA(1);
            return Gi(r, (s) => this.tokenMatcher(n, s)) !== void 0;
          }
          canRecoverWithSingleTokenDeletion(t) {
            return this.canTokenTypeBeDeletedInRecovery(t)
              ? this.tokenMatcher(this.LA(2), t)
              : !1;
          }
          isInCurrentRuleReSyncSet(t) {
            let r = this.getCurrFollowKey(),
              n = this.getFollowSetFromFollowKey(r);
            return Zr(n, t);
          }
          findReSyncTokenType() {
            let t = this.flattenFollowSet(),
              r = this.LA(1),
              n = 2;
            for (;;) {
              let i = Gi(t, (s) => _1(r, s));
              if (i !== void 0) return i;
              ((r = this.LA(n)), n++);
            }
          }
          getCurrFollowKey() {
            if (this.RULE_STACK.length === 1) return TL;
            let t = this.getLastExplicitRuleShortName(),
              r = this.getLastExplicitRuleOccurrenceIndex(),
              n = this.getPreviousExplicitRuleShortName();
            return {
              ruleName: this.shortRuleNameToFullName(t),
              idxInCallingRule: r,
              inRule: this.shortRuleNameToFullName(n),
            };
          }
          buildFullFollowKeyStack() {
            let t = this.RULE_STACK,
              r = this.RULE_OCCURRENCE_STACK;
            return Dt(t, (n, i) =>
              i === 0
                ? TL
                : {
                    ruleName: this.shortRuleNameToFullName(n),
                    idxInCallingRule: r[i],
                    inRule: this.shortRuleNameToFullName(t[i - 1]),
                  },
            );
          }
          flattenFollowSet() {
            let t = Dt(this.buildFullFollowKeyStack(), (r) =>
              this.getFollowSetFromFollowKey(r),
            );
            return dr(t);
          }
          getFollowSetFromFollowKey(t) {
            if (t === TL) return [Os];
            let r = t.ruleName + t.idxInCallingRule + RT + t.inRule;
            return this.resyncFollows[r];
          }
          addToResyncTokens(t, r) {
            return (this.tokenMatcher(t, Os) || r.push(t), r);
          }
          reSyncTo(t) {
            let r = [],
              n = this.LA(1);
            for (; this.tokenMatcher(n, t) === !1; )
              ((n = this.SKIP_TOKEN()), this.addToResyncTokens(n, r));
            return Sl(r);
          }
          attemptInRepetitionRecovery(t, r, n, i, s, o, l) {}
          getCurrentGrammarPath(t, r) {
            let n = this.getHumanReadableRuleStack(),
              i = Sr(this.RULE_OCCURRENCE_STACK);
            return {
              ruleStack: n,
              occurrenceStack: i,
              lastTok: t,
              lastTokOccurrence: r,
            };
          }
          getHumanReadableRuleStack() {
            return Dt(this.RULE_STACK, (t) => this.shortRuleNameToFullName(t));
          }
        }));
      a(C4t, "attemptInRepetitionRecovery");
    });
  function HT(e, t, r) {
    return r | t | e;
  }
  var YT = x(() => {
    "use strict";
    a(HT, "getKeyForAutomaticLookahead");
  });
  var Dl,
    wL = x(() => {
      "use strict";
      he();
      Bp();
      ys();
      L1();
      Vp();
      Dl = class {
        static {
          a(this, "LLkLookaheadStrategy");
        }
        constructor(t) {
          var r;
          this.maxLookahead =
            (r = t?.maxLookahead) !== null && r !== void 0
              ? r
              : ji.maxLookahead;
        }
        validate(t) {
          let r = this.validateNoLeftRecursion(t.rules);
          if (De(r)) {
            let n = this.validateEmptyOrAlternatives(t.rules),
              i = this.validateAmbiguousAlternationAlternatives(
                t.rules,
                this.maxLookahead,
              ),
              s = this.validateSomeNonEmptyLookaheadPath(
                t.rules,
                this.maxLookahead,
              );
            return [...r, ...n, ...i, ...s];
          }
          return r;
        }
        validateNoLeftRecursion(t) {
          return oi(t, (r) => kL(r, r, Ya));
        }
        validateEmptyOrAlternatives(t) {
          return oi(t, (r) => VQ(r, Ya));
        }
        validateAmbiguousAlternationAlternatives(t, r) {
          return oi(t, (n) => zQ(n, r, Ya));
        }
        validateSomeNonEmptyLookaheadPath(t, r) {
          return WQ(t, r, Ya);
        }
        buildLookaheadForAlternation(t) {
          return RQ(
            t.prodOccurrence,
            t.rule,
            t.maxLookahead,
            t.hasPredicates,
            t.dynamicTokensEnabled,
            NQ,
          );
        }
        buildLookaheadForOptional(t) {
          return DQ(
            t.prodOccurrence,
            t.rule,
            t.maxLookahead,
            t.dynamicTokensEnabled,
            E1(t.prodType),
            IQ,
          );
        }
      };
    });
  function w4t(e) {
    (XT.reset(), e.accept(XT));
    let t = XT.dslMethods;
    return (XT.reset(), t);
  }
  var KT,
    vL,
    XT,
    ZQ = x(() => {
      "use strict";
      he();
      ys();
      YT();
      Ui();
      wL();
      ((KT = class {
        static {
          a(this, "LooksAhead");
        }
        initLooksAhead(t) {
          ((this.dynamicTokensEnabled = te(t, "dynamicTokensEnabled")
            ? t.dynamicTokensEnabled
            : ji.dynamicTokensEnabled),
            (this.maxLookahead = te(t, "maxLookahead")
              ? t.maxLookahead
              : ji.maxLookahead),
            (this.lookaheadStrategy = te(t, "lookaheadStrategy")
              ? t.lookaheadStrategy
              : new Dl({ maxLookahead: this.maxLookahead })),
            (this.lookAheadFuncsCache = new Map()));
        }
        preComputeLookaheadFunctions(t) {
          rt(t, (r) => {
            this.TRACE_INIT(`${r.name} Rule Lookahead`, () => {
              let {
                alternation: n,
                repetition: i,
                option: s,
                repetitionMandatory: o,
                repetitionMandatoryWithSeparator: l,
                repetitionWithSeparator: u,
              } = w4t(r);
              (rt(n, (h) => {
                let f = h.idx === 0 ? "" : h.idx;
                this.TRACE_INIT(`${gs(h)}${f}`, () => {
                  let d = this.lookaheadStrategy.buildLookaheadForAlternation({
                      prodOccurrence: h.idx,
                      rule: r,
                      maxLookahead: h.maxLookahead || this.maxLookahead,
                      hasPredicates: h.hasPredicates,
                      dynamicTokensEnabled: this.dynamicTokensEnabled,
                    }),
                    p = HT(this.fullRuleNameToShort[r.name], 256, h.idx);
                  this.setLaFuncCache(p, d);
                });
              }),
                rt(i, (h) => {
                  this.computeLookaheadFunc(
                    r,
                    h.idx,
                    768,
                    "Repetition",
                    h.maxLookahead,
                    gs(h),
                  );
                }),
                rt(s, (h) => {
                  this.computeLookaheadFunc(
                    r,
                    h.idx,
                    512,
                    "Option",
                    h.maxLookahead,
                    gs(h),
                  );
                }),
                rt(o, (h) => {
                  this.computeLookaheadFunc(
                    r,
                    h.idx,
                    1024,
                    "RepetitionMandatory",
                    h.maxLookahead,
                    gs(h),
                  );
                }),
                rt(l, (h) => {
                  this.computeLookaheadFunc(
                    r,
                    h.idx,
                    1536,
                    "RepetitionMandatoryWithSeparator",
                    h.maxLookahead,
                    gs(h),
                  );
                }),
                rt(u, (h) => {
                  this.computeLookaheadFunc(
                    r,
                    h.idx,
                    1280,
                    "RepetitionWithSeparator",
                    h.maxLookahead,
                    gs(h),
                  );
                }));
            });
          });
        }
        computeLookaheadFunc(t, r, n, i, s, o) {
          this.TRACE_INIT(`${o}${r === 0 ? "" : r}`, () => {
            let l = this.lookaheadStrategy.buildLookaheadForOptional({
                prodOccurrence: r,
                rule: t,
                maxLookahead: s || this.maxLookahead,
                dynamicTokensEnabled: this.dynamicTokensEnabled,
                prodType: i,
              }),
              u = HT(this.fullRuleNameToShort[t.name], n, r);
            this.setLaFuncCache(u, l);
          });
        }
        getKeyForAutomaticLookahead(t, r) {
          let n = this.getLastExplicitRuleShortName();
          return HT(n, t, r);
        }
        getLaFuncFromCache(t) {
          return this.lookAheadFuncsCache.get(t);
        }
        setLaFuncCache(t, r) {
          this.lookAheadFuncsCache.set(t, r);
        }
      }),
        (vL = class extends Wi {
          static {
            a(this, "DslMethodsCollectorVisitor");
          }
          constructor() {
            (super(...arguments),
              (this.dslMethods = {
                option: [],
                alternation: [],
                repetition: [],
                repetitionWithSeparator: [],
                repetitionMandatory: [],
                repetitionMandatoryWithSeparator: [],
              }));
          }
          reset() {
            this.dslMethods = {
              option: [],
              alternation: [],
              repetition: [],
              repetitionWithSeparator: [],
              repetitionMandatory: [],
              repetitionMandatoryWithSeparator: [],
            };
          }
          visitOption(t) {
            this.dslMethods.option.push(t);
          }
          visitRepetitionWithSeparator(t) {
            this.dslMethods.repetitionWithSeparator.push(t);
          }
          visitRepetitionMandatory(t) {
            this.dslMethods.repetitionMandatory.push(t);
          }
          visitRepetitionMandatoryWithSeparator(t) {
            this.dslMethods.repetitionMandatoryWithSeparator.push(t);
          }
          visitRepetition(t) {
            this.dslMethods.repetition.push(t);
          }
          visitAlternation(t) {
            this.dslMethods.alternation.push(t);
          }
        }),
        (XT = new vL()));
      a(w4t, "collectMethods");
    });
  function LL(e, t) {
    isNaN(e.startOffset) === !0
      ? ((e.startOffset = t.startOffset), (e.endOffset = t.endOffset))
      : e.endOffset < t.endOffset && (e.endOffset = t.endOffset);
  }
  function RL(e, t) {
    isNaN(e.startOffset) === !0
      ? ((e.startOffset = t.startOffset),
        (e.startColumn = t.startColumn),
        (e.startLine = t.startLine),
        (e.endOffset = t.endOffset),
        (e.endColumn = t.endColumn),
        (e.endLine = t.endLine))
      : e.endOffset < t.endOffset &&
        ((e.endOffset = t.endOffset),
        (e.endColumn = t.endColumn),
        (e.endLine = t.endLine));
  }
  function JQ(e, t, r) {
    e.children[r] === void 0 ? (e.children[r] = [t]) : e.children[r].push(t);
  }
  function tZ(e, t, r) {
    e.children[t] === void 0 ? (e.children[t] = [r]) : e.children[t].push(r);
  }
  var eZ = x(() => {
    "use strict";
    a(LL, "setNodeLocationOnlyOffset");
    a(RL, "setNodeLocationFull");
    a(JQ, "addTerminalToCst");
    a(tZ, "addNoneTerminalToCst");
  });
  function DL(e, t) {
    Object.defineProperty(e, v4t, {
      enumerable: !1,
      configurable: !0,
      writable: !1,
      value: t,
    });
  }
  var v4t,
    rZ = x(() => {
      "use strict";
      v4t = "name";
      a(DL, "defineNameProp");
    });
  function E4t(e, t) {
    let r = cr(e),
      n = r.length;
    for (let i = 0; i < n; i++) {
      let s = r[i],
        o = e[s],
        l = o.length;
      for (let u = 0; u < l; u++) {
        let h = o[u];
        h.tokenTypeIdx === void 0 && this[h.name](h.children, t);
      }
    }
  }
  function nZ(e, t) {
    let r = a(function () {}, "derivedConstructor");
    DL(r, e + "BaseSemantics");
    let n = {
      visit: a(function (i, s) {
        if ((Jt(i) && (i = i[0]), !Fe(i))) return this[i.name](i.children, s);
      }, "visit"),
      validateVisitor: a(function () {
        let i = A4t(this, t);
        if (!De(i)) {
          let s = Dt(i, (o) => o.msg);
          throw Error(`Errors Detected in CST Visitor <${this.constructor.name}>:
	${s
    .join(
      `

`,
    )
    .replace(
      /\n/g,
      `
	`,
    )}`);
        }
      }, "validateVisitor"),
    };
    return (
      (r.prototype = n),
      (r.prototype.constructor = r),
      (r._RULE_NAMES = t),
      r
    );
  }
  function iZ(e, t, r) {
    let n = a(function () {}, "derivedConstructor");
    DL(n, e + "BaseSemanticsWithDefaults");
    let i = Object.create(r.prototype);
    return (
      rt(t, (s) => {
        i[s] = E4t;
      }),
      (n.prototype = i),
      (n.prototype.constructor = n),
      n
    );
  }
  function A4t(e, t) {
    return L4t(e, t);
  }
  function L4t(e, t) {
    let r = pr(t, (i) => vn(e[i]) === !1),
      n = Dt(r, (i) => ({
        msg: `Missing visitor method: <${i}> on ${e.constructor.name} CST Visitor.`,
        type: NL.MISSING_METHOD,
        methodName: i,
      }));
    return Ao(n);
  }
  var NL,
    sZ = x(() => {
      "use strict";
      he();
      rZ();
      a(E4t, "defaultVisit");
      a(nZ, "createBaseSemanticVisitorConstructor");
      a(iZ, "createBaseVisitorConstructorWithDefaults");
      (function (e) {
        ((e[(e.REDUNDANT_METHOD = 0)] = "REDUNDANT_METHOD"),
          (e[(e.MISSING_METHOD = 1)] = "MISSING_METHOD"));
      })(NL || (NL = {}));
      a(A4t, "validateVisitor");
      a(L4t, "validateMissingCstMethods");
    });
  var tS,
    aZ = x(() => {
      "use strict";
      eZ();
      he();
      sZ();
      ys();
      tS = class {
        static {
          a(this, "TreeBuilder");
        }
        initTreeBuilder(t) {
          if (
            ((this.CST_STACK = []),
            (this.outputCst = t.outputCst),
            (this.nodeLocationTracking = te(t, "nodeLocationTracking")
              ? t.nodeLocationTracking
              : ji.nodeLocationTracking),
            !this.outputCst)
          )
            ((this.cstInvocationStateUpdate = ln),
              (this.cstFinallyStateUpdate = ln),
              (this.cstPostTerminal = ln),
              (this.cstPostNonTerminal = ln),
              (this.cstPostRule = ln));
          else if (/full/i.test(this.nodeLocationTracking))
            this.recoveryEnabled
              ? ((this.setNodeLocationFromToken = RL),
                (this.setNodeLocationFromNode = RL),
                (this.cstPostRule = ln),
                (this.setInitialNodeLocation =
                  this.setInitialNodeLocationFullRecovery))
              : ((this.setNodeLocationFromToken = ln),
                (this.setNodeLocationFromNode = ln),
                (this.cstPostRule = this.cstPostRuleFull),
                (this.setInitialNodeLocation =
                  this.setInitialNodeLocationFullRegular));
          else if (/onlyOffset/i.test(this.nodeLocationTracking))
            this.recoveryEnabled
              ? ((this.setNodeLocationFromToken = LL),
                (this.setNodeLocationFromNode = LL),
                (this.cstPostRule = ln),
                (this.setInitialNodeLocation =
                  this.setInitialNodeLocationOnlyOffsetRecovery))
              : ((this.setNodeLocationFromToken = ln),
                (this.setNodeLocationFromNode = ln),
                (this.cstPostRule = this.cstPostRuleOnlyOffset),
                (this.setInitialNodeLocation =
                  this.setInitialNodeLocationOnlyOffsetRegular));
          else if (/none/i.test(this.nodeLocationTracking))
            ((this.setNodeLocationFromToken = ln),
              (this.setNodeLocationFromNode = ln),
              (this.cstPostRule = ln),
              (this.setInitialNodeLocation = ln));
          else
            throw Error(
              `Invalid <nodeLocationTracking> config option: "${t.nodeLocationTracking}"`,
            );
        }
        setInitialNodeLocationOnlyOffsetRecovery(t) {
          t.location = { startOffset: NaN, endOffset: NaN };
        }
        setInitialNodeLocationOnlyOffsetRegular(t) {
          t.location = { startOffset: this.LA(1).startOffset, endOffset: NaN };
        }
        setInitialNodeLocationFullRecovery(t) {
          t.location = {
            startOffset: NaN,
            startLine: NaN,
            startColumn: NaN,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN,
          };
        }
        setInitialNodeLocationFullRegular(t) {
          let r = this.LA(1);
          t.location = {
            startOffset: r.startOffset,
            startLine: r.startLine,
            startColumn: r.startColumn,
            endOffset: NaN,
            endLine: NaN,
            endColumn: NaN,
          };
        }
        cstInvocationStateUpdate(t) {
          let r = { name: t, children: Object.create(null) };
          (this.setInitialNodeLocation(r), this.CST_STACK.push(r));
        }
        cstFinallyStateUpdate() {
          this.CST_STACK.pop();
        }
        cstPostRuleFull(t) {
          let r = this.LA(0),
            n = t.location;
          n.startOffset <= r.startOffset
            ? ((n.endOffset = r.endOffset),
              (n.endLine = r.endLine),
              (n.endColumn = r.endColumn))
            : ((n.startOffset = NaN),
              (n.startLine = NaN),
              (n.startColumn = NaN));
        }
        cstPostRuleOnlyOffset(t) {
          let r = this.LA(0),
            n = t.location;
          n.startOffset <= r.startOffset
            ? (n.endOffset = r.endOffset)
            : (n.startOffset = NaN);
        }
        cstPostTerminal(t, r) {
          let n = this.CST_STACK[this.CST_STACK.length - 1];
          (JQ(n, r, t), this.setNodeLocationFromToken(n.location, r));
        }
        cstPostNonTerminal(t, r) {
          let n = this.CST_STACK[this.CST_STACK.length - 1];
          (tZ(n, r, t), this.setNodeLocationFromNode(n.location, t.location));
        }
        getBaseCstVisitorConstructor() {
          if (Fe(this.baseCstVisitorConstructor)) {
            let t = nZ(this.className, cr(this.gastProductionsCache));
            return ((this.baseCstVisitorConstructor = t), t);
          }
          return this.baseCstVisitorConstructor;
        }
        getBaseCstVisitorConstructorWithDefaults() {
          if (Fe(this.baseCstVisitorWithDefaultsConstructor)) {
            let t = iZ(
              this.className,
              cr(this.gastProductionsCache),
              this.getBaseCstVisitorConstructor(),
            );
            return ((this.baseCstVisitorWithDefaultsConstructor = t), t);
          }
          return this.baseCstVisitorWithDefaultsConstructor;
        }
        getLastExplicitRuleShortName() {
          let t = this.RULE_STACK;
          return t[t.length - 1];
        }
        getPreviousExplicitRuleShortName() {
          let t = this.RULE_STACK;
          return t[t.length - 2];
        }
        getLastExplicitRuleOccurrenceIndex() {
          let t = this.RULE_OCCURRENCE_STACK;
          return t[t.length - 1];
        }
      };
    });
  var eS,
    oZ = x(() => {
      "use strict";
      ys();
      eS = class {
        static {
          a(this, "LexerAdapter");
        }
        initLexerAdapter() {
          ((this.tokVector = []),
            (this.tokVectorLength = 0),
            (this.currIdx = -1));
        }
        set input(t) {
          if (this.selfAnalysisDone !== !0)
            throw Error(
              "Missing <performSelfAnalysis> invocation at the end of the Parser's constructor.",
            );
          (this.reset(),
            (this.tokVector = t),
            (this.tokVectorLength = t.length));
        }
        get input() {
          return this.tokVector;
        }
        SKIP_TOKEN() {
          return this.currIdx <= this.tokVector.length - 2
            ? (this.consumeToken(), this.LA(1))
            : Up;
        }
        LA(t) {
          let r = this.currIdx + t;
          return r < 0 || this.tokVectorLength <= r ? Up : this.tokVector[r];
        }
        consumeToken() {
          this.currIdx++;
        }
        exportLexerState() {
          return this.currIdx;
        }
        importLexerState(t) {
          this.currIdx = t;
        }
        resetLexerState() {
          this.currIdx = -1;
        }
        moveToTerminatedState() {
          this.currIdx = this.tokVector.length - 1;
        }
        getLexerPosition() {
          return this.exportLexerState();
        }
      };
    });
  var rS,
    lZ = x(() => {
      "use strict";
      he();
      Wp();
      ys();
      Bp();
      L1();
      Ui();
      rS = class {
        static {
          a(this, "RecognizerApi");
        }
        ACTION(t) {
          return t.call(this);
        }
        consume(t, r, n) {
          return this.consumeInternal(r, t, n);
        }
        subrule(t, r, n) {
          return this.subruleInternal(r, t, n);
        }
        option(t, r) {
          return this.optionInternal(r, t);
        }
        or(t, r) {
          return this.orInternal(r, t);
        }
        many(t, r) {
          return this.manyInternal(t, r);
        }
        atLeastOne(t, r) {
          return this.atLeastOneInternal(t, r);
        }
        CONSUME(t, r) {
          return this.consumeInternal(t, 0, r);
        }
        CONSUME1(t, r) {
          return this.consumeInternal(t, 1, r);
        }
        CONSUME2(t, r) {
          return this.consumeInternal(t, 2, r);
        }
        CONSUME3(t, r) {
          return this.consumeInternal(t, 3, r);
        }
        CONSUME4(t, r) {
          return this.consumeInternal(t, 4, r);
        }
        CONSUME5(t, r) {
          return this.consumeInternal(t, 5, r);
        }
        CONSUME6(t, r) {
          return this.consumeInternal(t, 6, r);
        }
        CONSUME7(t, r) {
          return this.consumeInternal(t, 7, r);
        }
        CONSUME8(t, r) {
          return this.consumeInternal(t, 8, r);
        }
        CONSUME9(t, r) {
          return this.consumeInternal(t, 9, r);
        }
        SUBRULE(t, r) {
          return this.subruleInternal(t, 0, r);
        }
        SUBRULE1(t, r) {
          return this.subruleInternal(t, 1, r);
        }
        SUBRULE2(t, r) {
          return this.subruleInternal(t, 2, r);
        }
        SUBRULE3(t, r) {
          return this.subruleInternal(t, 3, r);
        }
        SUBRULE4(t, r) {
          return this.subruleInternal(t, 4, r);
        }
        SUBRULE5(t, r) {
          return this.subruleInternal(t, 5, r);
        }
        SUBRULE6(t, r) {
          return this.subruleInternal(t, 6, r);
        }
        SUBRULE7(t, r) {
          return this.subruleInternal(t, 7, r);
        }
        SUBRULE8(t, r) {
          return this.subruleInternal(t, 8, r);
        }
        SUBRULE9(t, r) {
          return this.subruleInternal(t, 9, r);
        }
        OPTION(t) {
          return this.optionInternal(t, 0);
        }
        OPTION1(t) {
          return this.optionInternal(t, 1);
        }
        OPTION2(t) {
          return this.optionInternal(t, 2);
        }
        OPTION3(t) {
          return this.optionInternal(t, 3);
        }
        OPTION4(t) {
          return this.optionInternal(t, 4);
        }
        OPTION5(t) {
          return this.optionInternal(t, 5);
        }
        OPTION6(t) {
          return this.optionInternal(t, 6);
        }
        OPTION7(t) {
          return this.optionInternal(t, 7);
        }
        OPTION8(t) {
          return this.optionInternal(t, 8);
        }
        OPTION9(t) {
          return this.optionInternal(t, 9);
        }
        OR(t) {
          return this.orInternal(t, 0);
        }
        OR1(t) {
          return this.orInternal(t, 1);
        }
        OR2(t) {
          return this.orInternal(t, 2);
        }
        OR3(t) {
          return this.orInternal(t, 3);
        }
        OR4(t) {
          return this.orInternal(t, 4);
        }
        OR5(t) {
          return this.orInternal(t, 5);
        }
        OR6(t) {
          return this.orInternal(t, 6);
        }
        OR7(t) {
          return this.orInternal(t, 7);
        }
        OR8(t) {
          return this.orInternal(t, 8);
        }
        OR9(t) {
          return this.orInternal(t, 9);
        }
        MANY(t) {
          this.manyInternal(0, t);
        }
        MANY1(t) {
          this.manyInternal(1, t);
        }
        MANY2(t) {
          this.manyInternal(2, t);
        }
        MANY3(t) {
          this.manyInternal(3, t);
        }
        MANY4(t) {
          this.manyInternal(4, t);
        }
        MANY5(t) {
          this.manyInternal(5, t);
        }
        MANY6(t) {
          this.manyInternal(6, t);
        }
        MANY7(t) {
          this.manyInternal(7, t);
        }
        MANY8(t) {
          this.manyInternal(8, t);
        }
        MANY9(t) {
          this.manyInternal(9, t);
        }
        MANY_SEP(t) {
          this.manySepFirstInternal(0, t);
        }
        MANY_SEP1(t) {
          this.manySepFirstInternal(1, t);
        }
        MANY_SEP2(t) {
          this.manySepFirstInternal(2, t);
        }
        MANY_SEP3(t) {
          this.manySepFirstInternal(3, t);
        }
        MANY_SEP4(t) {
          this.manySepFirstInternal(4, t);
        }
        MANY_SEP5(t) {
          this.manySepFirstInternal(5, t);
        }
        MANY_SEP6(t) {
          this.manySepFirstInternal(6, t);
        }
        MANY_SEP7(t) {
          this.manySepFirstInternal(7, t);
        }
        MANY_SEP8(t) {
          this.manySepFirstInternal(8, t);
        }
        MANY_SEP9(t) {
          this.manySepFirstInternal(9, t);
        }
        AT_LEAST_ONE(t) {
          this.atLeastOneInternal(0, t);
        }
        AT_LEAST_ONE1(t) {
          return this.atLeastOneInternal(1, t);
        }
        AT_LEAST_ONE2(t) {
          this.atLeastOneInternal(2, t);
        }
        AT_LEAST_ONE3(t) {
          this.atLeastOneInternal(3, t);
        }
        AT_LEAST_ONE4(t) {
          this.atLeastOneInternal(4, t);
        }
        AT_LEAST_ONE5(t) {
          this.atLeastOneInternal(5, t);
        }
        AT_LEAST_ONE6(t) {
          this.atLeastOneInternal(6, t);
        }
        AT_LEAST_ONE7(t) {
          this.atLeastOneInternal(7, t);
        }
        AT_LEAST_ONE8(t) {
          this.atLeastOneInternal(8, t);
        }
        AT_LEAST_ONE9(t) {
          this.atLeastOneInternal(9, t);
        }
        AT_LEAST_ONE_SEP(t) {
          this.atLeastOneSepFirstInternal(0, t);
        }
        AT_LEAST_ONE_SEP1(t) {
          this.atLeastOneSepFirstInternal(1, t);
        }
        AT_LEAST_ONE_SEP2(t) {
          this.atLeastOneSepFirstInternal(2, t);
        }
        AT_LEAST_ONE_SEP3(t) {
          this.atLeastOneSepFirstInternal(3, t);
        }
        AT_LEAST_ONE_SEP4(t) {
          this.atLeastOneSepFirstInternal(4, t);
        }
        AT_LEAST_ONE_SEP5(t) {
          this.atLeastOneSepFirstInternal(5, t);
        }
        AT_LEAST_ONE_SEP6(t) {
          this.atLeastOneSepFirstInternal(6, t);
        }
        AT_LEAST_ONE_SEP7(t) {
          this.atLeastOneSepFirstInternal(7, t);
        }
        AT_LEAST_ONE_SEP8(t) {
          this.atLeastOneSepFirstInternal(8, t);
        }
        AT_LEAST_ONE_SEP9(t) {
          this.atLeastOneSepFirstInternal(9, t);
        }
        RULE(t, r, n = jp) {
          if (Zr(this.definedRulesNames, t)) {
            let o = {
              message: Ya.buildDuplicateRuleNameError({
                topLevelRule: t,
                grammarName: this.className,
              }),
              type: Fn.DUPLICATE_RULE_NAME,
              ruleName: t,
            };
            this.definitionErrors.push(o);
          }
          this.definedRulesNames.push(t);
          let i = this.defineRule(t, r, n);
          return ((this[t] = i), i);
        }
        OVERRIDE_RULE(t, r, n = jp) {
          let i = GQ(t, this.definedRulesNames, this.className);
          this.definitionErrors = this.definitionErrors.concat(i);
          let s = this.defineRule(t, r, n);
          return ((this[t] = s), s);
        }
        BACKTRACK(t, r) {
          return function () {
            this.isBackTrackingStack.push(1);
            let n = this.saveRecogState();
            try {
              return (t.apply(this, r), !0);
            } catch (i) {
              if (jc(i)) return !1;
              throw i;
            } finally {
              (this.reloadRecogState(n), this.isBackTrackingStack.pop());
            }
          };
        }
        getGAstProductions() {
          return this.gastProductionsCache;
        }
        getSerializedGastProductions() {
          return ET(We(this.gastProductionsCache));
        }
      };
    });
  var nS,
    cZ = x(() => {
      "use strict";
      he();
      YT();
      Wp();
      Vp();
      v1();
      ys();
      CL();
      Nh();
      Dh();
      nS = class {
        static {
          a(this, "RecognizerEngine");
        }
        initRecognizerEngine(t, r) {
          if (
            ((this.className = this.constructor.name),
            (this.shortRuleNameToFull = {}),
            (this.fullRuleNameToShort = {}),
            (this.ruleShortNameIdx = 256),
            (this.tokenMatcher = Op),
            (this.subruleIdx = 0),
            (this.definedRulesNames = []),
            (this.tokensMap = {}),
            (this.isBackTrackingStack = []),
            (this.RULE_STACK = []),
            (this.RULE_OCCURRENCE_STACK = []),
            (this.gastProductionsCache = {}),
            te(r, "serializedGrammar"))
          )
            throw Error(`The Parser's configuration can no longer contain a <serializedGrammar> property.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_6-0-0
	For Further details.`);
          if (Jt(t)) {
            if (De(t))
              throw Error(`A Token Vocabulary cannot be empty.
	Note that the first argument for the parser constructor
	is no longer a Token vector (since v4.0).`);
            if (typeof t[0].startOffset == "number")
              throw Error(`The Parser constructor no longer accepts a token vector as the first argument.
	See: https://chevrotain.io/docs/changes/BREAKING_CHANGES.html#_4-0-0
	For Further details.`);
          }
          if (Jt(t)) this.tokensMap = mr(t, (s, o) => ((s[o.name] = o), s), {});
          else if (te(t, "modes") && bi(dr(We(t.modes)), yQ)) {
            let s = dr(We(t.modes)),
              o = Nd(s);
            this.tokensMap = mr(o, (l, u) => ((l[u.name] = u), l), {});
          } else if (Nr(t)) this.tokensMap = Sr(t);
          else
            throw new Error(
              "<tokensDictionary> argument must be An Array of Token constructors, A dictionary of Token constructors or an IMultiModeLexerDefinition",
            );
          this.tokensMap.EOF = Os;
          let n = te(t, "modes") ? dr(We(t.modes)) : We(t),
            i = bi(n, (s) => De(s.categoryMatches));
          ((this.tokenMatcher = i ? Op : vl), El(We(this.tokensMap)));
        }
        defineRule(t, r, n) {
          if (this.selfAnalysisDone)
            throw Error(`Grammar rule <${t}> may not be defined after the 'performSelfAnalysis' method has been called'
Make sure that all grammar rule definitions are done before 'performSelfAnalysis' is called.`);
          let i = te(n, "resyncEnabled") ? n.resyncEnabled : jp.resyncEnabled,
            s = te(n, "recoveryValueFunc")
              ? n.recoveryValueFunc
              : jp.recoveryValueFunc,
            o = this.ruleShortNameIdx << 12;
          (this.ruleShortNameIdx++,
            (this.shortRuleNameToFull[o] = t),
            (this.fullRuleNameToShort[t] = o));
          let l;
          return (
            this.outputCst === !0
              ? (l = a(function (...f) {
                  try {
                    (this.ruleInvocationStateUpdate(o, t, this.subruleIdx),
                      r.apply(this, f));
                    let d = this.CST_STACK[this.CST_STACK.length - 1];
                    return (this.cstPostRule(d), d);
                  } catch (d) {
                    return this.invokeRuleCatch(d, i, s);
                  } finally {
                    this.ruleFinallyStateUpdate();
                  }
                }, "invokeRuleWithTry"))
              : (l = a(function (...f) {
                  try {
                    return (
                      this.ruleInvocationStateUpdate(o, t, this.subruleIdx),
                      r.apply(this, f)
                    );
                  } catch (d) {
                    return this.invokeRuleCatch(d, i, s);
                  } finally {
                    this.ruleFinallyStateUpdate();
                  }
                }, "invokeRuleWithTryCst")),
            Object.assign(l, { ruleName: t, originalGrammarAction: r })
          );
        }
        invokeRuleCatch(t, r, n) {
          let i = this.RULE_STACK.length === 1,
            s = r && !this.isBackTracking() && this.recoveryEnabled;
          if (jc(t)) {
            let o = t;
            if (s) {
              let l = this.findReSyncTokenType();
              if (this.isInCurrentRuleReSyncSet(l))
                if (((o.resyncedTokens = this.reSyncTo(l)), this.outputCst)) {
                  let u = this.CST_STACK[this.CST_STACK.length - 1];
                  return ((u.recoveredNode = !0), u);
                } else return n(t);
              else {
                if (this.outputCst) {
                  let u = this.CST_STACK[this.CST_STACK.length - 1];
                  ((u.recoveredNode = !0), (o.partialCstResult = u));
                }
                throw o;
              }
            } else {
              if (i) return (this.moveToTerminatedState(), n(t));
              throw o;
            }
          } else throw t;
        }
        optionInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(512, r);
          return this.optionInternalLogic(t, r, n);
        }
        optionInternalLogic(t, r, n) {
          let i = this.getLaFuncFromCache(n),
            s;
          if (typeof t != "function") {
            s = t.DEF;
            let o = t.GATE;
            if (o !== void 0) {
              let l = i;
              i = a(() => o.call(this) && l.call(this), "lookAheadFunc");
            }
          } else s = t;
          if (i.call(this) === !0) return s.call(this);
        }
        atLeastOneInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(1024, t);
          return this.atLeastOneInternalLogic(t, r, n);
        }
        atLeastOneInternalLogic(t, r, n) {
          let i = this.getLaFuncFromCache(n),
            s;
          if (typeof r != "function") {
            s = r.DEF;
            let o = r.GATE;
            if (o !== void 0) {
              let l = i;
              i = a(() => o.call(this) && l.call(this), "lookAheadFunc");
            }
          } else s = r;
          if (i.call(this) === !0) {
            let o = this.doSingleRepetition(s);
            for (; i.call(this) === !0 && o === !0; )
              o = this.doSingleRepetition(s);
          } else
            throw this.raiseEarlyExitException(
              t,
              en.REPETITION_MANDATORY,
              r.ERR_MSG,
            );
          this.attemptInRepetitionRecovery(
            this.atLeastOneInternal,
            [t, r],
            i,
            1024,
            t,
            $T,
          );
        }
        atLeastOneSepFirstInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(1536, t);
          this.atLeastOneSepFirstInternalLogic(t, r, n);
        }
        atLeastOneSepFirstInternalLogic(t, r, n) {
          let i = r.DEF,
            s = r.SEP;
          if (this.getLaFuncFromCache(n).call(this) === !0) {
            i.call(this);
            let l = a(
              () => this.tokenMatcher(this.LA(1), s),
              "separatorLookAheadFunc",
            );
            for (; this.tokenMatcher(this.LA(1), s) === !0; )
              (this.CONSUME(s), i.call(this));
            this.attemptInRepetitionRecovery(
              this.repetitionSepSecondInternal,
              [t, s, l, i, w1],
              l,
              1536,
              t,
              w1,
            );
          } else
            throw this.raiseEarlyExitException(
              t,
              en.REPETITION_MANDATORY_WITH_SEPARATOR,
              r.ERR_MSG,
            );
        }
        manyInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(768, t);
          return this.manyInternalLogic(t, r, n);
        }
        manyInternalLogic(t, r, n) {
          let i = this.getLaFuncFromCache(n),
            s;
          if (typeof r != "function") {
            s = r.DEF;
            let l = r.GATE;
            if (l !== void 0) {
              let u = i;
              i = a(() => l.call(this) && u.call(this), "lookaheadFunction");
            }
          } else s = r;
          let o = !0;
          for (; i.call(this) === !0 && o === !0; )
            o = this.doSingleRepetition(s);
          this.attemptInRepetitionRecovery(
            this.manyInternal,
            [t, r],
            i,
            768,
            t,
            FT,
            o,
          );
        }
        manySepFirstInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(1280, t);
          this.manySepFirstInternalLogic(t, r, n);
        }
        manySepFirstInternalLogic(t, r, n) {
          let i = r.DEF,
            s = r.SEP;
          if (this.getLaFuncFromCache(n).call(this) === !0) {
            i.call(this);
            let l = a(
              () => this.tokenMatcher(this.LA(1), s),
              "separatorLookAheadFunc",
            );
            for (; this.tokenMatcher(this.LA(1), s) === !0; )
              (this.CONSUME(s), i.call(this));
            this.attemptInRepetitionRecovery(
              this.repetitionSepSecondInternal,
              [t, s, l, i, C1],
              l,
              1280,
              t,
              C1,
            );
          }
        }
        repetitionSepSecondInternal(t, r, n, i, s) {
          for (; n(); ) (this.CONSUME(r), i.call(this));
          this.attemptInRepetitionRecovery(
            this.repetitionSepSecondInternal,
            [t, r, n, i, s],
            n,
            1536,
            t,
            s,
          );
        }
        doSingleRepetition(t) {
          let r = this.getLexerPosition();
          return (t.call(this), this.getLexerPosition() > r);
        }
        orInternal(t, r) {
          let n = this.getKeyForAutomaticLookahead(256, r),
            i = Jt(t) ? t : t.DEF,
            o = this.getLaFuncFromCache(n).call(this, i);
          if (o !== void 0) return i[o].ALT.call(this);
          this.raiseNoAltException(r, t.ERR_MSG);
        }
        ruleFinallyStateUpdate() {
          if (
            (this.RULE_STACK.pop(),
            this.RULE_OCCURRENCE_STACK.pop(),
            this.cstFinallyStateUpdate(),
            this.RULE_STACK.length === 0 && this.isAtEndOfInput() === !1)
          ) {
            let t = this.LA(1),
              r = this.errorMessageProvider.buildNotAllInputParsedMessage({
                firstRedundant: t,
                ruleName: this.getCurrRuleFullName(),
              });
            this.SAVE_ERROR(new D1(r, t));
          }
        }
        subruleInternal(t, r, n) {
          let i;
          try {
            let s = n !== void 0 ? n.ARGS : void 0;
            return (
              (this.subruleIdx = r),
              (i = t.apply(this, s)),
              this.cstPostNonTerminal(
                i,
                n !== void 0 && n.LABEL !== void 0 ? n.LABEL : t.ruleName,
              ),
              i
            );
          } catch (s) {
            throw this.subruleInternalError(s, n, t.ruleName);
          }
        }
        subruleInternalError(t, r, n) {
          throw (
            jc(t) &&
              t.partialCstResult !== void 0 &&
              (this.cstPostNonTerminal(
                t.partialCstResult,
                r !== void 0 && r.LABEL !== void 0 ? r.LABEL : n,
              ),
              delete t.partialCstResult),
            t
          );
        }
        consumeInternal(t, r, n) {
          let i;
          try {
            let s = this.LA(1);
            this.tokenMatcher(s, t) === !0
              ? (this.consumeToken(), (i = s))
              : this.consumeInternalError(t, s, n);
          } catch (s) {
            i = this.consumeInternalRecovery(t, r, s);
          }
          return (
            this.cstPostTerminal(
              n !== void 0 && n.LABEL !== void 0 ? n.LABEL : t.name,
              i,
            ),
            i
          );
        }
        consumeInternalError(t, r, n) {
          let i,
            s = this.LA(0);
          throw (
            n !== void 0 && n.ERR_MSG
              ? (i = n.ERR_MSG)
              : (i = this.errorMessageProvider.buildMismatchTokenMessage({
                  expected: t,
                  actual: r,
                  previous: s,
                  ruleName: this.getCurrRuleFullName(),
                })),
            this.SAVE_ERROR(new Ih(i, r, s))
          );
        }
        consumeInternalRecovery(t, r, n) {
          if (
            this.recoveryEnabled &&
            n.name === "MismatchedTokenException" &&
            !this.isBackTracking()
          ) {
            let i = this.getFollowsForInRuleRecovery(t, r);
            try {
              return this.tryInRuleRecovery(t, i);
            } catch (s) {
              throw s.name === _L ? n : s;
            }
          } else throw n;
        }
        saveRecogState() {
          let t = this.errors,
            r = Sr(this.RULE_STACK);
          return {
            errors: t,
            lexerState: this.exportLexerState(),
            RULE_STACK: r,
            CST_STACK: this.CST_STACK,
          };
        }
        reloadRecogState(t) {
          ((this.errors = t.errors),
            this.importLexerState(t.lexerState),
            (this.RULE_STACK = t.RULE_STACK));
        }
        ruleInvocationStateUpdate(t, r, n) {
          (this.RULE_OCCURRENCE_STACK.push(n),
            this.RULE_STACK.push(t),
            this.cstInvocationStateUpdate(r));
        }
        isBackTracking() {
          return this.isBackTrackingStack.length !== 0;
        }
        getCurrRuleFullName() {
          let t = this.getLastExplicitRuleShortName();
          return this.shortRuleNameToFull[t];
        }
        shortRuleNameToFullName(t) {
          return this.shortRuleNameToFull[t];
        }
        isAtEndOfInput() {
          return this.tokenMatcher(this.LA(1), Os);
        }
        reset() {
          (this.resetLexerState(),
            (this.subruleIdx = 0),
            (this.isBackTrackingStack = []),
            (this.errors = []),
            (this.RULE_STACK = []),
            (this.CST_STACK = []),
            (this.RULE_OCCURRENCE_STACK = []));
        }
      };
    });
  var iS,
    uZ = x(() => {
      "use strict";
      Wp();
      he();
      Vp();
      ys();
      iS = class {
        static {
          a(this, "ErrorHandler");
        }
        initErrorHandler(t) {
          ((this._errors = []),
            (this.errorMessageProvider = te(t, "errorMessageProvider")
              ? t.errorMessageProvider
              : ji.errorMessageProvider));
        }
        SAVE_ERROR(t) {
          if (jc(t))
            return (
              (t.context = {
                ruleStack: this.getHumanReadableRuleStack(),
                ruleOccurrenceStack: Sr(this.RULE_OCCURRENCE_STACK),
              }),
              this._errors.push(t),
              t
            );
          throw Error(
            "Trying to save an Error which is not a RecognitionException",
          );
        }
        get errors() {
          return Sr(this._errors);
        }
        set errors(t) {
          this._errors = t;
        }
        raiseEarlyExitException(t, r, n) {
          let i = this.getCurrRuleFullName(),
            s = this.getGAstProductions()[i],
            l = Gp(t, s, r, this.maxLookahead)[0],
            u = [];
          for (let f = 1; f <= this.maxLookahead; f++) u.push(this.LA(f));
          let h = this.errorMessageProvider.buildEarlyExitMessage({
            expectedIterationPaths: l,
            actual: u,
            previous: this.LA(0),
            customUserDescription: n,
            ruleName: i,
          });
          throw this.SAVE_ERROR(new N1(h, this.LA(1), this.LA(0)));
        }
        raiseNoAltException(t, r) {
          let n = this.getCurrRuleFullName(),
            i = this.getGAstProductions()[n],
            s = $p(t, i, this.maxLookahead),
            o = [];
          for (let h = 1; h <= this.maxLookahead; h++) o.push(this.LA(h));
          let l = this.LA(0),
            u = this.errorMessageProvider.buildNoViableAltMessage({
              expectedPathsPerAlt: s,
              actual: o,
              previous: l,
              customUserDescription: r,
              ruleName: this.getCurrRuleFullName(),
            });
          throw this.SAVE_ERROR(new R1(u, this.LA(1), l));
        }
      };
    });
  var sS,
    hZ = x(() => {
      "use strict";
      v1();
      he();
      sS = class {
        static {
          a(this, "ContentAssist");
        }
        initContentAssist() {}
        computeContentAssist(t, r) {
          let n = this.gastProductionsCache[t];
          if (Fe(n))
            throw Error(`Rule ->${t}<- does not exist in this grammar.`);
          return VT([n], r, this.tokenMatcher, this.maxLookahead);
        }
        getNextPossibleTokenTypes(t) {
          let r = Qn(t.ruleStack),
            i = this.getGAstProductions()[r];
          return new BT(i, t).startWalking();
        }
      };
    });
  function M1(e, t, r, n = !1) {
    oS(r);
    let i = ai(this.recordingProdStack),
      s = vn(t) ? t : t.DEF,
      o = new e({ definition: [], idx: r });
    return (
      n && (o.separator = t.SEP),
      te(t, "MAX_LOOKAHEAD") && (o.maxLookahead = t.MAX_LOOKAHEAD),
      this.recordingProdStack.push(o),
      s.call(this),
      i.definition.push(o),
      this.recordingProdStack.pop(),
      lS
    );
  }
  function N4t(e, t) {
    oS(t);
    let r = ai(this.recordingProdStack),
      n = Jt(e) === !1,
      i = n === !1 ? e : e.DEF,
      s = new Or({
        definition: [],
        idx: t,
        ignoreAmbiguities: n && e.IGNORE_AMBIGUITIES === !0,
      });
    te(e, "MAX_LOOKAHEAD") && (s.maxLookahead = e.MAX_LOOKAHEAD);
    let o = U0(i, (l) => vn(l.GATE));
    return (
      (s.hasPredicates = o),
      r.definition.push(s),
      rt(i, (l) => {
        let u = new Vr({ definition: [] });
        (s.definition.push(u),
          te(l, "IGNORE_AMBIGUITIES")
            ? (u.ignoreAmbiguities = l.IGNORE_AMBIGUITIES)
            : te(l, "GATE") && (u.ignoreAmbiguities = !0),
          this.recordingProdStack.push(u),
          l.ALT.call(this),
          this.recordingProdStack.pop());
      }),
      lS
    );
  }
  function pZ(e) {
    return e === 0 ? "" : `${e}`;
  }
  function oS(e) {
    if (e < 0 || e > dZ) {
      let t = new Error(`Invalid DSL Method idx value: <${e}>
	Idx value must be a none negative value smaller than ${dZ + 1}`);
      throw ((t.KNOWN_RECORDER_ERROR = !0), t);
    }
  }
  var lS,
    fZ,
    dZ,
    mZ,
    gZ,
    D4t,
    aS,
    yZ = x(() => {
      "use strict";
      he();
      Ui();
      T1();
      Dh();
      Nh();
      ys();
      YT();
      lS = {
        description:
          "This Object indicates the Parser is during Recording Phase",
      };
      Object.freeze(lS);
      ((fZ = !0),
        (dZ = Math.pow(2, 8) - 1),
        (mZ = Uc({ name: "RECORDING_PHASE_TOKEN", pattern: tn.NA })));
      El([mZ]);
      gZ = Ll(
        mZ,
        `This IToken indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
        -1,
        -1,
        -1,
        -1,
        -1,
        -1,
      );
      Object.freeze(gZ);
      ((D4t = {
        name: `This CSTNode indicates the Parser is in Recording Phase
	See: https://chevrotain.io/docs/guide/internals.html#grammar-recording for details`,
        children: {},
      }),
        (aS = class {
          static {
            a(this, "GastRecorder");
          }
          initGastRecorder(t) {
            ((this.recordingProdStack = []), (this.RECORDING_PHASE = !1));
          }
          enableRecording() {
            ((this.RECORDING_PHASE = !0),
              this.TRACE_INIT("Enable Recording", () => {
                for (let t = 0; t < 10; t++) {
                  let r = t > 0 ? t : "";
                  ((this[`CONSUME${r}`] = function (n, i) {
                    return this.consumeInternalRecord(n, t, i);
                  }),
                    (this[`SUBRULE${r}`] = function (n, i) {
                      return this.subruleInternalRecord(n, t, i);
                    }),
                    (this[`OPTION${r}`] = function (n) {
                      return this.optionInternalRecord(n, t);
                    }),
                    (this[`OR${r}`] = function (n) {
                      return this.orInternalRecord(n, t);
                    }),
                    (this[`MANY${r}`] = function (n) {
                      this.manyInternalRecord(t, n);
                    }),
                    (this[`MANY_SEP${r}`] = function (n) {
                      this.manySepFirstInternalRecord(t, n);
                    }),
                    (this[`AT_LEAST_ONE${r}`] = function (n) {
                      this.atLeastOneInternalRecord(t, n);
                    }),
                    (this[`AT_LEAST_ONE_SEP${r}`] = function (n) {
                      this.atLeastOneSepFirstInternalRecord(t, n);
                    }));
                }
                ((this.consume = function (t, r, n) {
                  return this.consumeInternalRecord(r, t, n);
                }),
                  (this.subrule = function (t, r, n) {
                    return this.subruleInternalRecord(r, t, n);
                  }),
                  (this.option = function (t, r) {
                    return this.optionInternalRecord(r, t);
                  }),
                  (this.or = function (t, r) {
                    return this.orInternalRecord(r, t);
                  }),
                  (this.many = function (t, r) {
                    this.manyInternalRecord(t, r);
                  }),
                  (this.atLeastOne = function (t, r) {
                    this.atLeastOneInternalRecord(t, r);
                  }),
                  (this.ACTION = this.ACTION_RECORD),
                  (this.BACKTRACK = this.BACKTRACK_RECORD),
                  (this.LA = this.LA_RECORD));
              }));
          }
          disableRecording() {
            ((this.RECORDING_PHASE = !1),
              this.TRACE_INIT("Deleting Recording methods", () => {
                let t = this;
                for (let r = 0; r < 10; r++) {
                  let n = r > 0 ? r : "";
                  (delete t[`CONSUME${n}`],
                    delete t[`SUBRULE${n}`],
                    delete t[`OPTION${n}`],
                    delete t[`OR${n}`],
                    delete t[`MANY${n}`],
                    delete t[`MANY_SEP${n}`],
                    delete t[`AT_LEAST_ONE${n}`],
                    delete t[`AT_LEAST_ONE_SEP${n}`]);
                }
                (delete t.consume,
                  delete t.subrule,
                  delete t.option,
                  delete t.or,
                  delete t.many,
                  delete t.atLeastOne,
                  delete t.ACTION,
                  delete t.BACKTRACK,
                  delete t.LA);
              }));
          }
          ACTION_RECORD(t) {}
          BACKTRACK_RECORD(t, r) {
            return () => !0;
          }
          LA_RECORD(t) {
            return Up;
          }
          topLevelRuleRecord(t, r) {
            try {
              let n = new zi({ definition: [], name: t });
              return (
                (n.name = t),
                this.recordingProdStack.push(n),
                r.call(this),
                this.recordingProdStack.pop(),
                n
              );
            } catch (n) {
              if (n.KNOWN_RECORDER_ERROR !== !0)
                try {
                  n.message =
                    n.message +
                    `
	 This error was thrown during the "grammar recording phase" For more info see:
	https://chevrotain.io/docs/guide/internals.html#grammar-recording`;
                } catch {
                  throw n;
                }
              throw n;
            }
          }
          optionInternalRecord(t, r) {
            return M1.call(this, wr, t, r);
          }
          atLeastOneInternalRecord(t, r) {
            M1.call(this, zr, r, t);
          }
          atLeastOneSepFirstInternalRecord(t, r) {
            M1.call(this, Wr, r, t, fZ);
          }
          manyInternalRecord(t, r) {
            M1.call(this, ir, r, t);
          }
          manySepFirstInternalRecord(t, r) {
            M1.call(this, Mr, r, t, fZ);
          }
          orInternalRecord(t, r) {
            return N4t.call(this, t, r);
          }
          subruleInternalRecord(t, r, n) {
            if ((oS(r), !t || te(t, "ruleName") === !1)) {
              let l =
                new Error(`<SUBRULE${pZ(r)}> argument is invalid expecting a Parser method reference but got: <${JSON.stringify(t)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
              throw ((l.KNOWN_RECORDER_ERROR = !0), l);
            }
            let i = ai(this.recordingProdStack),
              s = t.ruleName,
              o = new Cr({
                idx: r,
                nonTerminalName: s,
                label: n?.LABEL,
                referencedRule: void 0,
              });
            return (i.definition.push(o), this.outputCst ? D4t : lS);
          }
          consumeInternalRecord(t, r, n) {
            if ((oS(r), !hL(t))) {
              let o =
                new Error(`<CONSUME${pZ(r)}> argument is invalid expecting a TokenType reference but got: <${JSON.stringify(t)}>
 inside top level rule: <${this.recordingProdStack[0].name}>`);
              throw ((o.KNOWN_RECORDER_ERROR = !0), o);
            }
            let i = ai(this.recordingProdStack),
              s = new je({ idx: r, terminalType: t, label: n?.LABEL });
            return (i.definition.push(s), gZ);
          }
        }));
      a(M1, "recordProd");
      a(N4t, "recordOrProd");
      a(pZ, "getIdxSuffix");
      a(oS, "assertMethodIdxIsValid");
    });
  var cS,
    xZ = x(() => {
      "use strict";
      he();
      Rp();
      ys();
      cS = class {
        static {
          a(this, "PerformanceTracer");
        }
        initPerformanceTracer(t) {
          if (te(t, "traceInitPerf")) {
            let r = t.traceInitPerf,
              n = typeof r == "number";
            ((this.traceInitMaxIdent = n ? r : 1 / 0),
              (this.traceInitPerf = n ? r > 0 : r));
          } else
            ((this.traceInitMaxIdent = 0),
              (this.traceInitPerf = ji.traceInitPerf));
          this.traceInitIndent = -1;
        }
        TRACE_INIT(t, r) {
          if (this.traceInitPerf === !0) {
            this.traceInitIndent++;
            let n = new Array(this.traceInitIndent + 1).join("	");
            this.traceInitIndent < this.traceInitMaxIdent &&
              console.log(`${n}--> <${t}>`);
            let { time: i, value: s } = x1(r),
              o = i > 10 ? console.warn : console.log;
            return (
              this.traceInitIndent < this.traceInitMaxIdent &&
                o(`${n}<-- <${t}> time: ${i}ms`),
              this.traceInitIndent--,
              s
            );
          } else return r();
        }
      };
    });
  function bZ(e, t) {
    t.forEach((r) => {
      let n = r.prototype;
      Object.getOwnPropertyNames(n).forEach((i) => {
        if (i === "constructor") return;
        let s = Object.getOwnPropertyDescriptor(n, i);
        s && (s.get || s.set)
          ? Object.defineProperty(e.prototype, i, s)
          : (e.prototype[i] = r.prototype[i]);
      });
    });
  }
  var kZ = x(() => {
    "use strict";
    a(bZ, "applyMixins");
  });
  function uS(e = void 0) {
    return function () {
      return e;
    };
  }
  var Up,
    ji,
    jp,
    Fn,
    O1,
    P1,
    ys = x(() => {
      "use strict";
      he();
      Rp();
      KK();
      Nh();
      Bp();
      qQ();
      CL();
      ZQ();
      aZ();
      oZ();
      lZ();
      cZ();
      uZ();
      hZ();
      yZ();
      xZ();
      kZ();
      L1();
      Up = Ll(Os, "", NaN, NaN, NaN, NaN, NaN, NaN);
      Object.freeze(Up);
      ((ji = Object.freeze({
        recoveryEnabled: !1,
        maxLookahead: 3,
        dynamicTokensEnabled: !1,
        outputCst: !0,
        errorMessageProvider: Rl,
        nodeLocationTracking: "none",
        traceInitPerf: !1,
        skipValidations: !1,
      })),
        (jp = Object.freeze({
          recoveryValueFunc: a(() => {}, "recoveryValueFunc"),
          resyncEnabled: !0,
        })));
      (function (e) {
        ((e[(e.INVALID_RULE_NAME = 0)] = "INVALID_RULE_NAME"),
          (e[(e.DUPLICATE_RULE_NAME = 1)] = "DUPLICATE_RULE_NAME"),
          (e[(e.INVALID_RULE_OVERRIDE = 2)] = "INVALID_RULE_OVERRIDE"),
          (e[(e.DUPLICATE_PRODUCTIONS = 3)] = "DUPLICATE_PRODUCTIONS"),
          (e[(e.UNRESOLVED_SUBRULE_REF = 4)] = "UNRESOLVED_SUBRULE_REF"),
          (e[(e.LEFT_RECURSION = 5)] = "LEFT_RECURSION"),
          (e[(e.NONE_LAST_EMPTY_ALT = 6)] = "NONE_LAST_EMPTY_ALT"),
          (e[(e.AMBIGUOUS_ALTS = 7)] = "AMBIGUOUS_ALTS"),
          (e[(e.CONFLICT_TOKENS_RULES_NAMESPACE = 8)] =
            "CONFLICT_TOKENS_RULES_NAMESPACE"),
          (e[(e.INVALID_TOKEN_NAME = 9)] = "INVALID_TOKEN_NAME"),
          (e[(e.NO_NON_EMPTY_LOOKAHEAD = 10)] = "NO_NON_EMPTY_LOOKAHEAD"),
          (e[(e.AMBIGUOUS_PREFIX_ALTS = 11)] = "AMBIGUOUS_PREFIX_ALTS"),
          (e[(e.TOO_MANY_ALTS = 12)] = "TOO_MANY_ALTS"),
          (e[(e.CUSTOM_LOOKAHEAD_VALIDATION = 13)] =
            "CUSTOM_LOOKAHEAD_VALIDATION"));
      })(Fn || (Fn = {}));
      a(uS, "EMPTY_ALT");
      O1 = class e {
        static {
          a(this, "Parser");
        }
        static performSelfAnalysis(t) {
          throw Error(
            "The **static** `performSelfAnalysis` method has been deprecated.	\nUse the **instance** method with the same name instead.",
          );
        }
        performSelfAnalysis() {
          this.TRACE_INIT("performSelfAnalysis", () => {
            let t;
            this.selfAnalysisDone = !0;
            let r = this.className;
            (this.TRACE_INIT("toFastProps", () => {
              b1(this);
            }),
              this.TRACE_INIT("Grammar Recording", () => {
                try {
                  (this.enableRecording(),
                    rt(this.definedRulesNames, (i) => {
                      let o = this[i].originalGrammarAction,
                        l;
                      (this.TRACE_INIT(`${i} Rule`, () => {
                        l = this.topLevelRuleRecord(i, o);
                      }),
                        (this.gastProductionsCache[i] = l));
                    }));
                } finally {
                  this.disableRecording();
                }
              }));
            let n = [];
            if (
              (this.TRACE_INIT("Grammar Resolving", () => {
                ((n = UQ({ rules: We(this.gastProductionsCache) })),
                  (this.definitionErrors = this.definitionErrors.concat(n)));
              }),
              this.TRACE_INIT("Grammar Validations", () => {
                if (De(n) && this.skipValidations === !1) {
                  let i = jQ({
                      rules: We(this.gastProductionsCache),
                      tokenTypes: We(this.tokensMap),
                      errMsgProvider: Ya,
                      grammarName: r,
                    }),
                    s = BQ({
                      lookaheadStrategy: this.lookaheadStrategy,
                      rules: We(this.gastProductionsCache),
                      tokenTypes: We(this.tokensMap),
                      grammarName: r,
                    });
                  this.definitionErrors = this.definitionErrors.concat(i, s);
                }
              }),
              De(this.definitionErrors) &&
                (this.recoveryEnabled &&
                  this.TRACE_INIT("computeAllProdsFollows", () => {
                    let i = XK(We(this.gastProductionsCache));
                    this.resyncFollows = i;
                  }),
                this.TRACE_INIT("ComputeLookaheadFunctions", () => {
                  var i, s;
                  ((s = (i = this.lookaheadStrategy).initialize) === null ||
                    s === void 0 ||
                    s.call(i, { rules: We(this.gastProductionsCache) }),
                    this.preComputeLookaheadFunctions(
                      We(this.gastProductionsCache),
                    ));
                })),
              !e.DEFER_DEFINITION_ERRORS_HANDLING && !De(this.definitionErrors))
            )
              throw (
                (t = Dt(this.definitionErrors, (i) => i.message)),
                new Error(`Parser Definition Errors detected:
 ${t.join(`
-------------------------------
`)}`)
              );
          });
        }
        constructor(t, r) {
          ((this.definitionErrors = []), (this.selfAnalysisDone = !1));
          let n = this;
          if (
            (n.initErrorHandler(r),
            n.initLexerAdapter(),
            n.initLooksAhead(r),
            n.initRecognizerEngine(t, r),
            n.initRecoverable(r),
            n.initTreeBuilder(r),
            n.initContentAssist(),
            n.initGastRecorder(r),
            n.initPerformanceTracer(r),
            te(r, "ignoredIssues"))
          )
            throw new Error(`The <ignoredIssues> IParserConfig property has been deprecated.
	Please use the <IGNORE_AMBIGUITIES> flag on the relevant DSL method instead.
	See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#IGNORING_AMBIGUITIES
	For further details.`);
          this.skipValidations = te(r, "skipValidations")
            ? r.skipValidations
            : ji.skipValidations;
        }
      };
      O1.DEFER_DEFINITION_ERRORS_HANDLING = !1;
      bZ(O1, [qT, KT, tS, eS, nS, rS, iS, sS, aS, cS]);
      P1 = class extends O1 {
        static {
          a(this, "EmbeddedActionsParser");
        }
        constructor(t, r = ji) {
          let n = Sr(r);
          ((n.outputCst = !1), super(t, n));
        }
      };
    });
  var TZ = x(() => {
    "use strict";
    Ui();
  });
  var SZ = x(() => {
    "use strict";
  });
  var _Z = x(() => {
    "use strict";
    TZ();
    SZ();
  });
  var CZ = x(() => {
    "use strict";
    J6();
  });
  var qc = x(() => {
    "use strict";
    J6();
    ys();
    T1();
    Nh();
    Vp();
    wL();
    Bp();
    Wp();
    fL();
    Ui();
    Ui();
    _Z();
    CZ();
  });
  function Mh(e, t, r) {
    return `${e.name}_${t}_${r}`;
  }
  function AZ(e) {
    let t = {
      decisionMap: {},
      decisionStates: [],
      ruleToStartState: new Map(),
      ruleToStopState: new Map(),
      states: [],
    };
    $4t(t, e);
    let r = e.length;
    for (let n = 0; n < r; n++) {
      let i = e[n],
        s = Oh(t, i, i);
      s !== void 0 && K4t(t, i, s);
    }
    return t;
  }
  function $4t(e, t) {
    let r = t.length;
    for (let n = 0; n < r; n++) {
      let i = t[n],
        s = Zn(e, i, void 0, { type: M4t }),
        o = Zn(e, i, void 0, { type: Yp });
      ((s.stop = o), e.ruleToStartState.set(i, s), e.ruleToStopState.set(i, o));
    }
  }
  function LZ(e, t, r) {
    return r instanceof je
      ? ML(e, t, r.terminalType, r)
      : r instanceof Cr
        ? X4t(e, t, r)
        : r instanceof Or
          ? U4t(e, t, r)
          : r instanceof wr
            ? j4t(e, t, r)
            : r instanceof ir
              ? G4t(e, t, r)
              : r instanceof Mr
                ? V4t(e, t, r)
                : r instanceof zr
                  ? z4t(e, t, r)
                  : r instanceof Wr
                    ? W4t(e, t, r)
                    : Oh(e, t, r);
  }
  function G4t(e, t, r) {
    let n = Zn(e, t, r, { type: vZ });
    Yc(e, n);
    let i = Xp(e, t, n, r, Oh(e, t, r));
    return DZ(e, t, r, i);
  }
  function V4t(e, t, r) {
    let n = Zn(e, t, r, { type: vZ });
    Yc(e, n);
    let i = Xp(e, t, n, r, Oh(e, t, r)),
      s = ML(e, t, r.separator, r);
    return DZ(e, t, r, i, s);
  }
  function z4t(e, t, r) {
    let n = Zn(e, t, r, { type: wZ });
    Yc(e, n);
    let i = Xp(e, t, n, r, Oh(e, t, r));
    return RZ(e, t, r, i);
  }
  function W4t(e, t, r) {
    let n = Zn(e, t, r, { type: wZ });
    Yc(e, n);
    let i = Xp(e, t, n, r, Oh(e, t, r)),
      s = ML(e, t, r.separator, r);
    return RZ(e, t, r, i, s);
  }
  function U4t(e, t, r) {
    let n = Zn(e, t, r, { type: Hc });
    Yc(e, n);
    let i = Dt(r.definition, (o) => LZ(e, t, o));
    return Xp(e, t, n, r, ...i);
  }
  function j4t(e, t, r) {
    let n = Zn(e, t, r, { type: Hc });
    Yc(e, n);
    let i = Xp(e, t, n, r, Oh(e, t, r));
    return q4t(e, t, r, i);
  }
  function Oh(e, t, r) {
    let n = pr(
      Dt(r.definition, (i) => LZ(e, t, i)),
      (i) => i !== void 0,
    );
    return n.length === 1 ? n[0] : n.length === 0 ? void 0 : Y4t(e, n);
  }
  function RZ(e, t, r, n, i) {
    let s = n.left,
      o = n.right,
      l = Zn(e, t, r, { type: F4t });
    Yc(e, l);
    let u = Zn(e, t, r, { type: EZ });
    return (
      (s.loopback = l),
      (u.loopback = l),
      (e.decisionMap[
        Mh(
          t,
          i ? "RepetitionMandatoryWithSeparator" : "RepetitionMandatory",
          r.idx,
        )
      ] = l),
      An(o, l),
      i === void 0
        ? (An(l, s), An(l, u))
        : (An(l, u), An(l, i.left), An(i.right, s)),
      { left: s, right: u }
    );
  }
  function DZ(e, t, r, n, i) {
    let s = n.left,
      o = n.right,
      l = Zn(e, t, r, { type: B4t });
    Yc(e, l);
    let u = Zn(e, t, r, { type: EZ }),
      h = Zn(e, t, r, { type: P4t });
    return (
      (l.loopback = h),
      (u.loopback = h),
      An(l, s),
      An(l, u),
      An(o, h),
      i !== void 0 ? (An(h, u), An(h, i.left), An(i.right, s)) : An(h, l),
      (e.decisionMap[
        Mh(t, i ? "RepetitionWithSeparator" : "Repetition", r.idx)
      ] = l),
      { left: l, right: u }
    );
  }
  function q4t(e, t, r, n) {
    let i = n.left,
      s = n.right;
    return (An(i, s), (e.decisionMap[Mh(t, "Option", r.idx)] = i), n);
  }
  function Yc(e, t) {
    return (
      e.decisionStates.push(t),
      (t.decision = e.decisionStates.length - 1),
      t.decision
    );
  }
  function Xp(e, t, r, n, ...i) {
    let s = Zn(e, t, n, { type: O4t, start: r });
    r.end = s;
    for (let l of i) l !== void 0 ? (An(r, l.left), An(l.right, s)) : An(r, s);
    let o = { left: r, right: s };
    return ((e.decisionMap[Mh(t, H4t(n), n.idx)] = r), o);
  }
  function H4t(e) {
    if (e instanceof Or) return "Alternation";
    if (e instanceof wr) return "Option";
    if (e instanceof ir) return "Repetition";
    if (e instanceof Mr) return "RepetitionWithSeparator";
    if (e instanceof zr) return "RepetitionMandatory";
    if (e instanceof Wr) return "RepetitionMandatoryWithSeparator";
    throw new Error("Invalid production type encountered");
  }
  function Y4t(e, t) {
    let r = t.length;
    for (let s = 0; s < r - 1; s++) {
      let o = t[s],
        l;
      o.left.transitions.length === 1 && (l = o.left.transitions[0]);
      let u = l instanceof Hp,
        h = l,
        f = t[s + 1].left;
      o.left.type === Hc &&
      o.right.type === Hc &&
      l !== void 0 &&
      ((u && h.followState === o.right) || l.target === o.right)
        ? (u ? (h.followState = f) : (l.target = f), Q4t(e, o.right))
        : An(o.right, f);
    }
    let n = t[0],
      i = t[r - 1];
    return { left: n.left, right: i.right };
  }
  function ML(e, t, r, n) {
    let i = Zn(e, t, n, { type: Hc }),
      s = Zn(e, t, n, { type: Hc });
    return (OL(i, new qp(s, r)), { left: i, right: s });
  }
  function X4t(e, t, r) {
    let n = r.referencedRule,
      i = e.ruleToStartState.get(n),
      s = Zn(e, t, r, { type: Hc }),
      o = Zn(e, t, r, { type: Hc }),
      l = new Hp(i, n, o);
    return (OL(s, l), { left: s, right: o });
  }
  function K4t(e, t, r) {
    let n = e.ruleToStartState.get(t);
    An(n, r.left);
    let i = e.ruleToStopState.get(t);
    return (An(r.right, i), { left: n, right: i });
  }
  function An(e, t) {
    let r = new F1(t);
    OL(e, r);
  }
  function Zn(e, t, r, n) {
    let i = Object.assign(
      {
        atn: e,
        production: r,
        epsilonOnlyTransitions: !1,
        rule: t,
        transitions: [],
        nextTokenWithinRule: [],
        stateNumber: e.states.length,
      },
      n,
    );
    return (e.states.push(i), i);
  }
  function OL(e, t) {
    (e.transitions.length === 0 && (e.epsilonOnlyTransitions = t.isEpsilon()),
      e.transitions.push(t));
  }
  function Q4t(e, t) {
    e.states.splice(e.states.indexOf(t), 1);
  }
  var Hc,
    M4t,
    wZ,
    vZ,
    Yp,
    O4t,
    P4t,
    B4t,
    F4t,
    EZ,
    B1,
    qp,
    F1,
    Hp,
    NZ = x(() => {
      "use strict";
      Ld();
      u5();
      qc();
      a(Mh, "buildATNKey");
      ((Hc = 1),
        (M4t = 2),
        (wZ = 4),
        (vZ = 5),
        (Yp = 7),
        (O4t = 8),
        (P4t = 9),
        (B4t = 10),
        (F4t = 11),
        (EZ = 12),
        (B1 = class {
          static {
            a(this, "AbstractTransition");
          }
          constructor(t) {
            this.target = t;
          }
          isEpsilon() {
            return !1;
          }
        }),
        (qp = class extends B1 {
          static {
            a(this, "AtomTransition");
          }
          constructor(t, r) {
            (super(t), (this.tokenType = r));
          }
        }),
        (F1 = class extends B1 {
          static {
            a(this, "EpsilonTransition");
          }
          constructor(t) {
            super(t);
          }
          isEpsilon() {
            return !0;
          }
        }),
        (Hp = class extends B1 {
          static {
            a(this, "RuleTransition");
          }
          constructor(t, r, n) {
            (super(t), (this.rule = r), (this.followState = n));
          }
          isEpsilon() {
            return !0;
          }
        }));
      a(AZ, "createATN");
      a($4t, "createRuleStartAndStopATNStates");
      a(LZ, "atom");
      a(G4t, "repetition");
      a(V4t, "repetitionSep");
      a(z4t, "repetitionMandatory");
      a(W4t, "repetitionMandatorySep");
      a(U4t, "alternation");
      a(j4t, "option");
      a(Oh, "block");
      a(RZ, "plus");
      a(DZ, "star");
      a(q4t, "optional");
      a(Yc, "defineDecisionState");
      a(Xp, "makeAlts");
      a(H4t, "getProdType");
      a(Y4t, "makeBlock");
      a(ML, "tokenRef");
      a(X4t, "ruleRef");
      a(K4t, "buildRuleHandle");
      a(An, "epsilon");
      a(Zn, "newState");
      a(OL, "addTransition");
      a(Q4t, "removeState");
    });
  function PL(e, t = !0) {
    return `${t ? `a${e.alt}` : ""}s${e.state.stateNumber}:${e.stack.map((r) => r.stateNumber.toString()).join("_")}`;
  }
  var $1,
    Kp,
    IZ = x(() => {
      "use strict";
      Ld();
      (($1 = {}),
        (Kp = class {
          static {
            a(this, "ATNConfigSet");
          }
          constructor() {
            ((this.map = {}), (this.configs = []));
          }
          get size() {
            return this.configs.length;
          }
          finalize() {
            this.map = {};
          }
          add(t) {
            let r = PL(t);
            r in this.map ||
              ((this.map[r] = this.configs.length), this.configs.push(t));
          }
          get elements() {
            return this.configs;
          }
          get alts() {
            return Dt(this.configs, (t) => t.alt);
          }
          get key() {
            let t = "";
            for (let r in this.map) t += r + ":";
            return t;
          }
        }));
      a(PL, "getATNConfigKey");
    });
  function Z4t(e, t) {
    let r = {};
    return (n) => {
      let i = n.toString(),
        s = r[i];
      return (
        s !== void 0 ||
          ((s = { atnStartState: e, decision: t, states: {} }), (r[i] = s)),
        s
      );
    };
  }
  function OZ(e, t = !0) {
    let r = new Set();
    for (let n of e) {
      let i = new Set();
      for (let s of n) {
        if (s === void 0) {
          if (t) break;
          return !1;
        }
        let o = [s.tokenTypeIdx].concat(s.categoryMatches);
        for (let l of o)
          if (r.has(l)) {
            if (!i.has(l)) return !1;
          } else (r.add(l), i.add(l));
      }
    }
    return !0;
  }
  function J4t(e) {
    let t = e.decisionStates.length,
      r = Array(t);
    for (let n = 0; n < t; n++) r[n] = Z4t(e.decisionStates[n], n);
    return r;
  }
  function BL(e, t, r, n) {
    let i = e[t](r),
      s = i.start;
    if (s === void 0) {
      let l = uAt(i.atnStartState);
      ((s = FZ(i, BZ(l))), (i.start = s));
    }
    return tAt.apply(this, [i, s, r, n]);
  }
  function tAt(e, t, r, n) {
    let i = t,
      s = 1,
      o = [],
      l = this.LA(s++);
    for (;;) {
      let u = aAt(i, l);
      if ((u === void 0 && (u = eAt.apply(this, [e, i, l, s, r, n])), u === $1))
        return sAt(o, i, l);
      if (u.isAcceptState === !0) return u.prediction;
      ((i = u), o.push(l), (l = this.LA(s++)));
    }
  }
  function eAt(e, t, r, n, i, s) {
    let o = oAt(t.configs, r, i);
    if (o.size === 0) return (PZ(e, t, r, $1), $1);
    let l = BZ(o),
      u = cAt(o, i);
    if (u !== void 0)
      ((l.isAcceptState = !0), (l.prediction = u), (l.configs.uniqueAlt = u));
    else if (pAt(o)) {
      let h = Va(o.alts);
      ((l.isAcceptState = !0),
        (l.prediction = h),
        (l.configs.uniqueAlt = h),
        rAt.apply(this, [e, n, o.alts, s]));
    }
    return ((l = PZ(e, t, r, l)), l);
  }
  function rAt(e, t, r, n) {
    let i = [];
    for (let h = 1; h <= t; h++) i.push(this.LA(h).tokenType);
    let s = e.atnStartState,
      o = s.rule,
      l = s.production,
      u = nAt({
        topLevelRule: o,
        ambiguityIndices: r,
        production: l,
        prefixPath: i,
      });
    n(u);
  }
  function nAt(e) {
    let t = Dt(e.prefixPath, (i) => Al(i)).join(", "),
      r = e.production.idx === 0 ? "" : e.production.idx,
      n = `Ambiguous Alternatives Detected: <${e.ambiguityIndices.join(", ")}> in <${iAt(e.production)}${r}> inside <${e.topLevelRule.name}> Rule,
<${t}> may appears as a prefix path in all these alternatives.
`;
    return (
      (n =
        n +
        `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES
For Further details.`),
      n
    );
  }
  function iAt(e) {
    if (e instanceof Cr) return "SUBRULE";
    if (e instanceof wr) return "OPTION";
    if (e instanceof Or) return "OR";
    if (e instanceof zr) return "AT_LEAST_ONE";
    if (e instanceof Wr) return "AT_LEAST_ONE_SEP";
    if (e instanceof Mr) return "MANY_SEP";
    if (e instanceof ir) return "MANY";
    if (e instanceof je) return "CONSUME";
    throw Error("non exhaustive match");
  }
  function sAt(e, t, r) {
    let n = oi(t.configs.elements, (s) => s.state.transitions),
      i = fY(
        n.filter((s) => s instanceof qp).map((s) => s.tokenType),
        (s) => s.tokenTypeIdx,
      );
    return { actualToken: r, possibleTokenTypes: i, tokenPath: e };
  }
  function aAt(e, t) {
    return e.edges[t.tokenTypeIdx];
  }
  function oAt(e, t, r) {
    let n = new Kp(),
      i = [];
    for (let o of e.elements) {
      if (r.is(o.alt) === !1) continue;
      if (o.state.type === Yp) {
        i.push(o);
        continue;
      }
      let l = o.state.transitions.length;
      for (let u = 0; u < l; u++) {
        let h = o.state.transitions[u],
          f = lAt(h, t);
        f !== void 0 && n.add({ state: f, alt: o.alt, stack: o.stack });
      }
    }
    let s;
    if ((i.length === 0 && n.size === 1 && (s = n), s === void 0)) {
      s = new Kp();
      for (let o of n.elements) fS(o, s);
    }
    if (i.length > 0 && !fAt(s)) for (let o of i) s.add(o);
    return s;
  }
  function lAt(e, t) {
    if (e instanceof qp && _1(t, e.tokenType)) return e.target;
  }
  function cAt(e, t) {
    let r;
    for (let n of e.elements)
      if (t.is(n.alt) === !0) {
        if (r === void 0) r = n.alt;
        else if (r !== n.alt) return;
      }
    return r;
  }
  function BZ(e) {
    return { configs: e, edges: {}, isAcceptState: !1, prediction: -1 };
  }
  function PZ(e, t, r, n) {
    return ((n = FZ(e, n)), (t.edges[r.tokenTypeIdx] = n), n);
  }
  function FZ(e, t) {
    if (t === $1) return t;
    let r = t.configs.key,
      n = e.states[r];
    return n !== void 0 ? n : (t.configs.finalize(), (e.states[r] = t), t);
  }
  function uAt(e) {
    let t = new Kp(),
      r = e.transitions.length;
    for (let n = 0; n < r; n++) {
      let s = { state: e.transitions[n].target, alt: n, stack: [] };
      fS(s, t);
    }
    return t;
  }
  function fS(e, t) {
    let r = e.state;
    if (r.type === Yp) {
      if (e.stack.length > 0) {
        let i = [...e.stack],
          o = { state: i.pop(), alt: e.alt, stack: i };
        fS(o, t);
      } else t.add(e);
      return;
    }
    r.epsilonOnlyTransitions || t.add(e);
    let n = r.transitions.length;
    for (let i = 0; i < n; i++) {
      let s = r.transitions[i],
        o = hAt(e, s);
      o !== void 0 && fS(o, t);
    }
  }
  function hAt(e, t) {
    if (t instanceof F1) return { state: t.target, alt: e.alt, stack: e.stack };
    if (t instanceof Hp) {
      let r = [...e.stack, t.followState];
      return { state: t.target, alt: e.alt, stack: r };
    }
  }
  function fAt(e) {
    for (let t of e.elements) if (t.state.type === Yp) return !0;
    return !1;
  }
  function dAt(e) {
    for (let t of e.elements) if (t.state.type !== Yp) return !1;
    return !0;
  }
  function pAt(e) {
    if (dAt(e)) return !0;
    let t = mAt(e.elements);
    return gAt(t) && !yAt(t);
  }
  function mAt(e) {
    let t = new Map();
    for (let r of e) {
      let n = PL(r, !1),
        i = t.get(n);
      (i === void 0 && ((i = {}), t.set(n, i)), (i[r.alt] = !0));
    }
    return t;
  }
  function gAt(e) {
    for (let t of Array.from(e.values()))
      if (Object.keys(t).length > 1) return !0;
    return !1;
  }
  function yAt(e) {
    for (let t of Array.from(e.values()))
      if (Object.keys(t).length === 1) return !0;
    return !1;
  }
  var hS,
    MZ,
    G1,
    $Z = x(() => {
      "use strict";
      qc();
      NZ();
      IZ();
      x5();
      f5();
      dY();
      Ld();
      pk();
      Wk();
      Yk();
      S5();
      a(Z4t, "createDFACache");
      ((hS = class {
        static {
          a(this, "PredicateSet");
        }
        constructor() {
          this.predicates = [];
        }
        is(t) {
          return t >= this.predicates.length || this.predicates[t];
        }
        set(t, r) {
          this.predicates[t] = r;
        }
        toString() {
          let t = "",
            r = this.predicates.length;
          for (let n = 0; n < r; n++)
            t += this.predicates[n] === !0 ? "1" : "0";
          return t;
        }
      }),
        (MZ = new hS()),
        (G1 = class extends Dl {
          static {
            a(this, "LLStarLookaheadStrategy");
          }
          constructor(t) {
            var r;
            (super(),
              (this.logging =
                (r = t?.logging) !== null && r !== void 0
                  ? r
                  : (n) => console.log(n)));
          }
          initialize(t) {
            ((this.atn = AZ(t.rules)), (this.dfas = J4t(this.atn)));
          }
          validateAmbiguousAlternationAlternatives() {
            return [];
          }
          validateEmptyOrAlternatives() {
            return [];
          }
          buildLookaheadForAlternation(t) {
            let {
                prodOccurrence: r,
                rule: n,
                hasPredicates: i,
                dynamicTokensEnabled: s,
              } = t,
              o = this.dfas,
              l = this.logging,
              u = Mh(n, "Alternation", r),
              f = this.atn.decisionMap[u].decision,
              d = Dt(
                WT({
                  maxLookahead: 1,
                  occurrence: r,
                  prodType: "Alternation",
                  rule: n,
                }),
                (p) => Dt(p, (m) => m[0]),
              );
            if (OZ(d, !1) && !s) {
              let p = mr(
                d,
                (m, g, y) => (
                  rt(g, (b) => {
                    b &&
                      ((m[b.tokenTypeIdx] = y),
                      rt(b.categoryMatches, (k) => {
                        m[k] = y;
                      }));
                  }),
                  m
                ),
                {},
              );
              return i
                ? function (m) {
                    var g;
                    let y = this.LA(1),
                      b = p[y.tokenTypeIdx];
                    if (m !== void 0 && b !== void 0) {
                      let k =
                        (g = m[b]) === null || g === void 0 ? void 0 : g.GATE;
                      if (k !== void 0 && k.call(this) === !1) return;
                    }
                    return b;
                  }
                : function () {
                    let m = this.LA(1);
                    return p[m.tokenTypeIdx];
                  };
            } else
              return i
                ? function (p) {
                    let m = new hS(),
                      g = p === void 0 ? 0 : p.length;
                    for (let b = 0; b < g; b++) {
                      let k = p?.[b].GATE;
                      m.set(b, k === void 0 || k.call(this));
                    }
                    let y = BL.call(this, o, f, m, l);
                    return typeof y == "number" ? y : void 0;
                  }
                : function () {
                    let p = BL.call(this, o, f, MZ, l);
                    return typeof p == "number" ? p : void 0;
                  };
          }
          buildLookaheadForOptional(t) {
            let {
                prodOccurrence: r,
                rule: n,
                prodType: i,
                dynamicTokensEnabled: s,
              } = t,
              o = this.dfas,
              l = this.logging,
              u = Mh(n, i, r),
              f = this.atn.decisionMap[u].decision,
              d = Dt(
                WT({ maxLookahead: 1, occurrence: r, prodType: i, rule: n }),
                (p) => Dt(p, (m) => m[0]),
              );
            if (OZ(d) && d[0][0] && !s) {
              let p = d[0],
                m = dr(p);
              if (m.length === 1 && De(m[0].categoryMatches)) {
                let y = m[0].tokenTypeIdx;
                return function () {
                  return this.LA(1).tokenTypeIdx === y;
                };
              } else {
                let g = mr(
                  m,
                  (y, b) => (
                    b !== void 0 &&
                      ((y[b.tokenTypeIdx] = !0),
                      rt(b.categoryMatches, (k) => {
                        y[k] = !0;
                      })),
                    y
                  ),
                  {},
                );
                return function () {
                  let y = this.LA(1);
                  return g[y.tokenTypeIdx] === !0;
                };
              }
            }
            return function () {
              let p = BL.call(this, o, f, MZ, l);
              return typeof p == "object" ? !1 : p === 0;
            };
          }
        }));
      a(OZ, "isLL1Sequence");
      a(J4t, "initATNSimulator");
      a(BL, "adaptivePredict");
      a(tAt, "performLookahead");
      a(eAt, "computeLookaheadTarget");
      a(rAt, "reportLookaheadAmbiguity");
      a(nAt, "buildAmbiguityError");
      a(iAt, "getProductionDslName");
      a(sAt, "buildAdaptivePredictError");
      a(aAt, "getExistingTargetState");
      a(oAt, "computeReachSet");
      a(lAt, "getReachableTarget");
      a(cAt, "getUniqueAlt");
      a(BZ, "newDFAState");
      a(PZ, "addDFAEdge");
      a(FZ, "addDFAState");
      a(uAt, "computeStartState");
      a(fS, "closure");
      a(hAt, "getEpsilonTarget");
      a(fAt, "hasConfigInRuleStopState");
      a(dAt, "allConfigsInRuleStopStates");
      a(pAt, "hasConflictTerminatingPrediction");
      a(mAt, "getConflictingAltSets");
      a(gAt, "hasConflictingAltSet");
      a(yAt, "hasStateAssociatedWithOneAlt");
    });
  var GZ = x(() => {
    "use strict";
    $Z();
  });
  var VZ,
    FL,
    zZ,
    dS,
    gr,
    sr,
    pS,
    WZ,
    $L,
    UZ,
    jZ,
    qZ,
    HZ,
    GL,
    YZ,
    XZ,
    KZ,
    mS,
    Qp,
    Zp,
    VL,
    Jp,
    QZ,
    zL,
    WL,
    UL,
    jL,
    qL,
    ZZ,
    JZ,
    HL,
    tJ,
    YL,
    V1,
    eJ,
    rJ,
    nJ,
    iJ,
    sJ,
    aJ,
    oJ,
    lJ,
    gS,
    cJ,
    uJ,
    hJ,
    fJ,
    dJ,
    pJ,
    mJ,
    gJ,
    yJ,
    xJ,
    bJ,
    yS,
    kJ,
    TJ,
    SJ,
    _J,
    CJ,
    wJ,
    vJ,
    EJ,
    AJ,
    LJ,
    RJ,
    DJ,
    NJ,
    XL,
    KL,
    IJ,
    MJ,
    OJ,
    PJ,
    BJ,
    FJ,
    $J,
    GJ,
    VJ,
    QL,
    pt,
    ZL = x(() => {
      "use strict";
      (function (e) {
        function t(r) {
          return typeof r == "string";
        }
        (a(t, "is"), (e.is = t));
      })(VZ || (VZ = {}));
      (function (e) {
        function t(r) {
          return typeof r == "string";
        }
        (a(t, "is"), (e.is = t));
      })(FL || (FL = {}));
      (function (e) {
        ((e.MIN_VALUE = -2147483648), (e.MAX_VALUE = 2147483647));
        function t(r) {
          return typeof r == "number" && e.MIN_VALUE <= r && r <= e.MAX_VALUE;
        }
        (a(t, "is"), (e.is = t));
      })(zZ || (zZ = {}));
      (function (e) {
        ((e.MIN_VALUE = 0), (e.MAX_VALUE = 2147483647));
        function t(r) {
          return typeof r == "number" && e.MIN_VALUE <= r && r <= e.MAX_VALUE;
        }
        (a(t, "is"), (e.is = t));
      })(dS || (dS = {}));
      (function (e) {
        function t(n, i) {
          return (
            n === Number.MAX_VALUE && (n = dS.MAX_VALUE),
            i === Number.MAX_VALUE && (i = dS.MAX_VALUE),
            { line: n, character: i }
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            pt.uinteger(i.line) &&
            pt.uinteger(i.character)
          );
        }
        (a(r, "is"), (e.is = r));
      })(gr || (gr = {}));
      (function (e) {
        function t(n, i, s, o) {
          if (
            pt.uinteger(n) &&
            pt.uinteger(i) &&
            pt.uinteger(s) &&
            pt.uinteger(o)
          )
            return { start: gr.create(n, i), end: gr.create(s, o) };
          if (gr.is(n) && gr.is(i)) return { start: n, end: i };
          throw new Error(
            `Range#create called with invalid arguments[${n}, ${i}, ${s}, ${o}]`,
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return pt.objectLiteral(i) && gr.is(i.start) && gr.is(i.end);
        }
        (a(r, "is"), (e.is = r));
      })(sr || (sr = {}));
      (function (e) {
        function t(n, i) {
          return { uri: n, range: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            sr.is(i.range) &&
            (pt.string(i.uri) || pt.undefined(i.uri))
          );
        }
        (a(r, "is"), (e.is = r));
      })(pS || (pS = {}));
      (function (e) {
        function t(n, i, s, o) {
          return {
            targetUri: n,
            targetRange: i,
            targetSelectionRange: s,
            originSelectionRange: o,
          };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            sr.is(i.targetRange) &&
            pt.string(i.targetUri) &&
            sr.is(i.targetSelectionRange) &&
            (sr.is(i.originSelectionRange) ||
              pt.undefined(i.originSelectionRange))
          );
        }
        (a(r, "is"), (e.is = r));
      })(WZ || (WZ = {}));
      (function (e) {
        function t(n, i, s, o) {
          return { red: n, green: i, blue: s, alpha: o };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            pt.numberRange(i.red, 0, 1) &&
            pt.numberRange(i.green, 0, 1) &&
            pt.numberRange(i.blue, 0, 1) &&
            pt.numberRange(i.alpha, 0, 1)
          );
        }
        (a(r, "is"), (e.is = r));
      })($L || ($L = {}));
      (function (e) {
        function t(n, i) {
          return { range: n, color: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return pt.objectLiteral(i) && sr.is(i.range) && $L.is(i.color);
        }
        (a(r, "is"), (e.is = r));
      })(UZ || (UZ = {}));
      (function (e) {
        function t(n, i, s) {
          return { label: n, textEdit: i, additionalTextEdits: s };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            pt.string(i.label) &&
            (pt.undefined(i.textEdit) || Zp.is(i)) &&
            (pt.undefined(i.additionalTextEdits) ||
              pt.typedArray(i.additionalTextEdits, Zp.is))
          );
        }
        (a(r, "is"), (e.is = r));
      })(jZ || (jZ = {}));
      (function (e) {
        ((e.Comment = "comment"),
          (e.Imports = "imports"),
          (e.Region = "region"));
      })(qZ || (qZ = {}));
      (function (e) {
        function t(n, i, s, o, l, u) {
          let h = { startLine: n, endLine: i };
          return (
            pt.defined(s) && (h.startCharacter = s),
            pt.defined(o) && (h.endCharacter = o),
            pt.defined(l) && (h.kind = l),
            pt.defined(u) && (h.collapsedText = u),
            h
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            pt.uinteger(i.startLine) &&
            pt.uinteger(i.startLine) &&
            (pt.undefined(i.startCharacter) || pt.uinteger(i.startCharacter)) &&
            (pt.undefined(i.endCharacter) || pt.uinteger(i.endCharacter)) &&
            (pt.undefined(i.kind) || pt.string(i.kind))
          );
        }
        (a(r, "is"), (e.is = r));
      })(HZ || (HZ = {}));
      (function (e) {
        function t(n, i) {
          return { location: n, message: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return pt.defined(i) && pS.is(i.location) && pt.string(i.message);
        }
        (a(r, "is"), (e.is = r));
      })(GL || (GL = {}));
      (function (e) {
        ((e.Error = 1), (e.Warning = 2), (e.Information = 3), (e.Hint = 4));
      })(YZ || (YZ = {}));
      (function (e) {
        ((e.Unnecessary = 1), (e.Deprecated = 2));
      })(XZ || (XZ = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return pt.objectLiteral(n) && pt.string(n.href);
        }
        (a(t, "is"), (e.is = t));
      })(KZ || (KZ = {}));
      (function (e) {
        function t(n, i, s, o, l, u) {
          let h = { range: n, message: i };
          return (
            pt.defined(s) && (h.severity = s),
            pt.defined(o) && (h.code = o),
            pt.defined(l) && (h.source = l),
            pt.defined(u) && (h.relatedInformation = u),
            h
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          var i;
          let s = n;
          return (
            pt.defined(s) &&
            sr.is(s.range) &&
            pt.string(s.message) &&
            (pt.number(s.severity) || pt.undefined(s.severity)) &&
            (pt.integer(s.code) || pt.string(s.code) || pt.undefined(s.code)) &&
            (pt.undefined(s.codeDescription) ||
              pt.string(
                (i = s.codeDescription) === null || i === void 0
                  ? void 0
                  : i.href,
              )) &&
            (pt.string(s.source) || pt.undefined(s.source)) &&
            (pt.undefined(s.relatedInformation) ||
              pt.typedArray(s.relatedInformation, GL.is))
          );
        }
        (a(r, "is"), (e.is = r));
      })(mS || (mS = {}));
      (function (e) {
        function t(n, i, ...s) {
          let o = { title: n, command: i };
          return (pt.defined(s) && s.length > 0 && (o.arguments = s), o);
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return pt.defined(i) && pt.string(i.title) && pt.string(i.command);
        }
        (a(r, "is"), (e.is = r));
      })(Qp || (Qp = {}));
      (function (e) {
        function t(s, o) {
          return { range: s, newText: o };
        }
        (a(t, "replace"), (e.replace = t));
        function r(s, o) {
          return { range: { start: s, end: s }, newText: o };
        }
        (a(r, "insert"), (e.insert = r));
        function n(s) {
          return { range: s, newText: "" };
        }
        (a(n, "del"), (e.del = n));
        function i(s) {
          let o = s;
          return pt.objectLiteral(o) && pt.string(o.newText) && sr.is(o.range);
        }
        (a(i, "is"), (e.is = i));
      })(Zp || (Zp = {}));
      (function (e) {
        function t(n, i, s) {
          let o = { label: n };
          return (
            i !== void 0 && (o.needsConfirmation = i),
            s !== void 0 && (o.description = s),
            o
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            pt.string(i.label) &&
            (pt.boolean(i.needsConfirmation) ||
              i.needsConfirmation === void 0) &&
            (pt.string(i.description) || i.description === void 0)
          );
        }
        (a(r, "is"), (e.is = r));
      })(VL || (VL = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return pt.string(n);
        }
        (a(t, "is"), (e.is = t));
      })(Jp || (Jp = {}));
      (function (e) {
        function t(s, o, l) {
          return { range: s, newText: o, annotationId: l };
        }
        (a(t, "replace"), (e.replace = t));
        function r(s, o, l) {
          return { range: { start: s, end: s }, newText: o, annotationId: l };
        }
        (a(r, "insert"), (e.insert = r));
        function n(s, o) {
          return { range: s, newText: "", annotationId: o };
        }
        (a(n, "del"), (e.del = n));
        function i(s) {
          let o = s;
          return Zp.is(o) && (VL.is(o.annotationId) || Jp.is(o.annotationId));
        }
        (a(i, "is"), (e.is = i));
      })(QZ || (QZ = {}));
      (function (e) {
        function t(n, i) {
          return { textDocument: n, edits: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.defined(i) && HL.is(i.textDocument) && Array.isArray(i.edits)
          );
        }
        (a(r, "is"), (e.is = r));
      })(zL || (zL = {}));
      (function (e) {
        function t(n, i, s) {
          let o = { kind: "create", uri: n };
          return (
            i !== void 0 &&
              (i.overwrite !== void 0 || i.ignoreIfExists !== void 0) &&
              (o.options = i),
            s !== void 0 && (o.annotationId = s),
            o
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i &&
            i.kind === "create" &&
            pt.string(i.uri) &&
            (i.options === void 0 ||
              ((i.options.overwrite === void 0 ||
                pt.boolean(i.options.overwrite)) &&
                (i.options.ignoreIfExists === void 0 ||
                  pt.boolean(i.options.ignoreIfExists)))) &&
            (i.annotationId === void 0 || Jp.is(i.annotationId))
          );
        }
        (a(r, "is"), (e.is = r));
      })(WL || (WL = {}));
      (function (e) {
        function t(n, i, s, o) {
          let l = { kind: "rename", oldUri: n, newUri: i };
          return (
            s !== void 0 &&
              (s.overwrite !== void 0 || s.ignoreIfExists !== void 0) &&
              (l.options = s),
            o !== void 0 && (l.annotationId = o),
            l
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i &&
            i.kind === "rename" &&
            pt.string(i.oldUri) &&
            pt.string(i.newUri) &&
            (i.options === void 0 ||
              ((i.options.overwrite === void 0 ||
                pt.boolean(i.options.overwrite)) &&
                (i.options.ignoreIfExists === void 0 ||
                  pt.boolean(i.options.ignoreIfExists)))) &&
            (i.annotationId === void 0 || Jp.is(i.annotationId))
          );
        }
        (a(r, "is"), (e.is = r));
      })(UL || (UL = {}));
      (function (e) {
        function t(n, i, s) {
          let o = { kind: "delete", uri: n };
          return (
            i !== void 0 &&
              (i.recursive !== void 0 || i.ignoreIfNotExists !== void 0) &&
              (o.options = i),
            s !== void 0 && (o.annotationId = s),
            o
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i &&
            i.kind === "delete" &&
            pt.string(i.uri) &&
            (i.options === void 0 ||
              ((i.options.recursive === void 0 ||
                pt.boolean(i.options.recursive)) &&
                (i.options.ignoreIfNotExists === void 0 ||
                  pt.boolean(i.options.ignoreIfNotExists)))) &&
            (i.annotationId === void 0 || Jp.is(i.annotationId))
          );
        }
        (a(r, "is"), (e.is = r));
      })(jL || (jL = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return (
            n &&
            (n.changes !== void 0 || n.documentChanges !== void 0) &&
            (n.documentChanges === void 0 ||
              n.documentChanges.every((i) =>
                pt.string(i.kind) ? WL.is(i) || UL.is(i) || jL.is(i) : zL.is(i),
              ))
          );
        }
        (a(t, "is"), (e.is = t));
      })(qL || (qL = {}));
      (function (e) {
        function t(n) {
          return { uri: n };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return pt.defined(i) && pt.string(i.uri);
        }
        (a(r, "is"), (e.is = r));
      })(ZZ || (ZZ = {}));
      (function (e) {
        function t(n, i) {
          return { uri: n, version: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return pt.defined(i) && pt.string(i.uri) && pt.integer(i.version);
        }
        (a(r, "is"), (e.is = r));
      })(JZ || (JZ = {}));
      (function (e) {
        function t(n, i) {
          return { uri: n, version: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.defined(i) &&
            pt.string(i.uri) &&
            (i.version === null || pt.integer(i.version))
          );
        }
        (a(r, "is"), (e.is = r));
      })(HL || (HL = {}));
      (function (e) {
        function t(n, i, s, o) {
          return { uri: n, languageId: i, version: s, text: o };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.defined(i) &&
            pt.string(i.uri) &&
            pt.string(i.languageId) &&
            pt.integer(i.version) &&
            pt.string(i.text)
          );
        }
        (a(r, "is"), (e.is = r));
      })(tJ || (tJ = {}));
      (function (e) {
        ((e.PlainText = "plaintext"), (e.Markdown = "markdown"));
        function t(r) {
          let n = r;
          return n === e.PlainText || n === e.Markdown;
        }
        (a(t, "is"), (e.is = t));
      })(YL || (YL = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return pt.objectLiteral(r) && YL.is(n.kind) && pt.string(n.value);
        }
        (a(t, "is"), (e.is = t));
      })(V1 || (V1 = {}));
      (function (e) {
        ((e.Text = 1),
          (e.Method = 2),
          (e.Function = 3),
          (e.Constructor = 4),
          (e.Field = 5),
          (e.Variable = 6),
          (e.Class = 7),
          (e.Interface = 8),
          (e.Module = 9),
          (e.Property = 10),
          (e.Unit = 11),
          (e.Value = 12),
          (e.Enum = 13),
          (e.Keyword = 14),
          (e.Snippet = 15),
          (e.Color = 16),
          (e.File = 17),
          (e.Reference = 18),
          (e.Folder = 19),
          (e.EnumMember = 20),
          (e.Constant = 21),
          (e.Struct = 22),
          (e.Event = 23),
          (e.Operator = 24),
          (e.TypeParameter = 25));
      })(eJ || (eJ = {}));
      (function (e) {
        ((e.PlainText = 1), (e.Snippet = 2));
      })(rJ || (rJ = {}));
      (function (e) {
        e.Deprecated = 1;
      })(nJ || (nJ = {}));
      (function (e) {
        function t(n, i, s) {
          return { newText: n, insert: i, replace: s };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i && pt.string(i.newText) && sr.is(i.insert) && sr.is(i.replace)
          );
        }
        (a(r, "is"), (e.is = r));
      })(iJ || (iJ = {}));
      (function (e) {
        ((e.asIs = 1), (e.adjustIndentation = 2));
      })(sJ || (sJ = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return (
            n &&
            (pt.string(n.detail) || n.detail === void 0) &&
            (pt.string(n.description) || n.description === void 0)
          );
        }
        (a(t, "is"), (e.is = t));
      })(aJ || (aJ = {}));
      (function (e) {
        function t(r) {
          return { label: r };
        }
        (a(t, "create"), (e.create = t));
      })(oJ || (oJ = {}));
      (function (e) {
        function t(r, n) {
          return { items: r || [], isIncomplete: !!n };
        }
        (a(t, "create"), (e.create = t));
      })(lJ || (lJ = {}));
      (function (e) {
        function t(n) {
          return n.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&");
        }
        (a(t, "fromPlainText"), (e.fromPlainText = t));
        function r(n) {
          let i = n;
          return (
            pt.string(i) ||
            (pt.objectLiteral(i) && pt.string(i.language) && pt.string(i.value))
          );
        }
        (a(r, "is"), (e.is = r));
      })(gS || (gS = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return (
            !!n &&
            pt.objectLiteral(n) &&
            (V1.is(n.contents) ||
              gS.is(n.contents) ||
              pt.typedArray(n.contents, gS.is)) &&
            (r.range === void 0 || sr.is(r.range))
          );
        }
        (a(t, "is"), (e.is = t));
      })(cJ || (cJ = {}));
      (function (e) {
        function t(r, n) {
          return n ? { label: r, documentation: n } : { label: r };
        }
        (a(t, "create"), (e.create = t));
      })(uJ || (uJ = {}));
      (function (e) {
        function t(r, n, ...i) {
          let s = { label: r };
          return (
            pt.defined(n) && (s.documentation = n),
            pt.defined(i) ? (s.parameters = i) : (s.parameters = []),
            s
          );
        }
        (a(t, "create"), (e.create = t));
      })(hJ || (hJ = {}));
      (function (e) {
        ((e.Text = 1), (e.Read = 2), (e.Write = 3));
      })(fJ || (fJ = {}));
      (function (e) {
        function t(r, n) {
          let i = { range: r };
          return (pt.number(n) && (i.kind = n), i);
        }
        (a(t, "create"), (e.create = t));
      })(dJ || (dJ = {}));
      (function (e) {
        ((e.File = 1),
          (e.Module = 2),
          (e.Namespace = 3),
          (e.Package = 4),
          (e.Class = 5),
          (e.Method = 6),
          (e.Property = 7),
          (e.Field = 8),
          (e.Constructor = 9),
          (e.Enum = 10),
          (e.Interface = 11),
          (e.Function = 12),
          (e.Variable = 13),
          (e.Constant = 14),
          (e.String = 15),
          (e.Number = 16),
          (e.Boolean = 17),
          (e.Array = 18),
          (e.Object = 19),
          (e.Key = 20),
          (e.Null = 21),
          (e.EnumMember = 22),
          (e.Struct = 23),
          (e.Event = 24),
          (e.Operator = 25),
          (e.TypeParameter = 26));
      })(pJ || (pJ = {}));
      (function (e) {
        e.Deprecated = 1;
      })(mJ || (mJ = {}));
      (function (e) {
        function t(r, n, i, s, o) {
          let l = { name: r, kind: n, location: { uri: s, range: i } };
          return (o && (l.containerName = o), l);
        }
        (a(t, "create"), (e.create = t));
      })(gJ || (gJ = {}));
      (function (e) {
        function t(r, n, i, s) {
          return s !== void 0
            ? { name: r, kind: n, location: { uri: i, range: s } }
            : { name: r, kind: n, location: { uri: i } };
        }
        (a(t, "create"), (e.create = t));
      })(yJ || (yJ = {}));
      (function (e) {
        function t(n, i, s, o, l, u) {
          let h = { name: n, detail: i, kind: s, range: o, selectionRange: l };
          return (u !== void 0 && (h.children = u), h);
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i &&
            pt.string(i.name) &&
            pt.number(i.kind) &&
            sr.is(i.range) &&
            sr.is(i.selectionRange) &&
            (i.detail === void 0 || pt.string(i.detail)) &&
            (i.deprecated === void 0 || pt.boolean(i.deprecated)) &&
            (i.children === void 0 || Array.isArray(i.children)) &&
            (i.tags === void 0 || Array.isArray(i.tags))
          );
        }
        (a(r, "is"), (e.is = r));
      })(xJ || (xJ = {}));
      (function (e) {
        ((e.Empty = ""),
          (e.QuickFix = "quickfix"),
          (e.Refactor = "refactor"),
          (e.RefactorExtract = "refactor.extract"),
          (e.RefactorInline = "refactor.inline"),
          (e.RefactorRewrite = "refactor.rewrite"),
          (e.Source = "source"),
          (e.SourceOrganizeImports = "source.organizeImports"),
          (e.SourceFixAll = "source.fixAll"));
      })(bJ || (bJ = {}));
      (function (e) {
        ((e.Invoked = 1), (e.Automatic = 2));
      })(yS || (yS = {}));
      (function (e) {
        function t(n, i, s) {
          let o = { diagnostics: n };
          return (
            i != null && (o.only = i),
            s != null && (o.triggerKind = s),
            o
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.defined(i) &&
            pt.typedArray(i.diagnostics, mS.is) &&
            (i.only === void 0 || pt.typedArray(i.only, pt.string)) &&
            (i.triggerKind === void 0 ||
              i.triggerKind === yS.Invoked ||
              i.triggerKind === yS.Automatic)
          );
        }
        (a(r, "is"), (e.is = r));
      })(kJ || (kJ = {}));
      (function (e) {
        function t(n, i, s) {
          let o = { title: n },
            l = !0;
          return (
            typeof i == "string"
              ? ((l = !1), (o.kind = i))
              : Qp.is(i)
                ? (o.command = i)
                : (o.edit = i),
            l && s !== void 0 && (o.kind = s),
            o
          );
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i &&
            pt.string(i.title) &&
            (i.diagnostics === void 0 || pt.typedArray(i.diagnostics, mS.is)) &&
            (i.kind === void 0 || pt.string(i.kind)) &&
            (i.edit !== void 0 || i.command !== void 0) &&
            (i.command === void 0 || Qp.is(i.command)) &&
            (i.isPreferred === void 0 || pt.boolean(i.isPreferred)) &&
            (i.edit === void 0 || qL.is(i.edit))
          );
        }
        (a(r, "is"), (e.is = r));
      })(TJ || (TJ = {}));
      (function (e) {
        function t(n, i) {
          let s = { range: n };
          return (pt.defined(i) && (s.data = i), s);
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.defined(i) &&
            sr.is(i.range) &&
            (pt.undefined(i.command) || Qp.is(i.command))
          );
        }
        (a(r, "is"), (e.is = r));
      })(SJ || (SJ = {}));
      (function (e) {
        function t(n, i) {
          return { tabSize: n, insertSpaces: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.defined(i) &&
            pt.uinteger(i.tabSize) &&
            pt.boolean(i.insertSpaces)
          );
        }
        (a(r, "is"), (e.is = r));
      })(_J || (_J = {}));
      (function (e) {
        function t(n, i, s) {
          return { range: n, target: i, data: s };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.defined(i) &&
            sr.is(i.range) &&
            (pt.undefined(i.target) || pt.string(i.target))
          );
        }
        (a(r, "is"), (e.is = r));
      })(CJ || (CJ = {}));
      (function (e) {
        function t(n, i) {
          return { range: n, parent: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            sr.is(i.range) &&
            (i.parent === void 0 || e.is(i.parent))
          );
        }
        (a(r, "is"), (e.is = r));
      })(wJ || (wJ = {}));
      (function (e) {
        ((e.namespace = "namespace"),
          (e.type = "type"),
          (e.class = "class"),
          (e.enum = "enum"),
          (e.interface = "interface"),
          (e.struct = "struct"),
          (e.typeParameter = "typeParameter"),
          (e.parameter = "parameter"),
          (e.variable = "variable"),
          (e.property = "property"),
          (e.enumMember = "enumMember"),
          (e.event = "event"),
          (e.function = "function"),
          (e.method = "method"),
          (e.macro = "macro"),
          (e.keyword = "keyword"),
          (e.modifier = "modifier"),
          (e.comment = "comment"),
          (e.string = "string"),
          (e.number = "number"),
          (e.regexp = "regexp"),
          (e.operator = "operator"),
          (e.decorator = "decorator"));
      })(vJ || (vJ = {}));
      (function (e) {
        ((e.declaration = "declaration"),
          (e.definition = "definition"),
          (e.readonly = "readonly"),
          (e.static = "static"),
          (e.deprecated = "deprecated"),
          (e.abstract = "abstract"),
          (e.async = "async"),
          (e.modification = "modification"),
          (e.documentation = "documentation"),
          (e.defaultLibrary = "defaultLibrary"));
      })(EJ || (EJ = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return (
            pt.objectLiteral(n) &&
            (n.resultId === void 0 || typeof n.resultId == "string") &&
            Array.isArray(n.data) &&
            (n.data.length === 0 || typeof n.data[0] == "number")
          );
        }
        (a(t, "is"), (e.is = t));
      })(AJ || (AJ = {}));
      (function (e) {
        function t(n, i) {
          return { range: n, text: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return i != null && sr.is(i.range) && pt.string(i.text);
        }
        (a(r, "is"), (e.is = r));
      })(LJ || (LJ = {}));
      (function (e) {
        function t(n, i, s) {
          return { range: n, variableName: i, caseSensitiveLookup: s };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i != null &&
            sr.is(i.range) &&
            pt.boolean(i.caseSensitiveLookup) &&
            (pt.string(i.variableName) || i.variableName === void 0)
          );
        }
        (a(r, "is"), (e.is = r));
      })(RJ || (RJ = {}));
      (function (e) {
        function t(n, i) {
          return { range: n, expression: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            i != null &&
            sr.is(i.range) &&
            (pt.string(i.expression) || i.expression === void 0)
          );
        }
        (a(r, "is"), (e.is = r));
      })(DJ || (DJ = {}));
      (function (e) {
        function t(n, i) {
          return { frameId: n, stoppedLocation: i };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return pt.defined(i) && sr.is(n.stoppedLocation);
        }
        (a(r, "is"), (e.is = r));
      })(NJ || (NJ = {}));
      (function (e) {
        ((e.Type = 1), (e.Parameter = 2));
        function t(r) {
          return r === 1 || r === 2;
        }
        (a(t, "is"), (e.is = t));
      })(XL || (XL = {}));
      (function (e) {
        function t(n) {
          return { value: n };
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            pt.objectLiteral(i) &&
            (i.tooltip === void 0 ||
              pt.string(i.tooltip) ||
              V1.is(i.tooltip)) &&
            (i.location === void 0 || pS.is(i.location)) &&
            (i.command === void 0 || Qp.is(i.command))
          );
        }
        (a(r, "is"), (e.is = r));
      })(KL || (KL = {}));
      (function (e) {
        function t(n, i, s) {
          let o = { position: n, label: i };
          return (s !== void 0 && (o.kind = s), o);
        }
        (a(t, "create"), (e.create = t));
        function r(n) {
          let i = n;
          return (
            (pt.objectLiteral(i) &&
              gr.is(i.position) &&
              (pt.string(i.label) || pt.typedArray(i.label, KL.is)) &&
              (i.kind === void 0 || XL.is(i.kind)) &&
              i.textEdits === void 0) ||
            (pt.typedArray(i.textEdits, Zp.is) &&
              (i.tooltip === void 0 ||
                pt.string(i.tooltip) ||
                V1.is(i.tooltip)) &&
              (i.paddingLeft === void 0 || pt.boolean(i.paddingLeft)) &&
              (i.paddingRight === void 0 || pt.boolean(i.paddingRight)))
          );
        }
        (a(r, "is"), (e.is = r));
      })(IJ || (IJ = {}));
      (function (e) {
        function t(r) {
          return { kind: "snippet", value: r };
        }
        (a(t, "createSnippet"), (e.createSnippet = t));
      })(MJ || (MJ = {}));
      (function (e) {
        function t(r, n, i, s) {
          return { insertText: r, filterText: n, range: i, command: s };
        }
        (a(t, "create"), (e.create = t));
      })(OJ || (OJ = {}));
      (function (e) {
        function t(r) {
          return { items: r };
        }
        (a(t, "create"), (e.create = t));
      })(PJ || (PJ = {}));
      (function (e) {
        ((e.Invoked = 0), (e.Automatic = 1));
      })(BJ || (BJ = {}));
      (function (e) {
        function t(r, n) {
          return { range: r, text: n };
        }
        (a(t, "create"), (e.create = t));
      })(FJ || (FJ = {}));
      (function (e) {
        function t(r, n) {
          return { triggerKind: r, selectedCompletionInfo: n };
        }
        (a(t, "create"), (e.create = t));
      })($J || ($J = {}));
      (function (e) {
        function t(r) {
          let n = r;
          return pt.objectLiteral(n) && FL.is(n.uri) && pt.string(n.name);
        }
        (a(t, "is"), (e.is = t));
      })(GJ || (GJ = {}));
      (function (e) {
        function t(s, o, l, u) {
          return new QL(s, o, l, u);
        }
        (a(t, "create"), (e.create = t));
        function r(s) {
          let o = s;
          return !!(
            pt.defined(o) &&
            pt.string(o.uri) &&
            (pt.undefined(o.languageId) || pt.string(o.languageId)) &&
            pt.uinteger(o.lineCount) &&
            pt.func(o.getText) &&
            pt.func(o.positionAt) &&
            pt.func(o.offsetAt)
          );
        }
        (a(r, "is"), (e.is = r));
        function n(s, o) {
          let l = s.getText(),
            u = i(o, (f, d) => {
              let p = f.range.start.line - d.range.start.line;
              return p === 0
                ? f.range.start.character - d.range.start.character
                : p;
            }),
            h = l.length;
          for (let f = u.length - 1; f >= 0; f--) {
            let d = u[f],
              p = s.offsetAt(d.range.start),
              m = s.offsetAt(d.range.end);
            if (m <= h)
              l = l.substring(0, p) + d.newText + l.substring(m, l.length);
            else throw new Error("Overlapping edit");
            h = p;
          }
          return l;
        }
        (a(n, "applyEdits"), (e.applyEdits = n));
        function i(s, o) {
          if (s.length <= 1) return s;
          let l = (s.length / 2) | 0,
            u = s.slice(0, l),
            h = s.slice(l);
          (i(u, o), i(h, o));
          let f = 0,
            d = 0,
            p = 0;
          for (; f < u.length && d < h.length; )
            o(u[f], h[d]) <= 0 ? (s[p++] = u[f++]) : (s[p++] = h[d++]);
          for (; f < u.length; ) s[p++] = u[f++];
          for (; d < h.length; ) s[p++] = h[d++];
          return s;
        }
        a(i, "mergeSort");
      })(VJ || (VJ = {}));
      QL = class {
        static {
          a(this, "FullTextDocument");
        }
        constructor(t, r, n, i) {
          ((this._uri = t),
            (this._languageId = r),
            (this._version = n),
            (this._content = i),
            (this._lineOffsets = void 0));
        }
        get uri() {
          return this._uri;
        }
        get languageId() {
          return this._languageId;
        }
        get version() {
          return this._version;
        }
        getText(t) {
          if (t) {
            let r = this.offsetAt(t.start),
              n = this.offsetAt(t.end);
            return this._content.substring(r, n);
          }
          return this._content;
        }
        update(t, r) {
          ((this._content = t.text),
            (this._version = r),
            (this._lineOffsets = void 0));
        }
        getLineOffsets() {
          if (this._lineOffsets === void 0) {
            let t = [],
              r = this._content,
              n = !0;
            for (let i = 0; i < r.length; i++) {
              n && (t.push(i), (n = !1));
              let s = r.charAt(i);
              ((n =
                s === "\r" ||
                s ===
                  `
`),
                s === "\r" &&
                  i + 1 < r.length &&
                  r.charAt(i + 1) ===
                    `
` &&
                  i++);
            }
            (n && r.length > 0 && t.push(r.length), (this._lineOffsets = t));
          }
          return this._lineOffsets;
        }
        positionAt(t) {
          t = Math.max(Math.min(t, this._content.length), 0);
          let r = this.getLineOffsets(),
            n = 0,
            i = r.length;
          if (i === 0) return gr.create(0, t);
          for (; n < i; ) {
            let o = Math.floor((n + i) / 2);
            r[o] > t ? (i = o) : (n = o + 1);
          }
          let s = n - 1;
          return gr.create(s, t - r[s]);
        }
        offsetAt(t) {
          let r = this.getLineOffsets();
          if (t.line >= r.length) return this._content.length;
          if (t.line < 0) return 0;
          let n = r[t.line],
            i = t.line + 1 < r.length ? r[t.line + 1] : this._content.length;
          return Math.max(Math.min(n + t.character, i), n);
        }
        get lineCount() {
          return this.getLineOffsets().length;
        }
      };
      (function (e) {
        let t = Object.prototype.toString;
        function r(m) {
          return typeof m < "u";
        }
        (a(r, "defined"), (e.defined = r));
        function n(m) {
          return typeof m > "u";
        }
        (a(n, "undefined"), (e.undefined = n));
        function i(m) {
          return m === !0 || m === !1;
        }
        (a(i, "boolean"), (e.boolean = i));
        function s(m) {
          return t.call(m) === "[object String]";
        }
        (a(s, "string"), (e.string = s));
        function o(m) {
          return t.call(m) === "[object Number]";
        }
        (a(o, "number"), (e.number = o));
        function l(m, g, y) {
          return t.call(m) === "[object Number]" && g <= m && m <= y;
        }
        (a(l, "numberRange"), (e.numberRange = l));
        function u(m) {
          return (
            t.call(m) === "[object Number]" &&
            -2147483648 <= m &&
            m <= 2147483647
          );
        }
        (a(u, "integer"), (e.integer = u));
        function h(m) {
          return t.call(m) === "[object Number]" && 0 <= m && m <= 2147483647;
        }
        (a(h, "uinteger"), (e.uinteger = h));
        function f(m) {
          return t.call(m) === "[object Function]";
        }
        (a(f, "func"), (e.func = f));
        function d(m) {
          return m !== null && typeof m == "object";
        }
        (a(d, "objectLiteral"), (e.objectLiteral = d));
        function p(m, g) {
          return Array.isArray(m) && m.every(g);
        }
        (a(p, "typedArray"), (e.typedArray = p));
      })(pt || (pt = {}));
    });
  var z1,
    W1,
    Ph,
    Bh,
    JL,
    tm,
    xS = x(() => {
      "use strict";
      ZL();
      Ua();
      ((z1 = class {
        static {
          a(this, "CstNodeBuilder");
        }
        constructor() {
          this.nodeStack = [];
        }
        get current() {
          var t;
          return (t = this.nodeStack[this.nodeStack.length - 1]) !== null &&
            t !== void 0
            ? t
            : this.rootNode;
        }
        buildRootNode(t) {
          return (
            (this.rootNode = new tm(t)),
            (this.rootNode.root = this.rootNode),
            (this.nodeStack = [this.rootNode]),
            this.rootNode
          );
        }
        buildCompositeNode(t) {
          let r = new Bh();
          return (
            (r.grammarSource = t),
            (r.root = this.rootNode),
            this.current.content.push(r),
            this.nodeStack.push(r),
            r
          );
        }
        buildLeafNode(t, r) {
          let n = new Ph(t.startOffset, t.image.length, Pd(t), t.tokenType, !r);
          return (
            (n.grammarSource = r),
            (n.root = this.rootNode),
            this.current.content.push(n),
            n
          );
        }
        removeNode(t) {
          let r = t.container;
          if (r) {
            let n = r.content.indexOf(t);
            n >= 0 && r.content.splice(n, 1);
          }
        }
        addHiddenNodes(t) {
          let r = [];
          for (let s of t) {
            let o = new Ph(
              s.startOffset,
              s.image.length,
              Pd(s),
              s.tokenType,
              !0,
            );
            ((o.root = this.rootNode), r.push(o));
          }
          let n = this.current,
            i = !1;
          if (n.content.length > 0) {
            n.content.push(...r);
            return;
          }
          for (; n.container; ) {
            let s = n.container.content.indexOf(n);
            if (s > 0) {
              (n.container.content.splice(s, 0, ...r), (i = !0));
              break;
            }
            n = n.container;
          }
          i || this.rootNode.content.unshift(...r);
        }
        construct(t) {
          let r = this.current;
          (typeof t.$type == "string" && (this.current.astNode = t),
            (t.$cstNode = r));
          let n = this.nodeStack.pop();
          n?.content.length === 0 && this.removeNode(n);
        }
      }),
        (W1 = class {
          static {
            a(this, "AbstractCstNode");
          }
          get parent() {
            return this.container;
          }
          get feature() {
            return this.grammarSource;
          }
          get hidden() {
            return !1;
          }
          get astNode() {
            var t, r;
            let n =
              typeof ((t = this._astNode) === null || t === void 0
                ? void 0
                : t.$type) == "string"
                ? this._astNode
                : (r = this.container) === null || r === void 0
                  ? void 0
                  : r.astNode;
            if (!n) throw new Error("This node has no associated AST element");
            return n;
          }
          set astNode(t) {
            this._astNode = t;
          }
          get element() {
            return this.astNode;
          }
          get text() {
            return this.root.fullText.substring(this.offset, this.end);
          }
        }),
        (Ph = class extends W1 {
          static {
            a(this, "LeafCstNodeImpl");
          }
          get offset() {
            return this._offset;
          }
          get length() {
            return this._length;
          }
          get end() {
            return this._offset + this._length;
          }
          get hidden() {
            return this._hidden;
          }
          get tokenType() {
            return this._tokenType;
          }
          get range() {
            return this._range;
          }
          constructor(t, r, n, i, s = !1) {
            (super(),
              (this._hidden = s),
              (this._offset = t),
              (this._tokenType = i),
              (this._length = r),
              (this._range = n));
          }
        }),
        (Bh = class extends W1 {
          static {
            a(this, "CompositeCstNodeImpl");
          }
          constructor() {
            (super(...arguments), (this.content = new JL(this)));
          }
          get children() {
            return this.content;
          }
          get offset() {
            var t, r;
            return (r =
              (t = this.firstNonHiddenNode) === null || t === void 0
                ? void 0
                : t.offset) !== null && r !== void 0
              ? r
              : 0;
          }
          get length() {
            return this.end - this.offset;
          }
          get end() {
            var t, r;
            return (r =
              (t = this.lastNonHiddenNode) === null || t === void 0
                ? void 0
                : t.end) !== null && r !== void 0
              ? r
              : 0;
          }
          get range() {
            let t = this.firstNonHiddenNode,
              r = this.lastNonHiddenNode;
            if (t && r) {
              if (this._rangeCache === void 0) {
                let { range: n } = t,
                  { range: i } = r;
                this._rangeCache = {
                  start: n.start,
                  end: i.end.line < n.start.line ? n.start : i.end,
                };
              }
              return this._rangeCache;
            } else return { start: gr.create(0, 0), end: gr.create(0, 0) };
          }
          get firstNonHiddenNode() {
            for (let t of this.content) if (!t.hidden) return t;
            return this.content[0];
          }
          get lastNonHiddenNode() {
            for (let t = this.content.length - 1; t >= 0; t--) {
              let r = this.content[t];
              if (!r.hidden) return r;
            }
            return this.content[this.content.length - 1];
          }
        }),
        (JL = class e extends Array {
          static {
            a(this, "CstNodeContainer");
          }
          constructor(t) {
            (super(),
              (this.parent = t),
              Object.setPrototypeOf(this, e.prototype));
          }
          push(...t) {
            return (this.addParents(t), super.push(...t));
          }
          unshift(...t) {
            return (this.addParents(t), super.unshift(...t));
          }
          splice(t, r, ...n) {
            return (this.addParents(n), super.splice(t, r, ...n));
          }
          addParents(t) {
            for (let r of t) r.container = this.parent;
          }
        }),
        (tm = class extends Bh {
          static {
            a(this, "RootCstNodeImpl");
          }
          get text() {
            return this._text.substring(this.offset, this.end);
          }
          get fullText() {
            return this._text;
          }
          constructor(t) {
            (super(), (this._text = ""), (this._text = t ?? ""));
          }
        }));
    });
  function tR(e) {
    return e.$type === bS;
  }
  var bS,
    zJ,
    WJ,
    U1,
    j1,
    kS,
    em,
    q1,
    xAt,
    eR,
    H1 = x(() => {
      "use strict";
      qc();
      GZ();
      Bo();
      Ha();
      Vi();
      xS();
      bS = Symbol("Datatype");
      a(tR, "isDataTypeNode");
      ((zJ = "\u200B"),
        (WJ = a((e) => (e.endsWith(zJ) ? e : e + zJ), "withRuleSuffix")),
        (U1 = class {
          static {
            a(this, "AbstractLangiumParser");
          }
          constructor(t) {
            ((this._unorderedGroups = new Map()),
              (this.allRules = new Map()),
              (this.lexer = t.parser.Lexer));
            let r = this.lexer.definition,
              n = t.LanguageMetaData.mode === "production";
            this.wrapper = new eR(
              r,
              Object.assign(Object.assign({}, t.parser.ParserConfig), {
                skipValidations: n,
                errorMessageProvider: t.parser.ParserErrorMessageProvider,
              }),
            );
          }
          alternatives(t, r) {
            this.wrapper.wrapOr(t, r);
          }
          optional(t, r) {
            this.wrapper.wrapOption(t, r);
          }
          many(t, r) {
            this.wrapper.wrapMany(t, r);
          }
          atLeastOne(t, r) {
            this.wrapper.wrapAtLeastOne(t, r);
          }
          getRule(t) {
            return this.allRules.get(t);
          }
          isRecording() {
            return this.wrapper.IS_RECORDING;
          }
          get unorderedGroups() {
            return this._unorderedGroups;
          }
          getRuleStack() {
            return this.wrapper.RULE_STACK;
          }
          finalize() {
            this.wrapper.wrapSelfAnalysis();
          }
        }),
        (j1 = class extends U1 {
          static {
            a(this, "LangiumParser");
          }
          get current() {
            return this.stack[this.stack.length - 1];
          }
          constructor(t) {
            (super(t),
              (this.nodeBuilder = new z1()),
              (this.stack = []),
              (this.assignmentMap = new Map()),
              (this.linker = t.references.Linker),
              (this.converter = t.parser.ValueConverter),
              (this.astReflection = t.shared.AstReflection));
          }
          rule(t, r) {
            let n = this.computeRuleType(t),
              i = this.wrapper.DEFINE_RULE(
                WJ(t.name),
                this.startImplementation(n, r).bind(this),
              );
            return (
              this.allRules.set(t.name, i),
              t.entry && (this.mainRule = i),
              i
            );
          }
          computeRuleType(t) {
            if (!t.fragment) {
              if (m1(t)) return bS;
              {
                let r = vp(t);
                return r ?? t.name;
              }
            }
          }
          parse(t, r = {}) {
            this.nodeBuilder.buildRootNode(t);
            let n = (this.lexerResult = this.lexer.tokenize(t));
            this.wrapper.input = n.tokens;
            let i = r.rule ? this.allRules.get(r.rule) : this.mainRule;
            if (!i)
              throw new Error(
                r.rule
                  ? `No rule found with name '${r.rule}'`
                  : "No main rule available.",
              );
            let s = i.call(this.wrapper, {});
            return (
              this.nodeBuilder.addHiddenNodes(n.hidden),
              this.unorderedGroups.clear(),
              (this.lexerResult = void 0),
              {
                value: s,
                lexerErrors: n.errors,
                lexerReport: n.report,
                parserErrors: this.wrapper.errors,
              }
            );
          }
          startImplementation(t, r) {
            return (n) => {
              let i = !this.isRecording() && t !== void 0;
              if (i) {
                let o = { $type: t };
                (this.stack.push(o), t === bS && (o.value = ""));
              }
              let s;
              try {
                s = r(n);
              } catch {
                s = void 0;
              }
              return (s === void 0 && i && (s = this.construct()), s);
            };
          }
          extractHiddenTokens(t) {
            let r = this.lexerResult.hidden;
            if (!r.length) return [];
            let n = t.startOffset;
            for (let i = 0; i < r.length; i++)
              if (r[i].startOffset > n) return r.splice(0, i);
            return r.splice(0, r.length);
          }
          consume(t, r, n) {
            let i = this.wrapper.wrapConsume(t, r);
            if (!this.isRecording() && this.isValidToken(i)) {
              let s = this.extractHiddenTokens(i);
              this.nodeBuilder.addHiddenNodes(s);
              let o = this.nodeBuilder.buildLeafNode(i, n),
                { assignment: l, isCrossRef: u } = this.getAssignment(n),
                h = this.current;
              if (l) {
                let f = ca(n) ? i.image : this.converter.convert(i.image, o);
                this.assign(l.operator, l.feature, f, o, u);
              } else if (tR(h)) {
                let f = i.image;
                (ca(n) || (f = this.converter.convert(f, o).toString()),
                  (h.value += f));
              }
            }
          }
          isValidToken(t) {
            return (
              !t.isInsertedInRecovery &&
              !isNaN(t.startOffset) &&
              typeof t.endOffset == "number" &&
              !isNaN(t.endOffset)
            );
          }
          subrule(t, r, n, i, s) {
            let o;
            !this.isRecording() &&
              !n &&
              (o = this.nodeBuilder.buildCompositeNode(i));
            let l = this.wrapper.wrapSubrule(t, r, s);
            !this.isRecording() &&
              o &&
              o.length > 0 &&
              this.performSubruleAssignment(l, i, o);
          }
          performSubruleAssignment(t, r, n) {
            let { assignment: i, isCrossRef: s } = this.getAssignment(r);
            if (i) this.assign(i.operator, i.feature, t, n, s);
            else if (!i) {
              let o = this.current;
              if (tR(o)) o.value += t.toString();
              else if (typeof t == "object" && t) {
                let u = this.assignWithoutOverride(t, o);
                (this.stack.pop(), this.stack.push(u));
              }
            }
          }
          action(t, r) {
            if (!this.isRecording()) {
              let n = this.current;
              if (r.feature && r.operator) {
                ((n = this.construct()),
                  this.nodeBuilder.removeNode(n.$cstNode),
                  this.nodeBuilder
                    .buildCompositeNode(r)
                    .content.push(n.$cstNode));
                let s = { $type: t };
                (this.stack.push(s),
                  this.assign(r.operator, r.feature, n, n.$cstNode, !1));
              } else n.$type = t;
            }
          }
          construct() {
            if (this.isRecording()) return;
            let t = this.current;
            return (
              kT(t),
              this.nodeBuilder.construct(t),
              this.stack.pop(),
              tR(t)
                ? this.converter.convert(t.value, t.$cstNode)
                : (D6(this.astReflection, t), t)
            );
          }
          getAssignment(t) {
            if (!this.assignmentMap.has(t)) {
              let r = _h(t, ja);
              this.assignmentMap.set(t, {
                assignment: r,
                isCrossRef: r ? Sh(r.terminal) : !1,
              });
            }
            return this.assignmentMap.get(t);
          }
          assign(t, r, n, i, s) {
            let o = this.current,
              l;
            switch (
              (s && typeof n == "string"
                ? (l = this.linker.buildReference(o, r, i, n))
                : (l = n),
              t)
            ) {
              case "=": {
                o[r] = l;
                break;
              }
              case "?=": {
                o[r] = !0;
                break;
              }
              case "+=":
                (Array.isArray(o[r]) || (o[r] = []), o[r].push(l));
            }
          }
          assignWithoutOverride(t, r) {
            for (let [i, s] of Object.entries(r)) {
              let o = t[i];
              o === void 0
                ? (t[i] = s)
                : Array.isArray(o) &&
                  Array.isArray(s) &&
                  (s.push(...o), (t[i] = s));
            }
            let n = t.$cstNode;
            return (n && ((n.astNode = void 0), (t.$cstNode = void 0)), t);
          }
          get definitionErrors() {
            return this.wrapper.definitionErrors;
          }
        }),
        (kS = class {
          static {
            a(this, "AbstractParserErrorMessageProvider");
          }
          buildMismatchTokenMessage(t) {
            return Rl.buildMismatchTokenMessage(t);
          }
          buildNotAllInputParsedMessage(t) {
            return Rl.buildNotAllInputParsedMessage(t);
          }
          buildNoViableAltMessage(t) {
            return Rl.buildNoViableAltMessage(t);
          }
          buildEarlyExitMessage(t) {
            return Rl.buildEarlyExitMessage(t);
          }
        }),
        (em = class extends kS {
          static {
            a(this, "LangiumParserErrorMessageProvider");
          }
          buildMismatchTokenMessage({ expected: t, actual: r }) {
            return `Expecting ${t.LABEL ? "`" + t.LABEL + "`" : t.name.endsWith(":KW") ? `keyword '${t.name.substring(0, t.name.length - 3)}'` : `token of type '${t.name}'`} but found \`${r.image}\`.`;
          }
          buildNotAllInputParsedMessage({ firstRedundant: t }) {
            return `Expecting end of file but found \`${t.image}\`.`;
          }
        }),
        (q1 = class extends U1 {
          static {
            a(this, "LangiumCompletionParser");
          }
          constructor() {
            (super(...arguments),
              (this.tokens = []),
              (this.elementStack = []),
              (this.lastElementStack = []),
              (this.nextTokenIndex = 0),
              (this.stackSize = 0));
          }
          action() {}
          construct() {}
          parse(t) {
            this.resetState();
            let r = this.lexer.tokenize(t, { mode: "partial" });
            return (
              (this.tokens = r.tokens),
              (this.wrapper.input = [...this.tokens]),
              this.mainRule.call(this.wrapper, {}),
              this.unorderedGroups.clear(),
              {
                tokens: this.tokens,
                elementStack: [...this.lastElementStack],
                tokenIndex: this.nextTokenIndex,
              }
            );
          }
          rule(t, r) {
            let n = this.wrapper.DEFINE_RULE(
              WJ(t.name),
              this.startImplementation(r).bind(this),
            );
            return (
              this.allRules.set(t.name, n),
              t.entry && (this.mainRule = n),
              n
            );
          }
          resetState() {
            ((this.elementStack = []),
              (this.lastElementStack = []),
              (this.nextTokenIndex = 0),
              (this.stackSize = 0));
          }
          startImplementation(t) {
            return (r) => {
              let n = this.keepStackSize();
              try {
                t(r);
              } finally {
                this.resetStackSize(n);
              }
            };
          }
          removeUnexpectedElements() {
            this.elementStack.splice(this.stackSize);
          }
          keepStackSize() {
            let t = this.elementStack.length;
            return ((this.stackSize = t), t);
          }
          resetStackSize(t) {
            (this.removeUnexpectedElements(), (this.stackSize = t));
          }
          consume(t, r, n) {
            (this.wrapper.wrapConsume(t, r),
              this.isRecording() ||
                ((this.lastElementStack = [...this.elementStack, n]),
                (this.nextTokenIndex = this.currIdx + 1)));
          }
          subrule(t, r, n, i, s) {
            (this.before(i), this.wrapper.wrapSubrule(t, r, s), this.after(i));
          }
          before(t) {
            this.isRecording() || this.elementStack.push(t);
          }
          after(t) {
            if (!this.isRecording()) {
              let r = this.elementStack.lastIndexOf(t);
              r >= 0 && this.elementStack.splice(r);
            }
          }
          get currIdx() {
            return this.wrapper.currIdx;
          }
        }),
        (xAt = {
          recoveryEnabled: !0,
          nodeLocationTracking: "full",
          skipValidations: !0,
          errorMessageProvider: new em(),
        }),
        (eR = class extends P1 {
          static {
            a(this, "ChevrotainWrapper");
          }
          constructor(t, r) {
            let n = r && "maxLookahead" in r;
            super(
              t,
              Object.assign(
                Object.assign(Object.assign({}, xAt), {
                  lookaheadStrategy: n
                    ? new Dl({ maxLookahead: r.maxLookahead })
                    : new G1({
                        logging: r.skipValidations ? () => {} : void 0,
                      }),
                }),
                r,
              ),
            );
          }
          get IS_RECORDING() {
            return this.RECORDING_PHASE;
          }
          DEFINE_RULE(t, r) {
            return this.RULE(t, r);
          }
          wrapSelfAnalysis() {
            this.performSelfAnalysis();
          }
          wrapConsume(t, r) {
            return this.consume(t, r);
          }
          wrapSubrule(t, r, n) {
            return this.subrule(t, r, { ARGS: [n] });
          }
          wrapOr(t, r) {
            this.or(t, r);
          }
          wrapOption(t, r) {
            this.option(t, r);
          }
          wrapMany(t, r) {
            this.many(t, r);
          }
          wrapAtLeastOne(t, r) {
            this.atLeastOne(t, r);
          }
        }));
    });
  function Y1(e, t, r) {
    return (bAt({ parser: t, tokens: r, ruleNames: new Map() }, e), t);
  }
  function bAt(e, t) {
    let r = d1(t, !1),
      n = kr(t.rules)
        .filter(Ti)
        .filter((i) => r.has(i));
    for (let i of n) {
      let s = Object.assign(Object.assign({}, e), {
        consume: 1,
        optional: 1,
        subrule: 1,
        many: 1,
        or: 1,
      });
      e.parser.rule(i, Fh(s, i.definition));
    }
  }
  function Fh(e, t, r = !1) {
    let n;
    if (ca(t)) n = vAt(e, t);
    else if (_l(t)) n = kAt(e, t);
    else if (ja(t)) n = Fh(e, t.terminal);
    else if (Sh(t)) n = UJ(e, t);
    else if (qa(t)) n = TAt(e, t);
    else if (yT(t)) n = _At(e, t);
    else if (bT(t)) n = CAt(e, t);
    else if (Wc(t)) n = wAt(e, t);
    else if (S6(t)) {
      let i = e.consume++;
      n = a(() => e.parser.consume(i, Os, t), "method");
    } else throw new kh(t.$cstNode, `Unexpected element type: ${t.$type}`);
    return jJ(e, r ? void 0 : TS(t), n, t.cardinality);
  }
  function kAt(e, t) {
    let r = g1(t);
    return () => e.parser.action(r, t);
  }
  function TAt(e, t) {
    let r = t.rule.ref;
    if (Ti(r)) {
      let n = e.subrule++,
        i = r.fragment,
        s = t.arguments.length > 0 ? SAt(r, t.arguments) : () => ({});
      return (o) => e.parser.subrule(n, qJ(e, r), i, t, s(o));
    } else if (Is(r)) {
      let n = e.consume++,
        i = rR(e, r.name);
      return () => e.parser.consume(n, i, t);
    } else if (r) Po(r);
    else throw new kh(t.$cstNode, `Undefined rule: ${t.rule.$refText}`);
  }
  function SAt(e, t) {
    let r = t.map((n) => Nl(n.value));
    return (n) => {
      let i = {};
      for (let s = 0; s < r.length; s++) {
        let o = e.parameters[s],
          l = r[s];
        i[o.name] = l(n);
      }
      return i;
    };
  }
  function Nl(e) {
    if (m6(e)) {
      let t = Nl(e.left),
        r = Nl(e.right);
      return (n) => t(n) || r(n);
    } else if (p6(e)) {
      let t = Nl(e.left),
        r = Nl(e.right);
      return (n) => t(n) && r(n);
    } else if (g6(e)) {
      let t = Nl(e.value);
      return (r) => !t(r);
    } else if (y6(e)) {
      let t = e.parameter.ref.name;
      return (r) => r !== void 0 && r[t] === !0;
    } else if (d6(e)) {
      let t = !!e.true;
      return () => t;
    }
    Po(e);
  }
  function _At(e, t) {
    if (t.elements.length === 1) return Fh(e, t.elements[0]);
    {
      let r = [];
      for (let i of t.elements) {
        let s = { ALT: Fh(e, i, !0) },
          o = TS(i);
        (o && (s.GATE = Nl(o)), r.push(s));
      }
      let n = e.or++;
      return (i) =>
        e.parser.alternatives(
          n,
          r.map((s) => {
            let o = { ALT: a(() => s.ALT(i), "ALT") },
              l = s.GATE;
            return (l && (o.GATE = () => l(i)), o);
          }),
        );
    }
  }
  function CAt(e, t) {
    if (t.elements.length === 1) return Fh(e, t.elements[0]);
    let r = [];
    for (let l of t.elements) {
      let u = { ALT: Fh(e, l, !0) },
        h = TS(l);
      (h && (u.GATE = Nl(h)), r.push(u));
    }
    let n = e.or++,
      i = a((l, u) => {
        let h = u.getRuleStack().join("-");
        return `uGroup_${l}_${h}`;
      }, "idFunc"),
      s = a(
        (l) =>
          e.parser.alternatives(
            n,
            r.map((u, h) => {
              let f = { ALT: a(() => !0, "ALT") },
                d = e.parser;
              f.ALT = () => {
                if ((u.ALT(l), !d.isRecording())) {
                  let m = i(n, d);
                  d.unorderedGroups.get(m) || d.unorderedGroups.set(m, []);
                  let g = d.unorderedGroups.get(m);
                  typeof g?.[h] > "u" && (g[h] = !0);
                }
              };
              let p = u.GATE;
              return (
                p
                  ? (f.GATE = () => p(l))
                  : (f.GATE = () => {
                      let m = d.unorderedGroups.get(i(n, d));
                      return !m?.[h];
                    }),
                f
              );
            }),
          ),
        "alternatives",
      ),
      o = jJ(e, TS(t), s, "*");
    return (l) => {
      (o(l),
        e.parser.isRecording() ||
          e.parser.unorderedGroups.delete(i(n, e.parser)));
    };
  }
  function wAt(e, t) {
    let r = t.elements.map((n) => Fh(e, n));
    return (n) => r.forEach((i) => i(n));
  }
  function TS(e) {
    if (Wc(e)) return e.guardCondition;
  }
  function UJ(e, t, r = t.terminal) {
    if (r)
      if (qa(r) && Ti(r.rule.ref)) {
        let n = r.rule.ref,
          i = e.subrule++;
        return (s) => e.parser.subrule(i, qJ(e, n), !1, t, s);
      } else if (qa(r) && Is(r.rule.ref)) {
        let n = e.consume++,
          i = rR(e, r.rule.ref.name);
        return () => e.parser.consume(n, i, t);
      } else if (ca(r)) {
        let n = e.consume++,
          i = rR(e, r.value);
        return () => e.parser.consume(n, i, t);
      } else throw new Error("Could not build cross reference parser");
    else {
      if (!t.type.ref)
        throw new Error(
          "Could not resolve reference to type: " + t.type.$refText,
        );
      let n = wT(t.type.ref),
        i = n?.terminal;
      if (!i)
        throw new Error(
          "Could not find name assignment for type: " + g1(t.type.ref),
        );
      return UJ(e, t, i);
    }
  }
  function vAt(e, t) {
    let r = e.consume++,
      n = e.tokens[t.value];
    if (!n) throw new Error("Could not find token for keyword: " + t.value);
    return () => e.parser.consume(r, n, t);
  }
  function jJ(e, t, r, n) {
    let i = t && Nl(t);
    if (!n)
      if (i) {
        let s = e.or++;
        return (o) =>
          e.parser.alternatives(s, [
            { ALT: a(() => r(o), "ALT"), GATE: a(() => i(o), "GATE") },
            { ALT: uS(), GATE: a(() => !i(o), "GATE") },
          ]);
      } else return r;
    if (n === "*") {
      let s = e.many++;
      return (o) =>
        e.parser.many(s, {
          DEF: a(() => r(o), "DEF"),
          GATE: i ? () => i(o) : void 0,
        });
    } else if (n === "+") {
      let s = e.many++;
      if (i) {
        let o = e.or++;
        return (l) =>
          e.parser.alternatives(o, [
            {
              ALT: a(
                () => e.parser.atLeastOne(s, { DEF: a(() => r(l), "DEF") }),
                "ALT",
              ),
              GATE: a(() => i(l), "GATE"),
            },
            { ALT: uS(), GATE: a(() => !i(l), "GATE") },
          ]);
      } else
        return (o) => e.parser.atLeastOne(s, { DEF: a(() => r(o), "DEF") });
    } else if (n === "?") {
      let s = e.optional++;
      return (o) =>
        e.parser.optional(s, {
          DEF: a(() => r(o), "DEF"),
          GATE: i ? () => i(o) : void 0,
        });
    } else Po(n);
  }
  function qJ(e, t) {
    let r = EAt(e, t),
      n = e.parser.getRule(r);
    if (!n) throw new Error(`Rule "${r}" not found."`);
    return n;
  }
  function EAt(e, t) {
    if (Ti(t)) return t.name;
    if (e.ruleNames.has(t)) return e.ruleNames.get(t);
    {
      let r = t,
        n = r.$container,
        i = t.$type;
      for (; !Ti(n); )
        ((Wc(n) || yT(n) || bT(n)) &&
          (i = n.elements.indexOf(r).toString() + ":" + i),
          (r = n),
          (n = n.$container));
      return ((i = n.name + ":" + i), e.ruleNames.set(t, i), i);
    }
  }
  function rR(e, t) {
    let r = e.tokens[t];
    if (!r) throw new Error(`Token "${t}" not found."`);
    return r;
  }
  var SS = x(() => {
    "use strict";
    qc();
    Bo();
    fT();
    ms();
    Ha();
    a(Y1, "createParser");
    a(bAt, "buildRules");
    a(Fh, "buildElement");
    a(kAt, "buildAction");
    a(TAt, "buildRuleCall");
    a(SAt, "buildRuleCallPredicate");
    a(Nl, "buildPredicate");
    a(_At, "buildAlternatives");
    a(CAt, "buildUnorderedGroup");
    a(wAt, "buildGroup");
    a(TS, "getGuardCondition");
    a(UJ, "buildCrossReference");
    a(vAt, "buildKeyword");
    a(jJ, "wrap");
    a(qJ, "getRule");
    a(EAt, "getRuleName");
    a(rR, "getToken");
  });
  function nR(e) {
    let t = e.Grammar,
      r = e.parser.Lexer,
      n = new q1(e);
    return (Y1(t, n, r.definition), n.finalize(), n);
  }
  var iR = x(() => {
    "use strict";
    H1();
    SS();
    a(nR, "createCompletionParser");
  });
  function sR(e) {
    let t = HJ(e);
    return (t.finalize(), t);
  }
  function HJ(e) {
    let t = e.Grammar,
      r = e.parser.Lexer,
      n = new j1(e);
    return Y1(t, n, r.definition);
  }
  var aR = x(() => {
    "use strict";
    H1();
    SS();
    a(sR, "createLangiumParser");
    a(HJ, "prepareLangiumParser");
  });
  var Il,
    _S = x(() => {
      "use strict";
      qc();
      Bo();
      Vi();
      Ha();
      wp();
      ms();
      Il = class {
        static {
          a(this, "DefaultTokenBuilder");
        }
        constructor() {
          this.diagnostics = [];
        }
        buildTokens(t, r) {
          let n = kr(d1(t, !1)),
            i = this.buildTerminalTokens(n),
            s = this.buildKeywordTokens(n, i, r);
          return (
            i.forEach((o) => {
              let l = o.PATTERN;
              typeof l == "object" && l && "test" in l && Cp(l)
                ? s.unshift(o)
                : s.push(o);
            }),
            s
          );
        }
        flushLexingReport(t) {
          return { diagnostics: this.popDiagnostics() };
        }
        popDiagnostics() {
          let t = [...this.diagnostics];
          return ((this.diagnostics = []), t);
        }
        buildTerminalTokens(t) {
          return t
            .filter(Is)
            .filter((r) => !r.fragment)
            .map((r) => this.buildTerminalToken(r))
            .toArray();
        }
        buildTerminalToken(t) {
          let r = Ep(t),
            n = this.requiresCustomPattern(r)
              ? this.regexPatternFunction(r)
              : r,
            i = { name: t.name, PATTERN: n };
          return (
            typeof n == "function" && (i.LINE_BREAKS = !0),
            t.hidden && (i.GROUP = Cp(r) ? tn.SKIPPED : "hidden"),
            i
          );
        }
        requiresCustomPattern(t) {
          return t.flags.includes("u") || t.flags.includes("s")
            ? !0
            : !!(t.source.includes("?<=") || t.source.includes("?<!"));
        }
        regexPatternFunction(t) {
          let r = new RegExp(t, t.flags + "y");
          return (n, i) => ((r.lastIndex = i), r.exec(n));
        }
        buildKeywordTokens(t, r, n) {
          return t
            .filter(Ti)
            .flatMap((i) => Fo(i).filter(ca))
            .distinct((i) => i.value)
            .toArray()
            .sort((i, s) => s.value.length - i.value.length)
            .map((i) => this.buildKeywordToken(i, r, !!n?.caseInsensitive));
        }
        buildKeywordToken(t, r, n) {
          let i = this.buildKeywordPattern(t, n),
            s = {
              name: t.value,
              PATTERN: i,
              LONGER_ALT: this.findLongerAlt(t, r),
            };
          return (typeof i == "function" && (s.LINE_BREAKS = !0), s);
        }
        buildKeywordPattern(t, r) {
          return r ? new RegExp(F6(t.value)) : t.value;
        }
        findLongerAlt(t, r) {
          return r.reduce((n, i) => {
            let s = i?.PATTERN;
            return (
              s?.source && $6("^" + s.source + "$", t.value) && n.push(i),
              n
            );
          }, []);
        }
      };
    });
  var $h,
    Vo,
    oR = x(() => {
      "use strict";
      Bo();
      Ha();
      $h = class {
        static {
          a(this, "DefaultValueConverter");
        }
        convert(t, r) {
          let n = r.grammarSource;
          if ((Sh(n) && (n = z6(n)), qa(n))) {
            let i = n.rule.ref;
            if (!i) throw new Error("This cst node was not parsed by a rule.");
            return this.runConverter(i, t, r);
          }
          return t;
        }
        runConverter(t, r, n) {
          var i;
          switch (t.name.toUpperCase()) {
            case "INT":
              return Vo.convertInt(r);
            case "STRING":
              return Vo.convertString(r);
            case "ID":
              return Vo.convertID(r);
          }
          switch (
            (i = X6(t)) === null || i === void 0 ? void 0 : i.toLowerCase()
          ) {
            case "number":
              return Vo.convertNumber(r);
            case "boolean":
              return Vo.convertBoolean(r);
            case "bigint":
              return Vo.convertBigint(r);
            case "date":
              return Vo.convertDate(r);
            default:
              return r;
          }
        }
      };
      (function (e) {
        function t(h) {
          let f = "";
          for (let d = 1; d < h.length - 1; d++) {
            let p = h.charAt(d);
            if (p === "\\") {
              let m = h.charAt(++d);
              f += r(m);
            } else f += p;
          }
          return f;
        }
        (a(t, "convertString"), (e.convertString = t));
        function r(h) {
          switch (h) {
            case "b":
              return "\b";
            case "f":
              return "\f";
            case "n":
              return `
`;
            case "r":
              return "\r";
            case "t":
              return "	";
            case "v":
              return "\v";
            case "0":
              return "\0";
            default:
              return h;
          }
        }
        a(r, "convertEscapeCharacter");
        function n(h) {
          return h.charAt(0) === "^" ? h.substring(1) : h;
        }
        (a(n, "convertID"), (e.convertID = n));
        function i(h) {
          return parseInt(h);
        }
        (a(i, "convertInt"), (e.convertInt = i));
        function s(h) {
          return BigInt(h);
        }
        (a(s, "convertBigint"), (e.convertBigint = s));
        function o(h) {
          return new Date(h);
        }
        (a(o, "convertDate"), (e.convertDate = o));
        function l(h) {
          return Number(h);
        }
        (a(l, "convertNumber"), (e.convertNumber = l));
        function u(h) {
          return h.toLowerCase() === "true";
        }
        (a(u, "convertBoolean"), (e.convertBoolean = u));
      })(Vo || (Vo = {}));
    });
  var hR = to((uR) => {
    "use strict";
    Object.defineProperty(uR, "__esModule", { value: !0 });
    var lR;
    function cR() {
      if (lR === void 0)
        throw new Error("No runtime abstraction layer installed");
      return lR;
    }
    a(cR, "RAL");
    (function (e) {
      function t(r) {
        if (r === void 0)
          throw new Error("No runtime abstraction layer provided");
        lR = r;
      }
      (a(t, "install"), (e.install = t));
    })(cR || (cR = {}));
    uR.default = cR;
  });
  var KJ = to((_i) => {
    "use strict";
    Object.defineProperty(_i, "__esModule", { value: !0 });
    _i.stringArray =
      _i.array =
      _i.func =
      _i.error =
      _i.number =
      _i.string =
      _i.boolean =
        void 0;
    function AAt(e) {
      return e === !0 || e === !1;
    }
    a(AAt, "boolean");
    _i.boolean = AAt;
    function YJ(e) {
      return typeof e == "string" || e instanceof String;
    }
    a(YJ, "string");
    _i.string = YJ;
    function LAt(e) {
      return typeof e == "number" || e instanceof Number;
    }
    a(LAt, "number");
    _i.number = LAt;
    function RAt(e) {
      return e instanceof Error;
    }
    a(RAt, "error");
    _i.error = RAt;
    function DAt(e) {
      return typeof e == "function";
    }
    a(DAt, "func");
    _i.func = DAt;
    function XJ(e) {
      return Array.isArray(e);
    }
    a(XJ, "array");
    _i.array = XJ;
    function NAt(e) {
      return XJ(e) && e.every((t) => YJ(t));
    }
    a(NAt, "stringArray");
    _i.stringArray = NAt;
  });
  var dR = to((rm) => {
    "use strict";
    Object.defineProperty(rm, "__esModule", { value: !0 });
    rm.Emitter = rm.Event = void 0;
    var IAt = hR(),
      QJ;
    (function (e) {
      let t = { dispose() {} };
      e.None = function () {
        return t;
      };
    })(QJ || (rm.Event = QJ = {}));
    var fR = class {
        static {
          a(this, "CallbackList");
        }
        add(t, r = null, n) {
          (this._callbacks || ((this._callbacks = []), (this._contexts = [])),
            this._callbacks.push(t),
            this._contexts.push(r),
            Array.isArray(n) &&
              n.push({ dispose: a(() => this.remove(t, r), "dispose") }));
        }
        remove(t, r = null) {
          if (!this._callbacks) return;
          let n = !1;
          for (let i = 0, s = this._callbacks.length; i < s; i++)
            if (this._callbacks[i] === t)
              if (this._contexts[i] === r) {
                (this._callbacks.splice(i, 1), this._contexts.splice(i, 1));
                return;
              } else n = !0;
          if (n)
            throw new Error(
              "When adding a listener with a context, you should remove it with the same context",
            );
        }
        invoke(...t) {
          if (!this._callbacks) return [];
          let r = [],
            n = this._callbacks.slice(0),
            i = this._contexts.slice(0);
          for (let s = 0, o = n.length; s < o; s++)
            try {
              r.push(n[s].apply(i[s], t));
            } catch (l) {
              (0, IAt.default)().console.error(l);
            }
          return r;
        }
        isEmpty() {
          return !this._callbacks || this._callbacks.length === 0;
        }
        dispose() {
          ((this._callbacks = void 0), (this._contexts = void 0));
        }
      },
      CS = class e {
        static {
          a(this, "Emitter");
        }
        constructor(t) {
          this._options = t;
        }
        get event() {
          return (
            this._event ||
              (this._event = (t, r, n) => {
                (this._callbacks || (this._callbacks = new fR()),
                  this._options &&
                    this._options.onFirstListenerAdd &&
                    this._callbacks.isEmpty() &&
                    this._options.onFirstListenerAdd(this),
                  this._callbacks.add(t, r));
                let i = {
                  dispose: a(() => {
                    this._callbacks &&
                      (this._callbacks.remove(t, r),
                      (i.dispose = e._noop),
                      this._options &&
                        this._options.onLastListenerRemove &&
                        this._callbacks.isEmpty() &&
                        this._options.onLastListenerRemove(this));
                  }, "dispose"),
                };
                return (Array.isArray(n) && n.push(i), i);
              }),
            this._event
          );
        }
        fire(t) {
          this._callbacks && this._callbacks.invoke.call(this._callbacks, t);
        }
        dispose() {
          this._callbacks &&
            (this._callbacks.dispose(), (this._callbacks = void 0));
        }
      };
    rm.Emitter = CS;
    CS._noop = function () {};
  });
  var ZJ = to((nm) => {
    "use strict";
    Object.defineProperty(nm, "__esModule", { value: !0 });
    nm.CancellationTokenSource = nm.CancellationToken = void 0;
    var MAt = hR(),
      OAt = KJ(),
      pR = dR(),
      wS;
    (function (e) {
      ((e.None = Object.freeze({
        isCancellationRequested: !1,
        onCancellationRequested: pR.Event.None,
      })),
        (e.Cancelled = Object.freeze({
          isCancellationRequested: !0,
          onCancellationRequested: pR.Event.None,
        })));
      function t(r) {
        let n = r;
        return (
          n &&
          (n === e.None ||
            n === e.Cancelled ||
            (OAt.boolean(n.isCancellationRequested) &&
              !!n.onCancellationRequested))
        );
      }
      (a(t, "is"), (e.is = t));
    })(wS || (nm.CancellationToken = wS = {}));
    var PAt = Object.freeze(function (e, t) {
        let r = (0, MAt.default)().timer.setTimeout(e.bind(t), 0);
        return {
          dispose() {
            r.dispose();
          },
        };
      }),
      vS = class {
        static {
          a(this, "MutableToken");
        }
        constructor() {
          this._isCancelled = !1;
        }
        cancel() {
          this._isCancelled ||
            ((this._isCancelled = !0),
            this._emitter && (this._emitter.fire(void 0), this.dispose()));
        }
        get isCancellationRequested() {
          return this._isCancelled;
        }
        get onCancellationRequested() {
          return this._isCancelled
            ? PAt
            : (this._emitter || (this._emitter = new pR.Emitter()),
              this._emitter.event);
        }
        dispose() {
          this._emitter && (this._emitter.dispose(), (this._emitter = void 0));
        }
      },
      mR = class {
        static {
          a(this, "CancellationTokenSource");
        }
        get token() {
          return (this._token || (this._token = new vS()), this._token);
        }
        cancel() {
          this._token ? this._token.cancel() : (this._token = wS.Cancelled);
        }
        dispose() {
          this._token
            ? this._token instanceof vS && this._token.dispose()
            : (this._token = wS.None);
        }
      };
    nm.CancellationTokenSource = mR;
  });
  var Ve = {};
  var ha = x(() => {
    "use strict";
    qe(Ve, Ts(ZJ(), 1));
  });
  function gR() {
    return new Promise((e) => {
      typeof setImmediate > "u" ? setTimeout(e, 0) : setImmediate(e);
    });
  }
  function AS() {
    return ((ES = performance.now()), new Ve.CancellationTokenSource());
  }
  function ttt(e) {
    JJ = e;
  }
  function Wo(e) {
    return e === zo;
  }
  async function kn(e) {
    if (e === Ve.CancellationToken.None) return;
    let t = performance.now();
    if (
      (t - ES >= JJ && ((ES = t), await gR(), (ES = performance.now())),
      e.isCancellationRequested)
    )
      throw zo;
  }
  var ES,
    JJ,
    zo,
    qi,
    fa = x(() => {
      "use strict";
      ha();
      a(gR, "delayNextTick");
      ((ES = 0), (JJ = 10));
      a(AS, "startCancelableOperation");
      a(ttt, "setInterruptionPeriod");
      zo = Symbol("OperationCancelled");
      a(Wo, "isOperationCancelled");
      a(kn, "interruptAndCheck");
      qi = class {
        static {
          a(this, "Deferred");
        }
        constructor() {
          this.promise = new Promise((t, r) => {
            ((this.resolve = (n) => (t(n), this)),
              (this.reject = (n) => (r(n), this)));
          });
        }
      };
    });
  function yR(e, t) {
    if (e.length <= 1) return e;
    let r = (e.length / 2) | 0,
      n = e.slice(0, r),
      i = e.slice(r);
    (yR(n, t), yR(i, t));
    let s = 0,
      o = 0,
      l = 0;
    for (; s < n.length && o < i.length; )
      t(n[s], i[o]) <= 0 ? (e[l++] = n[s++]) : (e[l++] = i[o++]);
    for (; s < n.length; ) e[l++] = n[s++];
    for (; o < i.length; ) e[l++] = i[o++];
    return e;
  }
  function ett(e, t, r = 0) {
    let n = t ? [r] : [];
    for (let i = 0; i < e.length; i++) {
      let s = e.charCodeAt(i);
      rtt(s) &&
        (s === 13 && i + 1 < e.length && e.charCodeAt(i + 1) === 10 && i++,
        n.push(r + i + 1));
    }
    return n;
  }
  function rtt(e) {
    return e === 13 || e === 10;
  }
  function ntt(e) {
    let t = e.start,
      r = e.end;
    return t.line > r.line || (t.line === r.line && t.character > r.character)
      ? { start: r, end: t }
      : e;
  }
  function BAt(e) {
    let t = ntt(e.range);
    return t !== e.range ? { newText: e.newText, range: t } : e;
  }
  var LS,
    im,
    itt = x(() => {
      "use strict";
      LS = class e {
        static {
          a(this, "FullTextDocument");
        }
        constructor(t, r, n, i) {
          ((this._uri = t),
            (this._languageId = r),
            (this._version = n),
            (this._content = i),
            (this._lineOffsets = void 0));
        }
        get uri() {
          return this._uri;
        }
        get languageId() {
          return this._languageId;
        }
        get version() {
          return this._version;
        }
        getText(t) {
          if (t) {
            let r = this.offsetAt(t.start),
              n = this.offsetAt(t.end);
            return this._content.substring(r, n);
          }
          return this._content;
        }
        update(t, r) {
          for (let n of t)
            if (e.isIncremental(n)) {
              let i = ntt(n.range),
                s = this.offsetAt(i.start),
                o = this.offsetAt(i.end);
              this._content =
                this._content.substring(0, s) +
                n.text +
                this._content.substring(o, this._content.length);
              let l = Math.max(i.start.line, 0),
                u = Math.max(i.end.line, 0),
                h = this._lineOffsets,
                f = ett(n.text, !1, s);
              if (u - l === f.length)
                for (let p = 0, m = f.length; p < m; p++) h[p + l + 1] = f[p];
              else
                f.length < 1e4
                  ? h.splice(l + 1, u - l, ...f)
                  : (this._lineOffsets = h =
                      h.slice(0, l + 1).concat(f, h.slice(u + 1)));
              let d = n.text.length - (o - s);
              if (d !== 0)
                for (let p = l + 1 + f.length, m = h.length; p < m; p++)
                  h[p] = h[p] + d;
            } else if (e.isFull(n))
              ((this._content = n.text), (this._lineOffsets = void 0));
            else throw new Error("Unknown change event received");
          this._version = r;
        }
        getLineOffsets() {
          return (
            this._lineOffsets === void 0 &&
              (this._lineOffsets = ett(this._content, !0)),
            this._lineOffsets
          );
        }
        positionAt(t) {
          t = Math.max(Math.min(t, this._content.length), 0);
          let r = this.getLineOffsets(),
            n = 0,
            i = r.length;
          if (i === 0) return { line: 0, character: t };
          for (; n < i; ) {
            let o = Math.floor((n + i) / 2);
            r[o] > t ? (i = o) : (n = o + 1);
          }
          let s = n - 1;
          return (
            (t = this.ensureBeforeEOL(t, r[s])),
            { line: s, character: t - r[s] }
          );
        }
        offsetAt(t) {
          let r = this.getLineOffsets();
          if (t.line >= r.length) return this._content.length;
          if (t.line < 0) return 0;
          let n = r[t.line];
          if (t.character <= 0) return n;
          let i = t.line + 1 < r.length ? r[t.line + 1] : this._content.length,
            s = Math.min(n + t.character, i);
          return this.ensureBeforeEOL(s, n);
        }
        ensureBeforeEOL(t, r) {
          for (; t > r && rtt(this._content.charCodeAt(t - 1)); ) t--;
          return t;
        }
        get lineCount() {
          return this.getLineOffsets().length;
        }
        static isIncremental(t) {
          let r = t;
          return (
            r != null &&
            typeof r.text == "string" &&
            r.range !== void 0 &&
            (r.rangeLength === void 0 || typeof r.rangeLength == "number")
          );
        }
        static isFull(t) {
          let r = t;
          return (
            r != null &&
            typeof r.text == "string" &&
            r.range === void 0 &&
            r.rangeLength === void 0
          );
        }
      };
      (function (e) {
        function t(i, s, o, l) {
          return new LS(i, s, o, l);
        }
        (a(t, "create"), (e.create = t));
        function r(i, s, o) {
          if (i instanceof LS) return (i.update(s, o), i);
          throw new Error(
            "TextDocument.update: document must be created by TextDocument.create",
          );
        }
        (a(r, "update"), (e.update = r));
        function n(i, s) {
          let o = i.getText(),
            l = yR(s.map(BAt), (f, d) => {
              let p = f.range.start.line - d.range.start.line;
              return p === 0
                ? f.range.start.character - d.range.start.character
                : p;
            }),
            u = 0,
            h = [];
          for (let f of l) {
            let d = i.offsetAt(f.range.start);
            if (d < u) throw new Error("Overlapping edit");
            (d > u && h.push(o.substring(u, d)),
              f.newText.length && h.push(f.newText),
              (u = i.offsetAt(f.range.end)));
          }
          return (h.push(o.substr(u)), h.join(""));
        }
        (a(n, "applyEdits"), (e.applyEdits = n));
      })(im || (im = {}));
      a(yR, "mergeSort");
      a(ett, "computeLineOffsets");
      a(rtt, "isEOL");
      a(ntt, "getWellformedRange");
      a(BAt, "getWellformedEdit");
    });
  var stt,
    Hi,
    sm,
    xR = x(() => {
      "use strict";
      (() => {
        "use strict";
        var e = {
            470: (i) => {
              function s(u) {
                if (typeof u != "string")
                  throw new TypeError(
                    "Path must be a string. Received " + JSON.stringify(u),
                  );
              }
              a(s, "e");
              function o(u, h) {
                for (
                  var f, d = "", p = 0, m = -1, g = 0, y = 0;
                  y <= u.length;
                  ++y
                ) {
                  if (y < u.length) f = u.charCodeAt(y);
                  else {
                    if (f === 47) break;
                    f = 47;
                  }
                  if (f === 47) {
                    if (!(m === y - 1 || g === 1))
                      if (m !== y - 1 && g === 2) {
                        if (
                          d.length < 2 ||
                          p !== 2 ||
                          d.charCodeAt(d.length - 1) !== 46 ||
                          d.charCodeAt(d.length - 2) !== 46
                        ) {
                          if (d.length > 2) {
                            var b = d.lastIndexOf("/");
                            if (b !== d.length - 1) {
                              (b === -1
                                ? ((d = ""), (p = 0))
                                : (p =
                                    (d = d.slice(0, b)).length -
                                    1 -
                                    d.lastIndexOf("/")),
                                (m = y),
                                (g = 0));
                              continue;
                            }
                          } else if (d.length === 2 || d.length === 1) {
                            ((d = ""), (p = 0), (m = y), (g = 0));
                            continue;
                          }
                        }
                        h &&
                          (d.length > 0 ? (d += "/..") : (d = ".."), (p = 2));
                      } else
                        (d.length > 0
                          ? (d += "/" + u.slice(m + 1, y))
                          : (d = u.slice(m + 1, y)),
                          (p = y - m - 1));
                    ((m = y), (g = 0));
                  } else f === 46 && g !== -1 ? ++g : (g = -1);
                }
                return d;
              }
              a(o, "r");
              var l = {
                resolve: a(function () {
                  for (
                    var u, h = "", f = !1, d = arguments.length - 1;
                    d >= -1 && !f;
                    d--
                  ) {
                    var p;
                    (d >= 0
                      ? (p = arguments[d])
                      : (u === void 0 && (u = process.cwd()), (p = u)),
                      s(p),
                      p.length !== 0 &&
                        ((h = p + "/" + h), (f = p.charCodeAt(0) === 47)));
                  }
                  return (
                    (h = o(h, !f)),
                    f ? (h.length > 0 ? "/" + h : "/") : h.length > 0 ? h : "."
                  );
                }, "resolve"),
                normalize: a(function (u) {
                  if ((s(u), u.length === 0)) return ".";
                  var h = u.charCodeAt(0) === 47,
                    f = u.charCodeAt(u.length - 1) === 47;
                  return (
                    (u = o(u, !h)).length !== 0 || h || (u = "."),
                    u.length > 0 && f && (u += "/"),
                    h ? "/" + u : u
                  );
                }, "normalize"),
                isAbsolute: a(function (u) {
                  return (s(u), u.length > 0 && u.charCodeAt(0) === 47);
                }, "isAbsolute"),
                join: a(function () {
                  if (arguments.length === 0) return ".";
                  for (var u, h = 0; h < arguments.length; ++h) {
                    var f = arguments[h];
                    (s(f),
                      f.length > 0 &&
                        (u === void 0 ? (u = f) : (u += "/" + f)));
                  }
                  return u === void 0 ? "." : l.normalize(u);
                }, "join"),
                relative: a(function (u, h) {
                  if (
                    (s(u),
                    s(h),
                    u === h || (u = l.resolve(u)) === (h = l.resolve(h)))
                  )
                    return "";
                  for (var f = 1; f < u.length && u.charCodeAt(f) === 47; ++f);
                  for (
                    var d = u.length, p = d - f, m = 1;
                    m < h.length && h.charCodeAt(m) === 47;
                    ++m
                  );
                  for (
                    var g = h.length - m, y = p < g ? p : g, b = -1, k = 0;
                    k <= y;
                    ++k
                  ) {
                    if (k === y) {
                      if (g > y) {
                        if (h.charCodeAt(m + k) === 47)
                          return h.slice(m + k + 1);
                        if (k === 0) return h.slice(m + k);
                      } else
                        p > y &&
                          (u.charCodeAt(f + k) === 47
                            ? (b = k)
                            : k === 0 && (b = 0));
                      break;
                    }
                    var T = u.charCodeAt(f + k);
                    if (T !== h.charCodeAt(m + k)) break;
                    T === 47 && (b = k);
                  }
                  var C = "";
                  for (k = f + b + 1; k <= d; ++k)
                    (k !== d && u.charCodeAt(k) !== 47) ||
                      (C.length === 0 ? (C += "..") : (C += "/.."));
                  return C.length > 0
                    ? C + h.slice(m + b)
                    : ((m += b), h.charCodeAt(m) === 47 && ++m, h.slice(m));
                }, "relative"),
                _makeLong: a(function (u) {
                  return u;
                }, "_makeLong"),
                dirname: a(function (u) {
                  if ((s(u), u.length === 0)) return ".";
                  for (
                    var h = u.charCodeAt(0),
                      f = h === 47,
                      d = -1,
                      p = !0,
                      m = u.length - 1;
                    m >= 1;
                    --m
                  )
                    if ((h = u.charCodeAt(m)) === 47) {
                      if (!p) {
                        d = m;
                        break;
                      }
                    } else p = !1;
                  return d === -1
                    ? f
                      ? "/"
                      : "."
                    : f && d === 1
                      ? "//"
                      : u.slice(0, d);
                }, "dirname"),
                basename: a(function (u, h) {
                  if (h !== void 0 && typeof h != "string")
                    throw new TypeError('"ext" argument must be a string');
                  s(u);
                  var f,
                    d = 0,
                    p = -1,
                    m = !0;
                  if (h !== void 0 && h.length > 0 && h.length <= u.length) {
                    if (h.length === u.length && h === u) return "";
                    var g = h.length - 1,
                      y = -1;
                    for (f = u.length - 1; f >= 0; --f) {
                      var b = u.charCodeAt(f);
                      if (b === 47) {
                        if (!m) {
                          d = f + 1;
                          break;
                        }
                      } else
                        (y === -1 && ((m = !1), (y = f + 1)),
                          g >= 0 &&
                            (b === h.charCodeAt(g)
                              ? --g == -1 && (p = f)
                              : ((g = -1), (p = y))));
                    }
                    return (
                      d === p ? (p = y) : p === -1 && (p = u.length),
                      u.slice(d, p)
                    );
                  }
                  for (f = u.length - 1; f >= 0; --f)
                    if (u.charCodeAt(f) === 47) {
                      if (!m) {
                        d = f + 1;
                        break;
                      }
                    } else p === -1 && ((m = !1), (p = f + 1));
                  return p === -1 ? "" : u.slice(d, p);
                }, "basename"),
                extname: a(function (u) {
                  s(u);
                  for (
                    var h = -1, f = 0, d = -1, p = !0, m = 0, g = u.length - 1;
                    g >= 0;
                    --g
                  ) {
                    var y = u.charCodeAt(g);
                    if (y !== 47)
                      (d === -1 && ((p = !1), (d = g + 1)),
                        y === 46
                          ? h === -1
                            ? (h = g)
                            : m !== 1 && (m = 1)
                          : h !== -1 && (m = -1));
                    else if (!p) {
                      f = g + 1;
                      break;
                    }
                  }
                  return h === -1 ||
                    d === -1 ||
                    m === 0 ||
                    (m === 1 && h === d - 1 && h === f + 1)
                    ? ""
                    : u.slice(h, d);
                }, "extname"),
                format: a(function (u) {
                  if (u === null || typeof u != "object")
                    throw new TypeError(
                      'The "pathObject" argument must be of type Object. Received type ' +
                        typeof u,
                    );
                  return (function (h, f) {
                    var d = f.dir || f.root,
                      p = f.base || (f.name || "") + (f.ext || "");
                    return d ? (d === f.root ? d + p : d + "/" + p) : p;
                  })(0, u);
                }, "format"),
                parse: a(function (u) {
                  s(u);
                  var h = { root: "", dir: "", base: "", ext: "", name: "" };
                  if (u.length === 0) return h;
                  var f,
                    d = u.charCodeAt(0),
                    p = d === 47;
                  p ? ((h.root = "/"), (f = 1)) : (f = 0);
                  for (
                    var m = -1, g = 0, y = -1, b = !0, k = u.length - 1, T = 0;
                    k >= f;
                    --k
                  )
                    if ((d = u.charCodeAt(k)) !== 47)
                      (y === -1 && ((b = !1), (y = k + 1)),
                        d === 46
                          ? m === -1
                            ? (m = k)
                            : T !== 1 && (T = 1)
                          : m !== -1 && (T = -1));
                    else if (!b) {
                      g = k + 1;
                      break;
                    }
                  return (
                    m === -1 ||
                    y === -1 ||
                    T === 0 ||
                    (T === 1 && m === y - 1 && m === g + 1)
                      ? y !== -1 &&
                        (h.base = h.name =
                          g === 0 && p ? u.slice(1, y) : u.slice(g, y))
                      : (g === 0 && p
                          ? ((h.name = u.slice(1, m)), (h.base = u.slice(1, y)))
                          : ((h.name = u.slice(g, m)),
                            (h.base = u.slice(g, y))),
                        (h.ext = u.slice(m, y))),
                    g > 0 ? (h.dir = u.slice(0, g - 1)) : p && (h.dir = "/"),
                    h
                  );
                }, "parse"),
                sep: "/",
                delimiter: ":",
                win32: null,
                posix: null,
              };
              ((l.posix = l), (i.exports = l));
            },
          },
          t = {};
        function r(i) {
          var s = t[i];
          if (s !== void 0) return s.exports;
          var o = (t[i] = { exports: {} });
          return (e[i](o, o.exports, r), o.exports);
        }
        (a(r, "r"),
          (r.d = (i, s) => {
            for (var o in s)
              r.o(s, o) &&
                !r.o(i, o) &&
                Object.defineProperty(i, o, { enumerable: !0, get: s[o] });
          }),
          (r.o = (i, s) => Object.prototype.hasOwnProperty.call(i, s)),
          (r.r = (i) => {
            (typeof Symbol < "u" &&
              Symbol.toStringTag &&
              Object.defineProperty(i, Symbol.toStringTag, { value: "Module" }),
              Object.defineProperty(i, "__esModule", { value: !0 }));
          }));
        var n = {};
        ((() => {
          let i;
          (r.r(n),
            r.d(n, { URI: a(() => p, "URI"), Utils: a(() => F, "Utils") }),
            typeof process == "object"
              ? (i = process.platform === "win32")
              : typeof navigator == "object" &&
                (i = navigator.userAgent.indexOf("Windows") >= 0));
          let s = /^\w[\w\d+.-]*$/,
            o = /^\//,
            l = /^\/\//;
          function u(S, O) {
            if (!S.scheme && O)
              throw new Error(
                `[UriError]: Scheme is missing: {scheme: "", authority: "${S.authority}", path: "${S.path}", query: "${S.query}", fragment: "${S.fragment}"}`,
              );
            if (S.scheme && !s.test(S.scheme))
              throw new Error(
                "[UriError]: Scheme contains illegal characters.",
              );
            if (S.path) {
              if (S.authority) {
                if (!o.test(S.path))
                  throw new Error(
                    '[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character',
                  );
              } else if (l.test(S.path))
                throw new Error(
                  '[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")',
                );
            }
          }
          a(u, "s");
          let h = "",
            f = "/",
            d = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
          class p {
            static {
              a(this, "f");
            }
            static isUri(O) {
              return (
                O instanceof p ||
                (!!O &&
                  typeof O.authority == "string" &&
                  typeof O.fragment == "string" &&
                  typeof O.path == "string" &&
                  typeof O.query == "string" &&
                  typeof O.scheme == "string" &&
                  typeof O.fsPath == "string" &&
                  typeof O.with == "function" &&
                  typeof O.toString == "function")
              );
            }
            scheme;
            authority;
            path;
            query;
            fragment;
            constructor(O, v, _, A, N, B = !1) {
              typeof O == "object"
                ? ((this.scheme = O.scheme || h),
                  (this.authority = O.authority || h),
                  (this.path = O.path || h),
                  (this.query = O.query || h),
                  (this.fragment = O.fragment || h))
                : ((this.scheme = (function (M, I) {
                    return M || I ? M : "file";
                  })(O, B)),
                  (this.authority = v || h),
                  (this.path = (function (M, I) {
                    switch (M) {
                      case "https":
                      case "http":
                      case "file":
                        I ? I[0] !== f && (I = f + I) : (I = f);
                    }
                    return I;
                  })(this.scheme, _ || h)),
                  (this.query = A || h),
                  (this.fragment = N || h),
                  u(this, B));
            }
            get fsPath() {
              return T(this, !1);
            }
            with(O) {
              if (!O) return this;
              let {
                scheme: v,
                authority: _,
                path: A,
                query: N,
                fragment: B,
              } = O;
              return (
                v === void 0 ? (v = this.scheme) : v === null && (v = h),
                _ === void 0 ? (_ = this.authority) : _ === null && (_ = h),
                A === void 0 ? (A = this.path) : A === null && (A = h),
                N === void 0 ? (N = this.query) : N === null && (N = h),
                B === void 0 ? (B = this.fragment) : B === null && (B = h),
                v === this.scheme &&
                _ === this.authority &&
                A === this.path &&
                N === this.query &&
                B === this.fragment
                  ? this
                  : new g(v, _, A, N, B)
              );
            }
            static parse(O, v = !1) {
              let _ = d.exec(O);
              return _
                ? new g(
                    _[2] || h,
                    D(_[4] || h),
                    D(_[5] || h),
                    D(_[7] || h),
                    D(_[9] || h),
                    v,
                  )
                : new g(h, h, h, h, h);
            }
            static file(O) {
              let v = h;
              if ((i && (O = O.replace(/\\/g, f)), O[0] === f && O[1] === f)) {
                let _ = O.indexOf(f, 2);
                _ === -1
                  ? ((v = O.substring(2)), (O = f))
                  : ((v = O.substring(2, _)), (O = O.substring(_) || f));
              }
              return new g("file", v, O, h, h);
            }
            static from(O) {
              let v = new g(O.scheme, O.authority, O.path, O.query, O.fragment);
              return (u(v, !0), v);
            }
            toString(O = !1) {
              return C(this, O);
            }
            toJSON() {
              return this;
            }
            static revive(O) {
              if (O) {
                if (O instanceof p) return O;
                {
                  let v = new g(O);
                  return (
                    (v._formatted = O.external),
                    (v._fsPath = O._sep === m ? O.fsPath : null),
                    v
                  );
                }
              }
              return O;
            }
          }
          let m = i ? 1 : void 0;
          class g extends p {
            static {
              a(this, "l");
            }
            _formatted = null;
            _fsPath = null;
            get fsPath() {
              return (
                this._fsPath || (this._fsPath = T(this, !1)),
                this._fsPath
              );
            }
            toString(O = !1) {
              return O
                ? C(this, !0)
                : (this._formatted || (this._formatted = C(this, !1)),
                  this._formatted);
            }
            toJSON() {
              let O = { $mid: 1 };
              return (
                this._fsPath && ((O.fsPath = this._fsPath), (O._sep = m)),
                this._formatted && (O.external = this._formatted),
                this.path && (O.path = this.path),
                this.scheme && (O.scheme = this.scheme),
                this.authority && (O.authority = this.authority),
                this.query && (O.query = this.query),
                this.fragment && (O.fragment = this.fragment),
                O
              );
            }
          }
          let y = {
            58: "%3A",
            47: "%2F",
            63: "%3F",
            35: "%23",
            91: "%5B",
            93: "%5D",
            64: "%40",
            33: "%21",
            36: "%24",
            38: "%26",
            39: "%27",
            40: "%28",
            41: "%29",
            42: "%2A",
            43: "%2B",
            44: "%2C",
            59: "%3B",
            61: "%3D",
            32: "%20",
          };
          function b(S, O, v) {
            let _,
              A = -1;
            for (let N = 0; N < S.length; N++) {
              let B = S.charCodeAt(N);
              if (
                (B >= 97 && B <= 122) ||
                (B >= 65 && B <= 90) ||
                (B >= 48 && B <= 57) ||
                B === 45 ||
                B === 46 ||
                B === 95 ||
                B === 126 ||
                (O && B === 47) ||
                (v && B === 91) ||
                (v && B === 93) ||
                (v && B === 58)
              )
                (A !== -1 &&
                  ((_ += encodeURIComponent(S.substring(A, N))), (A = -1)),
                  _ !== void 0 && (_ += S.charAt(N)));
              else {
                _ === void 0 && (_ = S.substr(0, N));
                let M = y[B];
                M !== void 0
                  ? (A !== -1 &&
                      ((_ += encodeURIComponent(S.substring(A, N))), (A = -1)),
                    (_ += M))
                  : A === -1 && (A = N);
              }
            }
            return (
              A !== -1 && (_ += encodeURIComponent(S.substring(A))),
              _ !== void 0 ? _ : S
            );
          }
          a(b, "d");
          function k(S) {
            let O;
            for (let v = 0; v < S.length; v++) {
              let _ = S.charCodeAt(v);
              _ === 35 || _ === 63
                ? (O === void 0 && (O = S.substr(0, v)), (O += y[_]))
                : O !== void 0 && (O += S[v]);
            }
            return O !== void 0 ? O : S;
          }
          a(k, "p");
          function T(S, O) {
            let v;
            return (
              (v =
                S.authority && S.path.length > 1 && S.scheme === "file"
                  ? `//${S.authority}${S.path}`
                  : S.path.charCodeAt(0) === 47 &&
                      ((S.path.charCodeAt(1) >= 65 &&
                        S.path.charCodeAt(1) <= 90) ||
                        (S.path.charCodeAt(1) >= 97 &&
                          S.path.charCodeAt(1) <= 122)) &&
                      S.path.charCodeAt(2) === 58
                    ? O
                      ? S.path.substr(1)
                      : S.path[1].toLowerCase() + S.path.substr(2)
                    : S.path),
              i && (v = v.replace(/\//g, "\\")),
              v
            );
          }
          a(T, "m");
          function C(S, O) {
            let v = O ? k : b,
              _ = "",
              { scheme: A, authority: N, path: B, query: M, fragment: I } = S;
            if (
              (A && ((_ += A), (_ += ":")),
              (N || A === "file") && ((_ += f), (_ += f)),
              N)
            ) {
              let V = N.indexOf("@");
              if (V !== -1) {
                let $ = N.substr(0, V);
                ((N = N.substr(V + 1)),
                  (V = $.lastIndexOf(":")),
                  V === -1
                    ? (_ += v($, !1, !1))
                    : ((_ += v($.substr(0, V), !1, !1)),
                      (_ += ":"),
                      (_ += v($.substr(V + 1), !1, !0))),
                  (_ += "@"));
              }
              ((N = N.toLowerCase()),
                (V = N.lastIndexOf(":")),
                V === -1
                  ? (_ += v(N, !1, !0))
                  : ((_ += v(N.substr(0, V), !1, !0)), (_ += N.substr(V))));
            }
            if (B) {
              if (
                B.length >= 3 &&
                B.charCodeAt(0) === 47 &&
                B.charCodeAt(2) === 58
              ) {
                let V = B.charCodeAt(1);
                V >= 65 &&
                  V <= 90 &&
                  (B = `/${String.fromCharCode(V + 32)}:${B.substr(3)}`);
              } else if (B.length >= 2 && B.charCodeAt(1) === 58) {
                let V = B.charCodeAt(0);
                V >= 65 &&
                  V <= 90 &&
                  (B = `${String.fromCharCode(V + 32)}:${B.substr(2)}`);
              }
              _ += v(B, !0, !1);
            }
            return (
              M && ((_ += "?"), (_ += v(M, !1, !1))),
              I && ((_ += "#"), (_ += O ? I : b(I, !1, !1))),
              _
            );
          }
          a(C, "y");
          function L(S) {
            try {
              return decodeURIComponent(S);
            } catch {
              return S.length > 3 ? S.substr(0, 3) + L(S.substr(3)) : S;
            }
          }
          a(L, "v");
          let w = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
          function D(S) {
            return S.match(w) ? S.replace(w, (O) => L(O)) : S;
          }
          a(D, "C");
          var G = r(470);
          let E = G.posix || G,
            R = "/";
          var F;
          (function (S) {
            ((S.joinPath = function (O, ...v) {
              return O.with({ path: E.join(O.path, ...v) });
            }),
              (S.resolvePath = function (O, ...v) {
                let _ = O.path,
                  A = !1;
                _[0] !== R && ((_ = R + _), (A = !0));
                let N = E.resolve(_, ...v);
                return (
                  A && N[0] === R && !O.authority && (N = N.substring(1)),
                  O.with({ path: N })
                );
              }),
              (S.dirname = function (O) {
                if (O.path.length === 0 || O.path === R) return O;
                let v = E.dirname(O.path);
                return (
                  v.length === 1 && v.charCodeAt(0) === 46 && (v = ""),
                  O.with({ path: v })
                );
              }),
              (S.basename = function (O) {
                return E.basename(O.path);
              }),
              (S.extname = function (O) {
                return E.extname(O.path);
              }));
          })(F || (F = {}));
        })(),
          (stt = n));
      })();
      ({ URI: Hi, Utils: sm } = stt);
    });
  var Yi,
    Uo = x(() => {
      "use strict";
      xR();
      (function (e) {
        ((e.basename = sm.basename),
          (e.dirname = sm.dirname),
          (e.extname = sm.extname),
          (e.joinPath = sm.joinPath),
          (e.resolvePath = sm.resolvePath));
        function t(i, s) {
          return i?.toString() === s?.toString();
        }
        (a(t, "equals"), (e.equals = t));
        function r(i, s) {
          let o = typeof i == "string" ? i : i.path,
            l = typeof s == "string" ? s : s.path,
            u = o.split("/").filter((m) => m.length > 0),
            h = l.split("/").filter((m) => m.length > 0),
            f = 0;
          for (; f < u.length && u[f] === h[f]; f++);
          let d = "../".repeat(u.length - f),
            p = h.slice(f).join("/");
          return d + p;
        }
        (a(r, "relative"), (e.relative = r));
        function n(i) {
          return Hi.parse(i.toString()).toString();
        }
        (a(n, "normalize"), (e.normalize = n));
      })(Yi || (Yi = {}));
    });
  var Pr,
    X1,
    K1,
    am = x(() => {
      "use strict";
      itt();
      am();
      ha();
      ms();
      Uo();
      (function (e) {
        ((e[(e.Changed = 0)] = "Changed"),
          (e[(e.Parsed = 1)] = "Parsed"),
          (e[(e.IndexedContent = 2)] = "IndexedContent"),
          (e[(e.ComputedScopes = 3)] = "ComputedScopes"),
          (e[(e.Linked = 4)] = "Linked"),
          (e[(e.IndexedReferences = 5)] = "IndexedReferences"),
          (e[(e.Validated = 6)] = "Validated"));
      })(Pr || (Pr = {}));
      ((X1 = class {
        static {
          a(this, "DefaultLangiumDocumentFactory");
        }
        constructor(t) {
          ((this.serviceRegistry = t.ServiceRegistry),
            (this.textDocuments = t.workspace.TextDocuments),
            (this.fileSystemProvider = t.workspace.FileSystemProvider));
        }
        async fromUri(t, r = Ve.CancellationToken.None) {
          let n = await this.fileSystemProvider.readFile(t);
          return this.createAsync(t, n, r);
        }
        fromTextDocument(t, r, n) {
          return (
            (r = r ?? Hi.parse(t.uri)),
            Ve.CancellationToken.is(n)
              ? this.createAsync(r, t, n)
              : this.create(r, t, n)
          );
        }
        fromString(t, r, n) {
          return Ve.CancellationToken.is(n)
            ? this.createAsync(r, t, n)
            : this.create(r, t, n);
        }
        fromModel(t, r) {
          return this.create(r, { $model: t });
        }
        create(t, r, n) {
          if (typeof r == "string") {
            let i = this.parse(t, r, n);
            return this.createLangiumDocument(i, t, void 0, r);
          } else if ("$model" in r) {
            let i = { value: r.$model, parserErrors: [], lexerErrors: [] };
            return this.createLangiumDocument(i, t);
          } else {
            let i = this.parse(t, r.getText(), n);
            return this.createLangiumDocument(i, t, r);
          }
        }
        async createAsync(t, r, n) {
          if (typeof r == "string") {
            let i = await this.parseAsync(t, r, n);
            return this.createLangiumDocument(i, t, void 0, r);
          } else {
            let i = await this.parseAsync(t, r.getText(), n);
            return this.createLangiumDocument(i, t, r);
          }
        }
        createLangiumDocument(t, r, n, i) {
          let s;
          if (n)
            s = {
              parseResult: t,
              uri: r,
              state: Pr.Parsed,
              references: [],
              textDocument: n,
            };
          else {
            let o = this.createTextDocumentGetter(r, i);
            s = {
              parseResult: t,
              uri: r,
              state: Pr.Parsed,
              references: [],
              get textDocument() {
                return o();
              },
            };
          }
          return ((t.value.$document = s), s);
        }
        async update(t, r) {
          var n, i;
          let s =
              (n = t.parseResult.value.$cstNode) === null || n === void 0
                ? void 0
                : n.root.fullText,
            o =
              (i = this.textDocuments) === null || i === void 0
                ? void 0
                : i.get(t.uri.toString()),
            l = o ? o.getText() : await this.fileSystemProvider.readFile(t.uri);
          if (o) Object.defineProperty(t, "textDocument", { value: o });
          else {
            let u = this.createTextDocumentGetter(t.uri, l);
            Object.defineProperty(t, "textDocument", { get: u });
          }
          return (
            s !== l &&
              ((t.parseResult = await this.parseAsync(t.uri, l, r)),
              (t.parseResult.value.$document = t)),
            (t.state = Pr.Parsed),
            t
          );
        }
        parse(t, r, n) {
          return this.serviceRegistry
            .getServices(t)
            .parser.LangiumParser.parse(r, n);
        }
        parseAsync(t, r, n) {
          return this.serviceRegistry
            .getServices(t)
            .parser.AsyncParser.parse(r, n);
        }
        createTextDocumentGetter(t, r) {
          let n = this.serviceRegistry,
            i;
          return () =>
            i ??
            (i = im.create(
              t.toString(),
              n.getServices(t).LanguageMetaData.languageId,
              0,
              r ?? "",
            ));
        }
      }),
        (K1 = class {
          static {
            a(this, "DefaultLangiumDocuments");
          }
          constructor(t) {
            ((this.documentMap = new Map()),
              (this.langiumDocumentFactory =
                t.workspace.LangiumDocumentFactory),
              (this.serviceRegistry = t.ServiceRegistry));
          }
          get all() {
            return kr(this.documentMap.values());
          }
          addDocument(t) {
            let r = t.uri.toString();
            if (this.documentMap.has(r))
              throw new Error(
                `A document with the URI '${r}' is already present.`,
              );
            this.documentMap.set(r, t);
          }
          getDocument(t) {
            let r = t.toString();
            return this.documentMap.get(r);
          }
          async getOrCreateDocument(t, r) {
            let n = this.getDocument(t);
            return (
              n ||
              ((n = await this.langiumDocumentFactory.fromUri(t, r)),
              this.addDocument(n),
              n)
            );
          }
          createDocument(t, r, n) {
            if (n)
              return this.langiumDocumentFactory
                .fromString(r, t, n)
                .then((i) => (this.addDocument(i), i));
            {
              let i = this.langiumDocumentFactory.fromString(r, t);
              return (this.addDocument(i), i);
            }
          }
          hasDocument(t) {
            return this.documentMap.has(t.toString());
          }
          invalidateDocument(t) {
            let r = t.toString(),
              n = this.documentMap.get(r);
            return (
              n &&
                (this.serviceRegistry
                  .getServices(t)
                  .references.Linker.unlink(n),
                (n.state = Pr.Changed),
                (n.precomputedScopes = void 0),
                (n.diagnostics = void 0)),
              n
            );
          }
          deleteDocument(t) {
            let r = t.toString(),
              n = this.documentMap.get(r);
            return (
              n && ((n.state = Pr.Changed), this.documentMap.delete(r)),
              n
            );
          }
        }));
    });
  var bR,
    Q1,
    kR = x(() => {
      "use strict";
      ha();
      Wa();
      Vi();
      fa();
      am();
      ((bR = Symbol("ref_resolving")),
        (Q1 = class {
          static {
            a(this, "DefaultLinker");
          }
          constructor(t) {
            ((this.reflection = t.shared.AstReflection),
              (this.langiumDocuments = () =>
                t.shared.workspace.LangiumDocuments),
              (this.scopeProvider = t.references.ScopeProvider),
              (this.astNodeLocator = t.workspace.AstNodeLocator));
          }
          async link(t, r = Ve.CancellationToken.None) {
            for (let n of ua(t.parseResult.value))
              (await kn(r), Sp(n).forEach((i) => this.doLink(i, t)));
          }
          doLink(t, r) {
            var n;
            let i = t.reference;
            if (i._ref === void 0) {
              i._ref = bR;
              try {
                let s = this.getCandidate(t);
                if (yh(s)) i._ref = s;
                else if (
                  ((i._nodeDescription = s),
                  this.langiumDocuments().hasDocument(s.documentUri))
                ) {
                  let o = this.loadAstNode(s);
                  i._ref = o ?? this.createLinkingError(t, s);
                } else i._ref = void 0;
              } catch (s) {
                console.error(
                  `An error occurred while resolving reference to '${i.$refText}':`,
                  s,
                );
                let o =
                  (n = s.message) !== null && n !== void 0 ? n : String(s);
                i._ref = Object.assign(Object.assign({}, t), {
                  message: `An error occurred while resolving reference to '${i.$refText}': ${o}`,
                });
              }
              r.references.push(i);
            }
          }
          unlink(t) {
            for (let r of t.references)
              (delete r._ref, delete r._nodeDescription);
            t.references = [];
          }
          getCandidate(t) {
            let n = this.scopeProvider
              .getScope(t)
              .getElement(t.reference.$refText);
            return n ?? this.createLinkingError(t);
          }
          buildReference(t, r, n, i) {
            let s = this,
              o = {
                $refNode: n,
                $refText: i,
                get ref() {
                  var l;
                  if (cn(this._ref)) return this._ref;
                  if (a6(this._nodeDescription)) {
                    let u = s.loadAstNode(this._nodeDescription);
                    this._ref =
                      u ??
                      s.createLinkingError(
                        { reference: o, container: t, property: r },
                        this._nodeDescription,
                      );
                  } else if (this._ref === void 0) {
                    this._ref = bR;
                    let u = o1(t).$document,
                      h = s.getLinkedNode({
                        reference: o,
                        container: t,
                        property: r,
                      });
                    if (h.error && u && u.state < Pr.ComputedScopes)
                      return (this._ref = void 0);
                    ((this._ref =
                      (l = h.node) !== null && l !== void 0 ? l : h.error),
                      (this._nodeDescription = h.descr),
                      u?.references.push(this));
                  } else if (this._ref === bR)
                    throw new Error(
                      `Cyclic reference resolution detected: ${s.astNodeLocator.getAstNodePath(t)}/${r} (symbol '${i}')`,
                    );
                  return cn(this._ref) ? this._ref : void 0;
                },
                get $nodeDescription() {
                  return this._nodeDescription;
                },
                get error() {
                  return yh(this._ref) ? this._ref : void 0;
                },
              };
            return o;
          }
          getLinkedNode(t) {
            var r;
            try {
              let n = this.getCandidate(t);
              if (yh(n)) return { error: n };
              let i = this.loadAstNode(n);
              return i
                ? { node: i, descr: n }
                : { descr: n, error: this.createLinkingError(t, n) };
            } catch (n) {
              console.error(
                `An error occurred while resolving reference to '${t.reference.$refText}':`,
                n,
              );
              let i = (r = n.message) !== null && r !== void 0 ? r : String(n);
              return {
                error: Object.assign(Object.assign({}, t), {
                  message: `An error occurred while resolving reference to '${t.reference.$refText}': ${i}`,
                }),
              };
            }
          }
          loadAstNode(t) {
            if (t.node) return t.node;
            let r = this.langiumDocuments().getDocument(t.documentUri);
            if (r)
              return this.astNodeLocator.getAstNode(
                r.parseResult.value,
                t.path,
              );
          }
          createLinkingError(t, r) {
            let n = o1(t.container).$document;
            n &&
              n.state < Pr.ComputedScopes &&
              console.warn(
                `Attempted reference resolution before document reached ComputedScopes state (${n.uri}).`,
              );
            let i = this.reflection.getReferenceType(t);
            return Object.assign(Object.assign({}, t), {
              message: `Could not resolve reference to ${i} named '${t.reference.$refText}'.`,
              targetDescription: r,
            });
          }
        }));
    });
  function att(e) {
    return typeof e.name == "string";
  }
  var Z1,
    TR = x(() => {
      "use strict";
      Ha();
      a(att, "isNamed");
      Z1 = class {
        static {
          a(this, "DefaultNameProvider");
        }
        getName(t) {
          if (att(t)) return t.name;
        }
        getNameNode(t) {
          return p1(t.$cstNode, "name");
        }
      };
    });
  var J1,
    SR = x(() => {
      "use strict";
      Ha();
      Wa();
      Vi();
      Ua();
      ms();
      Uo();
      J1 = class {
        static {
          a(this, "DefaultReferences");
        }
        constructor(t) {
          ((this.nameProvider = t.references.NameProvider),
            (this.index = t.shared.workspace.IndexManager),
            (this.nodeLocator = t.workspace.AstNodeLocator));
        }
        findDeclaration(t) {
          if (t) {
            let r = Y6(t),
              n = t.astNode;
            if (r && n) {
              let i = n[r.feature];
              if (li(i)) return i.ref;
              if (Array.isArray(i)) {
                for (let s of i)
                  if (
                    li(s) &&
                    s.$refNode &&
                    s.$refNode.offset <= t.offset &&
                    s.$refNode.end >= t.end
                  )
                    return s.ref;
              }
            }
            if (n) {
              let i = this.nameProvider.getNameNode(n);
              if (i && (i === t || l6(t, i))) return n;
            }
          }
        }
        findDeclarationNode(t) {
          let r = this.findDeclaration(t);
          if (r?.$cstNode) {
            let n = this.nameProvider.getNameNode(r);
            return n ?? r.$cstNode;
          }
        }
        findReferences(t, r) {
          let n = [];
          if (r.includeDeclaration) {
            let s = this.getReferenceToSelf(t);
            s && n.push(s);
          }
          let i = this.index.findAllReferences(
            t,
            this.nodeLocator.getAstNodePath(t),
          );
          return (
            r.documentUri &&
              (i = i.filter((s) => Yi.equals(s.sourceUri, r.documentUri))),
            n.push(...i),
            kr(n)
          );
        }
        getReferenceToSelf(t) {
          let r = this.nameProvider.getNameNode(t);
          if (r) {
            let n = Si(t),
              i = this.nodeLocator.getAstNodePath(t);
            return {
              sourceUri: n.uri,
              sourcePath: i,
              targetUri: n.uri,
              targetPath: i,
              segment: bh(r),
              local: !0,
            };
          }
        }
      };
    });
  var Xa,
    Gh,
    om = x(() => {
      "use strict";
      ms();
      ((Xa = class {
        static {
          a(this, "MultiMap");
        }
        constructor(t) {
          if (((this.map = new Map()), t)) for (let [r, n] of t) this.add(r, n);
        }
        get size() {
          return Od.sum(kr(this.map.values()).map((t) => t.length));
        }
        clear() {
          this.map.clear();
        }
        delete(t, r) {
          if (r === void 0) return this.map.delete(t);
          {
            let n = this.map.get(t);
            if (n) {
              let i = n.indexOf(r);
              if (i >= 0)
                return (
                  n.length === 1 ? this.map.delete(t) : n.splice(i, 1),
                  !0
                );
            }
            return !1;
          }
        }
        get(t) {
          var r;
          return (r = this.map.get(t)) !== null && r !== void 0 ? r : [];
        }
        has(t, r) {
          if (r === void 0) return this.map.has(t);
          {
            let n = this.map.get(t);
            return n ? n.indexOf(r) >= 0 : !1;
          }
        }
        add(t, r) {
          return (
            this.map.has(t) ? this.map.get(t).push(r) : this.map.set(t, [r]),
            this
          );
        }
        addAll(t, r) {
          return (
            this.map.has(t)
              ? this.map.get(t).push(...r)
              : this.map.set(t, Array.from(r)),
            this
          );
        }
        forEach(t) {
          this.map.forEach((r, n) => r.forEach((i) => t(i, n, this)));
        }
        [Symbol.iterator]() {
          return this.entries().iterator();
        }
        entries() {
          return kr(this.map.entries()).flatMap(([t, r]) =>
            r.map((n) => [t, n]),
          );
        }
        keys() {
          return kr(this.map.keys());
        }
        values() {
          return kr(this.map.values()).flat();
        }
        entriesGroupedByKey() {
          return kr(this.map.entries());
        }
      }),
        (Gh = class {
          static {
            a(this, "BiMap");
          }
          get size() {
            return this.map.size;
          }
          constructor(t) {
            if (((this.map = new Map()), (this.inverse = new Map()), t))
              for (let [r, n] of t) this.set(r, n);
          }
          clear() {
            (this.map.clear(), this.inverse.clear());
          }
          set(t, r) {
            return (this.map.set(t, r), this.inverse.set(r, t), this);
          }
          get(t) {
            return this.map.get(t);
          }
          getKey(t) {
            return this.inverse.get(t);
          }
          delete(t) {
            let r = this.map.get(t);
            return r !== void 0
              ? (this.map.delete(t), this.inverse.delete(r), !0)
              : !1;
          }
        }));
    });
  var ty,
    _R = x(() => {
      "use strict";
      ha();
      Vi();
      om();
      fa();
      ty = class {
        static {
          a(this, "DefaultScopeComputation");
        }
        constructor(t) {
          ((this.nameProvider = t.references.NameProvider),
            (this.descriptions = t.workspace.AstNodeDescriptionProvider));
        }
        async computeExports(t, r = Ve.CancellationToken.None) {
          return this.computeExportsForNode(t.parseResult.value, t, void 0, r);
        }
        async computeExportsForNode(
          t,
          r,
          n = l1,
          i = Ve.CancellationToken.None,
        ) {
          let s = [];
          this.exportNode(t, s, r);
          for (let o of n(t)) (await kn(i), this.exportNode(o, s, r));
          return s;
        }
        exportNode(t, r, n) {
          let i = this.nameProvider.getName(t);
          i && r.push(this.descriptions.createDescription(t, i, n));
        }
        async computeLocalScopes(t, r = Ve.CancellationToken.None) {
          let n = t.parseResult.value,
            i = new Xa();
          for (let s of Fo(n)) (await kn(r), this.processNode(s, t, i));
          return i;
        }
        processNode(t, r, n) {
          let i = t.$container;
          if (i) {
            let s = this.nameProvider.getName(t);
            s && n.add(i, this.descriptions.createDescription(t, s, r));
          }
        }
      };
    });
  var lm,
    ey,
    FAt,
    CR = x(() => {
      "use strict";
      ms();
      ((lm = class {
        static {
          a(this, "StreamScope");
        }
        constructor(t, r, n) {
          var i;
          ((this.elements = t),
            (this.outerScope = r),
            (this.caseInsensitive =
              (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1));
        }
        getAllElements() {
          return this.outerScope
            ? this.elements.concat(this.outerScope.getAllElements())
            : this.elements;
        }
        getElement(t) {
          let r = this.caseInsensitive
            ? this.elements.find(
                (n) => n.name.toLowerCase() === t.toLowerCase(),
              )
            : this.elements.find((n) => n.name === t);
          if (r) return r;
          if (this.outerScope) return this.outerScope.getElement(t);
        }
      }),
        (ey = class {
          static {
            a(this, "MapScope");
          }
          constructor(t, r, n) {
            var i;
            ((this.elements = new Map()),
              (this.caseInsensitive =
                (i = n?.caseInsensitive) !== null && i !== void 0 ? i : !1));
            for (let s of t) {
              let o = this.caseInsensitive ? s.name.toLowerCase() : s.name;
              this.elements.set(o, s);
            }
            this.outerScope = r;
          }
          getElement(t) {
            let r = this.caseInsensitive ? t.toLowerCase() : t,
              n = this.elements.get(r);
            if (n) return n;
            if (this.outerScope) return this.outerScope.getElement(t);
          }
          getAllElements() {
            let t = kr(this.elements.values());
            return (
              this.outerScope &&
                (t = t.concat(this.outerScope.getAllElements())),
              t
            );
          }
        }),
        (FAt = {
          getElement() {},
          getAllElements() {
            return Q0;
          },
        }));
    });
  var cm,
    ry,
    Vh,
    RS,
    um,
    DS = x(() => {
      "use strict";
      ((cm = class {
        static {
          a(this, "DisposableCache");
        }
        constructor() {
          ((this.toDispose = []), (this.isDisposed = !1));
        }
        onDispose(t) {
          this.toDispose.push(t);
        }
        dispose() {
          (this.throwIfDisposed(),
            this.clear(),
            (this.isDisposed = !0),
            this.toDispose.forEach((t) => t.dispose()));
        }
        throwIfDisposed() {
          if (this.isDisposed)
            throw new Error("This cache has already been disposed");
        }
      }),
        (ry = class extends cm {
          static {
            a(this, "SimpleCache");
          }
          constructor() {
            (super(...arguments), (this.cache = new Map()));
          }
          has(t) {
            return (this.throwIfDisposed(), this.cache.has(t));
          }
          set(t, r) {
            (this.throwIfDisposed(), this.cache.set(t, r));
          }
          get(t, r) {
            if ((this.throwIfDisposed(), this.cache.has(t)))
              return this.cache.get(t);
            if (r) {
              let n = r();
              return (this.cache.set(t, n), n);
            } else return;
          }
          delete(t) {
            return (this.throwIfDisposed(), this.cache.delete(t));
          }
          clear() {
            (this.throwIfDisposed(), this.cache.clear());
          }
        }),
        (Vh = class extends cm {
          static {
            a(this, "ContextCache");
          }
          constructor(t) {
            (super(),
              (this.cache = new Map()),
              (this.converter = t ?? ((r) => r)));
          }
          has(t, r) {
            return (this.throwIfDisposed(), this.cacheForContext(t).has(r));
          }
          set(t, r, n) {
            (this.throwIfDisposed(), this.cacheForContext(t).set(r, n));
          }
          get(t, r, n) {
            this.throwIfDisposed();
            let i = this.cacheForContext(t);
            if (i.has(r)) return i.get(r);
            if (n) {
              let s = n();
              return (i.set(r, s), s);
            } else return;
          }
          delete(t, r) {
            return (this.throwIfDisposed(), this.cacheForContext(t).delete(r));
          }
          clear(t) {
            if ((this.throwIfDisposed(), t)) {
              let r = this.converter(t);
              this.cache.delete(r);
            } else this.cache.clear();
          }
          cacheForContext(t) {
            let r = this.converter(t),
              n = this.cache.get(r);
            return (n || ((n = new Map()), this.cache.set(r, n)), n);
          }
        }),
        (RS = class extends Vh {
          static {
            a(this, "DocumentCache");
          }
          constructor(t, r) {
            (super((n) => n.toString()),
              r
                ? (this.toDispose.push(
                    t.workspace.DocumentBuilder.onDocumentPhase(r, (n) => {
                      this.clear(n.uri.toString());
                    }),
                  ),
                  this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate((n, i) => {
                      for (let s of i) this.clear(s);
                    }),
                  ))
                : this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate((n, i) => {
                      let s = n.concat(i);
                      for (let o of s) this.clear(o);
                    }),
                  ));
          }
        }),
        (um = class extends ry {
          static {
            a(this, "WorkspaceCache");
          }
          constructor(t, r) {
            (super(),
              r
                ? (this.toDispose.push(
                    t.workspace.DocumentBuilder.onBuildPhase(r, () => {
                      this.clear();
                    }),
                  ),
                  this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate((n, i) => {
                      i.length > 0 && this.clear();
                    }),
                  ))
                : this.toDispose.push(
                    t.workspace.DocumentBuilder.onUpdate(() => {
                      this.clear();
                    }),
                  ));
          }
        }));
    });
  var ny,
    wR = x(() => {
      "use strict";
      CR();
      Vi();
      ms();
      DS();
      ny = class {
        static {
          a(this, "DefaultScopeProvider");
        }
        constructor(t) {
          ((this.reflection = t.shared.AstReflection),
            (this.nameProvider = t.references.NameProvider),
            (this.descriptions = t.workspace.AstNodeDescriptionProvider),
            (this.indexManager = t.shared.workspace.IndexManager),
            (this.globalScopeCache = new um(t.shared)));
        }
        getScope(t) {
          let r = [],
            n = this.reflection.getReferenceType(t),
            i = Si(t.container).precomputedScopes;
          if (i) {
            let o = t.container;
            do {
              let l = i.get(o);
              (l.length > 0 &&
                r.push(
                  kr(l).filter((u) => this.reflection.isSubtype(u.type, n)),
                ),
                (o = o.$container));
            } while (o);
          }
          let s = this.getGlobalScope(n, t);
          for (let o = r.length - 1; o >= 0; o--) s = this.createScope(r[o], s);
          return s;
        }
        createScope(t, r, n) {
          return new lm(kr(t), r, n);
        }
        createScopeForNodes(t, r, n) {
          let i = kr(t)
            .map((s) => {
              let o = this.nameProvider.getName(s);
              if (o) return this.descriptions.createDescription(s, o);
            })
            .nonNullable();
          return new lm(i, r, n);
        }
        getGlobalScope(t, r) {
          return this.globalScopeCache.get(
            t,
            () => new ey(this.indexManager.allElements(t)),
          );
        }
      };
    });
  function vR(e) {
    return typeof e.$comment == "string";
  }
  function ott(e) {
    return typeof e == "object" && !!e && ("$ref" in e || "$error" in e);
  }
  var iy,
    NS = x(() => {
      "use strict";
      xR();
      Wa();
      Vi();
      Ha();
      a(vR, "isAstNodeWithComment");
      a(ott, "isIntermediateReference");
      iy = class {
        static {
          a(this, "DefaultJsonSerializer");
        }
        constructor(t) {
          ((this.ignoreProperties = new Set([
            "$container",
            "$containerProperty",
            "$containerIndex",
            "$document",
            "$cstNode",
          ])),
            (this.langiumDocuments = t.shared.workspace.LangiumDocuments),
            (this.astNodeLocator = t.workspace.AstNodeLocator),
            (this.nameProvider = t.references.NameProvider),
            (this.commentProvider = t.documentation.CommentProvider));
        }
        serialize(t, r) {
          let n = r ?? {},
            i = r?.replacer,
            s = a((l, u) => this.replacer(l, u, n), "defaultReplacer"),
            o = i ? (l, u) => i(l, u, s) : s;
          try {
            return (
              (this.currentDocument = Si(t)),
              JSON.stringify(t, o, r?.space)
            );
          } finally {
            this.currentDocument = void 0;
          }
        }
        deserialize(t, r) {
          let n = r ?? {},
            i = JSON.parse(t);
          return (this.linkNode(i, i, n), i);
        }
        replacer(
          t,
          r,
          {
            refText: n,
            sourceText: i,
            textRegions: s,
            comments: o,
            uriConverter: l,
          },
        ) {
          var u, h, f, d;
          if (!this.ignoreProperties.has(t))
            if (li(r)) {
              let p = r.ref,
                m = n ? r.$refText : void 0;
              if (p) {
                let g = Si(p),
                  y = "";
                this.currentDocument &&
                  this.currentDocument !== g &&
                  (l ? (y = l(g.uri, r)) : (y = g.uri.toString()));
                let b = this.astNodeLocator.getAstNodePath(p);
                return { $ref: `${y}#${b}`, $refText: m };
              } else
                return {
                  $error:
                    (h =
                      (u = r.error) === null || u === void 0
                        ? void 0
                        : u.message) !== null && h !== void 0
                      ? h
                      : "Could not resolve reference",
                  $refText: m,
                };
            } else if (cn(r)) {
              let p;
              if (
                (s &&
                  ((p = this.addAstNodeRegionWithAssignmentsTo(
                    Object.assign({}, r),
                  )),
                  (!t || r.$document) &&
                    p?.$textRegion &&
                    (p.$textRegion.documentURI =
                      (f = this.currentDocument) === null || f === void 0
                        ? void 0
                        : f.uri.toString())),
                i &&
                  !t &&
                  (p ?? (p = Object.assign({}, r)),
                  (p.$sourceText =
                    (d = r.$cstNode) === null || d === void 0
                      ? void 0
                      : d.text)),
                o)
              ) {
                p ?? (p = Object.assign({}, r));
                let m = this.commentProvider.getComment(r);
                m && (p.$comment = m.replace(/\r/g, ""));
              }
              return p ?? r;
            } else return r;
        }
        addAstNodeRegionWithAssignmentsTo(t) {
          let r = a(
            (n) => ({
              offset: n.offset,
              end: n.end,
              length: n.length,
              range: n.range,
            }),
            "createDocumentSegment",
          );
          if (t.$cstNode) {
            let n = (t.$textRegion = r(t.$cstNode)),
              i = (n.assignments = {});
            return (
              Object.keys(t)
                .filter((s) => !s.startsWith("$"))
                .forEach((s) => {
                  let o = U6(t.$cstNode, s).map(r);
                  o.length !== 0 && (i[s] = o);
                }),
              t
            );
          }
        }
        linkNode(t, r, n, i, s, o) {
          for (let [u, h] of Object.entries(t))
            if (Array.isArray(h))
              for (let f = 0; f < h.length; f++) {
                let d = h[f];
                ott(d)
                  ? (h[f] = this.reviveReference(t, u, r, d, n))
                  : cn(d) && this.linkNode(d, r, n, t, u, f);
              }
            else
              ott(h)
                ? (t[u] = this.reviveReference(t, u, r, h, n))
                : cn(h) && this.linkNode(h, r, n, t, u);
          let l = t;
          ((l.$container = i),
            (l.$containerProperty = s),
            (l.$containerIndex = o));
        }
        reviveReference(t, r, n, i, s) {
          let o = i.$refText,
            l = i.$error;
          if (i.$ref) {
            let u = this.getRefNode(n, i.$ref, s.uriConverter);
            if (cn(u))
              return (
                o || (o = this.nameProvider.getName(u)),
                { $refText: o ?? "", ref: u }
              );
            l = u;
          }
          if (l) {
            let u = { $refText: o ?? "" };
            return (
              (u.error = {
                container: t,
                property: r,
                message: l,
                reference: u,
              }),
              u
            );
          } else return;
        }
        getRefNode(t, r, n) {
          try {
            let i = r.indexOf("#");
            if (i === 0) {
              let u = this.astNodeLocator.getAstNode(t, r.substring(1));
              return u || "Could not resolve path: " + r;
            }
            if (i < 0) {
              let u = n ? n(r) : Hi.parse(r),
                h = this.langiumDocuments.getDocument(u);
              return h
                ? h.parseResult.value
                : "Could not find document for URI: " + r;
            }
            let s = n ? n(r.substring(0, i)) : Hi.parse(r.substring(0, i)),
              o = this.langiumDocuments.getDocument(s);
            if (!o) return "Could not find document for URI: " + r;
            if (i === r.length - 1) return o.parseResult.value;
            let l = this.astNodeLocator.getAstNode(
              o.parseResult.value,
              r.substring(i + 1),
            );
            return l || "Could not resolve URI: " + r;
          } catch (i) {
            return String(i);
          }
        }
      };
    });
  var sy,
    ER = x(() => {
      "use strict";
      Uo();
      sy = class {
        static {
          a(this, "DefaultServiceRegistry");
        }
        get map() {
          return this.fileExtensionMap;
        }
        constructor(t) {
          ((this.languageIdMap = new Map()),
            (this.fileExtensionMap = new Map()),
            (this.textDocuments = t?.workspace.TextDocuments));
        }
        register(t) {
          let r = t.LanguageMetaData;
          for (let n of r.fileExtensions)
            (this.fileExtensionMap.has(n) &&
              console.warn(
                `The file extension ${n} is used by multiple languages. It is now assigned to '${r.languageId}'.`,
              ),
              this.fileExtensionMap.set(n, t));
          (this.languageIdMap.set(r.languageId, t),
            this.languageIdMap.size === 1
              ? (this.singleton = t)
              : (this.singleton = void 0));
        }
        getServices(t) {
          var r, n;
          if (this.singleton !== void 0) return this.singleton;
          if (this.languageIdMap.size === 0)
            throw new Error(
              "The service registry is empty. Use `register` to register the services of a language.",
            );
          let i =
            (n =
              (r = this.textDocuments) === null || r === void 0
                ? void 0
                : r.get(t)) === null || n === void 0
              ? void 0
              : n.languageId;
          if (i !== void 0) {
            let l = this.languageIdMap.get(i);
            if (l) return l;
          }
          let s = Yi.extname(t),
            o = this.fileExtensionMap.get(s);
          if (!o)
            throw i
              ? new Error(
                  `The service registry contains no services for the extension '${s}' for language '${i}'.`,
                )
              : new Error(
                  `The service registry contains no services for the extension '${s}'.`,
                );
          return o;
        }
        hasServices(t) {
          try {
            return (this.getServices(t), !0);
          } catch {
            return !1;
          }
        }
        get all() {
          return Array.from(this.languageIdMap.values());
        }
      };
    });
  function zh(e) {
    return { code: e };
  }
  var hm,
    ay,
    oy = x(() => {
      "use strict";
      Ps();
      om();
      fa();
      ms();
      a(zh, "diagnosticData");
      (function (e) {
        e.all = ["fast", "slow", "built-in"];
      })(hm || (hm = {}));
      ay = class {
        static {
          a(this, "ValidationRegistry");
        }
        constructor(t) {
          ((this.entries = new Xa()),
            (this.entriesBefore = []),
            (this.entriesAfter = []),
            (this.reflection = t.shared.AstReflection));
        }
        register(t, r = this, n = "fast") {
          if (n === "built-in")
            throw new Error(
              "The 'built-in' category is reserved for lexer, parser, and linker errors.",
            );
          for (let [i, s] of Object.entries(t)) {
            let o = s;
            if (Array.isArray(o))
              for (let l of o) {
                let u = {
                  check: this.wrapValidationException(l, r),
                  category: n,
                };
                this.addEntry(i, u);
              }
            else if (typeof o == "function") {
              let l = {
                check: this.wrapValidationException(o, r),
                category: n,
              };
              this.addEntry(i, l);
            } else Po(o);
          }
        }
        wrapValidationException(t, r) {
          return async (n, i, s) => {
            await this.handleException(
              () => t.call(r, n, i, s),
              "An error occurred during validation",
              i,
              n,
            );
          };
        }
        async handleException(t, r, n, i) {
          try {
            await t();
          } catch (s) {
            if (Wo(s)) throw s;
            (console.error(`${r}:`, s),
              s instanceof Error && s.stack && console.error(s.stack));
            let o = s instanceof Error ? s.message : String(s);
            n("error", `${r}: ${o}`, { node: i });
          }
        }
        addEntry(t, r) {
          if (t === "AstNode") {
            this.entries.add("AstNode", r);
            return;
          }
          for (let n of this.reflection.getAllSubTypes(t))
            this.entries.add(n, r);
        }
        getChecks(t, r) {
          let n = kr(this.entries.get(t)).concat(this.entries.get("AstNode"));
          return (
            r && (n = n.filter((i) => r.includes(i.category))),
            n.map((i) => i.check)
          );
        }
        registerBeforeDocument(t, r = this) {
          this.entriesBefore.push(
            this.wrapPreparationException(
              t,
              "An error occurred during set-up of the validation",
              r,
            ),
          );
        }
        registerAfterDocument(t, r = this) {
          this.entriesAfter.push(
            this.wrapPreparationException(
              t,
              "An error occurred during tear-down of the validation",
              r,
            ),
          );
        }
        wrapPreparationException(t, r, n) {
          return async (i, s, o, l) => {
            await this.handleException(() => t.call(n, i, s, o, l), r, s, i);
          };
        }
        get checksBefore() {
          return this.entriesBefore;
        }
        get checksAfter() {
          return this.entriesAfter;
        }
      };
    });
  function ltt(e) {
    if (e.range) return e.range;
    let t;
    return (
      typeof e.property == "string"
        ? (t = p1(e.node.$cstNode, e.property, e.index))
        : typeof e.keyword == "string" &&
          (t = q6(e.node.$cstNode, e.keyword, e.index)),
      t ?? (t = e.node.$cstNode),
      t
        ? t.range
        : { start: { line: 0, character: 0 }, end: { line: 0, character: 0 } }
    );
  }
  function IS(e) {
    switch (e) {
      case "error":
        return 1;
      case "warning":
        return 2;
      case "info":
        return 3;
      case "hint":
        return 4;
      default:
        throw new Error("Invalid diagnostic severity: " + e);
    }
  }
  function ctt(e) {
    switch (e) {
      case "error":
        return zh(da.LexingError);
      case "warning":
        return zh(da.LexingWarning);
      case "info":
        return zh(da.LexingInfo);
      case "hint":
        return zh(da.LexingHint);
      default:
        throw new Error("Invalid diagnostic severity: " + e);
    }
  }
  var ly,
    da,
    AR = x(() => {
      "use strict";
      ha();
      Ha();
      Vi();
      Ua();
      fa();
      oy();
      ly = class {
        static {
          a(this, "DefaultDocumentValidator");
        }
        constructor(t) {
          ((this.validationRegistry = t.validation.ValidationRegistry),
            (this.metadata = t.LanguageMetaData));
        }
        async validateDocument(t, r = {}, n = Ve.CancellationToken.None) {
          let i = t.parseResult,
            s = [];
          if (
            (await kn(n),
            (!r.categories || r.categories.includes("built-in")) &&
              (this.processLexingErrors(i, s, r),
              (r.stopAfterLexingErrors &&
                s.some((o) => {
                  var l;
                  return (
                    ((l = o.data) === null || l === void 0
                      ? void 0
                      : l.code) === da.LexingError
                  );
                })) ||
                (this.processParsingErrors(i, s, r),
                r.stopAfterParsingErrors &&
                  s.some((o) => {
                    var l;
                    return (
                      ((l = o.data) === null || l === void 0
                        ? void 0
                        : l.code) === da.ParsingError
                    );
                  })) ||
                (this.processLinkingErrors(t, s, r),
                r.stopAfterLinkingErrors &&
                  s.some((o) => {
                    var l;
                    return (
                      ((l = o.data) === null || l === void 0
                        ? void 0
                        : l.code) === da.LinkingError
                    );
                  }))))
          )
            return s;
          try {
            s.push(...(await this.validateAst(i.value, r, n)));
          } catch (o) {
            if (Wo(o)) throw o;
            console.error("An error occurred during validation:", o);
          }
          return (await kn(n), s);
        }
        processLexingErrors(t, r, n) {
          var i, s, o;
          let l = [
            ...t.lexerErrors,
            ...((s =
              (i = t.lexerReport) === null || i === void 0
                ? void 0
                : i.diagnostics) !== null && s !== void 0
              ? s
              : []),
          ];
          for (let u of l) {
            let h = (o = u.severity) !== null && o !== void 0 ? o : "error",
              f = {
                severity: IS(h),
                range: {
                  start: { line: u.line - 1, character: u.column - 1 },
                  end: { line: u.line - 1, character: u.column + u.length - 1 },
                },
                message: u.message,
                data: ctt(h),
                source: this.getSource(),
              };
            r.push(f);
          }
        }
        processParsingErrors(t, r, n) {
          for (let i of t.parserErrors) {
            let s;
            if (isNaN(i.token.startOffset)) {
              if ("previousToken" in i) {
                let o = i.previousToken;
                if (isNaN(o.startOffset)) {
                  let l = { line: 0, character: 0 };
                  s = { start: l, end: l };
                } else {
                  let l = { line: o.endLine - 1, character: o.endColumn };
                  s = { start: l, end: l };
                }
              }
            } else s = Pd(i.token);
            if (s) {
              let o = {
                severity: IS("error"),
                range: s,
                message: i.message,
                data: zh(da.ParsingError),
                source: this.getSource(),
              };
              r.push(o);
            }
          }
        }
        processLinkingErrors(t, r, n) {
          for (let i of t.references) {
            let s = i.error;
            if (s) {
              let o = {
                node: s.container,
                property: s.property,
                index: s.index,
                data: {
                  code: da.LinkingError,
                  containerType: s.container.$type,
                  property: s.property,
                  refText: s.reference.$refText,
                },
              };
              r.push(this.toDiagnostic("error", s.message, o));
            }
          }
        }
        async validateAst(t, r, n = Ve.CancellationToken.None) {
          let i = [],
            s = a((o, l, u) => {
              i.push(this.toDiagnostic(o, l, u));
            }, "acceptor");
          return (
            await this.validateAstBefore(t, r, s, n),
            await this.validateAstNodes(t, r, s, n),
            await this.validateAstAfter(t, r, s, n),
            i
          );
        }
        async validateAstBefore(t, r, n, i = Ve.CancellationToken.None) {
          var s;
          let o = this.validationRegistry.checksBefore;
          for (let l of o)
            (await kn(i),
              await l(
                t,
                n,
                (s = r.categories) !== null && s !== void 0 ? s : [],
                i,
              ));
        }
        async validateAstNodes(t, r, n, i = Ve.CancellationToken.None) {
          await Promise.all(
            ua(t).map(async (s) => {
              await kn(i);
              let o = this.validationRegistry.getChecks(s.$type, r.categories);
              for (let l of o) await l(s, n, i);
            }),
          );
        }
        async validateAstAfter(t, r, n, i = Ve.CancellationToken.None) {
          var s;
          let o = this.validationRegistry.checksAfter;
          for (let l of o)
            (await kn(i),
              await l(
                t,
                n,
                (s = r.categories) !== null && s !== void 0 ? s : [],
                i,
              ));
        }
        toDiagnostic(t, r, n) {
          return {
            message: r,
            range: ltt(n),
            severity: IS(t),
            code: n.code,
            codeDescription: n.codeDescription,
            tags: n.tags,
            relatedInformation: n.relatedInformation,
            data: n.data,
            source: this.getSource(),
          };
        }
        getSource() {
          return this.metadata.languageId;
        }
      };
      a(ltt, "getDiagnosticRange");
      a(IS, "toDiagnosticSeverity");
      a(ctt, "toDiagnosticData");
      (function (e) {
        ((e.LexingError = "lexing-error"),
          (e.LexingWarning = "lexing-warning"),
          (e.LexingInfo = "lexing-info"),
          (e.LexingHint = "lexing-hint"),
          (e.ParsingError = "parsing-error"),
          (e.LinkingError = "linking-error"));
      })(da || (da = {}));
    });
  var cy,
    uy,
    LR = x(() => {
      "use strict";
      ha();
      Wa();
      Vi();
      Ua();
      fa();
      Uo();
      ((cy = class {
        static {
          a(this, "DefaultAstNodeDescriptionProvider");
        }
        constructor(t) {
          ((this.astNodeLocator = t.workspace.AstNodeLocator),
            (this.nameProvider = t.references.NameProvider));
        }
        createDescription(t, r, n) {
          let i = n ?? Si(t);
          r ?? (r = this.nameProvider.getName(t));
          let s = this.astNodeLocator.getAstNodePath(t);
          if (!r) throw new Error(`Node at path ${s} has no name.`);
          let o,
            l = a(() => {
              var u;
              return (
                o ??
                (o = bh(
                  (u = this.nameProvider.getNameNode(t)) !== null &&
                    u !== void 0
                    ? u
                    : t.$cstNode,
                ))
              );
            }, "nameSegmentGetter");
          return {
            node: t,
            name: r,
            get nameSegment() {
              return l();
            },
            selectionSegment: bh(t.$cstNode),
            type: t.$type,
            documentUri: i.uri,
            path: s,
          };
        }
      }),
        (uy = class {
          static {
            a(this, "DefaultReferenceDescriptionProvider");
          }
          constructor(t) {
            this.nodeLocator = t.workspace.AstNodeLocator;
          }
          async createDescriptions(t, r = Ve.CancellationToken.None) {
            let n = [],
              i = t.parseResult.value;
            for (let s of ua(i))
              (await kn(r),
                Sp(s)
                  .filter((o) => !yh(o))
                  .forEach((o) => {
                    let l = this.createDescription(o);
                    l && n.push(l);
                  }));
            return n;
          }
          createDescription(t) {
            let r = t.reference.$nodeDescription,
              n = t.reference.$refNode;
            if (!r || !n) return;
            let i = Si(t.container).uri;
            return {
              sourceUri: i,
              sourcePath: this.nodeLocator.getAstNodePath(t.container),
              targetUri: r.documentUri,
              targetPath: r.path,
              segment: bh(n),
              local: Yi.equals(r.documentUri, i),
            };
          }
        }));
    });
  var hy,
    RR = x(() => {
      "use strict";
      hy = class {
        static {
          a(this, "DefaultAstNodeLocator");
        }
        constructor() {
          ((this.segmentSeparator = "/"), (this.indexSeparator = "@"));
        }
        getAstNodePath(t) {
          if (t.$container) {
            let r = this.getAstNodePath(t.$container),
              n = this.getPathSegment(t);
            return r + this.segmentSeparator + n;
          }
          return "";
        }
        getPathSegment({ $containerProperty: t, $containerIndex: r }) {
          if (!t) throw new Error("Missing '$containerProperty' in AST node.");
          return r !== void 0 ? t + this.indexSeparator + r : t;
        }
        getAstNode(t, r) {
          return r.split(this.segmentSeparator).reduce((i, s) => {
            if (!i || s.length === 0) return i;
            let o = s.indexOf(this.indexSeparator);
            if (o > 0) {
              let l = s.substring(0, o),
                u = parseInt(s.substring(o + 1)),
                h = i[l];
              return h?.[u];
            }
            return i[s];
          }, t);
        }
      };
    });
  var rn = {};
  var MS = x(() => {
    "use strict";
    qe(rn, Ts(dR(), 1));
  });
  var fy,
    DR = x(() => {
      "use strict";
      MS();
      fa();
      fy = class {
        static {
          a(this, "DefaultConfigurationProvider");
        }
        constructor(t) {
          ((this._ready = new qi()),
            (this.settings = {}),
            (this.workspaceConfig = !1),
            (this.onConfigurationSectionUpdateEmitter = new rn.Emitter()),
            (this.serviceRegistry = t.ServiceRegistry));
        }
        get ready() {
          return this._ready.promise;
        }
        initialize(t) {
          var r, n;
          this.workspaceConfig =
            (n =
              (r = t.capabilities.workspace) === null || r === void 0
                ? void 0
                : r.configuration) !== null && n !== void 0
              ? n
              : !1;
        }
        async initialized(t) {
          if (this.workspaceConfig) {
            if (t.register) {
              let r = this.serviceRegistry.all;
              t.register({
                section: r.map((n) =>
                  this.toSectionName(n.LanguageMetaData.languageId),
                ),
              });
            }
            if (t.fetchConfiguration) {
              let r = this.serviceRegistry.all.map((i) => ({
                  section: this.toSectionName(i.LanguageMetaData.languageId),
                })),
                n = await t.fetchConfiguration(r);
              r.forEach((i, s) => {
                this.updateSectionConfiguration(i.section, n[s]);
              });
            }
          }
          this._ready.resolve();
        }
        updateConfiguration(t) {
          t.settings &&
            Object.keys(t.settings).forEach((r) => {
              let n = t.settings[r];
              (this.updateSectionConfiguration(r, n),
                this.onConfigurationSectionUpdateEmitter.fire({
                  section: r,
                  configuration: n,
                }));
            });
        }
        updateSectionConfiguration(t, r) {
          this.settings[t] = r;
        }
        async getConfiguration(t, r) {
          await this.ready;
          let n = this.toSectionName(t);
          if (this.settings[n]) return this.settings[n][r];
        }
        toSectionName(t) {
          return `${t}`;
        }
        get onConfigurationSectionUpdate() {
          return this.onConfigurationSectionUpdateEmitter.event;
        }
      };
    });
  var Xc,
    NR = x(() => {
      "use strict";
      (function (e) {
        function t(r) {
          return { dispose: a(async () => await r(), "dispose") };
        }
        (a(t, "create"), (e.create = t));
      })(Xc || (Xc = {}));
    });
  var dy,
    IR = x(() => {
      "use strict";
      ha();
      NR();
      om();
      fa();
      ms();
      oy();
      am();
      dy = class {
        static {
          a(this, "DefaultDocumentBuilder");
        }
        constructor(t) {
          ((this.updateBuildOptions = {
            validation: { categories: ["built-in", "fast"] },
          }),
            (this.updateListeners = []),
            (this.buildPhaseListeners = new Xa()),
            (this.documentPhaseListeners = new Xa()),
            (this.buildState = new Map()),
            (this.documentBuildWaiters = new Map()),
            (this.currentState = Pr.Changed),
            (this.langiumDocuments = t.workspace.LangiumDocuments),
            (this.langiumDocumentFactory = t.workspace.LangiumDocumentFactory),
            (this.textDocuments = t.workspace.TextDocuments),
            (this.indexManager = t.workspace.IndexManager),
            (this.serviceRegistry = t.ServiceRegistry));
        }
        async build(t, r = {}, n = Ve.CancellationToken.None) {
          var i, s;
          for (let o of t) {
            let l = o.uri.toString();
            if (o.state === Pr.Validated) {
              if (typeof r.validation == "boolean" && r.validation)
                ((o.state = Pr.IndexedReferences),
                  (o.diagnostics = void 0),
                  this.buildState.delete(l));
              else if (typeof r.validation == "object") {
                let u = this.buildState.get(l),
                  h =
                    (i = u?.result) === null || i === void 0
                      ? void 0
                      : i.validationChecks;
                if (h) {
                  let d = (
                    (s = r.validation.categories) !== null && s !== void 0
                      ? s
                      : hm.all
                  ).filter((p) => !h.includes(p));
                  d.length > 0 &&
                    (this.buildState.set(l, {
                      completed: !1,
                      options: {
                        validation: Object.assign(
                          Object.assign({}, r.validation),
                          { categories: d },
                        ),
                      },
                      result: u.result,
                    }),
                    (o.state = Pr.IndexedReferences));
                }
              }
            } else this.buildState.delete(l);
          }
          ((this.currentState = Pr.Changed),
            await this.emitUpdate(
              t.map((o) => o.uri),
              [],
            ),
            await this.buildDocuments(t, r, n));
        }
        async update(t, r, n = Ve.CancellationToken.None) {
          this.currentState = Pr.Changed;
          for (let o of r)
            (this.langiumDocuments.deleteDocument(o),
              this.buildState.delete(o.toString()),
              this.indexManager.remove(o));
          for (let o of t) {
            if (!this.langiumDocuments.invalidateDocument(o)) {
              let u = this.langiumDocumentFactory.fromModel(
                { $type: "INVALID" },
                o,
              );
              ((u.state = Pr.Changed), this.langiumDocuments.addDocument(u));
            }
            this.buildState.delete(o.toString());
          }
          let i = kr(t)
            .concat(r)
            .map((o) => o.toString())
            .toSet();
          (this.langiumDocuments.all
            .filter((o) => !i.has(o.uri.toString()) && this.shouldRelink(o, i))
            .forEach((o) => {
              (this.serviceRegistry
                .getServices(o.uri)
                .references.Linker.unlink(o),
                (o.state = Math.min(o.state, Pr.ComputedScopes)),
                (o.diagnostics = void 0));
            }),
            await this.emitUpdate(t, r),
            await kn(n));
          let s = this.sortDocuments(
            this.langiumDocuments.all
              .filter((o) => {
                var l;
                return (
                  o.state < Pr.Linked ||
                  !(
                    !(
                      (l = this.buildState.get(o.uri.toString())) === null ||
                      l === void 0
                    ) && l.completed
                  )
                );
              })
              .toArray(),
          );
          await this.buildDocuments(s, this.updateBuildOptions, n);
        }
        async emitUpdate(t, r) {
          await Promise.all(this.updateListeners.map((n) => n(t, r)));
        }
        sortDocuments(t) {
          let r = 0,
            n = t.length - 1;
          for (; r < n; ) {
            for (; r < t.length && this.hasTextDocument(t[r]); ) r++;
            for (; n >= 0 && !this.hasTextDocument(t[n]); ) n--;
            r < n && ([t[r], t[n]] = [t[n], t[r]]);
          }
          return t;
        }
        hasTextDocument(t) {
          var r;
          return !!(
            !((r = this.textDocuments) === null || r === void 0) && r.get(t.uri)
          );
        }
        shouldRelink(t, r) {
          return t.references.some((n) => n.error !== void 0)
            ? !0
            : this.indexManager.isAffected(t, r);
        }
        onUpdate(t) {
          return (
            this.updateListeners.push(t),
            Xc.create(() => {
              let r = this.updateListeners.indexOf(t);
              r >= 0 && this.updateListeners.splice(r, 1);
            })
          );
        }
        async buildDocuments(t, r, n) {
          (this.prepareBuild(t, r),
            await this.runCancelable(t, Pr.Parsed, n, (s) =>
              this.langiumDocumentFactory.update(s, n),
            ),
            await this.runCancelable(t, Pr.IndexedContent, n, (s) =>
              this.indexManager.updateContent(s, n),
            ),
            await this.runCancelable(t, Pr.ComputedScopes, n, async (s) => {
              let o = this.serviceRegistry.getServices(s.uri).references
                .ScopeComputation;
              s.precomputedScopes = await o.computeLocalScopes(s, n);
            }),
            await this.runCancelable(t, Pr.Linked, n, (s) =>
              this.serviceRegistry
                .getServices(s.uri)
                .references.Linker.link(s, n),
            ),
            await this.runCancelable(t, Pr.IndexedReferences, n, (s) =>
              this.indexManager.updateReferences(s, n),
            ));
          let i = t.filter((s) => this.shouldValidate(s));
          await this.runCancelable(i, Pr.Validated, n, (s) =>
            this.validate(s, n),
          );
          for (let s of t) {
            let o = this.buildState.get(s.uri.toString());
            o && (o.completed = !0);
          }
        }
        prepareBuild(t, r) {
          for (let n of t) {
            let i = n.uri.toString(),
              s = this.buildState.get(i);
            (!s || s.completed) &&
              this.buildState.set(i, {
                completed: !1,
                options: r,
                result: s?.result,
              });
          }
        }
        async runCancelable(t, r, n, i) {
          let s = t.filter((l) => l.state < r);
          for (let l of s)
            (await kn(n),
              await i(l),
              (l.state = r),
              await this.notifyDocumentPhase(l, r, n));
          let o = t.filter((l) => l.state === r);
          (await this.notifyBuildPhase(o, r, n), (this.currentState = r));
        }
        onBuildPhase(t, r) {
          return (
            this.buildPhaseListeners.add(t, r),
            Xc.create(() => {
              this.buildPhaseListeners.delete(t, r);
            })
          );
        }
        onDocumentPhase(t, r) {
          return (
            this.documentPhaseListeners.add(t, r),
            Xc.create(() => {
              this.documentPhaseListeners.delete(t, r);
            })
          );
        }
        waitUntil(t, r, n) {
          let i;
          if (
            (r && "path" in r ? (i = r) : (n = r),
            n ?? (n = Ve.CancellationToken.None),
            i)
          ) {
            let s = this.langiumDocuments.getDocument(i);
            if (s && s.state > t) return Promise.resolve(i);
          }
          return this.currentState >= t
            ? Promise.resolve(void 0)
            : n.isCancellationRequested
              ? Promise.reject(zo)
              : new Promise((s, o) => {
                  let l = this.onBuildPhase(t, () => {
                      if ((l.dispose(), u.dispose(), i)) {
                        let h = this.langiumDocuments.getDocument(i);
                        s(h?.uri);
                      } else s(void 0);
                    }),
                    u = n.onCancellationRequested(() => {
                      (l.dispose(), u.dispose(), o(zo));
                    });
                });
        }
        async notifyDocumentPhase(t, r, n) {
          let s = this.documentPhaseListeners.get(r).slice();
          for (let o of s)
            try {
              await o(t, n);
            } catch (l) {
              if (!Wo(l)) throw l;
            }
        }
        async notifyBuildPhase(t, r, n) {
          if (t.length === 0) return;
          let s = this.buildPhaseListeners.get(r).slice();
          for (let o of s) (await kn(n), await o(t, n));
        }
        shouldValidate(t) {
          return !!this.getBuildOptions(t).validation;
        }
        async validate(t, r) {
          var n, i;
          let s = this.serviceRegistry.getServices(t.uri).validation
              .DocumentValidator,
            o = this.getBuildOptions(t).validation,
            l = typeof o == "object" ? o : void 0,
            u = await s.validateDocument(t, l, r);
          t.diagnostics ? t.diagnostics.push(...u) : (t.diagnostics = u);
          let h = this.buildState.get(t.uri.toString());
          if (h) {
            ((n = h.result) !== null && n !== void 0) || (h.result = {});
            let f = (i = l?.categories) !== null && i !== void 0 ? i : hm.all;
            h.result.validationChecks
              ? h.result.validationChecks.push(...f)
              : (h.result.validationChecks = [...f]);
          }
        }
        getBuildOptions(t) {
          var r, n;
          return (n =
            (r = this.buildState.get(t.uri.toString())) === null || r === void 0
              ? void 0
              : r.options) !== null && n !== void 0
            ? n
            : {};
        }
      };
    });
  var py,
    MR = x(() => {
      "use strict";
      Vi();
      DS();
      ha();
      ms();
      Uo();
      py = class {
        static {
          a(this, "DefaultIndexManager");
        }
        constructor(t) {
          ((this.symbolIndex = new Map()),
            (this.symbolByTypeIndex = new Vh()),
            (this.referenceIndex = new Map()),
            (this.documents = t.workspace.LangiumDocuments),
            (this.serviceRegistry = t.ServiceRegistry),
            (this.astReflection = t.AstReflection));
        }
        findAllReferences(t, r) {
          let n = Si(t).uri,
            i = [];
          return (
            this.referenceIndex.forEach((s) => {
              s.forEach((o) => {
                Yi.equals(o.targetUri, n) && o.targetPath === r && i.push(o);
              });
            }),
            kr(i)
          );
        }
        allElements(t, r) {
          let n = kr(this.symbolIndex.keys());
          return (
            r && (n = n.filter((i) => !r || r.has(i))),
            n.map((i) => this.getFileDescriptions(i, t)).flat()
          );
        }
        getFileDescriptions(t, r) {
          var n;
          return r
            ? this.symbolByTypeIndex.get(t, r, () => {
                var s;
                return (
                  (s = this.symbolIndex.get(t)) !== null && s !== void 0
                    ? s
                    : []
                ).filter((l) => this.astReflection.isSubtype(l.type, r));
              })
            : (n = this.symbolIndex.get(t)) !== null && n !== void 0
              ? n
              : [];
        }
        remove(t) {
          let r = t.toString();
          (this.symbolIndex.delete(r),
            this.symbolByTypeIndex.clear(r),
            this.referenceIndex.delete(r));
        }
        async updateContent(t, r = Ve.CancellationToken.None) {
          let i = await this.serviceRegistry
              .getServices(t.uri)
              .references.ScopeComputation.computeExports(t, r),
            s = t.uri.toString();
          (this.symbolIndex.set(s, i), this.symbolByTypeIndex.clear(s));
        }
        async updateReferences(t, r = Ve.CancellationToken.None) {
          let i = await this.serviceRegistry
            .getServices(t.uri)
            .workspace.ReferenceDescriptionProvider.createDescriptions(t, r);
          this.referenceIndex.set(t.uri.toString(), i);
        }
        isAffected(t, r) {
          let n = this.referenceIndex.get(t.uri.toString());
          return n
            ? n.some((i) => !i.local && r.has(i.targetUri.toString()))
            : !1;
        }
      };
    });
  var my,
    OR = x(() => {
      "use strict";
      ha();
      fa();
      Uo();
      my = class {
        static {
          a(this, "DefaultWorkspaceManager");
        }
        constructor(t) {
          ((this.initialBuildOptions = {}),
            (this._ready = new qi()),
            (this.serviceRegistry = t.ServiceRegistry),
            (this.langiumDocuments = t.workspace.LangiumDocuments),
            (this.documentBuilder = t.workspace.DocumentBuilder),
            (this.fileSystemProvider = t.workspace.FileSystemProvider),
            (this.mutex = t.workspace.WorkspaceLock));
        }
        get ready() {
          return this._ready.promise;
        }
        get workspaceFolders() {
          return this.folders;
        }
        initialize(t) {
          var r;
          this.folders =
            (r = t.workspaceFolders) !== null && r !== void 0 ? r : void 0;
        }
        initialized(t) {
          return this.mutex.write((r) => {
            var n;
            return this.initializeWorkspace(
              (n = this.folders) !== null && n !== void 0 ? n : [],
              r,
            );
          });
        }
        async initializeWorkspace(t, r = Ve.CancellationToken.None) {
          let n = await this.performStartup(t);
          (await kn(r),
            await this.documentBuilder.build(n, this.initialBuildOptions, r));
        }
        async performStartup(t) {
          let r = this.serviceRegistry.all.flatMap(
              (s) => s.LanguageMetaData.fileExtensions,
            ),
            n = [],
            i = a((s) => {
              (n.push(s),
                this.langiumDocuments.hasDocument(s.uri) ||
                  this.langiumDocuments.addDocument(s));
            }, "collector");
          return (
            await this.loadAdditionalDocuments(t, i),
            await Promise.all(
              t
                .map((s) => [s, this.getRootFolder(s)])
                .map(async (s) => this.traverseFolder(...s, r, i)),
            ),
            this._ready.resolve(),
            n
          );
        }
        loadAdditionalDocuments(t, r) {
          return Promise.resolve();
        }
        getRootFolder(t) {
          return Hi.parse(t.uri);
        }
        async traverseFolder(t, r, n, i) {
          let s = await this.fileSystemProvider.readDirectory(r);
          await Promise.all(
            s.map(async (o) => {
              if (this.includeEntry(t, o, n)) {
                if (o.isDirectory) await this.traverseFolder(t, o.uri, n, i);
                else if (o.isFile) {
                  let l = await this.langiumDocuments.getOrCreateDocument(
                    o.uri,
                  );
                  i(l);
                }
              }
            }),
          );
        }
        includeEntry(t, r, n) {
          let i = Yi.basename(r.uri);
          if (i.startsWith(".")) return !1;
          if (r.isDirectory) return i !== "node_modules" && i !== "out";
          if (r.isFile) {
            let s = Yi.extname(r.uri);
            return n.includes(s);
          }
          return !1;
        }
      };
    });
  function PS(e) {
    return Array.isArray(e) && (e.length === 0 || "name" in e[0]);
  }
  function BR(e) {
    return e && "modes" in e && "defaultMode" in e;
  }
  function PR(e) {
    return !PS(e) && !BR(e);
  }
  var gy,
    OS,
    Wh,
    BS = x(() => {
      "use strict";
      qc();
      ((gy = class {
        static {
          a(this, "DefaultLexerErrorMessageProvider");
        }
        buildUnexpectedCharactersMessage(t, r, n, i, s) {
          return Pp.buildUnexpectedCharactersMessage(t, r, n, i, s);
        }
        buildUnableToPopLexerModeMessage(t) {
          return Pp.buildUnableToPopLexerModeMessage(t);
        }
      }),
        (OS = { mode: "full" }),
        (Wh = class {
          static {
            a(this, "DefaultLexer");
          }
          constructor(t) {
            ((this.errorMessageProvider = t.parser.LexerErrorMessageProvider),
              (this.tokenBuilder = t.parser.TokenBuilder));
            let r = this.tokenBuilder.buildTokens(t.Grammar, {
              caseInsensitive: t.LanguageMetaData.caseInsensitive,
            });
            this.tokenTypes = this.toTokenTypeDictionary(r);
            let n = PR(r) ? Object.values(r) : r,
              i = t.LanguageMetaData.mode === "production";
            this.chevrotainLexer = new tn(n, {
              positionTracking: "full",
              skipValidations: i,
              errorMessageProvider: this.errorMessageProvider,
            });
          }
          get definition() {
            return this.tokenTypes;
          }
          tokenize(t, r = OS) {
            var n, i, s;
            let o = this.chevrotainLexer.tokenize(t);
            return {
              tokens: o.tokens,
              errors: o.errors,
              hidden: (n = o.groups.hidden) !== null && n !== void 0 ? n : [],
              report:
                (s = (i = this.tokenBuilder).flushLexingReport) === null ||
                s === void 0
                  ? void 0
                  : s.call(i, t),
            };
          }
          toTokenTypeDictionary(t) {
            if (PR(t)) return t;
            let r = BR(t) ? Object.values(t.modes).flat() : t,
              n = {};
            return (r.forEach((i) => (n[i.name] = i)), n);
          }
        }));
      a(PS, "isTokenTypeArray");
      a(BR, "isIMultiModeLexerDefinition");
      a(PR, "isTokenTypeDictionary");
    });
  function GR(e, t, r) {
    let n, i;
    (typeof e == "string" ? ((i = t), (n = r)) : ((i = e.range.start), (n = t)),
      i || (i = gr.create(0, 0)));
    let s = ftt(e),
      o = zR(n),
      l = GAt({ lines: s, position: i, options: o });
    return jAt({ index: 0, tokens: l, position: i });
  }
  function VR(e, t) {
    let r = zR(t),
      n = ftt(e);
    if (n.length === 0) return !1;
    let i = n[0],
      s = n[n.length - 1],
      o = r.start,
      l = r.end;
    return !!o?.exec(i) && !!l?.exec(s);
  }
  function ftt(e) {
    let t = "";
    return (typeof e == "string" ? (t = e) : (t = e.text), t.split(P6));
  }
  function GAt(e) {
    var t, r, n;
    let i = [],
      s = e.position.line,
      o = e.position.character;
    for (let l = 0; l < e.lines.length; l++) {
      let u = l === 0,
        h = l === e.lines.length - 1,
        f = e.lines[l],
        d = 0;
      if (u && e.options.start) {
        let m =
          (t = e.options.start) === null || t === void 0 ? void 0 : t.exec(f);
        m && (d = m.index + m[0].length);
      } else {
        let m =
          (r = e.options.line) === null || r === void 0 ? void 0 : r.exec(f);
        m && (d = m.index + m[0].length);
      }
      if (h) {
        let m =
          (n = e.options.end) === null || n === void 0 ? void 0 : n.exec(f);
        m && (f = f.substring(0, m.index));
      }
      if (((f = f.substring(0, UAt(f))), $R(f, d) >= f.length)) {
        if (i.length > 0) {
          let m = gr.create(s, o);
          i.push({ type: "break", content: "", range: sr.create(m, m) });
        }
      } else {
        utt.lastIndex = d;
        let m = utt.exec(f);
        if (m) {
          let g = m[0],
            y = m[1],
            b = gr.create(s, o + d),
            k = gr.create(s, o + d + g.length);
          (i.push({ type: "tag", content: y, range: sr.create(b, k) }),
            (d += g.length),
            (d = $R(f, d)));
        }
        if (d < f.length) {
          let g = f.substring(d),
            y = Array.from(g.matchAll($At));
          i.push(...VAt(y, g, s, o + d));
        }
      }
      (s++, (o = 0));
    }
    return i.length > 0 && i[i.length - 1].type === "break"
      ? i.slice(0, -1)
      : i;
  }
  function VAt(e, t, r, n) {
    let i = [];
    if (e.length === 0) {
      let s = gr.create(r, n),
        o = gr.create(r, n + t.length);
      i.push({ type: "text", content: t, range: sr.create(s, o) });
    } else {
      let s = 0;
      for (let l of e) {
        let u = l.index,
          h = t.substring(s, u);
        h.length > 0 &&
          i.push({
            type: "text",
            content: t.substring(s, u),
            range: sr.create(gr.create(r, s + n), gr.create(r, u + n)),
          });
        let f = h.length + 1,
          d = l[1];
        if (
          (i.push({
            type: "inline-tag",
            content: d,
            range: sr.create(
              gr.create(r, s + f + n),
              gr.create(r, s + f + d.length + n),
            ),
          }),
          (f += d.length),
          l.length === 4)
        ) {
          f += l[2].length;
          let p = l[3];
          i.push({
            type: "text",
            content: p,
            range: sr.create(
              gr.create(r, s + f + n),
              gr.create(r, s + f + p.length + n),
            ),
          });
        } else
          i.push({
            type: "text",
            content: "",
            range: sr.create(gr.create(r, s + f + n), gr.create(r, s + f + n)),
          });
        s = u + l[0].length;
      }
      let o = t.substring(s);
      o.length > 0 &&
        i.push({
          type: "text",
          content: o,
          range: sr.create(gr.create(r, s + n), gr.create(r, s + n + o.length)),
        });
    }
    return i;
  }
  function $R(e, t) {
    let r = e.substring(t).match(zAt);
    return r ? t + r.index : e.length;
  }
  function UAt(e) {
    let t = e.match(WAt);
    if (t && typeof t.index == "number") return t.index;
  }
  function jAt(e) {
    var t, r, n, i;
    let s = gr.create(e.position.line, e.position.character);
    if (e.tokens.length === 0) return new FS([], sr.create(s, s));
    let o = [];
    for (; e.index < e.tokens.length; ) {
      let h = qAt(e, o[o.length - 1]);
      h && o.push(h);
    }
    let l =
        (r = (t = o[0]) === null || t === void 0 ? void 0 : t.range.start) !==
          null && r !== void 0
          ? r
          : s,
      u =
        (i =
          (n = o[o.length - 1]) === null || n === void 0
            ? void 0
            : n.range.end) !== null && i !== void 0
          ? i
          : s;
    return new FS(o, sr.create(l, u));
  }
  function qAt(e, t) {
    let r = e.tokens[e.index];
    if (r.type === "tag") return ptt(e, !1);
    if (r.type === "text" || r.type === "inline-tag") return dtt(e);
    (HAt(r, t), e.index++);
  }
  function HAt(e, t) {
    if (t) {
      let r = new $S("", e.range);
      "inlines" in t ? t.inlines.push(r) : t.content.inlines.push(r);
    }
  }
  function dtt(e) {
    let t = e.tokens[e.index],
      r = t,
      n = t,
      i = [];
    for (; t && t.type !== "break" && t.type !== "tag"; )
      (i.push(YAt(e)), (n = t), (t = e.tokens[e.index]));
    return new xy(i, sr.create(r.range.start, n.range.end));
  }
  function YAt(e) {
    return e.tokens[e.index].type === "inline-tag" ? ptt(e, !0) : mtt(e);
  }
  function ptt(e, t) {
    let r = e.tokens[e.index++],
      n = r.content.substring(1),
      i = e.tokens[e.index];
    if (i?.type === "text")
      if (t) {
        let s = mtt(e);
        return new yy(
          n,
          new xy([s], s.range),
          t,
          sr.create(r.range.start, s.range.end),
        );
      } else {
        let s = dtt(e);
        return new yy(n, s, t, sr.create(r.range.start, s.range.end));
      }
    else {
      let s = r.range;
      return new yy(n, new xy([], s), t, s);
    }
  }
  function mtt(e) {
    let t = e.tokens[e.index++];
    return new $S(t.content, t.range);
  }
  function zR(e) {
    if (!e) return zR({ start: "/**", end: "*/", line: "*" });
    let { start: t, end: r, line: n } = e;
    return { start: FR(t, !0), end: FR(r, !1), line: FR(n, !0) };
  }
  function FR(e, t) {
    if (typeof e == "string" || typeof e == "object") {
      let r = typeof e == "string" ? Eh(e) : e.source;
      return t ? new RegExp(`^\\s*${r}`) : new RegExp(`\\s*${r}\\s*$`);
    } else return e;
  }
  function XAt(e, t, r) {
    var n, i;
    if (e === "linkplain" || e === "linkcode" || e === "link") {
      let s = t.indexOf(" "),
        o = t;
      if (s > 0) {
        let u = $R(t, s);
        ((o = t.substring(u)), (t = t.substring(0, s)));
      }
      return (
        (e === "linkcode" || (e === "link" && r.link === "code")) &&
          (o = `\`${o}\``),
        (i =
          (n = r.renderLink) === null || n === void 0
            ? void 0
            : n.call(r, t, o)) !== null && i !== void 0
          ? i
          : KAt(t, o)
      );
    }
  }
  function KAt(e, t) {
    try {
      return (Hi.parse(e, !0), `[${t}](${e})`);
    } catch {
      return e;
    }
  }
  function htt(e) {
    return e.endsWith(`
`)
      ? `
`
      : `

`;
  }
  var utt,
    $At,
    zAt,
    WAt,
    FS,
    yy,
    xy,
    $S,
    WR = x(() => {
      "use strict";
      ZL();
      wp();
      Uo();
      a(GR, "parseJSDoc");
      a(VR, "isJSDoc");
      a(ftt, "getLines");
      ((utt = /\s*(@([\p{L}][\p{L}\p{N}]*)?)/uy),
        ($At = /\{(@[\p{L}][\p{L}\p{N}]*)(\s*)([^\r\n}]+)?\}/gu));
      a(GAt, "tokenize");
      a(VAt, "buildInlineTokens");
      ((zAt = /\S/), (WAt = /\s*$/));
      a($R, "skipWhitespace");
      a(UAt, "lastCharacter");
      a(jAt, "parseJSDocComment");
      a(qAt, "parseJSDocElement");
      a(HAt, "appendEmptyLine");
      a(dtt, "parseJSDocText");
      a(YAt, "parseJSDocInline");
      a(ptt, "parseJSDocTag");
      a(mtt, "parseJSDocLine");
      a(zR, "normalizeOptions");
      a(FR, "normalizeOption");
      ((FS = class {
        static {
          a(this, "JSDocCommentImpl");
        }
        constructor(t, r) {
          ((this.elements = t), (this.range = r));
        }
        getTag(t) {
          return this.getAllTags().find((r) => r.name === t);
        }
        getTags(t) {
          return this.getAllTags().filter((r) => r.name === t);
        }
        getAllTags() {
          return this.elements.filter((t) => "name" in t);
        }
        toString() {
          let t = "";
          for (let r of this.elements)
            if (t.length === 0) t = r.toString();
            else {
              let n = r.toString();
              t += htt(t) + n;
            }
          return t.trim();
        }
        toMarkdown(t) {
          let r = "";
          for (let n of this.elements)
            if (r.length === 0) r = n.toMarkdown(t);
            else {
              let i = n.toMarkdown(t);
              r += htt(r) + i;
            }
          return r.trim();
        }
      }),
        (yy = class {
          static {
            a(this, "JSDocTagImpl");
          }
          constructor(t, r, n, i) {
            ((this.name = t),
              (this.content = r),
              (this.inline = n),
              (this.range = i));
          }
          toString() {
            let t = `@${this.name}`,
              r = this.content.toString();
            return (
              this.content.inlines.length === 1
                ? (t = `${t} ${r}`)
                : this.content.inlines.length > 1 &&
                  (t = `${t}
${r}`),
              this.inline ? `{${t}}` : t
            );
          }
          toMarkdown(t) {
            var r, n;
            return (n =
              (r = t?.renderTag) === null || r === void 0
                ? void 0
                : r.call(t, this)) !== null && n !== void 0
              ? n
              : this.toMarkdownDefault(t);
          }
          toMarkdownDefault(t) {
            let r = this.content.toMarkdown(t);
            if (this.inline) {
              let s = XAt(this.name, r, t ?? {});
              if (typeof s == "string") return s;
            }
            let n = "";
            t?.tag === "italic" || t?.tag === void 0
              ? (n = "*")
              : t?.tag === "bold"
                ? (n = "**")
                : t?.tag === "bold-italic" && (n = "***");
            let i = `${n}@${this.name}${n}`;
            return (
              this.content.inlines.length === 1
                ? (i = `${i} \u2014 ${r}`)
                : this.content.inlines.length > 1 &&
                  (i = `${i}
${r}`),
              this.inline ? `{${i}}` : i
            );
          }
        }));
      a(XAt, "renderInlineTag");
      a(KAt, "renderLinkDefault");
      ((xy = class {
        static {
          a(this, "JSDocTextImpl");
        }
        constructor(t, r) {
          ((this.inlines = t), (this.range = r));
        }
        toString() {
          let t = "";
          for (let r = 0; r < this.inlines.length; r++) {
            let n = this.inlines[r],
              i = this.inlines[r + 1];
            ((t += n.toString()),
              i &&
                i.range.start.line > n.range.start.line &&
                (t += `
`));
          }
          return t;
        }
        toMarkdown(t) {
          let r = "";
          for (let n = 0; n < this.inlines.length; n++) {
            let i = this.inlines[n],
              s = this.inlines[n + 1];
            ((r += i.toMarkdown(t)),
              s &&
                s.range.start.line > i.range.start.line &&
                (r += `
`));
          }
          return r;
        }
      }),
        ($S = class {
          static {
            a(this, "JSDocLineImpl");
          }
          constructor(t, r) {
            ((this.text = t), (this.range = r));
          }
          toString() {
            return this.text;
          }
          toMarkdown() {
            return this.text;
          }
        }));
      a(htt, "fillNewlines");
    });
  var by,
    UR = x(() => {
      "use strict";
      Vi();
      WR();
      by = class {
        static {
          a(this, "JSDocDocumentationProvider");
        }
        constructor(t) {
          ((this.indexManager = t.shared.workspace.IndexManager),
            (this.commentProvider = t.documentation.CommentProvider));
        }
        getDocumentation(t) {
          let r = this.commentProvider.getComment(t);
          if (r && VR(r))
            return GR(r).toMarkdown({
              renderLink: a(
                (i, s) => this.documentationLinkRenderer(t, i, s),
                "renderLink",
              ),
              renderTag: a(
                (i) => this.documentationTagRenderer(t, i),
                "renderTag",
              ),
            });
        }
        documentationLinkRenderer(t, r, n) {
          var i;
          let s =
            (i = this.findNameInPrecomputedScopes(t, r)) !== null &&
            i !== void 0
              ? i
              : this.findNameInGlobalScope(t, r);
          if (s && s.nameSegment) {
            let o = s.nameSegment.range.start.line + 1,
              l = s.nameSegment.range.start.character + 1,
              u = s.documentUri.with({ fragment: `L${o},${l}` });
            return `[${n}](${u.toString()})`;
          } else return;
        }
        documentationTagRenderer(t, r) {}
        findNameInPrecomputedScopes(t, r) {
          let i = Si(t).precomputedScopes;
          if (!i) return;
          let s = t;
          do {
            let l = i.get(s).find((u) => u.name === r);
            if (l) return l;
            s = s.$container;
          } while (s);
        }
        findNameInGlobalScope(t, r) {
          return this.indexManager.allElements().find((i) => i.name === r);
        }
      };
    });
  var ky,
    jR = x(() => {
      "use strict";
      NS();
      Ua();
      ky = class {
        static {
          a(this, "DefaultCommentProvider");
        }
        constructor(t) {
          this.grammarConfig = () => t.parser.GrammarConfig;
        }
        getComment(t) {
          var r;
          return vR(t)
            ? t.$comment
            : (r = u6(
                  t.$cstNode,
                  this.grammarConfig().multilineCommentRules,
                )) === null || r === void 0
              ? void 0
              : r.text;
        }
      };
    });
  var Ty,
    qR,
    HR,
    YR = x(() => {
      "use strict";
      fa();
      MS();
      ((Ty = class {
        static {
          a(this, "DefaultAsyncParser");
        }
        constructor(t) {
          this.syncParser = t.parser.LangiumParser;
        }
        parse(t, r) {
          return Promise.resolve(this.syncParser.parse(t));
        }
      }),
        (qR = class {
          static {
            a(this, "AbstractThreadedAsyncParser");
          }
          constructor(t) {
            ((this.threadCount = 8),
              (this.terminationDelay = 200),
              (this.workerPool = []),
              (this.queue = []),
              (this.hydrator = t.serializer.Hydrator));
          }
          initializeWorkers() {
            for (; this.workerPool.length < this.threadCount; ) {
              let t = this.createWorker();
              (t.onReady(() => {
                if (this.queue.length > 0) {
                  let r = this.queue.shift();
                  r && (t.lock(), r.resolve(t));
                }
              }),
                this.workerPool.push(t));
            }
          }
          async parse(t, r) {
            let n = await this.acquireParserWorker(r),
              i = new qi(),
              s,
              o = r.onCancellationRequested(() => {
                s = setTimeout(() => {
                  this.terminateWorker(n);
                }, this.terminationDelay);
              });
            return (
              n
                .parse(t)
                .then((l) => {
                  let u = this.hydrator.hydrate(l);
                  i.resolve(u);
                })
                .catch((l) => {
                  i.reject(l);
                })
                .finally(() => {
                  (o.dispose(), clearTimeout(s));
                }),
              i.promise
            );
          }
          terminateWorker(t) {
            t.terminate();
            let r = this.workerPool.indexOf(t);
            r >= 0 && this.workerPool.splice(r, 1);
          }
          async acquireParserWorker(t) {
            this.initializeWorkers();
            for (let n of this.workerPool) if (n.ready) return (n.lock(), n);
            let r = new qi();
            return (
              t.onCancellationRequested(() => {
                let n = this.queue.indexOf(r);
                (n >= 0 && this.queue.splice(n, 1), r.reject(zo));
              }),
              this.queue.push(r),
              r.promise
            );
          }
        }),
        (HR = class {
          static {
            a(this, "ParserWorker");
          }
          get ready() {
            return this._ready;
          }
          get onReady() {
            return this.onReadyEmitter.event;
          }
          constructor(t, r, n, i) {
            ((this.onReadyEmitter = new rn.Emitter()),
              (this.deferred = new qi()),
              (this._ready = !0),
              (this._parsing = !1),
              (this.sendMessage = t),
              (this._terminate = i),
              r((s) => {
                let o = s;
                (this.deferred.resolve(o), this.unlock());
              }),
              n((s) => {
                (this.deferred.reject(s), this.unlock());
              }));
          }
          terminate() {
            (this.deferred.reject(zo), this._terminate());
          }
          lock() {
            this._ready = !1;
          }
          unlock() {
            ((this._parsing = !1),
              (this._ready = !0),
              this.onReadyEmitter.fire());
          }
          parse(t) {
            if (this._parsing) throw new Error("Parser worker is busy");
            return (
              (this._parsing = !0),
              (this.deferred = new qi()),
              this.sendMessage(t),
              this.deferred.promise
            );
          }
        }));
    });
  var Sy,
    XR = x(() => {
      "use strict";
      ha();
      fa();
      Sy = class {
        static {
          a(this, "DefaultWorkspaceLock");
        }
        constructor() {
          ((this.previousTokenSource = new Ve.CancellationTokenSource()),
            (this.writeQueue = []),
            (this.readQueue = []),
            (this.done = !0));
        }
        write(t) {
          this.cancelWrite();
          let r = AS();
          return (
            (this.previousTokenSource = r),
            this.enqueue(this.writeQueue, t, r.token)
          );
        }
        read(t) {
          return this.enqueue(this.readQueue, t);
        }
        enqueue(t, r, n = Ve.CancellationToken.None) {
          let i = new qi(),
            s = { action: r, deferred: i, cancellationToken: n };
          return (t.push(s), this.performNextOperation(), i.promise);
        }
        async performNextOperation() {
          if (!this.done) return;
          let t = [];
          if (this.writeQueue.length > 0) t.push(this.writeQueue.shift());
          else if (this.readQueue.length > 0)
            t.push(...this.readQueue.splice(0, this.readQueue.length));
          else return;
          ((this.done = !1),
            await Promise.all(
              t.map(
                async ({ action: r, deferred: n, cancellationToken: i }) => {
                  try {
                    let s = await Promise.resolve().then(() => r(i));
                    n.resolve(s);
                  } catch (s) {
                    Wo(s) ? n.resolve(void 0) : n.reject(s);
                  }
                },
              ),
            ),
            (this.done = !0),
            this.performNextOperation());
        }
        cancelWrite() {
          this.previousTokenSource.cancel();
        }
      };
    });
  var _y,
    KR = x(() => {
      "use strict";
      xS();
      Bo();
      Wa();
      Vi();
      om();
      Ua();
      _y = class {
        static {
          a(this, "DefaultHydrator");
        }
        constructor(t) {
          ((this.grammarElementIdMap = new Gh()),
            (this.tokenTypeIdMap = new Gh()),
            (this.grammar = t.Grammar),
            (this.lexer = t.parser.Lexer),
            (this.linker = t.references.Linker));
        }
        dehydrate(t) {
          return {
            lexerErrors: t.lexerErrors,
            lexerReport: t.lexerReport
              ? this.dehydrateLexerReport(t.lexerReport)
              : void 0,
            parserErrors: t.parserErrors.map((r) =>
              Object.assign(Object.assign({}, r), { message: r.message }),
            ),
            value: this.dehydrateAstNode(
              t.value,
              this.createDehyrationContext(t.value),
            ),
          };
        }
        dehydrateLexerReport(t) {
          return t;
        }
        createDehyrationContext(t) {
          let r = new Map(),
            n = new Map();
          for (let i of ua(t)) r.set(i, {});
          if (t.$cstNode) for (let i of xh(t.$cstNode)) n.set(i, {});
          return { astNodes: r, cstNodes: n };
        }
        dehydrateAstNode(t, r) {
          let n = r.astNodes.get(t);
          ((n.$type = t.$type),
            (n.$containerIndex = t.$containerIndex),
            (n.$containerProperty = t.$containerProperty),
            t.$cstNode !== void 0 &&
              (n.$cstNode = this.dehydrateCstNode(t.$cstNode, r)));
          for (let [i, s] of Object.entries(t))
            if (!i.startsWith("$"))
              if (Array.isArray(s)) {
                let o = [];
                n[i] = o;
                for (let l of s)
                  cn(l)
                    ? o.push(this.dehydrateAstNode(l, r))
                    : li(l)
                      ? o.push(this.dehydrateReference(l, r))
                      : o.push(l);
              } else
                cn(s)
                  ? (n[i] = this.dehydrateAstNode(s, r))
                  : li(s)
                    ? (n[i] = this.dehydrateReference(s, r))
                    : s !== void 0 && (n[i] = s);
          return n;
        }
        dehydrateReference(t, r) {
          let n = {};
          return (
            (n.$refText = t.$refText),
            t.$refNode && (n.$refNode = r.cstNodes.get(t.$refNode)),
            n
          );
        }
        dehydrateCstNode(t, r) {
          let n = r.cstNodes.get(t);
          return (
            K0(t)
              ? (n.fullText = t.fullText)
              : (n.grammarSource = this.getGrammarElementId(t.grammarSource)),
            (n.hidden = t.hidden),
            (n.astNode = r.astNodes.get(t.astNode)),
            za(t)
              ? (n.content = t.content.map((i) => this.dehydrateCstNode(i, r)))
              : zc(t) &&
                ((n.tokenType = t.tokenType.name),
                (n.offset = t.offset),
                (n.length = t.length),
                (n.startLine = t.range.start.line),
                (n.startColumn = t.range.start.character),
                (n.endLine = t.range.end.line),
                (n.endColumn = t.range.end.character)),
            n
          );
        }
        hydrate(t) {
          let r = t.value,
            n = this.createHydrationContext(r);
          return (
            "$cstNode" in r && this.hydrateCstNode(r.$cstNode, n),
            {
              lexerErrors: t.lexerErrors,
              lexerReport: t.lexerReport,
              parserErrors: t.parserErrors,
              value: this.hydrateAstNode(r, n),
            }
          );
        }
        createHydrationContext(t) {
          let r = new Map(),
            n = new Map();
          for (let s of ua(t)) r.set(s, {});
          let i;
          if (t.$cstNode)
            for (let s of xh(t.$cstNode)) {
              let o;
              ("fullText" in s
                ? ((o = new tm(s.fullText)), (i = o))
                : "content" in s
                  ? (o = new Bh())
                  : "tokenType" in s && (o = this.hydrateCstLeafNode(s)),
                o && (n.set(s, o), (o.root = i)));
            }
          return { astNodes: r, cstNodes: n };
        }
        hydrateAstNode(t, r) {
          let n = r.astNodes.get(t);
          ((n.$type = t.$type),
            (n.$containerIndex = t.$containerIndex),
            (n.$containerProperty = t.$containerProperty),
            t.$cstNode && (n.$cstNode = r.cstNodes.get(t.$cstNode)));
          for (let [i, s] of Object.entries(t))
            if (!i.startsWith("$"))
              if (Array.isArray(s)) {
                let o = [];
                n[i] = o;
                for (let l of s)
                  cn(l)
                    ? o.push(this.setParent(this.hydrateAstNode(l, r), n))
                    : li(l)
                      ? o.push(this.hydrateReference(l, n, i, r))
                      : o.push(l);
              } else
                cn(s)
                  ? (n[i] = this.setParent(this.hydrateAstNode(s, r), n))
                  : li(s)
                    ? (n[i] = this.hydrateReference(s, n, i, r))
                    : s !== void 0 && (n[i] = s);
          return n;
        }
        setParent(t, r) {
          return ((t.$container = r), t);
        }
        hydrateReference(t, r, n, i) {
          return this.linker.buildReference(
            r,
            n,
            i.cstNodes.get(t.$refNode),
            t.$refText,
          );
        }
        hydrateCstNode(t, r, n = 0) {
          let i = r.cstNodes.get(t);
          if (
            (typeof t.grammarSource == "number" &&
              (i.grammarSource = this.getGrammarElement(t.grammarSource)),
            (i.astNode = r.astNodes.get(t.astNode)),
            za(i))
          )
            for (let s of t.content) {
              let o = this.hydrateCstNode(s, r, n++);
              i.content.push(o);
            }
          return i;
        }
        hydrateCstLeafNode(t) {
          let r = this.getTokenType(t.tokenType),
            n = t.offset,
            i = t.length,
            s = t.startLine,
            o = t.startColumn,
            l = t.endLine,
            u = t.endColumn,
            h = t.hidden;
          return new Ph(
            n,
            i,
            {
              start: { line: s, character: o },
              end: { line: l, character: u },
            },
            r,
            h,
          );
        }
        getTokenType(t) {
          return this.lexer.definition[t];
        }
        getGrammarElementId(t) {
          if (t)
            return (
              this.grammarElementIdMap.size === 0 &&
                this.createGrammarElementIdMap(),
              this.grammarElementIdMap.get(t)
            );
        }
        getGrammarElement(t) {
          return (
            this.grammarElementIdMap.size === 0 &&
              this.createGrammarElementIdMap(),
            this.grammarElementIdMap.getKey(t)
          );
        }
        createGrammarElementIdMap() {
          let t = 0;
          for (let r of ua(this.grammar))
            i1(r) && this.grammarElementIdMap.set(r, t++);
        }
      };
    });
  function ci(e) {
    return {
      documentation: {
        CommentProvider: a((t) => new ky(t), "CommentProvider"),
        DocumentationProvider: a((t) => new by(t), "DocumentationProvider"),
      },
      parser: {
        AsyncParser: a((t) => new Ty(t), "AsyncParser"),
        GrammarConfig: a((t) => Q6(t), "GrammarConfig"),
        LangiumParser: a((t) => sR(t), "LangiumParser"),
        CompletionParser: a((t) => nR(t), "CompletionParser"),
        ValueConverter: a(() => new $h(), "ValueConverter"),
        TokenBuilder: a(() => new Il(), "TokenBuilder"),
        Lexer: a((t) => new Wh(t), "Lexer"),
        ParserErrorMessageProvider: a(
          () => new em(),
          "ParserErrorMessageProvider",
        ),
        LexerErrorMessageProvider: a(
          () => new gy(),
          "LexerErrorMessageProvider",
        ),
      },
      workspace: {
        AstNodeLocator: a(() => new hy(), "AstNodeLocator"),
        AstNodeDescriptionProvider: a(
          (t) => new cy(t),
          "AstNodeDescriptionProvider",
        ),
        ReferenceDescriptionProvider: a(
          (t) => new uy(t),
          "ReferenceDescriptionProvider",
        ),
      },
      references: {
        Linker: a((t) => new Q1(t), "Linker"),
        NameProvider: a(() => new Z1(), "NameProvider"),
        ScopeProvider: a((t) => new ny(t), "ScopeProvider"),
        ScopeComputation: a((t) => new ty(t), "ScopeComputation"),
        References: a((t) => new J1(t), "References"),
      },
      serializer: {
        Hydrator: a((t) => new _y(t), "Hydrator"),
        JsonSerializer: a((t) => new iy(t), "JsonSerializer"),
      },
      validation: {
        DocumentValidator: a((t) => new ly(t), "DocumentValidator"),
        ValidationRegistry: a((t) => new ay(t), "ValidationRegistry"),
      },
      shared: a(() => e.shared, "shared"),
    };
  }
  function ui(e) {
    return {
      ServiceRegistry: a((t) => new sy(t), "ServiceRegistry"),
      workspace: {
        LangiumDocuments: a((t) => new K1(t), "LangiumDocuments"),
        LangiumDocumentFactory: a((t) => new X1(t), "LangiumDocumentFactory"),
        DocumentBuilder: a((t) => new dy(t), "DocumentBuilder"),
        IndexManager: a((t) => new py(t), "IndexManager"),
        WorkspaceManager: a((t) => new my(t), "WorkspaceManager"),
        FileSystemProvider: a(
          (t) => e.fileSystemProvider(t),
          "FileSystemProvider",
        ),
        WorkspaceLock: a(() => new Sy(), "WorkspaceLock"),
        ConfigurationProvider: a((t) => new fy(t), "ConfigurationProvider"),
      },
    };
  }
  var QR = x(() => {
    "use strict";
    Z6();
    iR();
    aR();
    _S();
    oR();
    kR();
    TR();
    SR();
    _R();
    wR();
    NS();
    ER();
    AR();
    oy();
    LR();
    RR();
    DR();
    IR();
    am();
    MR();
    OR();
    BS();
    UR();
    jR();
    H1();
    YR();
    XR();
    KR();
    a(ci, "createDefaultCoreModule");
    a(ui, "createDefaultSharedCoreModule");
  });
  function Yr(e, t, r, n, i, s, o, l, u) {
    let h = [e, t, r, n, i, s, o, l, u].reduce(GS, {});
    return ktt(h);
  }
  function btt(e) {
    if (e && e[xtt]) for (let t of Object.values(e)) btt(t);
    return e;
  }
  function ktt(e, t) {
    let r = new Proxy(
      {},
      {
        deleteProperty: a(() => !1, "deleteProperty"),
        set: a(() => {
          throw new Error("Cannot set property on injected service container");
        }, "set"),
        get: a((n, i) => (i === xtt ? !0 : ytt(n, i, e, t || r)), "get"),
        getOwnPropertyDescriptor: a(
          (n, i) => (
            ytt(n, i, e, t || r),
            Object.getOwnPropertyDescriptor(n, i)
          ),
          "getOwnPropertyDescriptor",
        ),
        has: a((n, i) => i in e, "has"),
        ownKeys: a(() => [...Object.getOwnPropertyNames(e)], "ownKeys"),
      },
    );
    return r;
  }
  function ytt(e, t, r, n) {
    if (t in e) {
      if (e[t] instanceof Error)
        throw new Error(
          "Construction failure. Please make sure that your dependencies are constructable.",
          { cause: e[t] },
        );
      if (e[t] === gtt)
        throw new Error(
          'Cycle detected. Please make "' +
            String(t) +
            '" lazy. Visit https://langium.org/docs/reference/configuration-services/#resolving-cyclic-dependencies',
        );
      return e[t];
    } else if (t in r) {
      let i = r[t];
      e[t] = gtt;
      try {
        e[t] = typeof i == "function" ? i(n) : ktt(i, n);
      } catch (s) {
        throw ((e[t] = s instanceof Error ? s : void 0), s);
      }
      return e[t];
    } else return;
  }
  function GS(e, t) {
    if (t) {
      for (let [r, n] of Object.entries(t))
        if (n !== void 0) {
          let i = e[r];
          i !== null &&
          n !== null &&
          typeof i == "object" &&
          typeof n == "object"
            ? (e[r] = GS(i, n))
            : (e[r] = n);
        }
    }
    return e;
  }
  var ZR,
    xtt,
    gtt,
    JR = x(() => {
      "use strict";
      (function (e) {
        e.merge = (t, r) => GS(GS({}, t), r);
      })(ZR || (ZR = {}));
      a(Yr, "inject");
      xtt = Symbol("isProxy");
      a(btt, "eagerLoad");
      a(ktt, "_inject");
      gtt = Symbol();
      a(ytt, "_resolve");
      a(GS, "_merge");
    });
  var Ttt = x(() => {
    "use strict";
  });
  var Stt = x(() => {
    "use strict";
    jR();
    UR();
    WR();
  });
  var _tt = x(() => {
    "use strict";
  });
  var Ctt = x(() => {
    "use strict";
    Z6();
    _tt();
  });
  var tD,
    Uh,
    VS,
    eD,
    wtt = x(() => {
      "use strict";
      qc();
      _S();
      BS();
      tD = {
        indentTokenName: "INDENT",
        dedentTokenName: "DEDENT",
        whitespaceTokenName: "WS",
        ignoreIndentationDelimiters: [],
      };
      (function (e) {
        ((e.REGULAR = "indentation-sensitive"),
          (e.IGNORE_INDENTATION = "ignore-indentation"));
      })(Uh || (Uh = {}));
      ((VS = class extends Il {
        static {
          a(this, "IndentationAwareTokenBuilder");
        }
        constructor(t = tD) {
          (super(),
            (this.indentationStack = [0]),
            (this.whitespaceRegExp = /[ \t]+/y),
            (this.options = Object.assign(Object.assign({}, tD), t)),
            (this.indentTokenType = Uc({
              name: this.options.indentTokenName,
              pattern: this.indentMatcher.bind(this),
              line_breaks: !1,
            })),
            (this.dedentTokenType = Uc({
              name: this.options.dedentTokenName,
              pattern: this.dedentMatcher.bind(this),
              line_breaks: !1,
            })));
        }
        buildTokens(t, r) {
          let n = super.buildTokens(t, r);
          if (!PS(n))
            throw new Error("Invalid tokens built by default builder");
          let {
              indentTokenName: i,
              dedentTokenName: s,
              whitespaceTokenName: o,
              ignoreIndentationDelimiters: l,
            } = this.options,
            u,
            h,
            f,
            d = [];
          for (let p of n) {
            for (let [m, g] of l)
              p.name === m
                ? (p.PUSH_MODE = Uh.IGNORE_INDENTATION)
                : p.name === g && (p.POP_MODE = !0);
            p.name === s
              ? (u = p)
              : p.name === i
                ? (h = p)
                : p.name === o
                  ? (f = p)
                  : d.push(p);
          }
          if (!u || !h || !f)
            throw new Error("Some indentation/whitespace tokens not found!");
          return l.length > 0
            ? {
                modes: {
                  [Uh.REGULAR]: [u, h, ...d, f],
                  [Uh.IGNORE_INDENTATION]: [...d, f],
                },
                defaultMode: Uh.REGULAR,
              }
            : [u, h, f, ...d];
        }
        flushLexingReport(t) {
          let r = super.flushLexingReport(t);
          return Object.assign(Object.assign({}, r), {
            remainingDedents: this.flushRemainingDedents(t),
          });
        }
        isStartOfLine(t, r) {
          return (
            r === 0 ||
            `\r
`.includes(t[r - 1])
          );
        }
        matchWhitespace(t, r, n, i) {
          var s;
          this.whitespaceRegExp.lastIndex = r;
          let o = this.whitespaceRegExp.exec(t);
          return {
            currIndentLevel:
              (s = o?.[0].length) !== null && s !== void 0 ? s : 0,
            prevIndentLevel: this.indentationStack.at(-1),
            match: o,
          };
        }
        createIndentationTokenInstance(t, r, n, i) {
          let s = this.getLineNumber(r, i);
          return Ll(t, n, i, i + n.length, s, s, 1, n.length);
        }
        getLineNumber(t, r) {
          return t.substring(0, r).split(/\r\n|\r|\n/).length;
        }
        indentMatcher(t, r, n, i) {
          if (!this.isStartOfLine(t, r)) return null;
          let {
            currIndentLevel: s,
            prevIndentLevel: o,
            match: l,
          } = this.matchWhitespace(t, r, n, i);
          return s <= o ? null : (this.indentationStack.push(s), l);
        }
        dedentMatcher(t, r, n, i) {
          var s, o, l, u;
          if (!this.isStartOfLine(t, r)) return null;
          let {
            currIndentLevel: h,
            prevIndentLevel: f,
            match: d,
          } = this.matchWhitespace(t, r, n, i);
          if (h >= f) return null;
          let p = this.indentationStack.lastIndexOf(h);
          if (p === -1)
            return (
              this.diagnostics.push({
                severity: "error",
                message: `Invalid dedent level ${h} at offset: ${r}. Current indentation stack: ${this.indentationStack}`,
                offset: r,
                length:
                  (o =
                    (s = d?.[0]) === null || s === void 0
                      ? void 0
                      : s.length) !== null && o !== void 0
                    ? o
                    : 0,
                line: this.getLineNumber(t, r),
                column: 1,
              }),
              null
            );
          let m = this.indentationStack.length - p - 1,
            g =
              (u =
                (l = t.substring(0, r).match(/[\r\n]+$/)) === null ||
                l === void 0
                  ? void 0
                  : l[0].length) !== null && u !== void 0
                ? u
                : 1;
          for (let y = 0; y < m; y++) {
            let b = this.createIndentationTokenInstance(
              this.dedentTokenType,
              t,
              "",
              r - (g - 1),
            );
            (n.push(b), this.indentationStack.pop());
          }
          return null;
        }
        buildTerminalToken(t) {
          let r = super.buildTerminalToken(t),
            {
              indentTokenName: n,
              dedentTokenName: i,
              whitespaceTokenName: s,
            } = this.options;
          return r.name === n
            ? this.indentTokenType
            : r.name === i
              ? this.dedentTokenType
              : r.name === s
                ? Uc({
                    name: s,
                    pattern: this.whitespaceRegExp,
                    group: tn.SKIPPED,
                  })
                : r;
        }
        flushRemainingDedents(t) {
          let r = [];
          for (; this.indentationStack.length > 1; )
            (r.push(
              this.createIndentationTokenInstance(
                this.dedentTokenType,
                t,
                "",
                t.length,
              ),
            ),
              this.indentationStack.pop());
          return ((this.indentationStack = [0]), r);
        }
      }),
        (eD = class extends Wh {
          static {
            a(this, "IndentationAwareLexer");
          }
          constructor(t) {
            if ((super(t), t.parser.TokenBuilder instanceof VS))
              this.indentationTokenBuilder = t.parser.TokenBuilder;
            else
              throw new Error(
                "IndentationAwareLexer requires an accompanying IndentationAwareTokenBuilder",
              );
          }
          tokenize(t, r = OS) {
            let n = super.tokenize(t),
              i = n.report;
            (r?.mode === "full" && n.tokens.push(...i.remainingDedents),
              (i.remainingDedents = []));
            let { indentTokenType: s, dedentTokenType: o } =
                this.indentationTokenBuilder,
              l = s.tokenTypeIdx,
              u = o.tokenTypeIdx,
              h = [],
              f = n.tokens.length - 1;
            for (let d = 0; d < f; d++) {
              let p = n.tokens[d],
                m = n.tokens[d + 1];
              if (p.tokenTypeIdx === l && m.tokenTypeIdx === u) {
                d++;
                continue;
              }
              h.push(p);
            }
            return (f >= 0 && h.push(n.tokens[f]), (n.tokens = h), n);
          }
        }));
    });
  var vtt = x(() => {
    "use strict";
  });
  var Ett = x(() => {
    "use strict";
    YR();
    iR();
    xS();
    wtt();
    aR();
    H1();
    BS();
    SS();
    vtt();
    _S();
    oR();
  });
  var Att = x(() => {
    "use strict";
    kR();
    TR();
    SR();
    CR();
    _R();
    wR();
  });
  var Ltt = x(() => {
    "use strict";
    KR();
    NS();
  });
  var zS,
    hi,
    rD = x(() => {
      "use strict";
      ((zS = class {
        static {
          a(this, "EmptyFileSystemProvider");
        }
        readFile() {
          throw new Error("No file system is available.");
        }
        async readDirectory() {
          return [];
        }
      }),
        (hi = { fileSystemProvider: a(() => new zS(), "fileSystemProvider") }));
    });
  function JAt() {
    let e = Yr(ui(hi), ZAt),
      t = Yr(ci({ shared: e }), QAt);
    return (e.ServiceRegistry.register(t), t);
  }
  function jo(e) {
    var t;
    let r = JAt(),
      n = r.serializer.JsonSerializer.deserialize(e);
    return (
      r.shared.workspace.LangiumDocumentFactory.fromModel(
        n,
        Hi.parse(
          `memory://${(t = n.name) !== null && t !== void 0 ? t : "grammar"}.langium`,
        ),
      ),
      n
    );
  }
  var QAt,
    ZAt,
    Rtt = x(() => {
      "use strict";
      QR();
      JR();
      Bo();
      rD();
      Uo();
      ((QAt = {
        Grammar: a(() => {}, "Grammar"),
        LanguageMetaData: a(
          () => ({
            caseInsensitive: !1,
            fileExtensions: [".langium"],
            languageId: "langium",
          }),
          "LanguageMetaData",
        ),
      }),
        (ZAt = { AstReflection: a(() => new Tp(), "AstReflection") }));
      a(JAt, "createMinimalGrammarServices");
      a(jo, "loadGrammarFromJson");
    });
  var ur = {};
  Oe(ur, {
    AstUtils: () => TT,
    BiMap: () => Gh,
    Cancellation: () => Ve,
    ContextCache: () => Vh,
    CstUtils: () => hT,
    DONE_RESULT: () => ki,
    Deferred: () => qi,
    Disposable: () => Xc,
    DisposableCache: () => cm,
    DocumentCache: () => RS,
    EMPTY_STREAM: () => Q0,
    ErrorWithLocation: () => kh,
    GrammarUtils: () => vT,
    MultiMap: () => Xa,
    OperationCancelled: () => zo,
    Reduction: () => Od,
    RegExpUtils: () => CT,
    SimpleCache: () => ry,
    StreamImpl: () => Ns,
    TreeStreamImpl: () => Mo,
    URI: () => Hi,
    UriUtils: () => Yi,
    WorkspaceCache: () => um,
    assertUnreachable: () => Po,
    delayNextTick: () => gR,
    interruptAndCheck: () => kn,
    isOperationCancelled: () => Wo,
    loadGrammarFromJson: () => jo,
    setInterruptionPeriod: () => ttt,
    startCancelableOperation: () => AS,
    stream: () => kr,
  });
  var Dtt = x(() => {
    "use strict";
    DS();
    MS();
    qe(ur, rn);
    om();
    NR();
    fT();
    Rtt();
    fa();
    ms();
    Uo();
    Vi();
    ha();
    Ua();
    Ha();
    wp();
  });
  var Ntt = x(() => {
    "use strict";
    AR();
    oy();
  });
  var Itt = x(() => {
    "use strict";
    LR();
    RR();
    DR();
    IR();
    am();
    rD();
    MR();
    XR();
    OR();
  });
  var fi = {};
  Oe(fi, {
    AbstractAstReflection: () => gh,
    AbstractCstNode: () => W1,
    AbstractLangiumParser: () => U1,
    AbstractParserErrorMessageProvider: () => kS,
    AbstractThreadedAsyncParser: () => qR,
    AstUtils: () => TT,
    BiMap: () => Gh,
    Cancellation: () => Ve,
    CompositeCstNodeImpl: () => Bh,
    ContextCache: () => Vh,
    CstNodeBuilder: () => z1,
    CstUtils: () => hT,
    DEFAULT_TOKENIZE_OPTIONS: () => OS,
    DONE_RESULT: () => ki,
    DatatypeSymbol: () => bS,
    DefaultAstNodeDescriptionProvider: () => cy,
    DefaultAstNodeLocator: () => hy,
    DefaultAsyncParser: () => Ty,
    DefaultCommentProvider: () => ky,
    DefaultConfigurationProvider: () => fy,
    DefaultDocumentBuilder: () => dy,
    DefaultDocumentValidator: () => ly,
    DefaultHydrator: () => _y,
    DefaultIndexManager: () => py,
    DefaultJsonSerializer: () => iy,
    DefaultLangiumDocumentFactory: () => X1,
    DefaultLangiumDocuments: () => K1,
    DefaultLexer: () => Wh,
    DefaultLexerErrorMessageProvider: () => gy,
    DefaultLinker: () => Q1,
    DefaultNameProvider: () => Z1,
    DefaultReferenceDescriptionProvider: () => uy,
    DefaultReferences: () => J1,
    DefaultScopeComputation: () => ty,
    DefaultScopeProvider: () => ny,
    DefaultServiceRegistry: () => sy,
    DefaultTokenBuilder: () => Il,
    DefaultValueConverter: () => $h,
    DefaultWorkspaceLock: () => Sy,
    DefaultWorkspaceManager: () => my,
    Deferred: () => qi,
    Disposable: () => Xc,
    DisposableCache: () => cm,
    DocumentCache: () => RS,
    DocumentState: () => Pr,
    DocumentValidator: () => da,
    EMPTY_SCOPE: () => FAt,
    EMPTY_STREAM: () => Q0,
    EmptyFileSystem: () => hi,
    EmptyFileSystemProvider: () => zS,
    ErrorWithLocation: () => kh,
    GrammarAST: () => a1,
    GrammarUtils: () => vT,
    IndentationAwareLexer: () => eD,
    IndentationAwareTokenBuilder: () => VS,
    JSDocDocumentationProvider: () => by,
    LangiumCompletionParser: () => q1,
    LangiumParser: () => j1,
    LangiumParserErrorMessageProvider: () => em,
    LeafCstNodeImpl: () => Ph,
    LexingMode: () => Uh,
    MapScope: () => ey,
    Module: () => ZR,
    MultiMap: () => Xa,
    OperationCancelled: () => zo,
    ParserWorker: () => HR,
    Reduction: () => Od,
    RegExpUtils: () => CT,
    RootCstNodeImpl: () => tm,
    SimpleCache: () => ry,
    StreamImpl: () => Ns,
    StreamScope: () => lm,
    TextDocument: () => im,
    TreeStreamImpl: () => Mo,
    URI: () => Hi,
    UriUtils: () => Yi,
    ValidationCategory: () => hm,
    ValidationRegistry: () => ay,
    ValueConverter: () => Vo,
    WorkspaceCache: () => um,
    assertUnreachable: () => Po,
    createCompletionParser: () => nR,
    createDefaultCoreModule: () => ci,
    createDefaultSharedCoreModule: () => ui,
    createGrammarConfig: () => Q6,
    createLangiumParser: () => sR,
    createParser: () => Y1,
    delayNextTick: () => gR,
    diagnosticData: () => zh,
    eagerLoad: () => btt,
    getDiagnosticRange: () => ltt,
    indentationBuilderDefaultOptions: () => tD,
    inject: () => Yr,
    interruptAndCheck: () => kn,
    isAstNode: () => cn,
    isAstNodeDescription: () => a6,
    isAstNodeWithComment: () => vR,
    isCompositeCstNode: () => za,
    isIMultiModeLexerDefinition: () => BR,
    isJSDoc: () => VR,
    isLeafCstNode: () => zc,
    isLinkingError: () => yh,
    isNamed: () => att,
    isOperationCancelled: () => Wo,
    isReference: () => li,
    isRootCstNode: () => K0,
    isTokenTypeArray: () => PS,
    isTokenTypeDictionary: () => PR,
    loadGrammarFromJson: () => jo,
    parseJSDoc: () => GR,
    prepareLangiumParser: () => HJ,
    setInterruptionPeriod: () => ttt,
    startCancelableOperation: () => AS,
    stream: () => kr,
    toDiagnosticData: () => ctt,
    toDiagnosticSeverity: () => IS,
  });
  var Ps = x(() => {
    "use strict";
    QR();
    JR();
    ER();
    Ttt();
    Wa();
    Stt();
    Ctt();
    Ett();
    Att();
    Ltt();
    Dtt();
    qe(fi, ur);
    Ntt();
    Itt();
    Bo();
  });
  function Vtt(e) {
    return Ka.isInstance(e, Cy);
  }
  function ztt(e) {
    return Ka.isInstance(e, fm);
  }
  function Wtt(e) {
    return Ka.isInstance(e, dm);
  }
  function Utt(e) {
    return Ka.isInstance(e, pm);
  }
  function jtt(e) {
    return Ka.isInstance(e, wy);
  }
  function qtt(e) {
    return Ka.isInstance(e, mm);
  }
  function Htt(e) {
    return Ka.isInstance(e, vy);
  }
  function Ytt(e) {
    return Ka.isInstance(e, Ey);
  }
  function Xtt(e) {
    return Ka.isInstance(e, Ay);
  }
  function Ktt(e) {
    return Ka.isInstance(e, Ly);
  }
  function Qtt(e) {
    return Ka.isInstance(e, Ry);
  }
  var t5t,
    zt,
    fD,
    Cy,
    WS,
    fm,
    US,
    jS,
    nD,
    dm,
    iD,
    sD,
    aD,
    pm,
    oD,
    wy,
    qS,
    lD,
    mm,
    cD,
    vy,
    Ey,
    Ay,
    Ly,
    KS,
    uD,
    Ry,
    hD,
    HS,
    YS,
    XS,
    Ztt,
    Ka,
    Mtt,
    e5t,
    Ott,
    r5t,
    Ptt,
    n5t,
    Btt,
    i5t,
    Ftt,
    s5t,
    $tt,
    a5t,
    Gtt,
    o5t,
    l5t,
    c5t,
    u5t,
    h5t,
    f5t,
    d5t,
    p5t,
    Xi,
    dD,
    pD,
    mD,
    gD,
    yD,
    xD,
    bD,
    m5t,
    g5t,
    y5t,
    x5t,
    Kc,
    Ml,
    Ci,
    b5t,
    wi = x(() => {
      "use strict";
      Ps();
      Ps();
      Ps();
      Ps();
      ((t5t = Object.defineProperty),
        (zt = a(
          (e, t) => t5t(e, "name", { value: t, configurable: !0 }),
          "__name",
        )),
        (fD = "Statement"),
        (Cy = "Architecture"));
      a(Vtt, "isArchitecture");
      zt(Vtt, "isArchitecture");
      ((WS = "Axis"), (fm = "Branch"));
      a(ztt, "isBranch");
      zt(ztt, "isBranch");
      ((US = "Checkout"),
        (jS = "CherryPicking"),
        (nD = "ClassDefStatement"),
        (dm = "Commit"));
      a(Wtt, "isCommit");
      zt(Wtt, "isCommit");
      ((iD = "Curve"), (sD = "Edge"), (aD = "Entry"), (pm = "GitGraph"));
      a(Utt, "isGitGraph");
      zt(Utt, "isGitGraph");
      ((oD = "Group"), (wy = "Info"));
      a(jtt, "isInfo");
      zt(jtt, "isInfo");
      ((qS = "Item"), (lD = "Junction"), (mm = "Merge"));
      a(qtt, "isMerge");
      zt(qtt, "isMerge");
      ((cD = "Option"), (vy = "Packet"));
      a(Htt, "isPacket");
      zt(Htt, "isPacket");
      Ey = "PacketBlock";
      a(Ytt, "isPacketBlock");
      zt(Ytt, "isPacketBlock");
      Ay = "Pie";
      a(Xtt, "isPie");
      zt(Xtt, "isPie");
      Ly = "PieSection";
      a(Ktt, "isPieSection");
      zt(Ktt, "isPieSection");
      ((KS = "Radar"), (uD = "Service"), (Ry = "Treemap"));
      a(Qtt, "isTreemap");
      zt(Qtt, "isTreemap");
      ((hD = "TreemapRow"),
        (HS = "Direction"),
        (YS = "Leaf"),
        (XS = "Section"),
        (Ztt = class extends gh {
          static {
            a(this, "MermaidAstReflection");
          }
          static {
            zt(this, "MermaidAstReflection");
          }
          getAllTypes() {
            return [
              Cy,
              WS,
              fm,
              US,
              jS,
              nD,
              dm,
              iD,
              HS,
              sD,
              aD,
              pm,
              oD,
              wy,
              qS,
              lD,
              YS,
              mm,
              cD,
              vy,
              Ey,
              Ay,
              Ly,
              KS,
              XS,
              uD,
              fD,
              Ry,
              hD,
            ];
          }
          computeIsSubtype(e, t) {
            switch (e) {
              case fm:
              case US:
              case jS:
              case dm:
              case mm:
                return this.isSubtype(fD, t);
              case HS:
                return this.isSubtype(pm, t);
              case YS:
              case XS:
                return this.isSubtype(qS, t);
              default:
                return !1;
            }
          }
          getReferenceType(e) {
            let t = `${e.container.$type}:${e.property}`;
            switch (t) {
              case "Entry:axis":
                return WS;
              default:
                throw new Error(`${t} is not a valid reference id.`);
            }
          }
          getTypeMetaData(e) {
            switch (e) {
              case Cy:
                return {
                  name: Cy,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "edges", defaultValue: [] },
                    { name: "groups", defaultValue: [] },
                    { name: "junctions", defaultValue: [] },
                    { name: "services", defaultValue: [] },
                    { name: "title" },
                  ],
                };
              case WS:
                return {
                  name: WS,
                  properties: [{ name: "label" }, { name: "name" }],
                };
              case fm:
                return {
                  name: fm,
                  properties: [{ name: "name" }, { name: "order" }],
                };
              case US:
                return { name: US, properties: [{ name: "branch" }] };
              case jS:
                return {
                  name: jS,
                  properties: [
                    { name: "id" },
                    { name: "parent" },
                    { name: "tags", defaultValue: [] },
                  ],
                };
              case nD:
                return {
                  name: nD,
                  properties: [{ name: "className" }, { name: "styleText" }],
                };
              case dm:
                return {
                  name: dm,
                  properties: [
                    { name: "id" },
                    { name: "message" },
                    { name: "tags", defaultValue: [] },
                    { name: "type" },
                  ],
                };
              case iD:
                return {
                  name: iD,
                  properties: [
                    { name: "entries", defaultValue: [] },
                    { name: "label" },
                    { name: "name" },
                  ],
                };
              case sD:
                return {
                  name: sD,
                  properties: [
                    { name: "lhsDir" },
                    { name: "lhsGroup", defaultValue: !1 },
                    { name: "lhsId" },
                    { name: "lhsInto", defaultValue: !1 },
                    { name: "rhsDir" },
                    { name: "rhsGroup", defaultValue: !1 },
                    { name: "rhsId" },
                    { name: "rhsInto", defaultValue: !1 },
                    { name: "title" },
                  ],
                };
              case aD:
                return {
                  name: aD,
                  properties: [{ name: "axis" }, { name: "value" }],
                };
              case pm:
                return {
                  name: pm,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "statements", defaultValue: [] },
                    { name: "title" },
                  ],
                };
              case oD:
                return {
                  name: oD,
                  properties: [
                    { name: "icon" },
                    { name: "id" },
                    { name: "in" },
                    { name: "title" },
                  ],
                };
              case wy:
                return {
                  name: wy,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "title" },
                  ],
                };
              case qS:
                return {
                  name: qS,
                  properties: [{ name: "classSelector" }, { name: "name" }],
                };
              case lD:
                return {
                  name: lD,
                  properties: [{ name: "id" }, { name: "in" }],
                };
              case mm:
                return {
                  name: mm,
                  properties: [
                    { name: "branch" },
                    { name: "id" },
                    { name: "tags", defaultValue: [] },
                    { name: "type" },
                  ],
                };
              case cD:
                return {
                  name: cD,
                  properties: [
                    { name: "name" },
                    { name: "value", defaultValue: !1 },
                  ],
                };
              case vy:
                return {
                  name: vy,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "blocks", defaultValue: [] },
                    { name: "title" },
                  ],
                };
              case Ey:
                return {
                  name: Ey,
                  properties: [
                    { name: "bits" },
                    { name: "end" },
                    { name: "label" },
                    { name: "start" },
                  ],
                };
              case Ay:
                return {
                  name: Ay,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "sections", defaultValue: [] },
                    { name: "showData", defaultValue: !1 },
                    { name: "title" },
                  ],
                };
              case Ly:
                return {
                  name: Ly,
                  properties: [{ name: "label" }, { name: "value" }],
                };
              case KS:
                return {
                  name: KS,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "axes", defaultValue: [] },
                    { name: "curves", defaultValue: [] },
                    { name: "options", defaultValue: [] },
                    { name: "title" },
                  ],
                };
              case uD:
                return {
                  name: uD,
                  properties: [
                    { name: "icon" },
                    { name: "iconText" },
                    { name: "id" },
                    { name: "in" },
                    { name: "title" },
                  ],
                };
              case Ry:
                return {
                  name: Ry,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "title" },
                    { name: "TreemapRows", defaultValue: [] },
                  ],
                };
              case hD:
                return {
                  name: hD,
                  properties: [{ name: "indent" }, { name: "item" }],
                };
              case HS:
                return {
                  name: HS,
                  properties: [
                    { name: "accDescr" },
                    { name: "accTitle" },
                    { name: "dir" },
                    { name: "statements", defaultValue: [] },
                    { name: "title" },
                  ],
                };
              case YS:
                return {
                  name: YS,
                  properties: [
                    { name: "classSelector" },
                    { name: "name" },
                    { name: "value" },
                  ],
                };
              case XS:
                return {
                  name: XS,
                  properties: [{ name: "classSelector" }, { name: "name" }],
                };
              default:
                return { name: e, properties: [] };
            }
          }
        }),
        (Ka = new Ztt()),
        (e5t = zt(
          () =>
            Mtt ??
            (Mtt = jo(
              `{"$type":"Grammar","isDeclared":true,"name":"Info","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Info","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"info"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"},{"$type":"Group","elements":[{"$type":"Keyword","value":"showInfo"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"*"}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@7"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          "InfoGrammar",
        )),
        (r5t = zt(
          () =>
            Ott ??
            (Ott = jo(
              `{"$type":"Grammar","isDeclared":true,"name":"Packet","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Packet","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"packet"},{"$type":"Keyword","value":"packet-beta"}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"Assignment","feature":"blocks","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PacketBlock","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"start","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"end","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}],"cardinality":"?"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"+"},{"$type":"Assignment","feature":"bits","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]}]},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@8"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@9"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          "PacketGrammar",
        )),
        (n5t = zt(
          () =>
            Ptt ??
            (Ptt = jo(
              `{"$type":"Grammar","isDeclared":true,"name":"Pie","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Pie","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"pie"},{"$type":"Assignment","feature":"showData","operator":"?=","terminal":{"$type":"Keyword","value":"showData"},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Assignment","feature":"sections","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"PieSection","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}},{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"FLOAT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/-?(0|[1-9][0-9]*)(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER_PIE","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@2"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@3"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@11"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@12"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          "PieGrammar",
        )),
        (i5t = zt(
          () =>
            Btt ??
            (Btt = jo(
              `{"$type":"Grammar","isDeclared":true,"name":"Architecture","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Architecture","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"*"},{"$type":"Keyword","value":"architecture-beta"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"groups","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Assignment","feature":"services","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Assignment","feature":"junctions","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Assignment","feature":"edges","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"LeftPort","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":":"},{"$type":"Assignment","feature":"lhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"RightPort","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"rhsDir","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}},{"$type":"Keyword","value":":"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Arrow","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Assignment","feature":"lhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"--"},{"$type":"Group","elements":[{"$type":"Keyword","value":"-"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]}},{"$type":"Keyword","value":"-"}]}]},{"$type":"Assignment","feature":"rhsInto","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Group","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"group"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]},"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Service","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"service"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"iconText","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]}},{"$type":"Assignment","feature":"icon","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@28"},"arguments":[]}}],"cardinality":"?"},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@29"},"arguments":[]},"cardinality":"?"},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Junction","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"junction"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"in"},{"$type":"Assignment","feature":"in","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Edge","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"lhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"lhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Assignment","feature":"rhsId","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Assignment","feature":"rhsGroup","operator":"?=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"ARROW_DIRECTION","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"L"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"R"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"T"}}]},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"B"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_GROUP","definition":{"$type":"RegexToken","regex":"/\\\\{group\\\\}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARROW_INTO","definition":{"$type":"RegexToken","regex":"/<|>/"},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@18"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@19"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"ARCH_ICON","definition":{"$type":"RegexToken","regex":"/\\\\([\\\\w-:]+\\\\)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ARCH_TITLE","definition":{"$type":"RegexToken","regex":"/\\\\[[\\\\w ]+\\\\]/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          "ArchitectureGrammar",
        )),
        (s5t = zt(
          () =>
            Ftt ??
            (Ftt = jo(
              `{"$type":"Grammar","isDeclared":true,"name":"GitGraph","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"GitGraph","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"Keyword","value":":"}]},{"$type":"Keyword","value":"gitGraph:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"gitGraph"},{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]},{"$type":"Keyword","value":":"}]}]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"Assignment","feature":"statements","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Statement","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Direction","definition":{"$type":"Assignment","feature":"dir","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"LR"},{"$type":"Keyword","value":"TB"},{"$type":"Keyword","value":"BT"}]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Commit","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"commit"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"msg:","cardinality":"?"},{"$type":"Assignment","feature":"message","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Branch","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"branch"},{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Group","elements":[{"$type":"Keyword","value":"order:"},{"$type":"Assignment","feature":"order","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}}],"cardinality":"?"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Merge","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"merge"},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"type:"},{"$type":"Assignment","feature":"type","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"NORMAL"},{"$type":"Keyword","value":"REVERSE"},{"$type":"Keyword","value":"HIGHLIGHT"}]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Checkout","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"checkout"},{"$type":"Keyword","value":"switch"}]},{"$type":"Assignment","feature":"branch","operator":"=","terminal":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@24"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"CherryPicking","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"cherry-pick"},{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Keyword","value":"id:"},{"$type":"Assignment","feature":"id","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"tag:"},{"$type":"Assignment","feature":"tags","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"parent:"},{"$type":"Assignment","feature":"parent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@14"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false},{"$type":"TerminalRule","name":"REFERENCE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\\\w([-\\\\./\\\\w]*[-\\\\w])?/"},"fragment":false,"hidden":false}],"definesHiddenTokens":false,"hiddenTokens":[],"interfaces":[],"types":[],"usedGrammars":[]}`,
            )),
          "GitGraphGrammar",
        )),
        (a5t = zt(
          () =>
            $tt ??
            ($tt = jo(
              `{"$type":"Grammar","isDeclared":true,"name":"Radar","imports":[],"rules":[{"$type":"ParserRule","entry":true,"name":"Radar","definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":"radar-beta:"},{"$type":"Group","elements":[{"$type":"Keyword","value":"radar-beta"},{"$type":"Keyword","value":":"}]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]},{"$type":"Group","elements":[{"$type":"Keyword","value":"axis"},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"axes","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Keyword","value":"curve"},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"curves","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"Assignment","feature":"options","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]}}],"cardinality":"*"}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Label","definition":{"$type":"Group","elements":[{"$type":"Keyword","value":"["},{"$type":"Assignment","feature":"label","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]}},{"$type":"Keyword","value":"]"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Axis","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Curve","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@1"},"arguments":[],"cardinality":"?"},{"$type":"Keyword","value":"{"},{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]},{"$type":"Keyword","value":"}"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"Entries","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"Keyword","value":","},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"},{"$type":"Assignment","feature":"entries","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@5"},"arguments":[]}}],"cardinality":"*"},{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"*"}]}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"DetailedEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"axis","operator":"=","terminal":{"$type":"CrossReference","type":{"$ref":"#/rules@2"},"terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"deprecatedSyntax":false}},{"$type":"Keyword","value":":","cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"NumberEntry","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Option","definition":{"$type":"Alternatives","elements":[{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"showLegend"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@11"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"ticks"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"max"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"min"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}}]},{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"Keyword","value":"graticule"}},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]}}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"GRATICULE","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"circle"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"polygon"}}]},"fragment":false,"hidden":false},{"$type":"ParserRule","fragment":true,"name":"EOL","dataType":"string","definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[],"cardinality":"+"},{"$type":"EndOfFile"}]},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Group","elements":[{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@12"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@13"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"FLOAT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/[0-9]+\\\\.[0-9]+(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"INT","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"RegexToken","regex":"/0|[1-9][0-9]*(?!\\\\.)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER","type":{"$type":"ReturnType","name":"number"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@15"}},{"$type":"TerminalRuleCall","rule":{"$ref":"#/rules@16"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STRING","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/\\"([^\\"\\\\\\\\]|\\\\\\\\.)*\\"|'([^'\\\\\\\\]|\\\\\\\\.)*'/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID","type":{"$type":"ReturnType","name":"string"},"definition":{"$type":"RegexToken","regex":"/[\\\\w]([-\\\\w]*\\\\w)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NEWLINE","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WHITESPACE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"YAML","definition":{"$type":"RegexToken","regex":"/---[\\\\t ]*\\\\r?\\\\n(?:[\\\\S\\\\s]*?\\\\r?\\\\n)?---(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"DIRECTIVE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%{[\\\\S\\\\s]*?}%%(?:\\\\r?\\\\n|(?!\\\\S))/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"SINGLE_LINE_COMMENT","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*%%[^\\\\n\\\\r]*/"},"fragment":false}],"interfaces":[{"$type":"Interface","name":"Entry","attributes":[{"$type":"TypeAttribute","name":"axis","isOptional":true,"type":{"$type":"ReferenceType","referenceType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@2"}}}},{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"types":[],"usedGrammars":[]}`,
            )),
          "RadarGrammar",
        )),
        (o5t = zt(
          () =>
            Gtt ??
            (Gtt = jo(
              `{"$type":"Grammar","isDeclared":true,"name":"Treemap","rules":[{"$type":"ParserRule","fragment":true,"name":"TitleAndAccessibilities","definition":{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"accDescr","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@2"},"arguments":[]}},{"$type":"Assignment","feature":"accTitle","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@3"},"arguments":[]}},{"$type":"Assignment","feature":"title","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@4"},"arguments":[]}}],"cardinality":"+"},"definesHiddenTokens":false,"entry":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"BOOLEAN","type":{"$type":"ReturnType","name":"boolean"},"definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"true"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"false"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_DESCR","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accDescr(?:[\\\\t ]*:([^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)|\\\\s*{([^}]*)})/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ACC_TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*accTitle[\\\\t ]*:(?:[^\\\\n\\\\r]*?(?=%%)|[^\\\\n\\\\r]*)/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"TITLE","definition":{"$type":"RegexToken","regex":"/[\\\\t ]*title(?:[\\\\t ][^\\\\n\\\\r]*?(?=%%)|[\\\\t ][^\\\\n\\\\r]*|)/"},"fragment":false,"hidden":false},{"$type":"ParserRule","entry":true,"name":"Treemap","returnType":{"$ref":"#/interfaces@4"},"definition":{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@6"},"arguments":[]},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@0"},"arguments":[]},{"$type":"Assignment","feature":"TreemapRows","operator":"+=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@14"},"arguments":[]}}],"cardinality":"*"}]},"definesHiddenTokens":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"TREEMAP_KEYWORD","definition":{"$type":"TerminalAlternatives","elements":[{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap-beta"}},{"$type":"CharacterRange","left":{"$type":"Keyword","value":"treemap"}}]},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"CLASS_DEF","definition":{"$type":"RegexToken","regex":"/classDef\\\\s+([a-zA-Z_][a-zA-Z0-9_]+)(?:\\\\s+([^;\\\\r\\\\n]*))?(?:;)?/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"STYLE_SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":::"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"SEPARATOR","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":":"}},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"COMMA","definition":{"$type":"CharacterRange","left":{"$type":"Keyword","value":","}},"fragment":false,"hidden":false},{"$type":"TerminalRule","hidden":true,"name":"WS","definition":{"$type":"RegexToken","regex":"/[ \\\\t]+/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"ML_COMMENT","definition":{"$type":"RegexToken","regex":"/\\\\%\\\\%[^\\\\n]*/"},"fragment":false},{"$type":"TerminalRule","hidden":true,"name":"NL","definition":{"$type":"RegexToken","regex":"/\\\\r?\\\\n/"},"fragment":false},{"$type":"ParserRule","name":"TreemapRow","definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"indent","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[]},"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"Assignment","feature":"item","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@16"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@15"},"arguments":[]}]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"ClassDef","dataType":"string","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@7"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Item","returnType":{"$ref":"#/interfaces@0"},"definition":{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@18"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@17"},"arguments":[]}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Section","returnType":{"$ref":"#/interfaces@1"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"ParserRule","name":"Leaf","returnType":{"$ref":"#/interfaces@2"},"definition":{"$type":"Group","elements":[{"$type":"Assignment","feature":"name","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@23"},"arguments":[]}},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Alternatives","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@9"},"arguments":[]},{"$type":"RuleCall","rule":{"$ref":"#/rules@10"},"arguments":[]}]},{"$type":"RuleCall","rule":{"$ref":"#/rules@19"},"arguments":[],"cardinality":"?"},{"$type":"Assignment","feature":"value","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@22"},"arguments":[]}},{"$type":"Group","elements":[{"$type":"RuleCall","rule":{"$ref":"#/rules@8"},"arguments":[]},{"$type":"Assignment","feature":"classSelector","operator":"=","terminal":{"$type":"RuleCall","rule":{"$ref":"#/rules@20"},"arguments":[]}}],"cardinality":"?"}]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"INDENTATION","definition":{"$type":"RegexToken","regex":"/[ \\\\t]{1,}/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"ID2","definition":{"$type":"RegexToken","regex":"/[a-zA-Z_][a-zA-Z0-9_]*/"},"fragment":false,"hidden":false},{"$type":"TerminalRule","name":"NUMBER2","definition":{"$type":"RegexToken","regex":"/[0-9_\\\\.\\\\,]+/"},"fragment":false,"hidden":false},{"$type":"ParserRule","name":"MyNumber","dataType":"number","definition":{"$type":"RuleCall","rule":{"$ref":"#/rules@21"},"arguments":[]},"definesHiddenTokens":false,"entry":false,"fragment":false,"hiddenTokens":[],"parameters":[],"wildcard":false},{"$type":"TerminalRule","name":"STRING2","definition":{"$type":"RegexToken","regex":"/\\"[^\\"]*\\"|'[^']*'/"},"fragment":false,"hidden":false}],"interfaces":[{"$type":"Interface","name":"Item","attributes":[{"$type":"TypeAttribute","name":"name","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"classSelector","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]},{"$type":"Interface","name":"Section","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[]},{"$type":"Interface","name":"Leaf","superTypes":[{"$ref":"#/interfaces@0"}],"attributes":[{"$type":"TypeAttribute","name":"value","type":{"$type":"SimpleType","primitiveType":"number"},"isOptional":false}]},{"$type":"Interface","name":"ClassDefStatement","attributes":[{"$type":"TypeAttribute","name":"className","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false},{"$type":"TypeAttribute","name":"styleText","type":{"$type":"SimpleType","primitiveType":"string"},"isOptional":false}],"superTypes":[]},{"$type":"Interface","name":"Treemap","attributes":[{"$type":"TypeAttribute","name":"TreemapRows","type":{"$type":"ArrayType","elementType":{"$type":"SimpleType","typeRef":{"$ref":"#/rules@14"}}},"isOptional":false},{"$type":"TypeAttribute","name":"title","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accTitle","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}},{"$type":"TypeAttribute","name":"accDescr","isOptional":true,"type":{"$type":"SimpleType","primitiveType":"string"}}],"superTypes":[]}],"definesHiddenTokens":false,"hiddenTokens":[],"imports":[],"types":[],"usedGrammars":[],"$comment":"/**\\n * Treemap grammar for Langium\\n * Converted from mindmap grammar\\n *\\n * The ML_COMMENT and NL hidden terminals handle whitespace, comments, and newlines\\n * before the treemap keyword, allowing for empty lines and comments before the\\n * treemap declaration.\\n */"}`,
            )),
          "TreemapGrammar",
        )),
        (l5t = {
          languageId: "info",
          fileExtensions: [".mmd", ".mermaid"],
          caseInsensitive: !1,
          mode: "production",
        }),
        (c5t = {
          languageId: "packet",
          fileExtensions: [".mmd", ".mermaid"],
          caseInsensitive: !1,
          mode: "production",
        }),
        (u5t = {
          languageId: "pie",
          fileExtensions: [".mmd", ".mermaid"],
          caseInsensitive: !1,
          mode: "production",
        }),
        (h5t = {
          languageId: "architecture",
          fileExtensions: [".mmd", ".mermaid"],
          caseInsensitive: !1,
          mode: "production",
        }),
        (f5t = {
          languageId: "gitGraph",
          fileExtensions: [".mmd", ".mermaid"],
          caseInsensitive: !1,
          mode: "production",
        }),
        (d5t = {
          languageId: "radar",
          fileExtensions: [".mmd", ".mermaid"],
          caseInsensitive: !1,
          mode: "production",
        }),
        (p5t = {
          languageId: "treemap",
          fileExtensions: [".mmd", ".mermaid"],
          caseInsensitive: !1,
          mode: "production",
        }),
        (Xi = { AstReflection: zt(() => new Ztt(), "AstReflection") }),
        (dD = {
          Grammar: zt(() => e5t(), "Grammar"),
          LanguageMetaData: zt(() => l5t, "LanguageMetaData"),
          parser: {},
        }),
        (pD = {
          Grammar: zt(() => r5t(), "Grammar"),
          LanguageMetaData: zt(() => c5t, "LanguageMetaData"),
          parser: {},
        }),
        (mD = {
          Grammar: zt(() => n5t(), "Grammar"),
          LanguageMetaData: zt(() => u5t, "LanguageMetaData"),
          parser: {},
        }),
        (gD = {
          Grammar: zt(() => i5t(), "Grammar"),
          LanguageMetaData: zt(() => h5t, "LanguageMetaData"),
          parser: {},
        }),
        (yD = {
          Grammar: zt(() => s5t(), "Grammar"),
          LanguageMetaData: zt(() => f5t, "LanguageMetaData"),
          parser: {},
        }),
        (xD = {
          Grammar: zt(() => a5t(), "Grammar"),
          LanguageMetaData: zt(() => d5t, "LanguageMetaData"),
          parser: {},
        }),
        (bD = {
          Grammar: zt(() => o5t(), "Grammar"),
          LanguageMetaData: zt(() => p5t, "LanguageMetaData"),
          parser: {},
        }),
        (m5t = /accDescr(?:[\t ]*:([^\n\r]*)|\s*{([^}]*)})/),
        (g5t = /accTitle[\t ]*:([^\n\r]*)/),
        (y5t = /title([\t ][^\n\r]*|)/),
        (x5t = { ACC_DESCR: m5t, ACC_TITLE: g5t, TITLE: y5t }),
        (Kc = class extends $h {
          static {
            a(this, "AbstractMermaidValueConverter");
          }
          static {
            zt(this, "AbstractMermaidValueConverter");
          }
          runConverter(e, t, r) {
            let n = this.runCommonConverter(e, t, r);
            return (
              n === void 0 && (n = this.runCustomConverter(e, t, r)),
              n === void 0 ? super.runConverter(e, t, r) : n
            );
          }
          runCommonConverter(e, t, r) {
            let n = x5t[e.name];
            if (n === void 0) return;
            let i = n.exec(t);
            if (i !== null) {
              if (i[1] !== void 0)
                return i[1].trim().replace(/[\t ]{2,}/gm, " ");
              if (i[2] !== void 0)
                return i[2]
                  .replace(/^\s*/gm, "")
                  .replace(/\s+$/gm, "")
                  .replace(/[\t ]{2,}/gm, " ")
                  .replace(
                    /[\n\r]{2,}/gm,
                    `
`,
                  );
            }
          }
        }),
        (Ml = class extends Kc {
          static {
            a(this, "CommonValueConverter");
          }
          static {
            zt(this, "CommonValueConverter");
          }
          runCustomConverter(e, t, r) {}
        }),
        (Ci = class extends Il {
          static {
            a(this, "AbstractMermaidTokenBuilder");
          }
          static {
            zt(this, "AbstractMermaidTokenBuilder");
          }
          constructor(e) {
            (super(), (this.keywords = new Set(e)));
          }
          buildKeywordTokens(e, t, r) {
            let n = super.buildKeywordTokens(e, t, r);
            return (
              n.forEach((i) => {
                this.keywords.has(i.name) &&
                  i.PATTERN !== void 0 &&
                  (i.PATTERN = new RegExp(
                    i.PATTERN.toString() + "(?:(?=%%)|(?!\\S))",
                  ));
              }),
              n
            );
          }
        }),
        (b5t = class extends Ci {
          static {
            a(this, "CommonTokenBuilder");
          }
          static {
            zt(this, "CommonTokenBuilder");
          }
        }));
    });
  function ZS(e = hi) {
    let t = Yr(ui(e), Xi),
      r = Yr(ci({ shared: t }), yD, QS);
    return (t.ServiceRegistry.register(r), { shared: t, GitGraph: r });
  }
  var k5t,
    QS,
    kD = x(() => {
      "use strict";
      wi();
      Ps();
      ((k5t = class extends Ci {
        static {
          a(this, "GitGraphTokenBuilder");
        }
        static {
          zt(this, "GitGraphTokenBuilder");
        }
        constructor() {
          super(["gitGraph"]);
        }
      }),
        (QS = {
          parser: {
            TokenBuilder: zt(() => new k5t(), "TokenBuilder"),
            ValueConverter: zt(() => new Ml(), "ValueConverter"),
          },
        }));
      a(ZS, "createGitGraphServices");
      zt(ZS, "createGitGraphServices");
    });
  function t_(e = hi) {
    let t = Yr(ui(e), Xi),
      r = Yr(ci({ shared: t }), dD, JS);
    return (t.ServiceRegistry.register(r), { shared: t, Info: r });
  }
  var T5t,
    JS,
    TD = x(() => {
      "use strict";
      wi();
      Ps();
      ((T5t = class extends Ci {
        static {
          a(this, "InfoTokenBuilder");
        }
        static {
          zt(this, "InfoTokenBuilder");
        }
        constructor() {
          super(["info", "showInfo"]);
        }
      }),
        (JS = {
          parser: {
            TokenBuilder: zt(() => new T5t(), "TokenBuilder"),
            ValueConverter: zt(() => new Ml(), "ValueConverter"),
          },
        }));
      a(t_, "createInfoServices");
      zt(t_, "createInfoServices");
    });
  function r_(e = hi) {
    let t = Yr(ui(e), Xi),
      r = Yr(ci({ shared: t }), pD, e_);
    return (t.ServiceRegistry.register(r), { shared: t, Packet: r });
  }
  var S5t,
    e_,
    SD = x(() => {
      "use strict";
      wi();
      Ps();
      ((S5t = class extends Ci {
        static {
          a(this, "PacketTokenBuilder");
        }
        static {
          zt(this, "PacketTokenBuilder");
        }
        constructor() {
          super(["packet"]);
        }
      }),
        (e_ = {
          parser: {
            TokenBuilder: zt(() => new S5t(), "TokenBuilder"),
            ValueConverter: zt(() => new Ml(), "ValueConverter"),
          },
        }));
      a(r_, "createPacketServices");
      zt(r_, "createPacketServices");
    });
  function i_(e = hi) {
    let t = Yr(ui(e), Xi),
      r = Yr(ci({ shared: t }), mD, n_);
    return (t.ServiceRegistry.register(r), { shared: t, Pie: r });
  }
  var _5t,
    C5t,
    n_,
    _D = x(() => {
      "use strict";
      wi();
      Ps();
      ((_5t = class extends Ci {
        static {
          a(this, "PieTokenBuilder");
        }
        static {
          zt(this, "PieTokenBuilder");
        }
        constructor() {
          super(["pie", "showData"]);
        }
      }),
        (C5t = class extends Kc {
          static {
            a(this, "PieValueConverter");
          }
          static {
            zt(this, "PieValueConverter");
          }
          runCustomConverter(e, t, r) {
            if (e.name === "PIE_SECTION_LABEL")
              return t.replace(/"/g, "").trim();
          }
        }),
        (n_ = {
          parser: {
            TokenBuilder: zt(() => new _5t(), "TokenBuilder"),
            ValueConverter: zt(() => new C5t(), "ValueConverter"),
          },
        }));
      a(i_, "createPieServices");
      zt(i_, "createPieServices");
    });
  function a_(e = hi) {
    let t = Yr(ui(e), Xi),
      r = Yr(ci({ shared: t }), gD, s_);
    return (t.ServiceRegistry.register(r), { shared: t, Architecture: r });
  }
  var w5t,
    v5t,
    s_,
    CD = x(() => {
      "use strict";
      wi();
      Ps();
      ((w5t = class extends Ci {
        static {
          a(this, "ArchitectureTokenBuilder");
        }
        static {
          zt(this, "ArchitectureTokenBuilder");
        }
        constructor() {
          super(["architecture"]);
        }
      }),
        (v5t = class extends Kc {
          static {
            a(this, "ArchitectureValueConverter");
          }
          static {
            zt(this, "ArchitectureValueConverter");
          }
          runCustomConverter(e, t, r) {
            if (e.name === "ARCH_ICON") return t.replace(/[()]/g, "").trim();
            if (e.name === "ARCH_TEXT_ICON") return t.replace(/["()]/g, "");
            if (e.name === "ARCH_TITLE") return t.replace(/[[\]]/g, "").trim();
          }
        }),
        (s_ = {
          parser: {
            TokenBuilder: zt(() => new w5t(), "TokenBuilder"),
            ValueConverter: zt(() => new v5t(), "ValueConverter"),
          },
        }));
      a(a_, "createArchitectureServices");
      zt(a_, "createArchitectureServices");
    });
  function l_(e = hi) {
    let t = Yr(ui(e), Xi),
      r = Yr(ci({ shared: t }), xD, o_);
    return (t.ServiceRegistry.register(r), { shared: t, Radar: r });
  }
  var E5t,
    o_,
    wD = x(() => {
      "use strict";
      wi();
      Ps();
      ((E5t = class extends Ci {
        static {
          a(this, "RadarTokenBuilder");
        }
        static {
          zt(this, "RadarTokenBuilder");
        }
        constructor() {
          super(["radar-beta"]);
        }
      }),
        (o_ = {
          parser: {
            TokenBuilder: zt(() => new E5t(), "TokenBuilder"),
            ValueConverter: zt(() => new Ml(), "ValueConverter"),
          },
        }));
      a(l_, "createRadarServices");
      zt(l_, "createRadarServices");
    });
  function Jtt(e) {
    let t = e.validation.TreemapValidator,
      r = e.validation.ValidationRegistry;
    if (r) {
      let n = { Treemap: t.checkSingleRoot.bind(t) };
      r.register(n, t);
    }
  }
  function u_(e = hi) {
    let t = Yr(ui(e), Xi),
      r = Yr(ci({ shared: t }), bD, c_);
    return (t.ServiceRegistry.register(r), Jtt(r), { shared: t, Treemap: r });
  }
  var A5t,
    L5t,
    R5t,
    D5t,
    c_,
    vD = x(() => {
      "use strict";
      wi();
      Ps();
      ((A5t = class extends Ci {
        static {
          a(this, "TreemapTokenBuilder");
        }
        static {
          zt(this, "TreemapTokenBuilder");
        }
        constructor() {
          super(["treemap"]);
        }
      }),
        (L5t = /classDef\s+([A-Z_a-z]\w+)(?:\s+([^\n\r;]*))?;?/),
        (R5t = class extends Kc {
          static {
            a(this, "TreemapValueConverter");
          }
          static {
            zt(this, "TreemapValueConverter");
          }
          runCustomConverter(e, t, r) {
            if (e.name === "NUMBER2") return parseFloat(t.replace(/,/g, ""));
            if (e.name === "SEPARATOR") return t.substring(1, t.length - 1);
            if (e.name === "STRING2") return t.substring(1, t.length - 1);
            if (e.name === "INDENTATION") return t.length;
            if (e.name === "ClassDef") {
              if (typeof t != "string") return t;
              let n = L5t.exec(t);
              if (n)
                return {
                  $type: "ClassDefStatement",
                  className: n[1],
                  styleText: n[2] || void 0,
                };
            }
          }
        }));
      a(Jtt, "registerValidationChecks");
      zt(Jtt, "registerValidationChecks");
      ((D5t = class {
        static {
          a(this, "TreemapValidator");
        }
        static {
          zt(this, "TreemapValidator");
        }
        checkSingleRoot(e, t) {
          let r;
          for (let n of e.TreemapRows)
            n.item &&
              (r === void 0 && n.indent === void 0
                ? (r = 0)
                : n.indent === void 0
                  ? t(
                      "error",
                      "Multiple root nodes are not allowed in a treemap.",
                      { node: n, property: "item" },
                    )
                  : r !== void 0 &&
                    r >= parseInt(n.indent, 10) &&
                    t(
                      "error",
                      "Multiple root nodes are not allowed in a treemap.",
                      { node: n, property: "item" },
                    ));
        }
      }),
        (c_ = {
          parser: {
            TokenBuilder: zt(() => new A5t(), "TokenBuilder"),
            ValueConverter: zt(() => new R5t(), "ValueConverter"),
          },
          validation: {
            TreemapValidator: zt(() => new D5t(), "TreemapValidator"),
          },
        }));
      a(u_, "createTreemapServices");
      zt(u_, "createTreemapServices");
    });
  var tet = {};
  Oe(tet, { InfoModule: () => JS, createInfoServices: () => t_ });
  var eet = x(() => {
    "use strict";
    TD();
    wi();
  });
  var ret = {};
  Oe(ret, { PacketModule: () => e_, createPacketServices: () => r_ });
  var net = x(() => {
    "use strict";
    SD();
    wi();
  });
  var iet = {};
  Oe(iet, { PieModule: () => n_, createPieServices: () => i_ });
  var set = x(() => {
    "use strict";
    _D();
    wi();
  });
  var aet = {};
  Oe(aet, {
    ArchitectureModule: () => s_,
    createArchitectureServices: () => a_,
  });
  var oet = x(() => {
    "use strict";
    CD();
    wi();
  });
  var cet = {};
  Oe(cet, { GitGraphModule: () => QS, createGitGraphServices: () => ZS });
  var uet = x(() => {
    "use strict";
    kD();
    wi();
  });
  var het = {};
  Oe(het, { RadarModule: () => o_, createRadarServices: () => l_ });
  var fet = x(() => {
    "use strict";
    wD();
    wi();
  });
  var det = {};
  Oe(det, { TreemapModule: () => c_, createTreemapServices: () => u_ });
  var pet = x(() => {
    "use strict";
    vD();
    wi();
  });
  async function Bs(e, t) {
    let r = N5t[e];
    if (!r) throw new Error(`Unknown diagram type: ${e}`);
    Ol[e] || (await r());
    let i = Ol[e].parse(t);
    if (i.lexerErrors.length > 0 || i.parserErrors.length > 0) throw new I5t(i);
    return i.value;
  }
  var Ol,
    N5t,
    I5t,
    jh = x(() => {
      "use strict";
      kD();
      TD();
      SD();
      _D();
      CD();
      wD();
      vD();
      wi();
      ((Ol = {}),
        (N5t = {
          info: zt(async () => {
            let { createInfoServices: e } = await Promise.resolve().then(
                () => (eet(), tet),
              ),
              t = e().Info.parser.LangiumParser;
            Ol.info = t;
          }, "info"),
          packet: zt(async () => {
            let { createPacketServices: e } = await Promise.resolve().then(
                () => (net(), ret),
              ),
              t = e().Packet.parser.LangiumParser;
            Ol.packet = t;
          }, "packet"),
          pie: zt(async () => {
            let { createPieServices: e } = await Promise.resolve().then(
                () => (set(), iet),
              ),
              t = e().Pie.parser.LangiumParser;
            Ol.pie = t;
          }, "pie"),
          architecture: zt(async () => {
            let { createArchitectureServices: e } =
                await Promise.resolve().then(() => (oet(), aet)),
              t = e().Architecture.parser.LangiumParser;
            Ol.architecture = t;
          }, "architecture"),
          gitGraph: zt(async () => {
            let { createGitGraphServices: e } = await Promise.resolve().then(
                () => (uet(), cet),
              ),
              t = e().GitGraph.parser.LangiumParser;
            Ol.gitGraph = t;
          }, "gitGraph"),
          radar: zt(async () => {
            let { createRadarServices: e } = await Promise.resolve().then(
                () => (fet(), het),
              ),
              t = e().Radar.parser.LangiumParser;
            Ol.radar = t;
          }, "radar"),
          treemap: zt(async () => {
            let { createTreemapServices: e } = await Promise.resolve().then(
                () => (pet(), det),
              ),
              t = e().Treemap.parser.LangiumParser;
            Ol.treemap = t;
          }, "treemap"),
        }));
      a(Bs, "parse");
      zt(Bs, "parse");
      I5t = class extends Error {
        static {
          a(this, "MermaidParseError");
        }
        constructor(e) {
          let t = e.lexerErrors.map((n) => n.message).join(`
`),
            r = e.parserErrors.map((n) => n.message).join(`
`);
          (super(`Parsing failed: ${t} ${r}`), (this.result = e));
        }
        static {
          zt(this, "MermaidParseError");
        }
      };
    });
  function qo(e, t) {
    (e.accDescr && t.setAccDescription?.(e.accDescr),
      e.accTitle && t.setAccTitle?.(e.accTitle),
      e.title && t.setDiagramTitle?.(e.title));
  }
  var gm = x(() => {
    "use strict";
    a(qo, "populateCommonDb");
  });
  var yr,
    h_ = x(() => {
      "use strict";
      yr = { NORMAL: 0, REVERSE: 1, HIGHLIGHT: 2, MERGE: 3, CHERRY_PICK: 4 };
    });
  var ym,
    ED = x(() => {
      "use strict";
      ym = class {
        constructor(t) {
          this.init = t;
          this.records = this.init();
        }
        static {
          a(this, "ImperativeState");
        }
        reset() {
          this.records = this.init();
        }
      };
    });
  function AD() {
    return L4({ length: 7 });
  }
  function O5t(e, t) {
    let r = Object.create(null);
    return e.reduce((n, i) => {
      let s = t(i);
      return (r[s] || ((r[s] = !0), n.push(i)), n);
    }, []);
  }
  function met(e, t, r) {
    let n = e.indexOf(t);
    n === -1 ? e.push(r) : e.splice(n, 1, r);
  }
  function yet(e) {
    let t = e.reduce((i, s) => (i.seq > s.seq ? i : s), e[0]),
      r = "";
    e.forEach(function (i) {
      i === t ? (r += "	*") : (r += "	|");
    });
    let n = [r, t.id, t.seq];
    for (let i in qt.records.branches)
      qt.records.branches.get(i) === t.id && n.push(i);
    if (
      (P.debug(n.join(" ")),
      t.parents && t.parents.length == 2 && t.parents[0] && t.parents[1])
    ) {
      let i = qt.records.commits.get(t.parents[0]);
      (met(e, t, i),
        t.parents[1] && e.push(qt.records.commits.get(t.parents[1])));
    } else {
      if (t.parents.length == 0) return;
      if (t.parents[0]) {
        let i = qt.records.commits.get(t.parents[0]);
        met(e, t, i);
      }
    }
    ((e = O5t(e, (i) => i.id)), yet(e));
  }
  var M5t,
    qh,
    qt,
    P5t,
    B5t,
    F5t,
    $5t,
    G5t,
    V5t,
    z5t,
    get,
    W5t,
    U5t,
    j5t,
    q5t,
    H5t,
    xet,
    Y5t,
    X5t,
    K5t,
    f_,
    LD = x(() => {
      "use strict";
      Vt();
      _e();
      un();
      Be();
      yn();
      h_();
      ED();
      Ss();
      ((M5t = ze.gitGraph),
        (qh = a(() => on({ ...M5t, ...ke().gitGraph }), "getConfig")),
        (qt = new ym(() => {
          let e = qh(),
            t = e.mainBranchName,
            r = e.mainBranchOrder;
          return {
            mainBranchName: t,
            commits: new Map(),
            head: null,
            branchConfig: new Map([[t, { name: t, order: r }]]),
            branches: new Map([[t, null]]),
            currBranch: t,
            direction: "LR",
            seq: 0,
            options: {},
          };
        })));
      a(AD, "getID");
      a(O5t, "uniqBy");
      ((P5t = a(function (e) {
        qt.records.direction = e;
      }, "setDirection")),
        (B5t = a(function (e) {
          (P.debug("options str", e), (e = e?.trim()), (e = e || "{}"));
          try {
            qt.records.options = JSON.parse(e);
          } catch (t) {
            P.error("error while parsing gitGraph options", t.message);
          }
        }, "setOptions")),
        (F5t = a(function () {
          return qt.records.options;
        }, "getOptions")),
        ($5t = a(function (e) {
          let t = e.msg,
            r = e.id,
            n = e.type,
            i = e.tags;
          (P.info("commit", t, r, n, i),
            P.debug("Entering commit:", t, r, n, i));
          let s = qh();
          ((r = Rt.sanitizeText(r, s)),
            (t = Rt.sanitizeText(t, s)),
            (i = i?.map((l) => Rt.sanitizeText(l, s))));
          let o = {
            id: r || qt.records.seq + "-" + AD(),
            message: t,
            seq: qt.records.seq++,
            type: n ?? yr.NORMAL,
            tags: i ?? [],
            parents: qt.records.head == null ? [] : [qt.records.head.id],
            branch: qt.records.currBranch,
          };
          ((qt.records.head = o),
            P.info("main branch", s.mainBranchName),
            qt.records.commits.has(o.id) &&
              P.warn(`Commit ID ${o.id} already exists`),
            qt.records.commits.set(o.id, o),
            qt.records.branches.set(qt.records.currBranch, o.id),
            P.debug("in pushCommit " + o.id));
        }, "commit")),
        (G5t = a(function (e) {
          let t = e.name,
            r = e.order;
          if (((t = Rt.sanitizeText(t, qh())), qt.records.branches.has(t)))
            throw new Error(
              `Trying to create an existing branch. (Help: Either use a new name if you want create a new branch or try using "checkout ${t}")`,
            );
          (qt.records.branches.set(
            t,
            qt.records.head != null ? qt.records.head.id : null,
          ),
            qt.records.branchConfig.set(t, { name: t, order: r }),
            get(t),
            P.debug("in createBranch"));
        }, "branch")),
        (V5t = a((e) => {
          let t = e.branch,
            r = e.id,
            n = e.type,
            i = e.tags,
            s = qh();
          ((t = Rt.sanitizeText(t, s)), r && (r = Rt.sanitizeText(r, s)));
          let o = qt.records.branches.get(qt.records.currBranch),
            l = qt.records.branches.get(t),
            u = o ? qt.records.commits.get(o) : void 0,
            h = l ? qt.records.commits.get(l) : void 0;
          if (u && h && u.branch === t)
            throw new Error(`Cannot merge branch '${t}' into itself.`);
          if (qt.records.currBranch === t) {
            let p = new Error(
              'Incorrect usage of "merge". Cannot merge a branch to itself',
            );
            throw (
              (p.hash = {
                text: `merge ${t}`,
                token: `merge ${t}`,
                expected: ["branch abc"],
              }),
              p
            );
          }
          if (u === void 0 || !u) {
            let p = new Error(
              `Incorrect usage of "merge". Current branch (${qt.records.currBranch})has no commits`,
            );
            throw (
              (p.hash = {
                text: `merge ${t}`,
                token: `merge ${t}`,
                expected: ["commit"],
              }),
              p
            );
          }
          if (!qt.records.branches.has(t)) {
            let p = new Error(
              'Incorrect usage of "merge". Branch to be merged (' +
                t +
                ") does not exist",
            );
            throw (
              (p.hash = {
                text: `merge ${t}`,
                token: `merge ${t}`,
                expected: [`branch ${t}`],
              }),
              p
            );
          }
          if (h === void 0 || !h) {
            let p = new Error(
              'Incorrect usage of "merge". Branch to be merged (' +
                t +
                ") has no commits",
            );
            throw (
              (p.hash = {
                text: `merge ${t}`,
                token: `merge ${t}`,
                expected: ['"commit"'],
              }),
              p
            );
          }
          if (u === h) {
            let p = new Error(
              'Incorrect usage of "merge". Both branches have same head',
            );
            throw (
              (p.hash = {
                text: `merge ${t}`,
                token: `merge ${t}`,
                expected: ["branch abc"],
              }),
              p
            );
          }
          if (r && qt.records.commits.has(r)) {
            let p = new Error(
              'Incorrect usage of "merge". Commit with id:' +
                r +
                " already exists, use different custom id",
            );
            throw (
              (p.hash = {
                text: `merge ${t} ${r} ${n} ${i?.join(" ")}`,
                token: `merge ${t} ${r} ${n} ${i?.join(" ")}`,
                expected: [`merge ${t} ${r}_UNIQUE ${n} ${i?.join(" ")}`],
              }),
              p
            );
          }
          let f = l || "",
            d = {
              id: r || `${qt.records.seq}-${AD()}`,
              message: `merged branch ${t} into ${qt.records.currBranch}`,
              seq: qt.records.seq++,
              parents: qt.records.head == null ? [] : [qt.records.head.id, f],
              branch: qt.records.currBranch,
              type: yr.MERGE,
              customType: n,
              customId: !!r,
              tags: i ?? [],
            };
          ((qt.records.head = d),
            qt.records.commits.set(d.id, d),
            qt.records.branches.set(qt.records.currBranch, d.id),
            P.debug(qt.records.branches),
            P.debug("in mergeBranch"));
        }, "merge")),
        (z5t = a(function (e) {
          let t = e.id,
            r = e.targetId,
            n = e.tags,
            i = e.parent;
          P.debug("Entering cherryPick:", t, r, n);
          let s = qh();
          if (
            ((t = Rt.sanitizeText(t, s)),
            (r = Rt.sanitizeText(r, s)),
            (n = n?.map((u) => Rt.sanitizeText(u, s))),
            (i = Rt.sanitizeText(i, s)),
            !t || !qt.records.commits.has(t))
          ) {
            let u = new Error(
              'Incorrect usage of "cherryPick". Source commit id should exist and provided',
            );
            throw (
              (u.hash = {
                text: `cherryPick ${t} ${r}`,
                token: `cherryPick ${t} ${r}`,
                expected: ["cherry-pick abc"],
              }),
              u
            );
          }
          let o = qt.records.commits.get(t);
          if (o === void 0 || !o)
            throw new Error(
              'Incorrect usage of "cherryPick". Source commit id should exist and provided',
            );
          if (i && !(Array.isArray(o.parents) && o.parents.includes(i)))
            throw new Error(
              "Invalid operation: The specified parent commit is not an immediate parent of the cherry-picked commit.",
            );
          let l = o.branch;
          if (o.type === yr.MERGE && !i)
            throw new Error(
              "Incorrect usage of cherry-pick: If the source commit is a merge commit, an immediate parent commit must be specified.",
            );
          if (!r || !qt.records.commits.has(r)) {
            if (l === qt.records.currBranch) {
              let d = new Error(
                'Incorrect usage of "cherryPick". Source commit is already on current branch',
              );
              throw (
                (d.hash = {
                  text: `cherryPick ${t} ${r}`,
                  token: `cherryPick ${t} ${r}`,
                  expected: ["cherry-pick abc"],
                }),
                d
              );
            }
            let u = qt.records.branches.get(qt.records.currBranch);
            if (u === void 0 || !u) {
              let d = new Error(
                `Incorrect usage of "cherry-pick". Current branch (${qt.records.currBranch})has no commits`,
              );
              throw (
                (d.hash = {
                  text: `cherryPick ${t} ${r}`,
                  token: `cherryPick ${t} ${r}`,
                  expected: ["cherry-pick abc"],
                }),
                d
              );
            }
            let h = qt.records.commits.get(u);
            if (h === void 0 || !h) {
              let d = new Error(
                `Incorrect usage of "cherry-pick". Current branch (${qt.records.currBranch})has no commits`,
              );
              throw (
                (d.hash = {
                  text: `cherryPick ${t} ${r}`,
                  token: `cherryPick ${t} ${r}`,
                  expected: ["cherry-pick abc"],
                }),
                d
              );
            }
            let f = {
              id: qt.records.seq + "-" + AD(),
              message: `cherry-picked ${o?.message} into ${qt.records.currBranch}`,
              seq: qt.records.seq++,
              parents:
                qt.records.head == null ? [] : [qt.records.head.id, o.id],
              branch: qt.records.currBranch,
              type: yr.CHERRY_PICK,
              tags: n
                ? n.filter(Boolean)
                : [
                    `cherry-pick:${o.id}${o.type === yr.MERGE ? `|parent:${i}` : ""}`,
                  ],
            };
            ((qt.records.head = f),
              qt.records.commits.set(f.id, f),
              qt.records.branches.set(qt.records.currBranch, f.id),
              P.debug(qt.records.branches),
              P.debug("in cherryPick"));
          }
        }, "cherryPick")),
        (get = a(function (e) {
          if (((e = Rt.sanitizeText(e, qh())), qt.records.branches.has(e))) {
            qt.records.currBranch = e;
            let t = qt.records.branches.get(qt.records.currBranch);
            t === void 0 || !t
              ? (qt.records.head = null)
              : (qt.records.head = qt.records.commits.get(t) ?? null);
          } else {
            let t = new Error(
              `Trying to checkout branch which is not yet created. (Help try using "branch ${e}")`,
            );
            throw (
              (t.hash = {
                text: `checkout ${e}`,
                token: `checkout ${e}`,
                expected: [`branch ${e}`],
              }),
              t
            );
          }
        }, "checkout")));
      a(met, "upsert");
      a(yet, "prettyPrintCommitHistory");
      ((W5t = a(function () {
        P.debug(qt.records.commits);
        let e = xet()[0];
        yet([e]);
      }, "prettyPrint")),
        (U5t = a(function () {
          (qt.reset(), Ye());
        }, "clear")),
        (j5t = a(function () {
          return [...qt.records.branchConfig.values()]
            .map((t, r) =>
              t.order !== null && t.order !== void 0
                ? t
                : { ...t, order: parseFloat(`0.${r}`) },
            )
            .sort((t, r) => (t.order ?? 0) - (r.order ?? 0))
            .map(({ name: t }) => ({ name: t }));
        }, "getBranchesAsObjArray")),
        (q5t = a(function () {
          return qt.records.branches;
        }, "getBranches")),
        (H5t = a(function () {
          return qt.records.commits;
        }, "getCommits")),
        (xet = a(function () {
          let e = [...qt.records.commits.values()];
          return (
            e.forEach(function (t) {
              P.debug(t.id);
            }),
            e.sort((t, r) => t.seq - r.seq),
            e
          );
        }, "getCommitsArray")),
        (Y5t = a(function () {
          return qt.records.currBranch;
        }, "getCurrentBranch")),
        (X5t = a(function () {
          return qt.records.direction;
        }, "getDirection")),
        (K5t = a(function () {
          return qt.records.head;
        }, "getHead")),
        (f_ = {
          commitType: yr,
          getConfig: qh,
          setDirection: P5t,
          setOptions: B5t,
          getOptions: F5t,
          commit: $5t,
          branch: G5t,
          merge: V5t,
          cherryPick: z5t,
          checkout: get,
          prettyPrint: W5t,
          clear: U5t,
          getBranchesAsObjArray: j5t,
          getBranches: q5t,
          getCommits: H5t,
          getCommitsArray: xet,
          getCurrentBranch: Y5t,
          getDirection: X5t,
          getHead: K5t,
          setAccTitle: Xe,
          getAccTitle: tr,
          getAccDescription: rr,
          setAccDescription: er,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
        }));
    });
  var Q5t,
    Z5t,
    J5t,
    t6t,
    e6t,
    r6t,
    n6t,
    bet,
    ket = x(() => {
      "use strict";
      jh();
      Vt();
      gm();
      LD();
      h_();
      ((Q5t = a((e, t) => {
        (qo(e, t), e.dir && t.setDirection(e.dir));
        for (let r of e.statements) Z5t(r, t);
      }, "populate")),
        (Z5t = a((e, t) => {
          let n = {
            Commit: a((i) => t.commit(J5t(i)), "Commit"),
            Branch: a((i) => t.branch(t6t(i)), "Branch"),
            Merge: a((i) => t.merge(e6t(i)), "Merge"),
            Checkout: a((i) => t.checkout(r6t(i)), "Checkout"),
            CherryPicking: a((i) => t.cherryPick(n6t(i)), "CherryPicking"),
          }[e.$type];
          n ? n(e) : P.error(`Unknown statement type: ${e.$type}`);
        }, "parseStatement")),
        (J5t = a(
          (e) => ({
            id: e.id,
            msg: e.message ?? "",
            type: e.type !== void 0 ? yr[e.type] : yr.NORMAL,
            tags: e.tags ?? void 0,
          }),
          "parseCommit",
        )),
        (t6t = a(
          (e) => ({ name: e.name, order: e.order ?? 0 }),
          "parseBranch",
        )),
        (e6t = a(
          (e) => ({
            branch: e.branch,
            id: e.id ?? "",
            type: e.type !== void 0 ? yr[e.type] : void 0,
            tags: e.tags ?? void 0,
          }),
          "parseMerge",
        )),
        (r6t = a((e) => e.branch, "parseCheckout")),
        (n6t = a(
          (e) => ({
            id: e.id,
            targetId: "",
            tags: e.tags?.length === 0 ? void 0 : e.tags,
            parent: e.parent,
          }),
          "parseCherryPicking",
        )),
        (bet = {
          parse: a(async (e) => {
            let t = await Bs("gitGraph", e);
            (P.debug(t), Q5t(t, f_));
          }, "parse"),
        }));
    });
  var i6t,
    pa,
    Zc,
    Jc,
    Ho,
    Pl,
    Hh,
    xs,
    bs,
    d_,
    Dy,
    p_,
    Qc,
    ar,
    s6t,
    _et,
    Cet,
    a6t,
    o6t,
    l6t,
    c6t,
    u6t,
    h6t,
    f6t,
    d6t,
    p6t,
    m6t,
    g6t,
    y6t,
    Tet,
    x6t,
    Ny,
    b6t,
    k6t,
    T6t,
    S6t,
    _6t,
    wet,
    vet = x(() => {
      "use strict";
      Ge();
      pe();
      Vt();
      _e();
      h_();
      ((i6t = K()),
        (pa = i6t?.gitGraph),
        (Zc = 10),
        (Jc = 40),
        (Ho = 4),
        (Pl = 2),
        (Hh = 8),
        (xs = new Map()),
        (bs = new Map()),
        (d_ = 30),
        (Dy = new Map()),
        (p_ = []),
        (Qc = 0),
        (ar = "LR"),
        (s6t = a(() => {
          (xs.clear(),
            bs.clear(),
            Dy.clear(),
            (Qc = 0),
            (p_ = []),
            (ar = "LR"));
        }, "clear")),
        (_et = a((e) => {
          let t = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text",
          );
          return (
            (typeof e == "string" ? e.split(/\\n|\n|<br\s*\/?>/gi) : e).forEach(
              (n) => {
                let i = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "tspan",
                );
                (i.setAttributeNS(
                  "http://www.w3.org/XML/1998/namespace",
                  "xml:space",
                  "preserve",
                ),
                  i.setAttribute("dy", "1em"),
                  i.setAttribute("x", "0"),
                  i.setAttribute("class", "row"),
                  (i.textContent = n.trim()),
                  t.appendChild(i));
              },
            ),
            t
          );
        }, "drawText")),
        (Cet = a((e) => {
          let t, r, n;
          return (
            ar === "BT"
              ? ((r = a((i, s) => i <= s, "comparisonFunc")), (n = 1 / 0))
              : ((r = a((i, s) => i >= s, "comparisonFunc")), (n = 0)),
            e.forEach((i) => {
              let s = ar === "TB" || ar == "BT" ? bs.get(i)?.y : bs.get(i)?.x;
              s !== void 0 && r(s, n) && ((t = i), (n = s));
            }),
            t
          );
        }, "findClosestParent")),
        (a6t = a((e) => {
          let t = "",
            r = 1 / 0;
          return (
            e.forEach((n) => {
              let i = bs.get(n).y;
              i <= r && ((t = n), (r = i));
            }),
            t || void 0
          );
        }, "findClosestParentBT")),
        (o6t = a((e, t, r) => {
          let n = r,
            i = r,
            s = [];
          (e.forEach((o) => {
            let l = t.get(o);
            if (!l) throw new Error(`Commit not found for key ${o}`);
            (l.parents.length
              ? ((n = c6t(l)), (i = Math.max(n, i)))
              : s.push(l),
              u6t(l, n));
          }),
            (n = i),
            s.forEach((o) => {
              h6t(o, n, r);
            }),
            e.forEach((o) => {
              let l = t.get(o);
              if (l?.parents.length) {
                let u = a6t(l.parents);
                ((n = bs.get(u).y - Jc), n <= i && (i = n));
                let h = xs.get(l.branch).pos,
                  f = n - Zc;
                bs.set(l.id, { x: h, y: f });
              }
            }));
        }, "setParallelBTPos")),
        (l6t = a((e) => {
          let t = Cet(e.parents.filter((n) => n !== null));
          if (!t)
            throw new Error(`Closest parent not found for commit ${e.id}`);
          let r = bs.get(t)?.y;
          if (r === void 0)
            throw new Error(
              `Closest parent position not found for commit ${e.id}`,
            );
          return r;
        }, "findClosestParentPos")),
        (c6t = a((e) => l6t(e) + Jc, "calculateCommitPosition")),
        (u6t = a((e, t) => {
          let r = xs.get(e.branch);
          if (!r) throw new Error(`Branch not found for commit ${e.id}`);
          let n = r.pos,
            i = t + Zc;
          return (bs.set(e.id, { x: n, y: i }), { x: n, y: i });
        }, "setCommitPosition")),
        (h6t = a((e, t, r) => {
          let n = xs.get(e.branch);
          if (!n) throw new Error(`Branch not found for commit ${e.id}`);
          let i = t + r,
            s = n.pos;
          bs.set(e.id, { x: s, y: i });
        }, "setRootPosition")),
        (f6t = a((e, t, r, n, i, s) => {
          if (s === yr.HIGHLIGHT)
            (e
              .append("rect")
              .attr("x", r.x - 10)
              .attr("y", r.y - 10)
              .attr("width", 20)
              .attr("height", 20)
              .attr(
                "class",
                `commit ${t.id} commit-highlight${i % Hh} ${n}-outer`,
              ),
              e
                .append("rect")
                .attr("x", r.x - 6)
                .attr("y", r.y - 6)
                .attr("width", 12)
                .attr("height", 12)
                .attr("class", `commit ${t.id} commit${i % Hh} ${n}-inner`));
          else if (s === yr.CHERRY_PICK)
            (e
              .append("circle")
              .attr("cx", r.x)
              .attr("cy", r.y)
              .attr("r", 10)
              .attr("class", `commit ${t.id} ${n}`),
              e
                .append("circle")
                .attr("cx", r.x - 3)
                .attr("cy", r.y + 2)
                .attr("r", 2.75)
                .attr("fill", "#fff")
                .attr("class", `commit ${t.id} ${n}`),
              e
                .append("circle")
                .attr("cx", r.x + 3)
                .attr("cy", r.y + 2)
                .attr("r", 2.75)
                .attr("fill", "#fff")
                .attr("class", `commit ${t.id} ${n}`),
              e
                .append("line")
                .attr("x1", r.x + 3)
                .attr("y1", r.y + 1)
                .attr("x2", r.x)
                .attr("y2", r.y - 5)
                .attr("stroke", "#fff")
                .attr("class", `commit ${t.id} ${n}`),
              e
                .append("line")
                .attr("x1", r.x - 3)
                .attr("y1", r.y + 1)
                .attr("x2", r.x)
                .attr("y2", r.y - 5)
                .attr("stroke", "#fff")
                .attr("class", `commit ${t.id} ${n}`));
          else {
            let o = e.append("circle");
            if (
              (o.attr("cx", r.x),
              o.attr("cy", r.y),
              o.attr("r", t.type === yr.MERGE ? 9 : 10),
              o.attr("class", `commit ${t.id} commit${i % Hh}`),
              s === yr.MERGE)
            ) {
              let l = e.append("circle");
              (l.attr("cx", r.x),
                l.attr("cy", r.y),
                l.attr("r", 6),
                l.attr("class", `commit ${n} ${t.id} commit${i % Hh}`));
            }
            s === yr.REVERSE &&
              e
                .append("path")
                .attr(
                  "d",
                  `M ${r.x - 5},${r.y - 5}L${r.x + 5},${r.y + 5}M${r.x - 5},${r.y + 5}L${r.x + 5},${r.y - 5}`,
                )
                .attr("class", `commit ${n} ${t.id} commit${i % Hh}`);
          }
        }, "drawCommitBullet")),
        (d6t = a((e, t, r, n) => {
          if (
            t.type !== yr.CHERRY_PICK &&
            ((t.customId && t.type === yr.MERGE) || t.type !== yr.MERGE) &&
            pa?.showCommitLabel
          ) {
            let i = e.append("g"),
              s = i.insert("rect").attr("class", "commit-label-bkg"),
              o = i
                .append("text")
                .attr("x", n)
                .attr("y", r.y + 25)
                .attr("class", "commit-label")
                .text(t.id),
              l = o.node()?.getBBox();
            if (
              l &&
              (s
                .attr("x", r.posWithOffset - l.width / 2 - Pl)
                .attr("y", r.y + 13.5)
                .attr("width", l.width + 2 * Pl)
                .attr("height", l.height + 2 * Pl),
              ar === "TB" || ar === "BT"
                ? (s
                    .attr("x", r.x - (l.width + 4 * Ho + 5))
                    .attr("y", r.y - 12),
                  o
                    .attr("x", r.x - (l.width + 4 * Ho))
                    .attr("y", r.y + l.height - 12))
                : o.attr("x", r.posWithOffset - l.width / 2),
              pa.rotateCommitLabel)
            )
              if (ar === "TB" || ar === "BT")
                (o.attr("transform", "rotate(-45, " + r.x + ", " + r.y + ")"),
                  s.attr("transform", "rotate(-45, " + r.x + ", " + r.y + ")"));
              else {
                let u = -7.5 - ((l.width + 10) / 25) * 9.5,
                  h = 10 + (l.width / 25) * 8.5;
                i.attr(
                  "transform",
                  "translate(" +
                    u +
                    ", " +
                    h +
                    ") rotate(-45, " +
                    n +
                    ", " +
                    r.y +
                    ")",
                );
              }
          }
        }, "drawCommitLabel")),
        (p6t = a((e, t, r, n) => {
          if (t.tags.length > 0) {
            let i = 0,
              s = 0,
              o = 0,
              l = [];
            for (let u of t.tags.reverse()) {
              let h = e.insert("polygon"),
                f = e.append("circle"),
                d = e
                  .append("text")
                  .attr("y", r.y - 16 - i)
                  .attr("class", "tag-label")
                  .text(u),
                p = d.node()?.getBBox();
              if (!p) throw new Error("Tag bbox not found");
              ((s = Math.max(s, p.width)),
                (o = Math.max(o, p.height)),
                d.attr("x", r.posWithOffset - p.width / 2),
                l.push({ tag: d, hole: f, rect: h, yOffset: i }),
                (i += 20));
            }
            for (let { tag: u, hole: h, rect: f, yOffset: d } of l) {
              let p = o / 2,
                m = r.y - 19.2 - d;
              if (
                (f.attr("class", "tag-label-bkg").attr(
                  "points",
                  `
      ${n - s / 2 - Ho / 2},${m + Pl}  
      ${n - s / 2 - Ho / 2},${m - Pl}
      ${r.posWithOffset - s / 2 - Ho},${m - p - Pl}
      ${r.posWithOffset + s / 2 + Ho},${m - p - Pl}
      ${r.posWithOffset + s / 2 + Ho},${m + p + Pl}
      ${r.posWithOffset - s / 2 - Ho},${m + p + Pl}`,
                ),
                h
                  .attr("cy", m)
                  .attr("cx", n - s / 2 + Ho / 2)
                  .attr("r", 1.5)
                  .attr("class", "tag-hole"),
                ar === "TB" || ar === "BT")
              ) {
                let g = n + d;
                (f
                  .attr("class", "tag-label-bkg")
                  .attr(
                    "points",
                    `
        ${r.x},${g + 2}
        ${r.x},${g - 2}
        ${r.x + Zc},${g - p - 2}
        ${r.x + Zc + s + 4},${g - p - 2}
        ${r.x + Zc + s + 4},${g + p + 2}
        ${r.x + Zc},${g + p + 2}`,
                  )
                  .attr(
                    "transform",
                    "translate(12,12) rotate(45, " + r.x + "," + n + ")",
                  ),
                  h
                    .attr("cx", r.x + Ho / 2)
                    .attr("cy", g)
                    .attr(
                      "transform",
                      "translate(12,12) rotate(45, " + r.x + "," + n + ")",
                    ),
                  u
                    .attr("x", r.x + 5)
                    .attr("y", g + 3)
                    .attr(
                      "transform",
                      "translate(14,14) rotate(45, " + r.x + "," + n + ")",
                    ));
              }
            }
          }
        }, "drawCommitTags")),
        (m6t = a((e) => {
          switch (e.customType ?? e.type) {
            case yr.NORMAL:
              return "commit-normal";
            case yr.REVERSE:
              return "commit-reverse";
            case yr.HIGHLIGHT:
              return "commit-highlight";
            case yr.MERGE:
              return "commit-merge";
            case yr.CHERRY_PICK:
              return "commit-cherry-pick";
            default:
              return "commit-normal";
          }
        }, "getCommitClassType")),
        (g6t = a((e, t, r, n) => {
          let i = { x: 0, y: 0 };
          if (e.parents.length > 0) {
            let s = Cet(e.parents);
            if (s) {
              let o = n.get(s) ?? i;
              return t === "TB"
                ? o.y + Jc
                : t === "BT"
                  ? (n.get(e.id) ?? i).y - Jc
                  : o.x + Jc;
            }
          } else
            return t === "TB" ? d_ : t === "BT" ? (n.get(e.id) ?? i).y - Jc : 0;
          return 0;
        }, "calculatePosition")),
        (y6t = a((e, t, r) => {
          let n = ar === "BT" && r ? t : t + Zc,
            i = ar === "TB" || ar === "BT" ? n : xs.get(e.branch)?.pos,
            s = ar === "TB" || ar === "BT" ? xs.get(e.branch)?.pos : n;
          if (s === void 0 || i === void 0)
            throw new Error(`Position were undefined for commit ${e.id}`);
          return { x: s, y: i, posWithOffset: n };
        }, "getCommitPosition")),
        (Tet = a((e, t, r) => {
          if (!pa) throw new Error("GitGraph config not found");
          let n = e.append("g").attr("class", "commit-bullets"),
            i = e.append("g").attr("class", "commit-labels"),
            s = ar === "TB" || ar === "BT" ? d_ : 0,
            o = [...t.keys()],
            l = pa?.parallelCommits ?? !1,
            u = a((f, d) => {
              let p = t.get(f)?.seq,
                m = t.get(d)?.seq;
              return p !== void 0 && m !== void 0 ? p - m : 0;
            }, "sortKeys"),
            h = o.sort(u);
          (ar === "BT" && (l && o6t(h, t, s), (h = h.reverse())),
            h.forEach((f) => {
              let d = t.get(f);
              if (!d) throw new Error(`Commit not found for key ${f}`);
              l && (s = g6t(d, ar, s, bs));
              let p = y6t(d, s, l);
              if (r) {
                let m = m6t(d),
                  g = d.customType ?? d.type,
                  y = xs.get(d.branch)?.index ?? 0;
                (f6t(n, d, p, m, y, g), d6t(i, d, p, s), p6t(i, d, p, s));
              }
              (ar === "TB" || ar === "BT"
                ? bs.set(d.id, { x: p.x, y: p.posWithOffset })
                : bs.set(d.id, { x: p.posWithOffset, y: p.y }),
                (s = ar === "BT" && l ? s + Jc : s + Jc + Zc),
                s > Qc && (Qc = s));
            }));
        }, "drawCommits")),
        (x6t = a((e, t, r, n, i) => {
          let o = (ar === "TB" || ar === "BT" ? r.x < n.x : r.y < n.y)
              ? t.branch
              : e.branch,
            l = a((h) => h.branch === o, "isOnBranchToGetCurve"),
            u = a((h) => h.seq > e.seq && h.seq < t.seq, "isBetweenCommits");
          return [...i.values()].some((h) => u(h) && l(h));
        }, "shouldRerouteArrow")),
        (Ny = a((e, t, r = 0) => {
          let n = e + Math.abs(e - t) / 2;
          if (r > 5) return n;
          if (p_.every((o) => Math.abs(o - n) >= 10)) return (p_.push(n), n);
          let s = Math.abs(e - t);
          return Ny(e, t - s / 5, r + 1);
        }, "findLane")),
        (b6t = a((e, t, r, n) => {
          let i = bs.get(t.id),
            s = bs.get(r.id);
          if (i === void 0 || s === void 0)
            throw new Error(
              `Commit positions not found for commits ${t.id} and ${r.id}`,
            );
          let o = x6t(t, r, i, s, n),
            l = "",
            u = "",
            h = 0,
            f = 0,
            d = xs.get(r.branch)?.index;
          r.type === yr.MERGE &&
            t.id !== r.parents[0] &&
            (d = xs.get(t.branch)?.index);
          let p;
          if (o) {
            ((l = "A 10 10, 0, 0, 0,"),
              (u = "A 10 10, 0, 0, 1,"),
              (h = 10),
              (f = 10));
            let m = i.y < s.y ? Ny(i.y, s.y) : Ny(s.y, i.y),
              g = i.x < s.x ? Ny(i.x, s.x) : Ny(s.x, i.x);
            ar === "TB"
              ? i.x < s.x
                ? (p = `M ${i.x} ${i.y} L ${g - h} ${i.y} ${u} ${g} ${i.y + f} L ${g} ${s.y - h} ${l} ${g + f} ${s.y} L ${s.x} ${s.y}`)
                : ((d = xs.get(t.branch)?.index),
                  (p = `M ${i.x} ${i.y} L ${g + h} ${i.y} ${l} ${g} ${i.y + f} L ${g} ${s.y - h} ${u} ${g - f} ${s.y} L ${s.x} ${s.y}`))
              : ar === "BT"
                ? i.x < s.x
                  ? (p = `M ${i.x} ${i.y} L ${g - h} ${i.y} ${l} ${g} ${i.y - f} L ${g} ${s.y + h} ${u} ${g + f} ${s.y} L ${s.x} ${s.y}`)
                  : ((d = xs.get(t.branch)?.index),
                    (p = `M ${i.x} ${i.y} L ${g + h} ${i.y} ${u} ${g} ${i.y - f} L ${g} ${s.y + h} ${l} ${g - f} ${s.y} L ${s.x} ${s.y}`))
                : i.y < s.y
                  ? (p = `M ${i.x} ${i.y} L ${i.x} ${m - h} ${l} ${i.x + f} ${m} L ${s.x - h} ${m} ${u} ${s.x} ${m + f} L ${s.x} ${s.y}`)
                  : ((d = xs.get(t.branch)?.index),
                    (p = `M ${i.x} ${i.y} L ${i.x} ${m + h} ${u} ${i.x + f} ${m} L ${s.x - h} ${m} ${l} ${s.x} ${m - f} L ${s.x} ${s.y}`));
          } else
            ((l = "A 20 20, 0, 0, 0,"),
              (u = "A 20 20, 0, 0, 1,"),
              (h = 20),
              (f = 20),
              ar === "TB"
                ? (i.x < s.x &&
                    (r.type === yr.MERGE && t.id !== r.parents[0]
                      ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${l} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)
                      : (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${u} ${s.x} ${i.y + f} L ${s.x} ${s.y}`)),
                  i.x > s.x &&
                    ((l = "A 20 20, 0, 0, 0,"),
                    (u = "A 20 20, 0, 0, 1,"),
                    (h = 20),
                    (f = 20),
                    r.type === yr.MERGE && t.id !== r.parents[0]
                      ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${u} ${i.x - f} ${s.y} L ${s.x} ${s.y}`)
                      : (p = `M ${i.x} ${i.y} L ${s.x + h} ${i.y} ${l} ${s.x} ${i.y + f} L ${s.x} ${s.y}`)),
                  i.x === s.x && (p = `M ${i.x} ${i.y} L ${s.x} ${s.y}`))
                : ar === "BT"
                  ? (i.x < s.x &&
                      (r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y + h} ${u} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${l} ${s.x} ${i.y - f} L ${s.x} ${s.y}`)),
                    i.x > s.x &&
                      ((l = "A 20 20, 0, 0, 0,"),
                      (u = "A 20 20, 0, 0, 1,"),
                      (h = 20),
                      (f = 20),
                      r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${i.x} ${s.y + h} ${l} ${i.x - f} ${s.y} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${l} ${s.x} ${i.y - f} L ${s.x} ${s.y}`)),
                    i.x === s.x && (p = `M ${i.x} ${i.y} L ${s.x} ${s.y}`))
                  : (i.y < s.y &&
                      (r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${u} ${s.x} ${i.y + f} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${i.x} ${s.y - h} ${l} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)),
                    i.y > s.y &&
                      (r.type === yr.MERGE && t.id !== r.parents[0]
                        ? (p = `M ${i.x} ${i.y} L ${s.x - h} ${i.y} ${l} ${s.x} ${i.y - f} L ${s.x} ${s.y}`)
                        : (p = `M ${i.x} ${i.y} L ${i.x} ${s.y + h} ${u} ${i.x + f} ${s.y} L ${s.x} ${s.y}`)),
                    i.y === s.y && (p = `M ${i.x} ${i.y} L ${s.x} ${s.y}`)));
          if (p === void 0) throw new Error("Line definition not found");
          e.append("path")
            .attr("d", p)
            .attr("class", "arrow arrow" + (d % Hh));
        }, "drawArrow")),
        (k6t = a((e, t) => {
          let r = e.append("g").attr("class", "commit-arrows");
          [...t.keys()].forEach((n) => {
            let i = t.get(n);
            i.parents &&
              i.parents.length > 0 &&
              i.parents.forEach((s) => {
                b6t(r, t.get(s), i, t);
              });
          });
        }, "drawArrows")),
        (T6t = a((e, t) => {
          let r = e.append("g");
          t.forEach((n, i) => {
            let s = i % Hh,
              o = xs.get(n.name)?.pos;
            if (o === void 0)
              throw new Error(`Position not found for branch ${n.name}`);
            let l = r.append("line");
            (l.attr("x1", 0),
              l.attr("y1", o),
              l.attr("x2", Qc),
              l.attr("y2", o),
              l.attr("class", "branch branch" + s),
              ar === "TB"
                ? (l.attr("y1", d_),
                  l.attr("x1", o),
                  l.attr("y2", Qc),
                  l.attr("x2", o))
                : ar === "BT" &&
                  (l.attr("y1", Qc),
                  l.attr("x1", o),
                  l.attr("y2", d_),
                  l.attr("x2", o)),
              p_.push(o));
            let u = n.name,
              h = _et(u),
              f = r.insert("rect"),
              p = r
                .insert("g")
                .attr("class", "branchLabel")
                .insert("g")
                .attr("class", "label branch-label" + s);
            p.node().appendChild(h);
            let m = h.getBBox();
            (f
              .attr("class", "branchLabelBkg label" + s)
              .attr("rx", 4)
              .attr("ry", 4)
              .attr("x", -m.width - 4 - (pa?.rotateCommitLabel === !0 ? 30 : 0))
              .attr("y", -m.height / 2 + 8)
              .attr("width", m.width + 18)
              .attr("height", m.height + 4),
              p.attr(
                "transform",
                "translate(" +
                  (-m.width - 14 - (pa?.rotateCommitLabel === !0 ? 30 : 0)) +
                  ", " +
                  (o - m.height / 2 - 1) +
                  ")",
              ),
              ar === "TB"
                ? (f.attr("x", o - m.width / 2 - 10).attr("y", 0),
                  p.attr(
                    "transform",
                    "translate(" + (o - m.width / 2 - 5) + ", 0)",
                  ))
                : ar === "BT"
                  ? (f.attr("x", o - m.width / 2 - 10).attr("y", Qc),
                    p.attr(
                      "transform",
                      "translate(" + (o - m.width / 2 - 5) + ", " + Qc + ")",
                    ))
                  : f.attr(
                      "transform",
                      "translate(-19, " + (o - m.height / 2) + ")",
                    ));
          });
        }, "drawBranches")),
        (S6t = a(function (e, t, r, n, i) {
          return (
            xs.set(e, { pos: t, index: r }),
            (t +=
              50 +
              (i ? 40 : 0) +
              (ar === "TB" || ar === "BT" ? n.width / 2 : 0)),
            t
          );
        }, "setBranchPosition")),
        (_6t = a(function (e, t, r, n) {
          if (
            (s6t(),
            P.debug(
              "in gitgraph renderer",
              e +
                `
`,
              "id:",
              t,
              r,
            ),
            !pa)
          )
            throw new Error("GitGraph config not found");
          let i = pa.rotateCommitLabel ?? !1,
            s = n.db;
          Dy = s.getCommits();
          let o = s.getBranchesAsObjArray();
          ar = s.getDirection();
          let l = xt(`[id="${t}"]`),
            u = 0;
          (o.forEach((h, f) => {
            let d = _et(h.name),
              p = l.append("g"),
              m = p.insert("g").attr("class", "branchLabel"),
              g = m.insert("g").attr("class", "label branch-label");
            g.node()?.appendChild(d);
            let y = d.getBBox();
            ((u = S6t(h.name, u, f, y, i)), g.remove(), m.remove(), p.remove());
          }),
            Tet(l, Dy, !1),
            pa.showBranches && T6t(l, o),
            k6t(l, Dy),
            Tet(l, Dy, !0),
            le.insertTitle(
              l,
              "gitTitleText",
              pa.titleTopMargin ?? 0,
              s.getDiagramTitle(),
            ),
            ww(void 0, l, pa.diagramPadding, pa.useMaxWidth));
        }, "draw")),
        (wet = { draw: _6t }));
    });
  var C6t,
    Eet,
    Aet = x(() => {
      "use strict";
      ((C6t = a(
        (e) => `
  .commit-id,
  .commit-msg,
  .branch-label {
    fill: lightgrey;
    color: lightgrey;
    font-family: 'trebuchet ms', verdana, arial, sans-serif;
    font-family: var(--mermaid-font-family);
  }
  ${[0, 1, 2, 3, 4, 5, 6, 7].map(
    (t) => `
        .branch-label${t} { fill: ${e["gitBranchLabel" + t]}; }
        .commit${t} { stroke: ${e["git" + t]}; fill: ${e["git" + t]}; }
        .commit-highlight${t} { stroke: ${e["gitInv" + t]}; fill: ${e["gitInv" + t]}; }
        .label${t}  { fill: ${e["git" + t]}; }
        .arrow${t} { stroke: ${e["git" + t]}; }
        `,
  ).join(`
`)}

  .branch {
    stroke-width: 1;
    stroke: ${e.lineColor};
    stroke-dasharray: 2;
  }
  .commit-label { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelColor};}
  .commit-label-bkg { font-size: ${e.commitLabelFontSize}; fill: ${e.commitLabelBackground}; opacity: 0.5; }
  .tag-label { font-size: ${e.tagLabelFontSize}; fill: ${e.tagLabelColor};}
  .tag-label-bkg { fill: ${e.tagLabelBackground}; stroke: ${e.tagLabelBorder}; }
  .tag-hole { fill: ${e.textColor}; }

  .commit-merge {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }
  .commit-reverse {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
    stroke-width: 3;
  }
  .commit-highlight-outer {
  }
  .commit-highlight-inner {
    stroke: ${e.primaryColor};
    fill: ${e.primaryColor};
  }

  .arrow { stroke-width: 8; stroke-linecap: round; fill: none}
  .gitTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
`,
        "getStyles",
      )),
        (Eet = C6t));
    });
  var Let = {};
  Oe(Let, { diagram: () => w6t });
  var w6t,
    Ret = x(() => {
      "use strict";
      ket();
      LD();
      vet();
      Aet();
      w6t = { parser: bet, db: f_, renderer: wet, styles: Eet };
    });
  var RD,
    Iet,
    Met = x(() => {
      "use strict";
      RD = (function () {
        var e = a(function (v, _, A, N) {
            for (A = A || {}, N = v.length; N--; A[v[N]] = _);
            return A;
          }, "o"),
          t = [
            6, 8, 10, 12, 13, 14, 15, 16, 17, 18, 20, 21, 22, 23, 24, 25, 26,
            27, 28, 29, 30, 31, 33, 35, 36, 38, 40,
          ],
          r = [1, 26],
          n = [1, 27],
          i = [1, 28],
          s = [1, 29],
          o = [1, 30],
          l = [1, 31],
          u = [1, 32],
          h = [1, 33],
          f = [1, 34],
          d = [1, 9],
          p = [1, 10],
          m = [1, 11],
          g = [1, 12],
          y = [1, 13],
          b = [1, 14],
          k = [1, 15],
          T = [1, 16],
          C = [1, 19],
          L = [1, 20],
          w = [1, 21],
          D = [1, 22],
          G = [1, 23],
          E = [1, 25],
          R = [1, 35],
          F = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              gantt: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NL: 10,
              weekday: 11,
              weekday_monday: 12,
              weekday_tuesday: 13,
              weekday_wednesday: 14,
              weekday_thursday: 15,
              weekday_friday: 16,
              weekday_saturday: 17,
              weekday_sunday: 18,
              weekend: 19,
              weekend_friday: 20,
              weekend_saturday: 21,
              dateFormat: 22,
              inclusiveEndDates: 23,
              topAxis: 24,
              axisFormat: 25,
              tickInterval: 26,
              excludes: 27,
              includes: 28,
              todayMarker: 29,
              title: 30,
              acc_title: 31,
              acc_title_value: 32,
              acc_descr: 33,
              acc_descr_value: 34,
              acc_descr_multiline_value: 35,
              section: 36,
              clickStatement: 37,
              taskTxt: 38,
              taskData: 39,
              click: 40,
              callbackname: 41,
              callbackargs: 42,
              href: 43,
              clickStatementDebug: 44,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "gantt",
              6: "EOF",
              8: "SPACE",
              10: "NL",
              12: "weekday_monday",
              13: "weekday_tuesday",
              14: "weekday_wednesday",
              15: "weekday_thursday",
              16: "weekday_friday",
              17: "weekday_saturday",
              18: "weekday_sunday",
              20: "weekend_friday",
              21: "weekend_saturday",
              22: "dateFormat",
              23: "inclusiveEndDates",
              24: "topAxis",
              25: "axisFormat",
              26: "tickInterval",
              27: "excludes",
              28: "includes",
              29: "todayMarker",
              30: "title",
              31: "acc_title",
              32: "acc_title_value",
              33: "acc_descr",
              34: "acc_descr_value",
              35: "acc_descr_multiline_value",
              36: "section",
              38: "taskTxt",
              39: "taskData",
              40: "click",
              41: "callbackname",
              42: "callbackargs",
              43: "href",
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [19, 1],
              [19, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 2],
              [37, 2],
              [37, 3],
              [37, 3],
              [37, 4],
              [37, 3],
              [37, 4],
              [37, 2],
              [44, 2],
              [44, 3],
              [44, 3],
              [44, 4],
              [44, 3],
              [44, 4],
              [44, 2],
            ],
            performAction: a(function (_, A, N, B, M, I, V) {
              var $ = I.length - 1;
              switch (M) {
                case 1:
                  return I[$ - 1];
                case 2:
                  this.$ = [];
                  break;
                case 3:
                  (I[$ - 1].push(I[$]), (this.$ = I[$ - 1]));
                  break;
                case 4:
                case 5:
                  this.$ = I[$];
                  break;
                case 6:
                case 7:
                  this.$ = [];
                  break;
                case 8:
                  B.setWeekday("monday");
                  break;
                case 9:
                  B.setWeekday("tuesday");
                  break;
                case 10:
                  B.setWeekday("wednesday");
                  break;
                case 11:
                  B.setWeekday("thursday");
                  break;
                case 12:
                  B.setWeekday("friday");
                  break;
                case 13:
                  B.setWeekday("saturday");
                  break;
                case 14:
                  B.setWeekday("sunday");
                  break;
                case 15:
                  B.setWeekend("friday");
                  break;
                case 16:
                  B.setWeekend("saturday");
                  break;
                case 17:
                  (B.setDateFormat(I[$].substr(11)),
                    (this.$ = I[$].substr(11)));
                  break;
                case 18:
                  (B.enableInclusiveEndDates(), (this.$ = I[$].substr(18)));
                  break;
                case 19:
                  (B.TopAxis(), (this.$ = I[$].substr(8)));
                  break;
                case 20:
                  (B.setAxisFormat(I[$].substr(11)),
                    (this.$ = I[$].substr(11)));
                  break;
                case 21:
                  (B.setTickInterval(I[$].substr(13)),
                    (this.$ = I[$].substr(13)));
                  break;
                case 22:
                  (B.setExcludes(I[$].substr(9)), (this.$ = I[$].substr(9)));
                  break;
                case 23:
                  (B.setIncludes(I[$].substr(9)), (this.$ = I[$].substr(9)));
                  break;
                case 24:
                  (B.setTodayMarker(I[$].substr(12)),
                    (this.$ = I[$].substr(12)));
                  break;
                case 27:
                  (B.setDiagramTitle(I[$].substr(6)),
                    (this.$ = I[$].substr(6)));
                  break;
                case 28:
                  ((this.$ = I[$].trim()), B.setAccTitle(this.$));
                  break;
                case 29:
                case 30:
                  ((this.$ = I[$].trim()), B.setAccDescription(this.$));
                  break;
                case 31:
                  (B.addSection(I[$].substr(8)), (this.$ = I[$].substr(8)));
                  break;
                case 33:
                  (B.addTask(I[$ - 1], I[$]), (this.$ = "task"));
                  break;
                case 34:
                  ((this.$ = I[$ - 1]), B.setClickEvent(I[$ - 1], I[$], null));
                  break;
                case 35:
                  ((this.$ = I[$ - 2]),
                    B.setClickEvent(I[$ - 2], I[$ - 1], I[$]));
                  break;
                case 36:
                  ((this.$ = I[$ - 2]),
                    B.setClickEvent(I[$ - 2], I[$ - 1], null),
                    B.setLink(I[$ - 2], I[$]));
                  break;
                case 37:
                  ((this.$ = I[$ - 3]),
                    B.setClickEvent(I[$ - 3], I[$ - 2], I[$ - 1]),
                    B.setLink(I[$ - 3], I[$]));
                  break;
                case 38:
                  ((this.$ = I[$ - 2]),
                    B.setClickEvent(I[$ - 2], I[$], null),
                    B.setLink(I[$ - 2], I[$ - 1]));
                  break;
                case 39:
                  ((this.$ = I[$ - 3]),
                    B.setClickEvent(I[$ - 3], I[$ - 1], I[$]),
                    B.setLink(I[$ - 3], I[$ - 2]));
                  break;
                case 40:
                  ((this.$ = I[$ - 1]), B.setLink(I[$ - 1], I[$]));
                  break;
                case 41:
                case 47:
                  this.$ = I[$ - 1] + " " + I[$];
                  break;
                case 42:
                case 43:
                case 45:
                  this.$ = I[$ - 2] + " " + I[$ - 1] + " " + I[$];
                  break;
                case 44:
                case 46:
                  this.$ =
                    I[$ - 3] + " " + I[$ - 2] + " " + I[$ - 1] + " " + I[$];
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              {
                6: [1, 4],
                7: 5,
                8: [1, 6],
                9: 7,
                10: [1, 8],
                11: 17,
                12: r,
                13: n,
                14: i,
                15: s,
                16: o,
                17: l,
                18: u,
                19: 18,
                20: h,
                21: f,
                22: d,
                23: p,
                24: m,
                25: g,
                26: y,
                27: b,
                28: k,
                29: T,
                30: C,
                31: L,
                33: w,
                35: D,
                36: G,
                37: 24,
                38: E,
                40: R,
              },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              {
                9: 36,
                11: 17,
                12: r,
                13: n,
                14: i,
                15: s,
                16: o,
                17: l,
                18: u,
                19: 18,
                20: h,
                21: f,
                22: d,
                23: p,
                24: m,
                25: g,
                26: y,
                27: b,
                28: k,
                29: T,
                30: C,
                31: L,
                33: w,
                35: D,
                36: G,
                37: 24,
                38: E,
                40: R,
              },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 17]),
              e(t, [2, 18]),
              e(t, [2, 19]),
              e(t, [2, 20]),
              e(t, [2, 21]),
              e(t, [2, 22]),
              e(t, [2, 23]),
              e(t, [2, 24]),
              e(t, [2, 25]),
              e(t, [2, 26]),
              e(t, [2, 27]),
              { 32: [1, 37] },
              { 34: [1, 38] },
              e(t, [2, 30]),
              e(t, [2, 31]),
              e(t, [2, 32]),
              { 39: [1, 39] },
              e(t, [2, 8]),
              e(t, [2, 9]),
              e(t, [2, 10]),
              e(t, [2, 11]),
              e(t, [2, 12]),
              e(t, [2, 13]),
              e(t, [2, 14]),
              e(t, [2, 15]),
              e(t, [2, 16]),
              { 41: [1, 40], 43: [1, 41] },
              e(t, [2, 4]),
              e(t, [2, 28]),
              e(t, [2, 29]),
              e(t, [2, 33]),
              e(t, [2, 34], { 42: [1, 42], 43: [1, 43] }),
              e(t, [2, 40], { 41: [1, 44] }),
              e(t, [2, 35], { 43: [1, 45] }),
              e(t, [2, 36]),
              e(t, [2, 38], { 42: [1, 46] }),
              e(t, [2, 37]),
              e(t, [2, 39]),
            ],
            defaultActions: {},
            parseError: a(function (_, A) {
              if (A.recoverable) this.trace(_);
              else {
                var N = new Error(_);
                throw ((N.hash = A), N);
              }
            }, "parseError"),
            parse: a(function (_) {
              var A = this,
                N = [0],
                B = [],
                M = [null],
                I = [],
                V = this.table,
                $ = "",
                q = 0,
                tt = 0,
                ht = 0,
                H = 2,
                kt = 1,
                ft = I.slice.call(arguments, 1),
                yt = Object.create(this.lexer),
                ot = { yy: {} };
              for (var dt in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, dt) &&
                  (ot.yy[dt] = this.yy[dt]);
              (yt.setInput(_, ot.yy),
                (ot.yy.lexer = yt),
                (ot.yy.parser = this),
                typeof yt.yylloc > "u" && (yt.yylloc = {}));
              var nt = yt.yylloc;
              I.push(nt);
              var Q = yt.options && yt.options.ranges;
              typeof ot.yy.parseError == "function"
                ? (this.parseError = ot.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function et(ct) {
                ((N.length = N.length - 2 * ct),
                  (M.length = M.length - ct),
                  (I.length = I.length - ct));
              }
              a(et, "popStack");
              function X() {
                var ct;
                return (
                  (ct = B.pop() || yt.lex() || kt),
                  typeof ct != "number" &&
                    (ct instanceof Array && ((B = ct), (ct = B.pop())),
                    (ct = A.symbols_[ct] || ct)),
                  ct
                );
              }
              a(X, "lex");
              for (var st, U, gt, z, ge, lt, jt = {}, Me, se, Nt, At; ; ) {
                if (
                  ((gt = N[N.length - 1]),
                  this.defaultActions[gt]
                    ? (z = this.defaultActions[gt])
                    : ((st === null || typeof st > "u") && (st = X()),
                      (z = V[gt] && V[gt][st])),
                  typeof z > "u" || !z.length || !z[0])
                ) {
                  var bt = "";
                  At = [];
                  for (Me in V[gt])
                    this.terminals_[Me] &&
                      Me > H &&
                      At.push("'" + this.terminals_[Me] + "'");
                  (yt.showPosition
                    ? (bt =
                        "Parse error on line " +
                        (q + 1) +
                        `:
` +
                        yt.showPosition() +
                        `
Expecting ` +
                        At.join(", ") +
                        ", got '" +
                        (this.terminals_[st] || st) +
                        "'")
                    : (bt =
                        "Parse error on line " +
                        (q + 1) +
                        ": Unexpected " +
                        (st == kt
                          ? "end of input"
                          : "'" + (this.terminals_[st] || st) + "'")),
                    this.parseError(bt, {
                      text: yt.match,
                      token: this.terminals_[st] || st,
                      line: yt.yylineno,
                      loc: nt,
                      expected: At,
                    }));
                }
                if (z[0] instanceof Array && z.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      gt +
                      ", token: " +
                      st,
                  );
                switch (z[0]) {
                  case 1:
                    (N.push(st),
                      M.push(yt.yytext),
                      I.push(yt.yylloc),
                      N.push(z[1]),
                      (st = null),
                      U
                        ? ((st = U), (U = null))
                        : ((tt = yt.yyleng),
                          ($ = yt.yytext),
                          (q = yt.yylineno),
                          (nt = yt.yylloc),
                          ht > 0 && ht--));
                    break;
                  case 2:
                    if (
                      ((se = this.productions_[z[1]][1]),
                      (jt.$ = M[M.length - se]),
                      (jt._$ = {
                        first_line: I[I.length - (se || 1)].first_line,
                        last_line: I[I.length - 1].last_line,
                        first_column: I[I.length - (se || 1)].first_column,
                        last_column: I[I.length - 1].last_column,
                      }),
                      Q &&
                        (jt._$.range = [
                          I[I.length - (se || 1)].range[0],
                          I[I.length - 1].range[1],
                        ]),
                      (lt = this.performAction.apply(
                        jt,
                        [$, tt, q, ot.yy, z[1], M, I].concat(ft),
                      )),
                      typeof lt < "u")
                    )
                      return lt;
                    (se &&
                      ((N = N.slice(0, -1 * se * 2)),
                      (M = M.slice(0, -1 * se)),
                      (I = I.slice(0, -1 * se))),
                      N.push(this.productions_[z[1]][0]),
                      M.push(jt.$),
                      I.push(jt._$),
                      (Nt = V[N[N.length - 2]][N[N.length - 1]]),
                      N.push(Nt));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          S = (function () {
            var v = {
              EOF: 1,
              parseError: a(function (A, N) {
                if (this.yy.parser) this.yy.parser.parseError(A, N);
                else throw new Error(A);
              }, "parseError"),
              setInput: a(function (_, A) {
                return (
                  (this.yy = A || this.yy || {}),
                  (this._input = _),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var _ = this._input[0];
                ((this.yytext += _),
                  this.yyleng++,
                  this.offset++,
                  (this.match += _),
                  (this.matched += _));
                var A = _.match(/(?:\r\n?|\n).*/g);
                return (
                  A
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  _
                );
              }, "input"),
              unput: a(function (_) {
                var A = _.length,
                  N = _.split(/(?:\r\n?|\n)/g);
                ((this._input = _ + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - A)),
                  (this.offset -= A));
                var B = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  N.length - 1 && (this.yylineno -= N.length - 1));
                var M = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: N
                      ? (N.length === B.length ? this.yylloc.first_column : 0) +
                        B[B.length - N.length].length -
                        N[0].length
                      : this.yylloc.first_column - A,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [M[0], M[0] + this.yyleng - A]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (_) {
                this.unput(this.match.slice(_));
              }, "less"),
              pastInput: a(function () {
                var _ = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (_.length > 20 ? "..." : "") +
                  _.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var _ = this.match;
                return (
                  _.length < 20 && (_ += this._input.substr(0, 20 - _.length)),
                  (_.substr(0, 20) + (_.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var _ = this.pastInput(),
                  A = new Array(_.length + 1).join("-");
                return (
                  _ +
                  this.upcomingInput() +
                  `
` +
                  A +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (_, A) {
                var N, B, M;
                if (
                  (this.options.backtrack_lexer &&
                    ((M = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (M.yylloc.range = this.yylloc.range.slice(0))),
                  (B = _[0].match(/(?:\r\n?|\n).*/g)),
                  B && (this.yylineno += B.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: B
                      ? B[B.length - 1].length -
                        B[B.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + _[0].length,
                  }),
                  (this.yytext += _[0]),
                  (this.match += _[0]),
                  (this.matches = _),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(_[0].length)),
                  (this.matched += _[0]),
                  (N = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    A,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  N)
                )
                  return N;
                if (this._backtrack) {
                  for (var I in M) this[I] = M[I];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var _, A, N, B;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var M = this._currentRules(), I = 0; I < M.length; I++)
                  if (
                    ((N = this._input.match(this.rules[M[I]])),
                    N && (!A || N[0].length > A[0].length))
                  ) {
                    if (((A = N), (B = I), this.options.backtrack_lexer)) {
                      if (((_ = this.test_match(N, M[I])), _ !== !1)) return _;
                      if (this._backtrack) {
                        A = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return A
                  ? ((_ = this.test_match(A, M[B])), _ !== !1 ? _ : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var A = this.next();
                return A || this.lex();
              }, "lex"),
              begin: a(function (A) {
                this.conditionStack.push(A);
              }, "begin"),
              popState: a(function () {
                var A = this.conditionStack.length - 1;
                return A > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (A) {
                return (
                  (A = this.conditionStack.length - 1 - Math.abs(A || 0)),
                  A >= 0 ? this.conditionStack[A] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (A) {
                this.begin(A);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (A, N, B, M) {
                var I = M;
                switch (B) {
                  case 0:
                    return (this.begin("open_directive"), "open_directive");
                    break;
                  case 1:
                    return (this.begin("acc_title"), 31);
                    break;
                  case 2:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 3:
                    return (this.begin("acc_descr"), 33);
                    break;
                  case 4:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 5:
                    this.begin("acc_descr_multiline");
                    break;
                  case 6:
                    this.popState();
                    break;
                  case 7:
                    return "acc_descr_multiline_value";
                  case 8:
                    break;
                  case 9:
                    break;
                  case 10:
                    break;
                  case 11:
                    return 10;
                  case 12:
                    break;
                  case 13:
                    break;
                  case 14:
                    this.begin("href");
                    break;
                  case 15:
                    this.popState();
                    break;
                  case 16:
                    return 43;
                  case 17:
                    this.begin("callbackname");
                    break;
                  case 18:
                    this.popState();
                    break;
                  case 19:
                    (this.popState(), this.begin("callbackargs"));
                    break;
                  case 20:
                    return 41;
                  case 21:
                    this.popState();
                    break;
                  case 22:
                    return 42;
                  case 23:
                    this.begin("click");
                    break;
                  case 24:
                    this.popState();
                    break;
                  case 25:
                    return 40;
                  case 26:
                    return 4;
                  case 27:
                    return 22;
                  case 28:
                    return 23;
                  case 29:
                    return 24;
                  case 30:
                    return 25;
                  case 31:
                    return 26;
                  case 32:
                    return 28;
                  case 33:
                    return 27;
                  case 34:
                    return 29;
                  case 35:
                    return 12;
                  case 36:
                    return 13;
                  case 37:
                    return 14;
                  case 38:
                    return 15;
                  case 39:
                    return 16;
                  case 40:
                    return 17;
                  case 41:
                    return 18;
                  case 42:
                    return 20;
                  case 43:
                    return 21;
                  case 44:
                    return "date";
                  case 45:
                    return 30;
                  case 46:
                    return "accDescription";
                  case 47:
                    return 36;
                  case 48:
                    return 38;
                  case 49:
                    return 39;
                  case 50:
                    return ":";
                  case 51:
                    return 6;
                  case 52:
                    return "INVALID";
                }
              }, "anonymous"),
              rules: [
                /^(?:%%\{)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:%%(?!\{)*[^\n]*)/i,
                /^(?:[^\}]%%*[^\n]*)/i,
                /^(?:%%*[^\n]*[\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:%[^\n]*)/i,
                /^(?:href[\s]+["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:call[\s]+)/i,
                /^(?:\([\s]*\))/i,
                /^(?:\()/i,
                /^(?:[^(]*)/i,
                /^(?:\))/i,
                /^(?:[^)]*)/i,
                /^(?:click[\s]+)/i,
                /^(?:[\s\n])/i,
                /^(?:[^\s\n]*)/i,
                /^(?:gantt\b)/i,
                /^(?:dateFormat\s[^#\n;]+)/i,
                /^(?:inclusiveEndDates\b)/i,
                /^(?:topAxis\b)/i,
                /^(?:axisFormat\s[^#\n;]+)/i,
                /^(?:tickInterval\s[^#\n;]+)/i,
                /^(?:includes\s[^#\n;]+)/i,
                /^(?:excludes\s[^#\n;]+)/i,
                /^(?:todayMarker\s[^\n;]+)/i,
                /^(?:weekday\s+monday\b)/i,
                /^(?:weekday\s+tuesday\b)/i,
                /^(?:weekday\s+wednesday\b)/i,
                /^(?:weekday\s+thursday\b)/i,
                /^(?:weekday\s+friday\b)/i,
                /^(?:weekday\s+saturday\b)/i,
                /^(?:weekday\s+sunday\b)/i,
                /^(?:weekend\s+friday\b)/i,
                /^(?:weekend\s+saturday\b)/i,
                /^(?:\d\d\d\d-\d\d-\d\d\b)/i,
                /^(?:title\s[^\n]+)/i,
                /^(?:accDescription\s[^#\n;]+)/i,
                /^(?:section\s[^\n]+)/i,
                /^(?:[^:\n]+)/i,
                /^(?::[^#\n;]+)/i,
                /^(?::)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [6, 7], inclusive: !1 },
                acc_descr: { rules: [4], inclusive: !1 },
                acc_title: { rules: [2], inclusive: !1 },
                callbackargs: { rules: [21, 22], inclusive: !1 },
                callbackname: { rules: [18, 19, 20], inclusive: !1 },
                href: { rules: [15, 16], inclusive: !1 },
                click: { rules: [24, 25], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 17, 23, 26, 27, 28,
                    29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
                    44, 45, 46, 47, 48, 49, 50, 51, 52,
                  ],
                  inclusive: !0,
                },
              },
            };
            return v;
          })();
        F.lexer = S;
        function O() {
          this.yy = {};
        }
        return (a(O, "Parser"), (O.prototype = F), (F.Parser = O), new O());
      })();
      RD.parser = RD;
      Iet = RD;
    });
  var Oet = to((DD, ND) => {
    "use strict";
    (function (e, t) {
      typeof DD == "object" && typeof ND < "u"
        ? (ND.exports = t())
        : typeof define == "function" && define.amd
          ? define(t)
          : ((e =
              typeof globalThis < "u"
                ? globalThis
                : e || self).dayjs_plugin_isoWeek = t());
    })(DD, function () {
      "use strict";
      var e = "day";
      return function (t, r, n) {
        var i = a(function (l) {
            return l.add(4 - l.isoWeekday(), e);
          }, "a"),
          s = r.prototype;
        ((s.isoWeekYear = function () {
          return i(this).year();
        }),
          (s.isoWeek = function (l) {
            if (!this.$utils().u(l))
              return this.add(7 * (l - this.isoWeek()), e);
            var u,
              h,
              f,
              d,
              p = i(this),
              m =
                ((u = this.isoWeekYear()),
                (h = this.$u),
                (f = (h ? n.utc : n)().year(u).startOf("year")),
                (d = 4 - f.isoWeekday()),
                f.isoWeekday() > 4 && (d += 7),
                f.add(d, e));
            return p.diff(m, "week") + 1;
          }),
          (s.isoWeekday = function (l) {
            return this.$utils().u(l)
              ? this.day() || 7
              : this.day(this.day() % 7 ? l : l - 7);
          }));
        var o = s.startOf;
        s.startOf = function (l, u) {
          var h = this.$utils(),
            f = !!h.u(u) || u;
          return h.p(l) === "isoweek"
            ? f
              ? this.date(this.date() - (this.isoWeekday() - 1)).startOf("day")
              : this.date(this.date() - 1 - (this.isoWeekday() - 1) + 7).endOf(
                  "day",
                )
            : o.bind(this)(l, u);
        };
      };
    });
  });
  var Pet = to((ID, MD) => {
    "use strict";
    (function (e, t) {
      typeof ID == "object" && typeof MD < "u"
        ? (MD.exports = t())
        : typeof define == "function" && define.amd
          ? define(t)
          : ((e =
              typeof globalThis < "u"
                ? globalThis
                : e || self).dayjs_plugin_customParseFormat = t());
    })(ID, function () {
      "use strict";
      var e = {
          LTS: "h:mm:ss A",
          LT: "h:mm A",
          L: "MM/DD/YYYY",
          LL: "MMMM D, YYYY",
          LLL: "MMMM D, YYYY h:mm A",
          LLLL: "dddd, MMMM D, YYYY h:mm A",
        },
        t =
          /(\[[^[]*\])|([-_:/.,()\s]+)|(A|a|Q|YYYY|YY?|ww?|MM?M?M?|Do|DD?|hh?|HH?|mm?|ss?|S{1,3}|z|ZZ?)/g,
        r = /\d/,
        n = /\d\d/,
        i = /\d\d?/,
        s = /\d*[^-_:/,()\s\d]+/,
        o = {},
        l = a(function (g) {
          return (g = +g) + (g > 68 ? 1900 : 2e3);
        }, "a"),
        u = a(function (g) {
          return function (y) {
            this[g] = +y;
          };
        }, "f"),
        h = [
          /[+-]\d\d:?(\d\d)?|Z/,
          function (g) {
            (this.zone || (this.zone = {})).offset = (function (y) {
              if (!y || y === "Z") return 0;
              var b = y.match(/([+-]|\d\d)/g),
                k = 60 * b[1] + (+b[2] || 0);
              return k === 0 ? 0 : b[0] === "+" ? -k : k;
            })(g);
          },
        ],
        f = a(function (g) {
          var y = o[g];
          return y && (y.indexOf ? y : y.s.concat(y.f));
        }, "u"),
        d = a(function (g, y) {
          var b,
            k = o.meridiem;
          if (k) {
            for (var T = 1; T <= 24; T += 1)
              if (g.indexOf(k(T, 0, y)) > -1) {
                b = T > 12;
                break;
              }
          } else b = g === (y ? "pm" : "PM");
          return b;
        }, "d"),
        p = {
          A: [
            s,
            function (g) {
              this.afternoon = d(g, !1);
            },
          ],
          a: [
            s,
            function (g) {
              this.afternoon = d(g, !0);
            },
          ],
          Q: [
            r,
            function (g) {
              this.month = 3 * (g - 1) + 1;
            },
          ],
          S: [
            r,
            function (g) {
              this.milliseconds = 100 * +g;
            },
          ],
          SS: [
            n,
            function (g) {
              this.milliseconds = 10 * +g;
            },
          ],
          SSS: [
            /\d{3}/,
            function (g) {
              this.milliseconds = +g;
            },
          ],
          s: [i, u("seconds")],
          ss: [i, u("seconds")],
          m: [i, u("minutes")],
          mm: [i, u("minutes")],
          H: [i, u("hours")],
          h: [i, u("hours")],
          HH: [i, u("hours")],
          hh: [i, u("hours")],
          D: [i, u("day")],
          DD: [n, u("day")],
          Do: [
            s,
            function (g) {
              var y = o.ordinal,
                b = g.match(/\d+/);
              if (((this.day = b[0]), y))
                for (var k = 1; k <= 31; k += 1)
                  y(k).replace(/\[|\]/g, "") === g && (this.day = k);
            },
          ],
          w: [i, u("week")],
          ww: [n, u("week")],
          M: [i, u("month")],
          MM: [n, u("month")],
          MMM: [
            s,
            function (g) {
              var y = f("months"),
                b =
                  (
                    f("monthsShort") ||
                    y.map(function (k) {
                      return k.slice(0, 3);
                    })
                  ).indexOf(g) + 1;
              if (b < 1) throw new Error();
              this.month = b % 12 || b;
            },
          ],
          MMMM: [
            s,
            function (g) {
              var y = f("months").indexOf(g) + 1;
              if (y < 1) throw new Error();
              this.month = y % 12 || y;
            },
          ],
          Y: [/[+-]?\d+/, u("year")],
          YY: [
            n,
            function (g) {
              this.year = l(g);
            },
          ],
          YYYY: [/\d{4}/, u("year")],
          Z: h,
          ZZ: h,
        };
      function m(g) {
        var y, b;
        ((y = g), (b = o && o.formats));
        for (
          var k = (g = y.replace(
              /(\[[^\]]+])|(LTS?|l{1,4}|L{1,4})/g,
              function (E, R, F) {
                var S = F && F.toUpperCase();
                return (
                  R ||
                  b[F] ||
                  e[F] ||
                  b[S].replace(
                    /(\[[^\]]+])|(MMMM|MM|DD|dddd)/g,
                    function (O, v, _) {
                      return v || _.slice(1);
                    },
                  )
                );
              },
            )).match(t),
            T = k.length,
            C = 0;
          C < T;
          C += 1
        ) {
          var L = k[C],
            w = p[L],
            D = w && w[0],
            G = w && w[1];
          k[C] = G ? { regex: D, parser: G } : L.replace(/^\[|\]$/g, "");
        }
        return function (E) {
          for (var R = {}, F = 0, S = 0; F < T; F += 1) {
            var O = k[F];
            if (typeof O == "string") S += O.length;
            else {
              var v = O.regex,
                _ = O.parser,
                A = E.slice(S),
                N = v.exec(A)[0];
              (_.call(R, N), (E = E.replace(N, "")));
            }
          }
          return (
            (function (B) {
              var M = B.afternoon;
              if (M !== void 0) {
                var I = B.hours;
                (M ? I < 12 && (B.hours += 12) : I === 12 && (B.hours = 0),
                  delete B.afternoon);
              }
            })(R),
            R
          );
        };
      }
      return (
        a(m, "l"),
        function (g, y, b) {
          ((b.p.customParseFormat = !0),
            g && g.parseTwoDigitYear && (l = g.parseTwoDigitYear));
          var k = y.prototype,
            T = k.parse;
          k.parse = function (C) {
            var L = C.date,
              w = C.utc,
              D = C.args;
            this.$u = w;
            var G = D[1];
            if (typeof G == "string") {
              var E = D[2] === !0,
                R = D[3] === !0,
                F = E || R,
                S = D[2];
              (R && (S = D[2]),
                (o = this.$locale()),
                !E && S && (o = b.Ls[S]),
                (this.$d = (function (A, N, B, M) {
                  try {
                    if (["x", "X"].indexOf(N) > -1)
                      return new Date((N === "X" ? 1e3 : 1) * A);
                    var I = m(N)(A),
                      V = I.year,
                      $ = I.month,
                      q = I.day,
                      tt = I.hours,
                      ht = I.minutes,
                      H = I.seconds,
                      kt = I.milliseconds,
                      ft = I.zone,
                      yt = I.week,
                      ot = new Date(),
                      dt = q || (V || $ ? 1 : ot.getDate()),
                      nt = V || ot.getFullYear(),
                      Q = 0;
                    (V && !$) || (Q = $ > 0 ? $ - 1 : ot.getMonth());
                    var et,
                      X = tt || 0,
                      st = ht || 0,
                      U = H || 0,
                      gt = kt || 0;
                    return ft
                      ? new Date(
                          Date.UTC(
                            nt,
                            Q,
                            dt,
                            X,
                            st,
                            U,
                            gt + 60 * ft.offset * 1e3,
                          ),
                        )
                      : B
                        ? new Date(Date.UTC(nt, Q, dt, X, st, U, gt))
                        : ((et = new Date(nt, Q, dt, X, st, U, gt)),
                          yt && (et = M(et).week(yt).toDate()),
                          et);
                  } catch {
                    return new Date("");
                  }
                })(L, G, w, b)),
                this.init(),
                S && S !== !0 && (this.$L = this.locale(S).$L),
                F && L != this.format(G) && (this.$d = new Date("")),
                (o = {}));
            } else if (G instanceof Array)
              for (var O = G.length, v = 1; v <= O; v += 1) {
                D[1] = G[v - 1];
                var _ = b.apply(this, D);
                if (_.isValid()) {
                  ((this.$d = _.$d), (this.$L = _.$L), this.init());
                  break;
                }
                v === O && (this.$d = new Date(""));
              }
            else T.call(this, C);
          };
        }
      );
    });
  });
  var Bet = to((OD, PD) => {
    "use strict";
    (function (e, t) {
      typeof OD == "object" && typeof PD < "u"
        ? (PD.exports = t())
        : typeof define == "function" && define.amd
          ? define(t)
          : ((e =
              typeof globalThis < "u"
                ? globalThis
                : e || self).dayjs_plugin_advancedFormat = t());
    })(OD, function () {
      "use strict";
      return function (e, t) {
        var r = t.prototype,
          n = r.format;
        r.format = function (i) {
          var s = this,
            o = this.$locale();
          if (!this.isValid()) return n.bind(this)(i);
          var l = this.$utils(),
            u = (i || "YYYY-MM-DDTHH:mm:ssZ").replace(
              /\[([^\]]+)]|Q|wo|ww|w|WW|W|zzz|z|gggg|GGGG|Do|X|x|k{1,2}|S/g,
              function (h) {
                switch (h) {
                  case "Q":
                    return Math.ceil((s.$M + 1) / 3);
                  case "Do":
                    return o.ordinal(s.$D);
                  case "gggg":
                    return s.weekYear();
                  case "GGGG":
                    return s.isoWeekYear();
                  case "wo":
                    return o.ordinal(s.week(), "W");
                  case "w":
                  case "ww":
                    return l.s(s.week(), h === "w" ? 1 : 2, "0");
                  case "W":
                  case "WW":
                    return l.s(s.isoWeek(), h === "W" ? 1 : 2, "0");
                  case "k":
                  case "kk":
                    return l.s(
                      String(s.$H === 0 ? 24 : s.$H),
                      h === "k" ? 1 : 2,
                      "0",
                    );
                  case "X":
                    return Math.floor(s.$d.getTime() / 1e3);
                  case "x":
                    return s.$d.getTime();
                  case "z":
                    return "[" + s.offsetName() + "]";
                  case "zzz":
                    return "[" + s.offsetName("long") + "]";
                  default:
                    return h;
                }
              },
            );
          return n.bind(this)(u);
        };
      };
    });
  });
  function Jet(e, t, r) {
    let n = !0;
    for (; n; )
      ((n = !1),
        r.forEach(function (i) {
          let s = "^\\s*" + i + "\\s*$",
            o = new RegExp(s);
          e[0].match(o) && ((t[i] = !0), e.shift(1), (n = !0));
        }));
  }
  var Get,
    Fs,
    Vet,
    zet,
    Wet,
    Fet,
    Yo,
    GD,
    VD,
    zD,
    Iy,
    My,
    WD,
    UD,
    y_,
    bm,
    jD,
    Uet,
    qD,
    Oy,
    HD,
    YD,
    x_,
    BD,
    L6t,
    R6t,
    D6t,
    N6t,
    I6t,
    M6t,
    O6t,
    P6t,
    B6t,
    F6t,
    $6t,
    G6t,
    V6t,
    z6t,
    W6t,
    U6t,
    j6t,
    q6t,
    H6t,
    Y6t,
    X6t,
    K6t,
    Q6t,
    jet,
    Z6t,
    J6t,
    tLt,
    qet,
    eLt,
    FD,
    Het,
    Yet,
    m_,
    xm,
    rLt,
    nLt,
    $D,
    g_,
    $n,
    Xet,
    iLt,
    Yh,
    sLt,
    $et,
    aLt,
    Ket,
    oLt,
    Qet,
    lLt,
    cLt,
    Zet,
    trt = x(() => {
      "use strict";
      ((Get = Ts(Vf(), 1)),
        (Fs = Ts(ox(), 1)),
        (Vet = Ts(Oet(), 1)),
        (zet = Ts(Pet(), 1)),
        (Wet = Ts(Bet(), 1)));
      Vt();
      pe();
      _e();
      yn();
      Fs.default.extend(Vet.default);
      Fs.default.extend(zet.default);
      Fs.default.extend(Wet.default);
      ((Fet = { friday: 5, saturday: 6 }),
        (Yo = ""),
        (GD = ""),
        (zD = ""),
        (Iy = []),
        (My = []),
        (WD = new Map()),
        (UD = []),
        (y_ = []),
        (bm = ""),
        (jD = ""),
        (Uet = ["active", "done", "crit", "milestone", "vert"]),
        (qD = []),
        (Oy = !1),
        (HD = !1),
        (YD = "sunday"),
        (x_ = "saturday"),
        (BD = 0),
        (L6t = a(function () {
          ((UD = []),
            (y_ = []),
            (bm = ""),
            (qD = []),
            (m_ = 0),
            ($D = void 0),
            (g_ = void 0),
            ($n = []),
            (Yo = ""),
            (GD = ""),
            (jD = ""),
            (VD = void 0),
            (zD = ""),
            (Iy = []),
            (My = []),
            (Oy = !1),
            (HD = !1),
            (BD = 0),
            (WD = new Map()),
            Ye(),
            (YD = "sunday"),
            (x_ = "saturday"));
        }, "clear")),
        (R6t = a(function (e) {
          GD = e;
        }, "setAxisFormat")),
        (D6t = a(function () {
          return GD;
        }, "getAxisFormat")),
        (N6t = a(function (e) {
          VD = e;
        }, "setTickInterval")),
        (I6t = a(function () {
          return VD;
        }, "getTickInterval")),
        (M6t = a(function (e) {
          zD = e;
        }, "setTodayMarker")),
        (O6t = a(function () {
          return zD;
        }, "getTodayMarker")),
        (P6t = a(function (e) {
          Yo = e;
        }, "setDateFormat")),
        (B6t = a(function () {
          Oy = !0;
        }, "enableInclusiveEndDates")),
        (F6t = a(function () {
          return Oy;
        }, "endDatesAreInclusive")),
        ($6t = a(function () {
          HD = !0;
        }, "enableTopAxis")),
        (G6t = a(function () {
          return HD;
        }, "topAxisEnabled")),
        (V6t = a(function (e) {
          jD = e;
        }, "setDisplayMode")),
        (z6t = a(function () {
          return jD;
        }, "getDisplayMode")),
        (W6t = a(function () {
          return Yo;
        }, "getDateFormat")),
        (U6t = a(function (e) {
          Iy = e.toLowerCase().split(/[\s,]+/);
        }, "setIncludes")),
        (j6t = a(function () {
          return Iy;
        }, "getIncludes")),
        (q6t = a(function (e) {
          My = e.toLowerCase().split(/[\s,]+/);
        }, "setExcludes")),
        (H6t = a(function () {
          return My;
        }, "getExcludes")),
        (Y6t = a(function () {
          return WD;
        }, "getLinks")),
        (X6t = a(function (e) {
          ((bm = e), UD.push(e));
        }, "addSection")),
        (K6t = a(function () {
          return UD;
        }, "getSections")),
        (Q6t = a(function () {
          let e = $et(),
            t = 10,
            r = 0;
          for (; !e && r < t; ) ((e = $et()), r++);
          return ((y_ = $n), y_);
        }, "getTasks")),
        (jet = a(function (e, t, r, n) {
          let i = e.format(t.trim()),
            s = e.format("YYYY-MM-DD");
          return n.includes(i) || n.includes(s)
            ? !1
            : (r.includes("weekends") &&
                  (e.isoWeekday() === Fet[x_] ||
                    e.isoWeekday() === Fet[x_] + 1)) ||
                r.includes(e.format("dddd").toLowerCase())
              ? !0
              : r.includes(i) || r.includes(s);
        }, "isInvalidDate")),
        (Z6t = a(function (e) {
          YD = e;
        }, "setWeekday")),
        (J6t = a(function () {
          return YD;
        }, "getWeekday")),
        (tLt = a(function (e) {
          x_ = e;
        }, "setWeekend")),
        (qet = a(function (e, t, r, n) {
          if (!r.length || e.manualEndTime) return;
          let i;
          (e.startTime instanceof Date
            ? (i = (0, Fs.default)(e.startTime))
            : (i = (0, Fs.default)(e.startTime, t, !0)),
            (i = i.add(1, "d")));
          let s;
          e.endTime instanceof Date
            ? (s = (0, Fs.default)(e.endTime))
            : (s = (0, Fs.default)(e.endTime, t, !0));
          let [o, l] = eLt(i, s, t, r, n);
          ((e.endTime = o.toDate()), (e.renderEndTime = l));
        }, "checkTaskDates")),
        (eLt = a(function (e, t, r, n, i) {
          let s = !1,
            o = null;
          for (; e <= t; )
            (s || (o = t.toDate()),
              (s = jet(e, r, n, i)),
              s && (t = t.add(1, "d")),
              (e = e.add(1, "d")));
          return [t, o];
        }, "fixTaskDates")),
        (FD = a(function (e, t, r) {
          r = r.trim();
          let i = /^after\s+(?<ids>[\d\w- ]+)/.exec(r);
          if (i !== null) {
            let o = null;
            for (let u of i.groups.ids.split(" ")) {
              let h = Yh(u);
              h !== void 0 && (!o || h.endTime > o.endTime) && (o = h);
            }
            if (o) return o.endTime;
            let l = new Date();
            return (l.setHours(0, 0, 0, 0), l);
          }
          let s = (0, Fs.default)(r, t.trim(), !0);
          if (s.isValid()) return s.toDate();
          {
            (P.debug("Invalid date:" + r),
              P.debug("With date format:" + t.trim()));
            let o = new Date(r);
            if (
              o === void 0 ||
              isNaN(o.getTime()) ||
              o.getFullYear() < -1e4 ||
              o.getFullYear() > 1e4
            )
              throw new Error("Invalid date:" + r);
            return o;
          }
        }, "getStartDate")),
        (Het = a(function (e) {
          let t = /^(\d+(?:\.\d+)?)([Mdhmswy]|ms)$/.exec(e.trim());
          return t !== null ? [Number.parseFloat(t[1]), t[2]] : [NaN, "ms"];
        }, "parseDuration")),
        (Yet = a(function (e, t, r, n = !1) {
          r = r.trim();
          let s = /^until\s+(?<ids>[\d\w- ]+)/.exec(r);
          if (s !== null) {
            let f = null;
            for (let p of s.groups.ids.split(" ")) {
              let m = Yh(p);
              m !== void 0 && (!f || m.startTime < f.startTime) && (f = m);
            }
            if (f) return f.startTime;
            let d = new Date();
            return (d.setHours(0, 0, 0, 0), d);
          }
          let o = (0, Fs.default)(r, t.trim(), !0);
          if (o.isValid()) return (n && (o = o.add(1, "d")), o.toDate());
          let l = (0, Fs.default)(e),
            [u, h] = Het(r);
          if (!Number.isNaN(u)) {
            let f = l.add(u, h);
            f.isValid() && (l = f);
          }
          return l.toDate();
        }, "getEndDate")),
        (m_ = 0),
        (xm = a(function (e) {
          return e === void 0 ? ((m_ = m_ + 1), "task" + m_) : e;
        }, "parseId")),
        (rLt = a(function (e, t) {
          let r;
          t.substr(0, 1) === ":" ? (r = t.substr(1, t.length)) : (r = t);
          let n = r.split(","),
            i = {};
          Jet(n, i, Uet);
          for (let o = 0; o < n.length; o++) n[o] = n[o].trim();
          let s = "";
          switch (n.length) {
            case 1:
              ((i.id = xm()), (i.startTime = e.endTime), (s = n[0]));
              break;
            case 2:
              ((i.id = xm()), (i.startTime = FD(void 0, Yo, n[0])), (s = n[1]));
              break;
            case 3:
              ((i.id = xm(n[0])),
                (i.startTime = FD(void 0, Yo, n[1])),
                (s = n[2]));
              break;
            default:
          }
          return (
            s &&
              ((i.endTime = Yet(i.startTime, Yo, s, Oy)),
              (i.manualEndTime = (0, Fs.default)(
                s,
                "YYYY-MM-DD",
                !0,
              ).isValid()),
              qet(i, Yo, My, Iy)),
            i
          );
        }, "compileData")),
        (nLt = a(function (e, t) {
          let r;
          t.substr(0, 1) === ":" ? (r = t.substr(1, t.length)) : (r = t);
          let n = r.split(","),
            i = {};
          Jet(n, i, Uet);
          for (let s = 0; s < n.length; s++) n[s] = n[s].trim();
          switch (n.length) {
            case 1:
              ((i.id = xm()),
                (i.startTime = { type: "prevTaskEnd", id: e }),
                (i.endTime = { data: n[0] }));
              break;
            case 2:
              ((i.id = xm()),
                (i.startTime = { type: "getStartDate", startData: n[0] }),
                (i.endTime = { data: n[1] }));
              break;
            case 3:
              ((i.id = xm(n[0])),
                (i.startTime = { type: "getStartDate", startData: n[1] }),
                (i.endTime = { data: n[2] }));
              break;
            default:
          }
          return i;
        }, "parseData")),
        ($n = []),
        (Xet = {}),
        (iLt = a(function (e, t) {
          let r = {
              section: bm,
              type: bm,
              processed: !1,
              manualEndTime: !1,
              renderEndTime: null,
              raw: { data: t },
              task: e,
              classes: [],
            },
            n = nLt(g_, t);
          ((r.raw.startTime = n.startTime),
            (r.raw.endTime = n.endTime),
            (r.id = n.id),
            (r.prevTaskId = g_),
            (r.active = n.active),
            (r.done = n.done),
            (r.crit = n.crit),
            (r.milestone = n.milestone),
            (r.vert = n.vert),
            (r.order = BD),
            BD++);
          let i = $n.push(r);
          ((g_ = r.id), (Xet[r.id] = i - 1));
        }, "addTask")),
        (Yh = a(function (e) {
          let t = Xet[e];
          return $n[t];
        }, "findTaskById")),
        (sLt = a(function (e, t) {
          let r = {
              section: bm,
              type: bm,
              description: e,
              task: e,
              classes: [],
            },
            n = rLt($D, t);
          ((r.startTime = n.startTime),
            (r.endTime = n.endTime),
            (r.id = n.id),
            (r.active = n.active),
            (r.done = n.done),
            (r.crit = n.crit),
            (r.milestone = n.milestone),
            (r.vert = n.vert),
            ($D = r),
            y_.push(r));
        }, "addTaskOrg")),
        ($et = a(function () {
          let e = a(function (r) {
              let n = $n[r],
                i = "";
              switch ($n[r].raw.startTime.type) {
                case "prevTaskEnd": {
                  let s = Yh(n.prevTaskId);
                  n.startTime = s.endTime;
                  break;
                }
                case "getStartDate":
                  ((i = FD(void 0, Yo, $n[r].raw.startTime.startData)),
                    i && ($n[r].startTime = i));
                  break;
              }
              return (
                $n[r].startTime &&
                  (($n[r].endTime = Yet(
                    $n[r].startTime,
                    Yo,
                    $n[r].raw.endTime.data,
                    Oy,
                  )),
                  $n[r].endTime &&
                    (($n[r].processed = !0),
                    ($n[r].manualEndTime = (0, Fs.default)(
                      $n[r].raw.endTime.data,
                      "YYYY-MM-DD",
                      !0,
                    ).isValid()),
                    qet($n[r], Yo, My, Iy))),
                $n[r].processed
              );
            }, "compileTask"),
            t = !0;
          for (let [r, n] of $n.entries()) (e(r), (t = t && n.processed));
          return t;
        }, "compileTasks")),
        (aLt = a(function (e, t) {
          let r = t;
          (K().securityLevel !== "loose" && (r = (0, Get.sanitizeUrl)(t)),
            e.split(",").forEach(function (n) {
              Yh(n) !== void 0 &&
                (Qet(n, () => {
                  window.open(r, "_self");
                }),
                WD.set(n, r));
            }),
            Ket(e, "clickable"));
        }, "setLink")),
        (Ket = a(function (e, t) {
          e.split(",").forEach(function (r) {
            let n = Yh(r);
            n !== void 0 && n.classes.push(t);
          });
        }, "setClass")),
        (oLt = a(function (e, t, r) {
          if (K().securityLevel !== "loose" || t === void 0) return;
          let n = [];
          if (typeof r == "string") {
            n = r.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
            for (let s = 0; s < n.length; s++) {
              let o = n[s].trim();
              (o.startsWith('"') &&
                o.endsWith('"') &&
                (o = o.substr(1, o.length - 2)),
                (n[s] = o));
            }
          }
          (n.length === 0 && n.push(e),
            Yh(e) !== void 0 &&
              Qet(e, () => {
                le.runFunc(t, ...n);
              }));
        }, "setClickFun")),
        (Qet = a(function (e, t) {
          qD.push(
            function () {
              let r = document.querySelector(`[id="${e}"]`);
              r !== null &&
                r.addEventListener("click", function () {
                  t();
                });
            },
            function () {
              let r = document.querySelector(`[id="${e}-text"]`);
              r !== null &&
                r.addEventListener("click", function () {
                  t();
                });
            },
          );
        }, "pushFun")),
        (lLt = a(function (e, t, r) {
          (e.split(",").forEach(function (n) {
            oLt(n, t, r);
          }),
            Ket(e, "clickable"));
        }, "setClickEvent")),
        (cLt = a(function (e) {
          qD.forEach(function (t) {
            t(e);
          });
        }, "bindFunctions")),
        (Zet = {
          getConfig: a(() => K().gantt, "getConfig"),
          clear: L6t,
          setDateFormat: P6t,
          getDateFormat: W6t,
          enableInclusiveEndDates: B6t,
          endDatesAreInclusive: F6t,
          enableTopAxis: $6t,
          topAxisEnabled: G6t,
          setAxisFormat: R6t,
          getAxisFormat: D6t,
          setTickInterval: N6t,
          getTickInterval: I6t,
          setTodayMarker: M6t,
          getTodayMarker: O6t,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          setDisplayMode: V6t,
          getDisplayMode: z6t,
          setAccDescription: er,
          getAccDescription: rr,
          addSection: X6t,
          getSections: K6t,
          getTasks: Q6t,
          addTask: iLt,
          findTaskById: Yh,
          addTaskOrg: sLt,
          setIncludes: U6t,
          getIncludes: j6t,
          setExcludes: q6t,
          getExcludes: H6t,
          setClickEvent: lLt,
          setLink: aLt,
          getLinks: Y6t,
          bindFunctions: cLt,
          parseDuration: Het,
          isInvalidDate: jet,
          setWeekday: Z6t,
          getWeekday: J6t,
          setWeekend: tLt,
        }));
      a(Jet, "getTaskTags");
    });
  var b_,
    uLt,
    ert,
    hLt,
    Bl,
    fLt,
    rrt,
    nrt = x(() => {
      "use strict";
      b_ = Ts(ox(), 1);
      Vt();
      Ge();
      Be();
      pe();
      On();
      ((uLt = a(function () {
        P.debug("Something is calling, setConf, remove the call");
      }, "setConf")),
        (ert = {
          monday: lc,
          tuesday: k2,
          wednesday: T2,
          thursday: ho,
          friday: S2,
          saturday: _2,
          sunday: Da,
        }),
        (hLt = a((e, t) => {
          let r = [...e].map(() => -1 / 0),
            n = [...e].sort(
              (s, o) => s.startTime - o.startTime || s.order - o.order,
            ),
            i = 0;
          for (let s of n)
            for (let o = 0; o < r.length; o++)
              if (s.startTime >= r[o]) {
                ((r[o] = s.endTime), (s.order = o + t), o > i && (i = o));
                break;
              }
          return i;
        }, "getMaxIntersections")),
        (fLt = a(function (e, t, r, n) {
          let i = K().gantt,
            s = K().securityLevel,
            o;
          s === "sandbox" && (o = xt("#i" + t));
          let l =
              s === "sandbox"
                ? xt(o.nodes()[0].contentDocument.body)
                : xt("body"),
            u = s === "sandbox" ? o.nodes()[0].contentDocument : document,
            h = u.getElementById(t);
          ((Bl = h.parentElement.offsetWidth),
            Bl === void 0 && (Bl = 1200),
            i.useWidth !== void 0 && (Bl = i.useWidth));
          let f = n.db.getTasks(),
            d = [];
          for (let E of f) d.push(E.type);
          d = G(d);
          let p = {},
            m = 2 * i.topPadding;
          if (
            n.db.getDisplayMode() === "compact" ||
            i.displayMode === "compact"
          ) {
            let E = {};
            for (let F of f)
              E[F.section] === void 0
                ? (E[F.section] = [F])
                : E[F.section].push(F);
            let R = 0;
            for (let F of Object.keys(E)) {
              let S = hLt(E[F], R) + 1;
              ((R += S), (m += S * (i.barHeight + i.barGap)), (p[F] = S));
            }
          } else {
            m += f.length * (i.barHeight + i.barGap);
            for (let E of d) p[E] = f.filter((R) => R.type === E).length;
          }
          h.setAttribute("viewBox", "0 0 " + Bl + " " + m);
          let g = l.select(`[id="${t}"]`),
            y = v2()
              .domain([
                Dx(f, function (E) {
                  return E.startTime;
                }),
                Rx(f, function (E) {
                  return E.endTime;
                }),
              ])
              .rangeRound([0, Bl - i.leftPadding - i.rightPadding]);
          function b(E, R) {
            let F = E.startTime,
              S = R.startTime,
              O = 0;
            return (F > S ? (O = 1) : F < S && (O = -1), O);
          }
          (a(b, "taskCompare"),
            f.sort(b),
            k(f, Bl, m),
            Ar(g, m, Bl, i.useMaxWidth),
            g
              .append("text")
              .text(n.db.getDiagramTitle())
              .attr("x", Bl / 2)
              .attr("y", i.titleTopMargin)
              .attr("class", "titleText"));
          function k(E, R, F) {
            let S = i.barHeight,
              O = S + i.barGap,
              v = i.topPadding,
              _ = i.leftPadding,
              A = Ra()
                .domain([0, d.length])
                .range(["#00B9FA", "#F95002"])
                .interpolate(nE);
            (C(O, v, _, R, F, E, n.db.getExcludes(), n.db.getIncludes()),
              L(_, v, R, F),
              T(E, O, v, _, S, A, R, F),
              w(O, v, _, S, A),
              D(_, v, R, F));
          }
          a(k, "makeGantt");
          function T(E, R, F, S, O, v, _) {
            E.sort((V, $) => (V.vert === $.vert ? 0 : V.vert ? 1 : -1));
            let N = [...new Set(E.map((V) => V.order))].map((V) =>
              E.find(($) => $.order === V),
            );
            g.append("g")
              .selectAll("rect")
              .data(N)
              .enter()
              .append("rect")
              .attr("x", 0)
              .attr("y", function (V, $) {
                return (($ = V.order), $ * R + F - 2);
              })
              .attr("width", function () {
                return _ - i.rightPadding / 2;
              })
              .attr("height", R)
              .attr("class", function (V) {
                for (let [$, q] of d.entries())
                  if (V.type === q)
                    return "section section" + ($ % i.numberSectionStyles);
                return "section section0";
              })
              .enter();
            let B = g.append("g").selectAll("rect").data(E).enter(),
              M = n.db.getLinks();
            if (
              (B.append("rect")
                .attr("id", function (V) {
                  return V.id;
                })
                .attr("rx", 3)
                .attr("ry", 3)
                .attr("x", function (V) {
                  return V.milestone
                    ? y(V.startTime) +
                        S +
                        0.5 * (y(V.endTime) - y(V.startTime)) -
                        0.5 * O
                    : y(V.startTime) + S;
                })
                .attr("y", function (V, $) {
                  return (
                    ($ = V.order),
                    V.vert ? i.gridLineStartPadding : $ * R + F
                  );
                })
                .attr("width", function (V) {
                  return V.milestone
                    ? O
                    : V.vert
                      ? 0.08 * O
                      : y(V.renderEndTime || V.endTime) - y(V.startTime);
                })
                .attr("height", function (V) {
                  return V.vert
                    ? f.length * (i.barHeight + i.barGap) + i.barHeight * 2
                    : O;
                })
                .attr("transform-origin", function (V, $) {
                  return (
                    ($ = V.order),
                    (
                      y(V.startTime) +
                      S +
                      0.5 * (y(V.endTime) - y(V.startTime))
                    ).toString() +
                      "px " +
                      ($ * R + F + 0.5 * O).toString() +
                      "px"
                  );
                })
                .attr("class", function (V) {
                  let $ = "task",
                    q = "";
                  V.classes.length > 0 && (q = V.classes.join(" "));
                  let tt = 0;
                  for (let [H, kt] of d.entries())
                    V.type === kt && (tt = H % i.numberSectionStyles);
                  let ht = "";
                  return (
                    V.active
                      ? V.crit
                        ? (ht += " activeCrit")
                        : (ht = " active")
                      : V.done
                        ? V.crit
                          ? (ht = " doneCrit")
                          : (ht = " done")
                        : V.crit && (ht += " crit"),
                    ht.length === 0 && (ht = " task"),
                    V.milestone && (ht = " milestone " + ht),
                    V.vert && (ht = " vert " + ht),
                    (ht += tt),
                    (ht += " " + q),
                    $ + ht
                  );
                }),
              B.append("text")
                .attr("id", function (V) {
                  return V.id + "-text";
                })
                .text(function (V) {
                  return V.task;
                })
                .attr("font-size", i.fontSize)
                .attr("x", function (V) {
                  let $ = y(V.startTime),
                    q = y(V.renderEndTime || V.endTime);
                  if (
                    (V.milestone &&
                      (($ += 0.5 * (y(V.endTime) - y(V.startTime)) - 0.5 * O),
                      (q = $ + O)),
                    V.vert)
                  )
                    return y(V.startTime) + S;
                  let tt = this.getBBox().width;
                  return tt > q - $
                    ? q + tt + 1.5 * i.leftPadding > _
                      ? $ + S - 5
                      : q + S + 5
                    : (q - $) / 2 + $ + S;
                })
                .attr("y", function (V, $) {
                  return V.vert
                    ? i.gridLineStartPadding +
                        f.length * (i.barHeight + i.barGap) +
                        60
                    : (($ = V.order),
                      $ * R + i.barHeight / 2 + (i.fontSize / 2 - 2) + F);
                })
                .attr("text-height", O)
                .attr("class", function (V) {
                  let $ = y(V.startTime),
                    q = y(V.endTime);
                  V.milestone && (q = $ + O);
                  let tt = this.getBBox().width,
                    ht = "";
                  V.classes.length > 0 && (ht = V.classes.join(" "));
                  let H = 0;
                  for (let [ft, yt] of d.entries())
                    V.type === yt && (H = ft % i.numberSectionStyles);
                  let kt = "";
                  return (
                    V.active &&
                      (V.crit
                        ? (kt = "activeCritText" + H)
                        : (kt = "activeText" + H)),
                    V.done
                      ? V.crit
                        ? (kt = kt + " doneCritText" + H)
                        : (kt = kt + " doneText" + H)
                      : V.crit && (kt = kt + " critText" + H),
                    V.milestone && (kt += " milestoneText"),
                    V.vert && (kt += " vertText"),
                    tt > q - $
                      ? q + tt + 1.5 * i.leftPadding > _
                        ? ht +
                          " taskTextOutsideLeft taskTextOutside" +
                          H +
                          " " +
                          kt
                        : ht +
                          " taskTextOutsideRight taskTextOutside" +
                          H +
                          " " +
                          kt +
                          " width-" +
                          tt
                      : ht +
                        " taskText taskText" +
                        H +
                        " " +
                        kt +
                        " width-" +
                        tt
                  );
                }),
              K().securityLevel === "sandbox")
            ) {
              let V;
              V = xt("#i" + t);
              let $ = V.nodes()[0].contentDocument;
              B.filter(function (q) {
                return M.has(q.id);
              }).each(function (q) {
                var tt = $.querySelector("#" + q.id),
                  ht = $.querySelector("#" + q.id + "-text");
                let H = tt.parentNode;
                var kt = $.createElement("a");
                (kt.setAttribute("xlink:href", M.get(q.id)),
                  kt.setAttribute("target", "_top"),
                  H.appendChild(kt),
                  kt.appendChild(tt),
                  kt.appendChild(ht));
              });
            }
          }
          a(T, "drawRects");
          function C(E, R, F, S, O, v, _, A) {
            if (_.length === 0 && A.length === 0) return;
            let N, B;
            for (let { startTime: tt, endTime: ht } of v)
              ((N === void 0 || tt < N) && (N = tt),
                (B === void 0 || ht > B) && (B = ht));
            if (!N || !B) return;
            if ((0, b_.default)(B).diff((0, b_.default)(N), "year") > 5) {
              P.warn(
                "The difference between the min and max time is more than 5 years. This will cause performance issues. Skipping drawing exclude days.",
              );
              return;
            }
            let M = n.db.getDateFormat(),
              I = [],
              V = null,
              $ = (0, b_.default)(N);
            for (; $.valueOf() <= B; )
              (n.db.isInvalidDate($, M, _, A)
                ? V
                  ? (V.end = $)
                  : (V = { start: $, end: $ })
                : V && (I.push(V), (V = null)),
                ($ = $.add(1, "d")));
            g.append("g")
              .selectAll("rect")
              .data(I)
              .enter()
              .append("rect")
              .attr("id", (tt) => "exclude-" + tt.start.format("YYYY-MM-DD"))
              .attr("x", (tt) => y(tt.start.startOf("day")) + F)
              .attr("y", i.gridLineStartPadding)
              .attr(
                "width",
                (tt) => y(tt.end.endOf("day")) - y(tt.start.startOf("day")),
              )
              .attr("height", O - R - i.gridLineStartPadding)
              .attr("transform-origin", function (tt, ht) {
                return (
                  (
                    y(tt.start) +
                    F +
                    0.5 * (y(tt.end) - y(tt.start))
                  ).toString() +
                  "px " +
                  (ht * E + 0.5 * O).toString() +
                  "px"
                );
              })
              .attr("class", "exclude-range");
          }
          a(C, "drawExcludeDays");
          function L(E, R, F, S) {
            let O = n.db.getDateFormat(),
              v = n.db.getAxisFormat(),
              _;
            v
              ? (_ = v)
              : O === "D"
                ? (_ = "%d")
                : (_ = i.axisFormat ?? "%Y-%m-%d");
            let A = Fw(y)
                .tickSize(-S + R + i.gridLineStartPadding)
                .tickFormat($u(_)),
              B =
                /^([1-9]\d*)(millisecond|second|minute|hour|day|week|month)$/.exec(
                  n.db.getTickInterval() || i.tickInterval,
                );
            if (B !== null) {
              let M = B[1],
                I = B[2],
                V = n.db.getWeekday() || i.weekday;
              switch (I) {
                case "millisecond":
                  A.ticks(co.every(M));
                  break;
                case "second":
                  A.ticks(Cs.every(M));
                  break;
                case "minute":
                  A.ticks(ll.every(M));
                  break;
                case "hour":
                  A.ticks(cl.every(M));
                  break;
                case "day":
                  A.ticks(Hs.every(M));
                  break;
                case "week":
                  A.ticks(ert[V].every(M));
                  break;
                case "month":
                  A.ticks(ul.every(M));
                  break;
              }
            }
            if (
              (g
                .append("g")
                .attr("class", "grid")
                .attr("transform", "translate(" + E + ", " + (S - 50) + ")")
                .call(A)
                .selectAll("text")
                .style("text-anchor", "middle")
                .attr("fill", "#000")
                .attr("stroke", "none")
                .attr("font-size", 10)
                .attr("dy", "1em"),
              n.db.topAxisEnabled() || i.topAxis)
            ) {
              let M = Bw(y)
                .tickSize(-S + R + i.gridLineStartPadding)
                .tickFormat($u(_));
              if (B !== null) {
                let I = B[1],
                  V = B[2],
                  $ = n.db.getWeekday() || i.weekday;
                switch (V) {
                  case "millisecond":
                    M.ticks(co.every(I));
                    break;
                  case "second":
                    M.ticks(Cs.every(I));
                    break;
                  case "minute":
                    M.ticks(ll.every(I));
                    break;
                  case "hour":
                    M.ticks(cl.every(I));
                    break;
                  case "day":
                    M.ticks(Hs.every(I));
                    break;
                  case "week":
                    M.ticks(ert[$].every(I));
                    break;
                  case "month":
                    M.ticks(ul.every(I));
                    break;
                }
              }
              g.append("g")
                .attr("class", "grid")
                .attr("transform", "translate(" + E + ", " + R + ")")
                .call(M)
                .selectAll("text")
                .style("text-anchor", "middle")
                .attr("fill", "#000")
                .attr("stroke", "none")
                .attr("font-size", 10);
            }
          }
          a(L, "makeGrid");
          function w(E, R) {
            let F = 0,
              S = Object.keys(p).map((O) => [O, p[O]]);
            g.append("g")
              .selectAll("text")
              .data(S)
              .enter()
              .append(function (O) {
                let v = O[0].split(Rt.lineBreakRegex),
                  _ = -(v.length - 1) / 2,
                  A = u.createElementNS("http://www.w3.org/2000/svg", "text");
                A.setAttribute("dy", _ + "em");
                for (let [N, B] of v.entries()) {
                  let M = u.createElementNS(
                    "http://www.w3.org/2000/svg",
                    "tspan",
                  );
                  (M.setAttribute("alignment-baseline", "central"),
                    M.setAttribute("x", "10"),
                    N > 0 && M.setAttribute("dy", "1em"),
                    (M.textContent = B),
                    A.appendChild(M));
                }
                return A;
              })
              .attr("x", 10)
              .attr("y", function (O, v) {
                if (v > 0)
                  for (let _ = 0; _ < v; _++)
                    return ((F += S[v - 1][1]), (O[1] * E) / 2 + F * E + R);
                else return (O[1] * E) / 2 + R;
              })
              .attr("font-size", i.sectionFontSize)
              .attr("class", function (O) {
                for (let [v, _] of d.entries())
                  if (O[0] === _)
                    return (
                      "sectionTitle sectionTitle" + (v % i.numberSectionStyles)
                    );
                return "sectionTitle";
              });
          }
          a(w, "vertLabels");
          function D(E, R, F, S) {
            let O = n.db.getTodayMarker();
            if (O === "off") return;
            let v = g.append("g").attr("class", "today"),
              _ = new Date(),
              A = v.append("line");
            (A.attr("x1", y(_) + E)
              .attr("x2", y(_) + E)
              .attr("y1", i.titleTopMargin)
              .attr("y2", S - i.titleTopMargin)
              .attr("class", "today"),
              O !== "" && A.attr("style", O.replace(/,/g, ";")));
          }
          a(D, "drawToday");
          function G(E) {
            let R = {},
              F = [];
            for (let S = 0, O = E.length; S < O; ++S)
              Object.prototype.hasOwnProperty.call(R, E[S]) ||
                ((R[E[S]] = !0), F.push(E[S]));
            return F;
          }
          a(G, "checkUnique");
        }, "draw")),
        (rrt = { setConf: uLt, draw: fLt }));
    });
  var dLt,
    irt,
    srt = x(() => {
      "use strict";
      ((dLt = a(
        (e) => `
  .mermaid-main-font {
        font-family: ${e.fontFamily};
  }

  .exclude-range {
    fill: ${e.excludeBkgColor};
  }

  .section {
    stroke: none;
    opacity: 0.2;
  }

  .section0 {
    fill: ${e.sectionBkgColor};
  }

  .section2 {
    fill: ${e.sectionBkgColor2};
  }

  .section1,
  .section3 {
    fill: ${e.altSectionBkgColor};
    opacity: 0.2;
  }

  .sectionTitle0 {
    fill: ${e.titleColor};
  }

  .sectionTitle1 {
    fill: ${e.titleColor};
  }

  .sectionTitle2 {
    fill: ${e.titleColor};
  }

  .sectionTitle3 {
    fill: ${e.titleColor};
  }

  .sectionTitle {
    text-anchor: start;
    font-family: ${e.fontFamily};
  }


  /* Grid and axis */

  .grid .tick {
    stroke: ${e.gridColor};
    opacity: 0.8;
    shape-rendering: crispEdges;
  }

  .grid .tick text {
    font-family: ${e.fontFamily};
    fill: ${e.textColor};
  }

  .grid path {
    stroke-width: 0;
  }


  /* Today line */

  .today {
    fill: none;
    stroke: ${e.todayLineColor};
    stroke-width: 2px;
  }


  /* Task styling */

  /* Default task */

  .task {
    stroke-width: 2;
  }

  .taskText {
    text-anchor: middle;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideRight {
    fill: ${e.taskTextDarkColor};
    text-anchor: start;
    font-family: ${e.fontFamily};
  }

  .taskTextOutsideLeft {
    fill: ${e.taskTextDarkColor};
    text-anchor: end;
  }


  /* Special case clickable */

  .task.clickable {
    cursor: pointer;
  }

  .taskText.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideLeft.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }

  .taskTextOutsideRight.clickable {
    cursor: pointer;
    fill: ${e.taskTextClickableColor} !important;
    font-weight: bold;
  }


  /* Specific task settings for the sections*/

  .taskText0,
  .taskText1,
  .taskText2,
  .taskText3 {
    fill: ${e.taskTextColor};
  }

  .task0,
  .task1,
  .task2,
  .task3 {
    fill: ${e.taskBkgColor};
    stroke: ${e.taskBorderColor};
  }

  .taskTextOutside0,
  .taskTextOutside2
  {
    fill: ${e.taskTextOutsideColor};
  }

  .taskTextOutside1,
  .taskTextOutside3 {
    fill: ${e.taskTextOutsideColor};
  }


  /* Active task */

  .active0,
  .active1,
  .active2,
  .active3 {
    fill: ${e.activeTaskBkgColor};
    stroke: ${e.activeTaskBorderColor};
  }

  .activeText0,
  .activeText1,
  .activeText2,
  .activeText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Completed task */

  .done0,
  .done1,
  .done2,
  .done3 {
    stroke: ${e.doneTaskBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
  }

  .doneText0,
  .doneText1,
  .doneText2,
  .doneText3 {
    fill: ${e.taskTextDarkColor} !important;
  }


  /* Tasks on the critical line */

  .crit0,
  .crit1,
  .crit2,
  .crit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.critBkgColor};
    stroke-width: 2;
  }

  .activeCrit0,
  .activeCrit1,
  .activeCrit2,
  .activeCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.activeTaskBkgColor};
    stroke-width: 2;
  }

  .doneCrit0,
  .doneCrit1,
  .doneCrit2,
  .doneCrit3 {
    stroke: ${e.critBorderColor};
    fill: ${e.doneTaskBkgColor};
    stroke-width: 2;
    cursor: pointer;
    shape-rendering: crispEdges;
  }

  .milestone {
    transform: rotate(45deg) scale(0.8,0.8);
  }

  .milestoneText {
    font-style: italic;
  }
  .doneCritText0,
  .doneCritText1,
  .doneCritText2,
  .doneCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .vert {
    stroke: ${e.vertLineColor};
  }

  .vertText {
    font-size: 15px;
    text-anchor: middle;
    fill: ${e.vertLineColor} !important;
  }

  .activeCritText0,
  .activeCritText1,
  .activeCritText2,
  .activeCritText3 {
    fill: ${e.taskTextDarkColor} !important;
  }

  .titleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.titleColor || e.textColor};
    font-family: ${e.fontFamily};
  }
`,
        "getStyles",
      )),
        (irt = dLt));
    });
  var art = {};
  Oe(art, { diagram: () => pLt });
  var pLt,
    ort = x(() => {
      "use strict";
      Met();
      trt();
      nrt();
      srt();
      pLt = { parser: Iet, db: Zet, renderer: rrt, styles: irt };
    });
  var urt,
    hrt = x(() => {
      "use strict";
      jh();
      Vt();
      urt = {
        parse: a(async (e) => {
          let t = await Bs("info", e);
          P.debug(t);
        }, "parse"),
      };
    });
  var Py,
    XD = x(() => {
      Py = {
        name: "mermaid",
        version: "11.11.0",
        description:
          "Markdown-ish syntax for generating flowcharts, mindmaps, sequence diagrams, class diagrams, gantt charts, git graphs and more.",
        type: "module",
        module: "./dist/mermaid.core.mjs",
        types: "./dist/mermaid.d.ts",
        exports: {
          ".": {
            types: "./dist/mermaid.d.ts",
            import: "./dist/mermaid.core.mjs",
            default: "./dist/mermaid.core.mjs",
          },
          "./*": "./*",
        },
        keywords: [
          "diagram",
          "markdown",
          "flowchart",
          "sequence diagram",
          "gantt",
          "class diagram",
          "git graph",
          "mindmap",
          "packet diagram",
          "c4 diagram",
          "er diagram",
          "pie chart",
          "pie diagram",
          "quadrant chart",
          "requirement diagram",
          "graph",
        ],
        scripts: {
          clean: "rimraf dist",
          dev: "pnpm -w dev",
          "docs:code":
            "typedoc src/defaultConfig.ts src/config.ts src/mermaid.ts && prettier --write ./src/docs/config/setup",
          "docs:build":
            "rimraf ../../docs && pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts",
          "docs:verify":
            "pnpm docs:code && pnpm docs:spellcheck && tsx scripts/docs.cli.mts --verify",
          "docs:pre:vitepress":
            "pnpm --filter ./src/docs prefetch && rimraf src/vitepress && pnpm docs:code && tsx scripts/docs.cli.mts --vitepress && pnpm --filter ./src/vitepress install --no-frozen-lockfile --ignore-scripts",
          "docs:build:vitepress":
            "pnpm docs:pre:vitepress && (cd src/vitepress && pnpm run build) && cpy --flat src/docs/landing/ ./src/vitepress/.vitepress/dist/landing",
          "docs:dev":
            'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev" "tsx scripts/docs.cli.mts --watch --vitepress"',
          "docs:dev:docker":
            'pnpm docs:pre:vitepress && concurrently "pnpm --filter ./src/vitepress dev:docker" "tsx scripts/docs.cli.mts --watch --vitepress"',
          "docs:serve":
            "pnpm docs:build:vitepress && vitepress serve src/vitepress",
          "docs:spellcheck": 'cspell "src/docs/**/*.md"',
          "docs:release-version": "tsx scripts/update-release-version.mts",
          "docs:verify-version":
            "tsx scripts/update-release-version.mts --verify",
          "types:build-config": "tsx scripts/create-types-from-json-schema.mts",
          "types:verify-config":
            "tsx scripts/create-types-from-json-schema.mts --verify",
          checkCircle: "npx madge --circular ./src",
          prepublishOnly: "pnpm docs:verify-version",
        },
        repository: {
          type: "git",
          url: "https://github.com/mermaid-js/mermaid",
        },
        author: "Knut Sveidqvist",
        license: "MIT",
        standard: {
          ignore: ["**/parser/*.js", "dist/**/*.js", "cypress/**/*.js"],
          globals: ["page"],
        },
        dependencies: {
          "@braintree/sanitize-url": "^7.0.4",
          "@iconify/utils": "^3.0.1",
          "@mermaid-js/parser": "workspace:^",
          "@types/d3": "^7.4.3",
          cytoscape: "^3.29.3",
          "cytoscape-cose-bilkent": "^4.1.0",
          "cytoscape-fcose": "^2.2.0",
          d3: "^7.9.0",
          "d3-sankey": "^0.12.3",
          "dagre-d3-es": "7.0.11",
          dayjs: "^1.11.13",
          dompurify: "^3.2.5",
          katex: "^0.16.22",
          khroma: "^2.1.0",
          "lodash-es": "^4.17.21",
          marked: "^15.0.7",
          roughjs: "^4.6.6",
          stylis: "^4.3.6",
          "ts-dedent": "^2.2.0",
          uuid: "^11.1.0",
        },
        devDependencies: {
          "@adobe/jsonschema2md": "^8.0.2",
          "@iconify/types": "^2.0.0",
          "@types/cytoscape": "^3.21.9",
          "@types/cytoscape-fcose": "^2.2.4",
          "@types/d3-sankey": "^0.12.4",
          "@types/d3-scale": "^4.0.9",
          "@types/d3-scale-chromatic": "^3.1.0",
          "@types/d3-selection": "^3.0.11",
          "@types/d3-shape": "^3.1.7",
          "@types/jsdom": "^21.1.7",
          "@types/katex": "^0.16.7",
          "@types/lodash-es": "^4.17.12",
          "@types/micromatch": "^4.0.9",
          "@types/stylis": "^4.2.7",
          "@types/uuid": "^10.0.0",
          ajv: "^8.17.1",
          canvas: "^3.1.0",
          chokidar: "3.6.0",
          concurrently: "^9.1.2",
          "csstree-validator": "^4.0.1",
          globby: "^14.0.2",
          jison: "^0.4.18",
          "js-base64": "^3.7.7",
          jsdom: "^26.1.0",
          "json-schema-to-typescript": "^15.0.4",
          micromatch: "^4.0.8",
          "path-browserify": "^1.0.1",
          prettier: "^3.5.2",
          remark: "^15.0.1",
          "remark-frontmatter": "^5.0.0",
          "remark-gfm": "^4.0.1",
          rimraf: "^6.0.1",
          "start-server-and-test": "^2.0.10",
          "type-fest": "^4.35.0",
          typedoc: "^0.28.9",
          "typedoc-plugin-markdown": "^4.8.0",
          typescript: "~5.7.3",
          "unist-util-flatmap": "^1.0.0",
          "unist-util-visit": "^5.0.0",
          vitepress: "^1.0.2",
          "vitepress-plugin-search": "1.0.4-alpha.22",
        },
        files: ["dist/", "README.md"],
        publishConfig: { access: "public" },
      };
    });
  var bLt,
    kLt,
    frt,
    drt = x(() => {
      "use strict";
      XD();
      ((bLt = { version: Py.version + "-tiny" }),
        (kLt = a(() => bLt.version, "getVersion")),
        (frt = { getVersion: kLt }));
    });
  var Ei,
    Fl = x(() => {
      "use strict";
      Ge();
      pe();
      Ei = a((e) => {
        let { securityLevel: t } = K(),
          r = xt("body");
        if (t === "sandbox") {
          let s = xt(`#i${e}`).node()?.contentDocument ?? document;
          r = xt(s.body);
        }
        return r.select(`#${e}`);
      }, "selectSvgElement");
    });
  var TLt,
    prt,
    mrt = x(() => {
      "use strict";
      Vt();
      Fl();
      On();
      ((TLt = a((e, t, r) => {
        P.debug(
          `rendering info diagram
` + e,
        );
        let n = Ei(t);
        (Ar(n, 100, 400, !0),
          n
            .append("g")
            .append("text")
            .attr("x", 100)
            .attr("y", 40)
            .attr("class", "version")
            .attr("font-size", 32)
            .style("text-anchor", "middle")
            .text(`v${r}`));
      }, "draw")),
        (prt = { draw: TLt }));
    });
  var grt = {};
  Oe(grt, { diagram: () => SLt });
  var SLt,
    yrt = x(() => {
      "use strict";
      hrt();
      drt();
      mrt();
      SLt = { parser: urt, db: frt, renderer: prt };
    });
  var krt,
    KD,
    k_,
    QD,
    wLt,
    vLt,
    ELt,
    ALt,
    LLt,
    RLt,
    DLt,
    T_,
    ZD = x(() => {
      "use strict";
      Vt();
      yn();
      Ss();
      ((krt = ze.pie),
        (KD = { sections: new Map(), showData: !1, config: krt }),
        (k_ = KD.sections),
        (QD = KD.showData),
        (wLt = structuredClone(krt)),
        (vLt = a(() => structuredClone(wLt), "getConfig")),
        (ELt = a(() => {
          ((k_ = new Map()), (QD = KD.showData), Ye());
        }, "clear")),
        (ALt = a(({ label: e, value: t }) => {
          if (t < 0)
            throw new Error(
              `"${e}" has invalid value: ${t}. Negative values are not allowed in pie charts. All slice values must be >= 0.`,
            );
          k_.has(e) ||
            (k_.set(e, t),
            P.debug(`added new section: ${e}, with value: ${t}`));
        }, "addSection")),
        (LLt = a(() => k_, "getSections")),
        (RLt = a((e) => {
          QD = e;
        }, "setShowData")),
        (DLt = a(() => QD, "getShowData")),
        (T_ = {
          getConfig: vLt,
          clear: ELt,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          setAccTitle: Xe,
          getAccTitle: tr,
          setAccDescription: er,
          getAccDescription: rr,
          addSection: ALt,
          getSections: LLt,
          setShowData: RLt,
          getShowData: DLt,
        }));
    });
  var NLt,
    Trt,
    Srt = x(() => {
      "use strict";
      jh();
      Vt();
      gm();
      ZD();
      ((NLt = a((e, t) => {
        (qo(e, t), t.setShowData(e.showData), e.sections.map(t.addSection));
      }, "populateDb")),
        (Trt = {
          parse: a(async (e) => {
            let t = await Bs("pie", e);
            (P.debug(t), NLt(t, T_));
          }, "parse"),
        }));
    });
  var ILt,
    _rt,
    Crt = x(() => {
      "use strict";
      ((ILt = a(
        (e) => `
  .pieCircle{
    stroke: ${e.pieStrokeColor};
    stroke-width : ${e.pieStrokeWidth};
    opacity : ${e.pieOpacity};
  }
  .pieOuterCircle{
    stroke: ${e.pieOuterStrokeColor};
    stroke-width: ${e.pieOuterStrokeWidth};
    fill: none;
  }
  .pieTitleText {
    text-anchor: middle;
    font-size: ${e.pieTitleTextSize};
    fill: ${e.pieTitleTextColor};
    font-family: ${e.fontFamily};
  }
  .slice {
    font-family: ${e.fontFamily};
    fill: ${e.pieSectionTextColor};
    font-size:${e.pieSectionTextSize};
    // fill: white;
  }
  .legend text {
    fill: ${e.pieLegendTextColor};
    font-family: ${e.fontFamily};
    font-size: ${e.pieLegendTextSize};
  }
`,
        "getStyles",
      )),
        (_rt = ILt));
    });
  var MLt,
    OLt,
    wrt,
    vrt = x(() => {
      "use strict";
      Ge();
      pe();
      Vt();
      Fl();
      On();
      _e();
      ((MLt = a((e) => {
        let t = [...e.values()].reduce((i, s) => i + s, 0),
          r = [...e.entries()]
            .map(([i, s]) => ({ label: i, value: s }))
            .filter((i) => (i.value / t) * 100 >= 1)
            .sort((i, s) => s.value - i.value);
        return N2().value((i) => i.value)(r);
      }, "createPieArcs")),
        (OLt = a((e, t, r, n) => {
          P.debug(
            `rendering pie chart
` + e,
          );
          let i = n.db,
            s = K(),
            o = on(i.getConfig(), s.pie),
            l = 40,
            u = 18,
            h = 4,
            f = 450,
            d = f,
            p = Ei(t),
            m = p.append("g");
          m.attr("transform", "translate(" + d / 2 + "," + f / 2 + ")");
          let { themeVariables: g } = s,
            [y] = xo(g.pieOuterStrokeWidth);
          y ??= 2;
          let b = o.textPosition,
            k = Math.min(d, f) / 2 - l,
            T = Ma().innerRadius(0).outerRadius(k),
            C = Ma()
              .innerRadius(k * b)
              .outerRadius(k * b);
          m.append("circle")
            .attr("cx", 0)
            .attr("cy", 0)
            .attr("r", k + y / 2)
            .attr("class", "pieOuterCircle");
          let L = i.getSections(),
            w = MLt(L),
            D = [
              g.pie1,
              g.pie2,
              g.pie3,
              g.pie4,
              g.pie5,
              g.pie6,
              g.pie7,
              g.pie8,
              g.pie9,
              g.pie10,
              g.pie11,
              g.pie12,
            ],
            G = 0;
          L.forEach((_) => {
            G += _;
          });
          let E = w.filter(
              (_) => ((_.data.value / G) * 100).toFixed(0) !== "0",
            ),
            R = _s(D);
          (m
            .selectAll("mySlices")
            .data(E)
            .enter()
            .append("path")
            .attr("d", T)
            .attr("fill", (_) => R(_.data.label))
            .attr("class", "pieCircle"),
            m
              .selectAll("mySlices")
              .data(E)
              .enter()
              .append("text")
              .text((_) => ((_.data.value / G) * 100).toFixed(0) + "%")
              .attr("transform", (_) => "translate(" + C.centroid(_) + ")")
              .style("text-anchor", "middle")
              .attr("class", "slice"),
            m
              .append("text")
              .text(i.getDiagramTitle())
              .attr("x", 0)
              .attr("y", -(f - 50) / 2)
              .attr("class", "pieTitleText"));
          let F = [...L.entries()].map(([_, A]) => ({ label: _, value: A })),
            S = m
              .selectAll(".legend")
              .data(F)
              .enter()
              .append("g")
              .attr("class", "legend")
              .attr("transform", (_, A) => {
                let N = u + h,
                  B = (N * F.length) / 2,
                  M = 12 * u,
                  I = A * N - B;
                return "translate(" + M + "," + I + ")";
              });
          (S.append("rect")
            .attr("width", u)
            .attr("height", u)
            .style("fill", (_) => R(_.label))
            .style("stroke", (_) => R(_.label)),
            S.append("text")
              .attr("x", u + h)
              .attr("y", u - h)
              .text((_) =>
                i.getShowData() ? `${_.label} [${_.value}]` : _.label,
              ));
          let O = Math.max(
              ...S.selectAll("text")
                .nodes()
                .map((_) => _?.getBoundingClientRect().width ?? 0),
            ),
            v = d + l + u + h + O;
          (p.attr("viewBox", `0 0 ${v} ${f}`), Ar(p, f, v, o.useMaxWidth));
        }, "draw")),
        (wrt = { draw: OLt }));
    });
  var Ert = {};
  Oe(Ert, { diagram: () => PLt });
  var PLt,
    Art = x(() => {
      "use strict";
      Srt();
      ZD();
      Crt();
      vrt();
      PLt = { parser: Trt, db: T_, renderer: wrt, styles: _rt };
    });
  var JD,
    Drt,
    Nrt = x(() => {
      "use strict";
      JD = (function () {
        var e = a(function (Gt, j, Et, mt) {
            for (Et = Et || {}, mt = Gt.length; mt--; Et[Gt[mt]] = j);
            return Et;
          }, "o"),
          t = [1, 3],
          r = [1, 4],
          n = [1, 5],
          i = [1, 6],
          s = [1, 7],
          o = [
            1, 4, 5, 10, 12, 13, 14, 18, 25, 35, 37, 39, 41, 42, 48, 50, 51, 52,
            53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67,
          ],
          l = [
            1, 4, 5, 10, 12, 13, 14, 18, 25, 28, 35, 37, 39, 41, 42, 48, 50, 51,
            52, 53, 54, 55, 56, 57, 60, 61, 63, 64, 65, 66, 67,
          ],
          u = [55, 56, 57],
          h = [2, 36],
          f = [1, 37],
          d = [1, 36],
          p = [1, 38],
          m = [1, 35],
          g = [1, 43],
          y = [1, 41],
          b = [1, 14],
          k = [1, 23],
          T = [1, 18],
          C = [1, 19],
          L = [1, 20],
          w = [1, 21],
          D = [1, 22],
          G = [1, 24],
          E = [1, 25],
          R = [1, 26],
          F = [1, 27],
          S = [1, 28],
          O = [1, 29],
          v = [1, 32],
          _ = [1, 33],
          A = [1, 34],
          N = [1, 39],
          B = [1, 40],
          M = [1, 42],
          I = [1, 44],
          V = [1, 62],
          $ = [1, 61],
          q = [
            4, 5, 8, 10, 12, 13, 14, 18, 44, 47, 49, 55, 56, 57, 63, 64, 65, 66,
            67,
          ],
          tt = [1, 65],
          ht = [1, 66],
          H = [1, 67],
          kt = [1, 68],
          ft = [1, 69],
          yt = [1, 70],
          ot = [1, 71],
          dt = [1, 72],
          nt = [1, 73],
          Q = [1, 74],
          et = [1, 75],
          X = [1, 76],
          st = [4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 18],
          U = [1, 90],
          gt = [1, 91],
          z = [1, 92],
          ge = [1, 99],
          lt = [1, 93],
          jt = [1, 96],
          Me = [1, 94],
          se = [1, 95],
          Nt = [1, 97],
          At = [1, 98],
          bt = [1, 102],
          ct = [10, 55, 56, 57],
          Lt = [4, 5, 6, 8, 10, 11, 13, 17, 18, 19, 20, 55, 56, 57],
          Z = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              idStringToken: 3,
              ALPHA: 4,
              NUM: 5,
              NODE_STRING: 6,
              DOWN: 7,
              MINUS: 8,
              DEFAULT: 9,
              COMMA: 10,
              COLON: 11,
              AMP: 12,
              BRKT: 13,
              MULT: 14,
              UNICODE_TEXT: 15,
              styleComponent: 16,
              UNIT: 17,
              SPACE: 18,
              STYLE: 19,
              PCT: 20,
              idString: 21,
              style: 22,
              stylesOpt: 23,
              classDefStatement: 24,
              CLASSDEF: 25,
              start: 26,
              eol: 27,
              QUADRANT: 28,
              document: 29,
              line: 30,
              statement: 31,
              axisDetails: 32,
              quadrantDetails: 33,
              points: 34,
              title: 35,
              title_value: 36,
              acc_title: 37,
              acc_title_value: 38,
              acc_descr: 39,
              acc_descr_value: 40,
              acc_descr_multiline_value: 41,
              section: 42,
              text: 43,
              point_start: 44,
              point_x: 45,
              point_y: 46,
              class_name: 47,
              "X-AXIS": 48,
              "AXIS-TEXT-DELIMITER": 49,
              "Y-AXIS": 50,
              QUADRANT_1: 51,
              QUADRANT_2: 52,
              QUADRANT_3: 53,
              QUADRANT_4: 54,
              NEWLINE: 55,
              SEMI: 56,
              EOF: 57,
              alphaNumToken: 58,
              textNoTagsToken: 59,
              STR: 60,
              MD_STR: 61,
              alphaNum: 62,
              PUNCTUATION: 63,
              PLUS: 64,
              EQUALS: 65,
              DOT: 66,
              UNDERSCORE: 67,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "ALPHA",
              5: "NUM",
              6: "NODE_STRING",
              7: "DOWN",
              8: "MINUS",
              9: "DEFAULT",
              10: "COMMA",
              11: "COLON",
              12: "AMP",
              13: "BRKT",
              14: "MULT",
              15: "UNICODE_TEXT",
              17: "UNIT",
              18: "SPACE",
              19: "STYLE",
              20: "PCT",
              25: "CLASSDEF",
              28: "QUADRANT",
              35: "title",
              36: "title_value",
              37: "acc_title",
              38: "acc_title_value",
              39: "acc_descr",
              40: "acc_descr_value",
              41: "acc_descr_multiline_value",
              42: "section",
              44: "point_start",
              45: "point_x",
              46: "point_y",
              47: "class_name",
              48: "X-AXIS",
              49: "AXIS-TEXT-DELIMITER",
              50: "Y-AXIS",
              51: "QUADRANT_1",
              52: "QUADRANT_2",
              53: "QUADRANT_3",
              54: "QUADRANT_4",
              55: "NEWLINE",
              56: "SEMI",
              57: "EOF",
              60: "STR",
              61: "MD_STR",
              63: "PUNCTUATION",
              64: "PLUS",
              65: "EQUALS",
              66: "DOT",
              67: "UNDERSCORE",
            },
            productions_: [
              0,
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [3, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [21, 1],
              [21, 2],
              [22, 1],
              [22, 2],
              [23, 1],
              [23, 3],
              [24, 5],
              [26, 2],
              [26, 2],
              [26, 2],
              [29, 0],
              [29, 2],
              [30, 2],
              [31, 0],
              [31, 1],
              [31, 2],
              [31, 1],
              [31, 1],
              [31, 1],
              [31, 2],
              [31, 2],
              [31, 2],
              [31, 1],
              [31, 1],
              [34, 4],
              [34, 5],
              [34, 5],
              [34, 6],
              [32, 4],
              [32, 3],
              [32, 2],
              [32, 4],
              [32, 3],
              [32, 2],
              [33, 2],
              [33, 2],
              [33, 2],
              [33, 2],
              [27, 1],
              [27, 1],
              [27, 1],
              [43, 1],
              [43, 2],
              [43, 1],
              [43, 1],
              [62, 1],
              [62, 2],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [58, 1],
              [59, 1],
              [59, 1],
              [59, 1],
            ],
            performAction: a(function (j, Et, mt, Xt, Ft, _t, Qe) {
              var It = _t.length - 1;
              switch (Ft) {
                case 23:
                  this.$ = _t[It];
                  break;
                case 24:
                  this.$ = _t[It - 1] + "" + _t[It];
                  break;
                case 26:
                  this.$ = _t[It - 1] + _t[It];
                  break;
                case 27:
                  this.$ = [_t[It].trim()];
                  break;
                case 28:
                  (_t[It - 2].push(_t[It].trim()), (this.$ = _t[It - 2]));
                  break;
                case 29:
                  ((this.$ = _t[It - 4]), Xt.addClass(_t[It - 2], _t[It]));
                  break;
                case 37:
                  this.$ = [];
                  break;
                case 42:
                  ((this.$ = _t[It].trim()), Xt.setDiagramTitle(this.$));
                  break;
                case 43:
                  ((this.$ = _t[It].trim()), Xt.setAccTitle(this.$));
                  break;
                case 44:
                case 45:
                  ((this.$ = _t[It].trim()), Xt.setAccDescription(this.$));
                  break;
                case 46:
                  (Xt.addSection(_t[It].substr(8)),
                    (this.$ = _t[It].substr(8)));
                  break;
                case 47:
                  Xt.addPoint(_t[It - 3], "", _t[It - 1], _t[It], []);
                  break;
                case 48:
                  Xt.addPoint(_t[It - 4], _t[It - 3], _t[It - 1], _t[It], []);
                  break;
                case 49:
                  Xt.addPoint(_t[It - 4], "", _t[It - 2], _t[It - 1], _t[It]);
                  break;
                case 50:
                  Xt.addPoint(
                    _t[It - 5],
                    _t[It - 4],
                    _t[It - 2],
                    _t[It - 1],
                    _t[It],
                  );
                  break;
                case 51:
                  (Xt.setXAxisLeftText(_t[It - 2]),
                    Xt.setXAxisRightText(_t[It]));
                  break;
                case 52:
                  ((_t[It - 1].text += " \u27F6 "),
                    Xt.setXAxisLeftText(_t[It - 1]));
                  break;
                case 53:
                  Xt.setXAxisLeftText(_t[It]);
                  break;
                case 54:
                  (Xt.setYAxisBottomText(_t[It - 2]),
                    Xt.setYAxisTopText(_t[It]));
                  break;
                case 55:
                  ((_t[It - 1].text += " \u27F6 "),
                    Xt.setYAxisBottomText(_t[It - 1]));
                  break;
                case 56:
                  Xt.setYAxisBottomText(_t[It]);
                  break;
                case 57:
                  Xt.setQuadrant1Text(_t[It]);
                  break;
                case 58:
                  Xt.setQuadrant2Text(_t[It]);
                  break;
                case 59:
                  Xt.setQuadrant3Text(_t[It]);
                  break;
                case 60:
                  Xt.setQuadrant4Text(_t[It]);
                  break;
                case 64:
                  this.$ = { text: _t[It], type: "text" };
                  break;
                case 65:
                  this.$ = {
                    text: _t[It - 1].text + "" + _t[It],
                    type: _t[It - 1].type,
                  };
                  break;
                case 66:
                  this.$ = { text: _t[It], type: "text" };
                  break;
                case 67:
                  this.$ = { text: _t[It], type: "markdown" };
                  break;
                case 68:
                  this.$ = _t[It];
                  break;
                case 69:
                  this.$ = _t[It - 1] + "" + _t[It];
                  break;
              }
            }, "anonymous"),
            table: [
              { 18: t, 26: 1, 27: 2, 28: r, 55: n, 56: i, 57: s },
              { 1: [3] },
              { 18: t, 26: 8, 27: 2, 28: r, 55: n, 56: i, 57: s },
              { 18: t, 26: 9, 27: 2, 28: r, 55: n, 56: i, 57: s },
              e(o, [2, 33], { 29: 10 }),
              e(l, [2, 61]),
              e(l, [2, 62]),
              e(l, [2, 63]),
              { 1: [2, 30] },
              { 1: [2, 31] },
              e(u, h, {
                30: 11,
                31: 12,
                24: 13,
                32: 15,
                33: 16,
                34: 17,
                43: 30,
                58: 31,
                1: [2, 32],
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                18: b,
                25: k,
                35: T,
                37: C,
                39: L,
                41: w,
                42: D,
                48: G,
                50: E,
                51: R,
                52: F,
                53: S,
                54: O,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(o, [2, 34]),
              { 27: 45, 55: n, 56: i, 57: s },
              e(u, [2, 37]),
              e(u, h, {
                24: 13,
                32: 15,
                33: 16,
                34: 17,
                43: 30,
                58: 31,
                31: 46,
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                18: b,
                25: k,
                35: T,
                37: C,
                39: L,
                41: w,
                42: D,
                48: G,
                50: E,
                51: R,
                52: F,
                53: S,
                54: O,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 39]),
              e(u, [2, 40]),
              e(u, [2, 41]),
              { 36: [1, 47] },
              { 38: [1, 48] },
              { 40: [1, 49] },
              e(u, [2, 45]),
              e(u, [2, 46]),
              { 18: [1, 50] },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 51,
                58: 31,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 52,
                58: 31,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 53,
                58: 31,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 54,
                58: 31,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 55,
                58: 31,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              },
              {
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                43: 56,
                58: 31,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              },
              {
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                44: [1, 57],
                47: [1, 58],
                58: 60,
                59: 59,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              },
              e(q, [2, 64]),
              e(q, [2, 66]),
              e(q, [2, 67]),
              e(q, [2, 70]),
              e(q, [2, 71]),
              e(q, [2, 72]),
              e(q, [2, 73]),
              e(q, [2, 74]),
              e(q, [2, 75]),
              e(q, [2, 76]),
              e(q, [2, 77]),
              e(q, [2, 78]),
              e(q, [2, 79]),
              e(q, [2, 80]),
              e(o, [2, 35]),
              e(u, [2, 38]),
              e(u, [2, 42]),
              e(u, [2, 43]),
              e(u, [2, 44]),
              {
                3: 64,
                4: tt,
                5: ht,
                6: H,
                7: kt,
                8: ft,
                9: yt,
                10: ot,
                11: dt,
                12: nt,
                13: Q,
                14: et,
                15: X,
                21: 63,
              },
              e(u, [2, 53], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                49: [1, 77],
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 56], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                49: [1, 78],
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 57], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 58], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 59], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 60], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              { 45: [1, 79] },
              { 44: [1, 80] },
              e(q, [2, 65]),
              e(q, [2, 81]),
              e(q, [2, 82]),
              e(q, [2, 83]),
              {
                3: 82,
                4: tt,
                5: ht,
                6: H,
                7: kt,
                8: ft,
                9: yt,
                10: ot,
                11: dt,
                12: nt,
                13: Q,
                14: et,
                15: X,
                18: [1, 81],
              },
              e(st, [2, 23]),
              e(st, [2, 1]),
              e(st, [2, 2]),
              e(st, [2, 3]),
              e(st, [2, 4]),
              e(st, [2, 5]),
              e(st, [2, 6]),
              e(st, [2, 7]),
              e(st, [2, 8]),
              e(st, [2, 9]),
              e(st, [2, 10]),
              e(st, [2, 11]),
              e(st, [2, 12]),
              e(u, [2, 52], {
                58: 31,
                43: 83,
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 55], {
                58: 31,
                43: 84,
                4: f,
                5: d,
                10: p,
                12: m,
                13: g,
                14: y,
                60: v,
                61: _,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              { 46: [1, 85] },
              { 45: [1, 86] },
              {
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                16: 89,
                17: Me,
                18: se,
                19: Nt,
                20: At,
                22: 88,
                23: 87,
              },
              e(st, [2, 24]),
              e(u, [2, 51], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 54], {
                59: 59,
                58: 60,
                4: f,
                5: d,
                8: V,
                10: p,
                12: m,
                13: g,
                14: y,
                18: $,
                63: A,
                64: N,
                65: B,
                66: M,
                67: I,
              }),
              e(u, [2, 47], {
                22: 88,
                16: 89,
                23: 100,
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                17: Me,
                18: se,
                19: Nt,
                20: At,
              }),
              { 46: [1, 101] },
              e(u, [2, 29], { 10: bt }),
              e(ct, [2, 27], {
                16: 103,
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                17: Me,
                18: se,
                19: Nt,
                20: At,
              }),
              e(Lt, [2, 25]),
              e(Lt, [2, 13]),
              e(Lt, [2, 14]),
              e(Lt, [2, 15]),
              e(Lt, [2, 16]),
              e(Lt, [2, 17]),
              e(Lt, [2, 18]),
              e(Lt, [2, 19]),
              e(Lt, [2, 20]),
              e(Lt, [2, 21]),
              e(Lt, [2, 22]),
              e(u, [2, 49], { 10: bt }),
              e(u, [2, 48], {
                22: 88,
                16: 89,
                23: 104,
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                17: Me,
                18: se,
                19: Nt,
                20: At,
              }),
              {
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                16: 89,
                17: Me,
                18: se,
                19: Nt,
                20: At,
                22: 105,
              },
              e(Lt, [2, 26]),
              e(u, [2, 50], { 10: bt }),
              e(ct, [2, 28], {
                16: 103,
                4: U,
                5: gt,
                6: z,
                8: ge,
                11: lt,
                13: jt,
                17: Me,
                18: se,
                19: Nt,
                20: At,
              }),
            ],
            defaultActions: { 8: [2, 30], 9: [2, 31] },
            parseError: a(function (j, Et) {
              if (Et.recoverable) this.trace(j);
              else {
                var mt = new Error(j);
                throw ((mt.hash = Et), mt);
              }
            }, "parseError"),
            parse: a(function (j) {
              var Et = this,
                mt = [0],
                Xt = [],
                Ft = [null],
                _t = [],
                Qe = this.table,
                It = "",
                xr = 0,
                Ze = 0,
                mn = 0,
                Ae = 2,
                Te = 1,
                Je = _t.slice.call(arguments, 1),
                Se = Object.create(this.lexer),
                hr = { yy: {} };
              for (var Sn in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, Sn) &&
                  (hr.yy[Sn] = this.yy[Sn]);
              (Se.setInput(j, hr.yy),
                (hr.yy.lexer = Se),
                (hr.yy.parser = this),
                typeof Se.yylloc > "u" && (Se.yylloc = {}));
              var Ee = Se.yylloc;
              _t.push(Ee);
              var $e = Se.options && Se.options.ranges;
              typeof hr.yy.parseError == "function"
                ? (this.parseError = hr.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function Le(it) {
                ((mt.length = mt.length - 2 * it),
                  (Ft.length = Ft.length - it),
                  (_t.length = _t.length - it));
              }
              a(Le, "popStack");
              function xe() {
                var it;
                return (
                  (it = Xt.pop() || Se.lex() || Te),
                  typeof it != "number" &&
                    (it instanceof Array && ((Xt = it), (it = Xt.pop())),
                    (it = Et.symbols_[it] || it)),
                  it
                );
              }
              a(xe, "lex");
              for (var fe, ye, be, Ht, Dn, ne, Li = {}, gn, Br, Er, pi; ; ) {
                if (
                  ((be = mt[mt.length - 1]),
                  this.defaultActions[be]
                    ? (Ht = this.defaultActions[be])
                    : ((fe === null || typeof fe > "u") && (fe = xe()),
                      (Ht = Qe[be] && Qe[be][fe])),
                  typeof Ht > "u" || !Ht.length || !Ht[0])
                ) {
                  var Zt = "";
                  pi = [];
                  for (gn in Qe[be])
                    this.terminals_[gn] &&
                      gn > Ae &&
                      pi.push("'" + this.terminals_[gn] + "'");
                  (Se.showPosition
                    ? (Zt =
                        "Parse error on line " +
                        (xr + 1) +
                        `:
` +
                        Se.showPosition() +
                        `
Expecting ` +
                        pi.join(", ") +
                        ", got '" +
                        (this.terminals_[fe] || fe) +
                        "'")
                    : (Zt =
                        "Parse error on line " +
                        (xr + 1) +
                        ": Unexpected " +
                        (fe == Te
                          ? "end of input"
                          : "'" + (this.terminals_[fe] || fe) + "'")),
                    this.parseError(Zt, {
                      text: Se.match,
                      token: this.terminals_[fe] || fe,
                      line: Se.yylineno,
                      loc: Ee,
                      expected: pi,
                    }));
                }
                if (Ht[0] instanceof Array && Ht.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      be +
                      ", token: " +
                      fe,
                  );
                switch (Ht[0]) {
                  case 1:
                    (mt.push(fe),
                      Ft.push(Se.yytext),
                      _t.push(Se.yylloc),
                      mt.push(Ht[1]),
                      (fe = null),
                      ye
                        ? ((fe = ye), (ye = null))
                        : ((Ze = Se.yyleng),
                          (It = Se.yytext),
                          (xr = Se.yylineno),
                          (Ee = Se.yylloc),
                          mn > 0 && mn--));
                    break;
                  case 2:
                    if (
                      ((Br = this.productions_[Ht[1]][1]),
                      (Li.$ = Ft[Ft.length - Br]),
                      (Li._$ = {
                        first_line: _t[_t.length - (Br || 1)].first_line,
                        last_line: _t[_t.length - 1].last_line,
                        first_column: _t[_t.length - (Br || 1)].first_column,
                        last_column: _t[_t.length - 1].last_column,
                      }),
                      $e &&
                        (Li._$.range = [
                          _t[_t.length - (Br || 1)].range[0],
                          _t[_t.length - 1].range[1],
                        ]),
                      (ne = this.performAction.apply(
                        Li,
                        [It, Ze, xr, hr.yy, Ht[1], Ft, _t].concat(Je),
                      )),
                      typeof ne < "u")
                    )
                      return ne;
                    (Br &&
                      ((mt = mt.slice(0, -1 * Br * 2)),
                      (Ft = Ft.slice(0, -1 * Br)),
                      (_t = _t.slice(0, -1 * Br))),
                      mt.push(this.productions_[Ht[1]][0]),
                      Ft.push(Li.$),
                      _t.push(Li._$),
                      (Er = Qe[mt[mt.length - 2]][mt[mt.length - 1]]),
                      mt.push(Er));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          Mt = (function () {
            var Gt = {
              EOF: 1,
              parseError: a(function (Et, mt) {
                if (this.yy.parser) this.yy.parser.parseError(Et, mt);
                else throw new Error(Et);
              }, "parseError"),
              setInput: a(function (j, Et) {
                return (
                  (this.yy = Et || this.yy || {}),
                  (this._input = j),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var j = this._input[0];
                ((this.yytext += j),
                  this.yyleng++,
                  this.offset++,
                  (this.match += j),
                  (this.matched += j));
                var Et = j.match(/(?:\r\n?|\n).*/g);
                return (
                  Et
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  j
                );
              }, "input"),
              unput: a(function (j) {
                var Et = j.length,
                  mt = j.split(/(?:\r\n?|\n)/g);
                ((this._input = j + this._input),
                  (this.yytext = this.yytext.substr(
                    0,
                    this.yytext.length - Et,
                  )),
                  (this.offset -= Et));
                var Xt = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  mt.length - 1 && (this.yylineno -= mt.length - 1));
                var Ft = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: mt
                      ? (mt.length === Xt.length
                          ? this.yylloc.first_column
                          : 0) +
                        Xt[Xt.length - mt.length].length -
                        mt[0].length
                      : this.yylloc.first_column - Et,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [Ft[0], Ft[0] + this.yyleng - Et]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (j) {
                this.unput(this.match.slice(j));
              }, "less"),
              pastInput: a(function () {
                var j = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (j.length > 20 ? "..." : "") +
                  j.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var j = this.match;
                return (
                  j.length < 20 && (j += this._input.substr(0, 20 - j.length)),
                  (j.substr(0, 20) + (j.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var j = this.pastInput(),
                  Et = new Array(j.length + 1).join("-");
                return (
                  j +
                  this.upcomingInput() +
                  `
` +
                  Et +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (j, Et) {
                var mt, Xt, Ft;
                if (
                  (this.options.backtrack_lexer &&
                    ((Ft = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (Ft.yylloc.range = this.yylloc.range.slice(0))),
                  (Xt = j[0].match(/(?:\r\n?|\n).*/g)),
                  Xt && (this.yylineno += Xt.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: Xt
                      ? Xt[Xt.length - 1].length -
                        Xt[Xt.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + j[0].length,
                  }),
                  (this.yytext += j[0]),
                  (this.match += j[0]),
                  (this.matches = j),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(j[0].length)),
                  (this.matched += j[0]),
                  (mt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    Et,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  mt)
                )
                  return mt;
                if (this._backtrack) {
                  for (var _t in Ft) this[_t] = Ft[_t];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var j, Et, mt, Xt;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (
                  var Ft = this._currentRules(), _t = 0;
                  _t < Ft.length;
                  _t++
                )
                  if (
                    ((mt = this._input.match(this.rules[Ft[_t]])),
                    mt && (!Et || mt[0].length > Et[0].length))
                  ) {
                    if (((Et = mt), (Xt = _t), this.options.backtrack_lexer)) {
                      if (((j = this.test_match(mt, Ft[_t])), j !== !1))
                        return j;
                      if (this._backtrack) {
                        Et = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return Et
                  ? ((j = this.test_match(Et, Ft[Xt])), j !== !1 ? j : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var Et = this.next();
                return Et || this.lex();
              }, "lex"),
              begin: a(function (Et) {
                this.conditionStack.push(Et);
              }, "begin"),
              popState: a(function () {
                var Et = this.conditionStack.length - 1;
                return Et > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (Et) {
                return (
                  (Et = this.conditionStack.length - 1 - Math.abs(Et || 0)),
                  Et >= 0 ? this.conditionStack[Et] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (Et) {
                this.begin(Et);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (Et, mt, Xt, Ft) {
                var _t = Ft;
                switch (Xt) {
                  case 0:
                    break;
                  case 1:
                    break;
                  case 2:
                    return 55;
                  case 3:
                    break;
                  case 4:
                    return (this.begin("title"), 35);
                    break;
                  case 5:
                    return (this.popState(), "title_value");
                    break;
                  case 6:
                    return (this.begin("acc_title"), 37);
                    break;
                  case 7:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 8:
                    return (this.begin("acc_descr"), 39);
                    break;
                  case 9:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 10:
                    this.begin("acc_descr_multiline");
                    break;
                  case 11:
                    this.popState();
                    break;
                  case 12:
                    return "acc_descr_multiline_value";
                  case 13:
                    return 48;
                  case 14:
                    return 50;
                  case 15:
                    return 49;
                  case 16:
                    return 51;
                  case 17:
                    return 52;
                  case 18:
                    return 53;
                  case 19:
                    return 54;
                  case 20:
                    return 25;
                  case 21:
                    this.begin("md_string");
                    break;
                  case 22:
                    return "MD_STR";
                  case 23:
                    this.popState();
                    break;
                  case 24:
                    this.begin("string");
                    break;
                  case 25:
                    this.popState();
                    break;
                  case 26:
                    return "STR";
                  case 27:
                    this.begin("class_name");
                    break;
                  case 28:
                    return (this.popState(), 47);
                    break;
                  case 29:
                    return (this.begin("point_start"), 44);
                    break;
                  case 30:
                    return (this.begin("point_x"), 45);
                    break;
                  case 31:
                    this.popState();
                    break;
                  case 32:
                    (this.popState(), this.begin("point_y"));
                    break;
                  case 33:
                    return (this.popState(), 46);
                    break;
                  case 34:
                    return 28;
                  case 35:
                    return 4;
                  case 36:
                    return 11;
                  case 37:
                    return 64;
                  case 38:
                    return 10;
                  case 39:
                    return 65;
                  case 40:
                    return 65;
                  case 41:
                    return 14;
                  case 42:
                    return 13;
                  case 43:
                    return 67;
                  case 44:
                    return 66;
                  case 45:
                    return 12;
                  case 46:
                    return 8;
                  case 47:
                    return 5;
                  case 48:
                    return 18;
                  case 49:
                    return 56;
                  case 50:
                    return 63;
                  case 51:
                    return 57;
                }
              }, "anonymous"),
              rules: [
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n\r]+)/i,
                /^(?:%%[^\n]*)/i,
                /^(?:title\b)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?: *x-axis *)/i,
                /^(?: *y-axis *)/i,
                /^(?: *--+> *)/i,
                /^(?: *quadrant-1 *)/i,
                /^(?: *quadrant-2 *)/i,
                /^(?: *quadrant-3 *)/i,
                /^(?: *quadrant-4 *)/i,
                /^(?:classDef\b)/i,
                /^(?:["][`])/i,
                /^(?:[^`"]+)/i,
                /^(?:[`]["])/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?::::)/i,
                /^(?:^\w+)/i,
                /^(?:\s*:\s*\[\s*)/i,
                /^(?:(1)|(0(.\d+)?))/i,
                /^(?:\s*\] *)/i,
                /^(?:\s*,\s*)/i,
                /^(?:(1)|(0(.\d+)?))/i,
                /^(?: *quadrantChart *)/i,
                /^(?:[A-Za-z]+)/i,
                /^(?::)/i,
                /^(?:\+)/i,
                /^(?:,)/i,
                /^(?:=)/i,
                /^(?:=)/i,
                /^(?:\*)/i,
                /^(?:#)/i,
                /^(?:[\_])/i,
                /^(?:\.)/i,
                /^(?:&)/i,
                /^(?:-)/i,
                /^(?:[0-9]+)/i,
                /^(?:\s)/i,
                /^(?:;)/i,
                /^(?:[!"#$%&'*+,-.`?\\_/])/i,
                /^(?:$)/i,
              ],
              conditions: {
                class_name: { rules: [28], inclusive: !1 },
                point_y: { rules: [33], inclusive: !1 },
                point_x: { rules: [32], inclusive: !1 },
                point_start: { rules: [30, 31], inclusive: !1 },
                acc_descr_multiline: { rules: [11, 12], inclusive: !1 },
                acc_descr: { rules: [9], inclusive: !1 },
                acc_title: { rules: [7], inclusive: !1 },
                title: { rules: [5], inclusive: !1 },
                md_string: { rules: [22, 23], inclusive: !1 },
                string: { rules: [25, 26], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 6, 8, 10, 13, 14, 15, 16, 17, 18, 19, 20, 21,
                    24, 27, 29, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
                    46, 47, 48, 49, 50, 51,
                  ],
                  inclusive: !0,
                },
              },
            };
            return Gt;
          })();
        Z.lexer = Mt;
        function W() {
          this.yy = {};
        }
        return (a(W, "Parser"), (W.prototype = Z), (Z.Parser = W), new W());
      })();
      JD.parser = JD;
      Drt = JD;
    });
  var Ki,
    S_,
    Irt = x(() => {
      "use strict";
      Ge();
      Ss();
      Vt();
      Qm();
      ((Ki = Hl()),
        (S_ = class {
          constructor() {
            this.classes = new Map();
            ((this.config = this.getDefaultConfig()),
              (this.themeConfig = this.getDefaultThemeConfig()),
              (this.data = this.getDefaultData()));
          }
          static {
            a(this, "QuadrantBuilder");
          }
          getDefaultData() {
            return {
              titleText: "",
              quadrant1Text: "",
              quadrant2Text: "",
              quadrant3Text: "",
              quadrant4Text: "",
              xAxisLeftText: "",
              xAxisRightText: "",
              yAxisBottomText: "",
              yAxisTopText: "",
              points: [],
            };
          }
          getDefaultConfig() {
            return {
              showXAxis: !0,
              showYAxis: !0,
              showTitle: !0,
              chartHeight: ze.quadrantChart?.chartWidth || 500,
              chartWidth: ze.quadrantChart?.chartHeight || 500,
              titlePadding: ze.quadrantChart?.titlePadding || 10,
              titleFontSize: ze.quadrantChart?.titleFontSize || 20,
              quadrantPadding: ze.quadrantChart?.quadrantPadding || 5,
              xAxisLabelPadding: ze.quadrantChart?.xAxisLabelPadding || 5,
              yAxisLabelPadding: ze.quadrantChart?.yAxisLabelPadding || 5,
              xAxisLabelFontSize: ze.quadrantChart?.xAxisLabelFontSize || 16,
              yAxisLabelFontSize: ze.quadrantChart?.yAxisLabelFontSize || 16,
              quadrantLabelFontSize:
                ze.quadrantChart?.quadrantLabelFontSize || 16,
              quadrantTextTopPadding:
                ze.quadrantChart?.quadrantTextTopPadding || 5,
              pointTextPadding: ze.quadrantChart?.pointTextPadding || 5,
              pointLabelFontSize: ze.quadrantChart?.pointLabelFontSize || 12,
              pointRadius: ze.quadrantChart?.pointRadius || 5,
              xAxisPosition: ze.quadrantChart?.xAxisPosition || "top",
              yAxisPosition: ze.quadrantChart?.yAxisPosition || "left",
              quadrantInternalBorderStrokeWidth:
                ze.quadrantChart?.quadrantInternalBorderStrokeWidth || 1,
              quadrantExternalBorderStrokeWidth:
                ze.quadrantChart?.quadrantExternalBorderStrokeWidth || 2,
            };
          }
          getDefaultThemeConfig() {
            return {
              quadrant1Fill: Ki.quadrant1Fill,
              quadrant2Fill: Ki.quadrant2Fill,
              quadrant3Fill: Ki.quadrant3Fill,
              quadrant4Fill: Ki.quadrant4Fill,
              quadrant1TextFill: Ki.quadrant1TextFill,
              quadrant2TextFill: Ki.quadrant2TextFill,
              quadrant3TextFill: Ki.quadrant3TextFill,
              quadrant4TextFill: Ki.quadrant4TextFill,
              quadrantPointFill: Ki.quadrantPointFill,
              quadrantPointTextFill: Ki.quadrantPointTextFill,
              quadrantXAxisTextFill: Ki.quadrantXAxisTextFill,
              quadrantYAxisTextFill: Ki.quadrantYAxisTextFill,
              quadrantTitleFill: Ki.quadrantTitleFill,
              quadrantInternalBorderStrokeFill:
                Ki.quadrantInternalBorderStrokeFill,
              quadrantExternalBorderStrokeFill:
                Ki.quadrantExternalBorderStrokeFill,
            };
          }
          clear() {
            ((this.config = this.getDefaultConfig()),
              (this.themeConfig = this.getDefaultThemeConfig()),
              (this.data = this.getDefaultData()),
              (this.classes = new Map()),
              P.info("clear called"));
          }
          setData(t) {
            this.data = { ...this.data, ...t };
          }
          addPoints(t) {
            this.data.points = [...t, ...this.data.points];
          }
          addClass(t, r) {
            this.classes.set(t, r);
          }
          setConfig(t) {
            (P.trace("setConfig called with: ", t),
              (this.config = { ...this.config, ...t }));
          }
          setThemeConfig(t) {
            (P.trace("setThemeConfig called with: ", t),
              (this.themeConfig = { ...this.themeConfig, ...t }));
          }
          calculateSpace(t, r, n, i) {
            let s =
                this.config.xAxisLabelPadding * 2 +
                this.config.xAxisLabelFontSize,
              o = {
                top: t === "top" && r ? s : 0,
                bottom: t === "bottom" && r ? s : 0,
              },
              l =
                this.config.yAxisLabelPadding * 2 +
                this.config.yAxisLabelFontSize,
              u = {
                left: this.config.yAxisPosition === "left" && n ? l : 0,
                right: this.config.yAxisPosition === "right" && n ? l : 0,
              },
              h = this.config.titleFontSize + this.config.titlePadding * 2,
              f = { top: i ? h : 0 },
              d = this.config.quadrantPadding + u.left,
              p = this.config.quadrantPadding + o.top + f.top,
              m =
                this.config.chartWidth -
                this.config.quadrantPadding * 2 -
                u.left -
                u.right,
              g =
                this.config.chartHeight -
                this.config.quadrantPadding * 2 -
                o.top -
                o.bottom -
                f.top,
              y = m / 2,
              b = g / 2;
            return {
              xAxisSpace: o,
              yAxisSpace: u,
              titleSpace: f,
              quadrantSpace: {
                quadrantLeft: d,
                quadrantTop: p,
                quadrantWidth: m,
                quadrantHalfWidth: y,
                quadrantHeight: g,
                quadrantHalfHeight: b,
              },
            };
          }
          getAxisLabels(t, r, n, i) {
            let { quadrantSpace: s, titleSpace: o } = i,
              {
                quadrantHalfHeight: l,
                quadrantHeight: u,
                quadrantLeft: h,
                quadrantHalfWidth: f,
                quadrantTop: d,
                quadrantWidth: p,
              } = s,
              m = !!this.data.xAxisRightText,
              g = !!this.data.yAxisTopText,
              y = [];
            return (
              this.data.xAxisLeftText &&
                r &&
                y.push({
                  text: this.data.xAxisLeftText,
                  fill: this.themeConfig.quadrantXAxisTextFill,
                  x: h + (m ? f / 2 : 0),
                  y:
                    t === "top"
                      ? this.config.xAxisLabelPadding + o.top
                      : this.config.xAxisLabelPadding +
                        d +
                        u +
                        this.config.quadrantPadding,
                  fontSize: this.config.xAxisLabelFontSize,
                  verticalPos: m ? "center" : "left",
                  horizontalPos: "top",
                  rotation: 0,
                }),
              this.data.xAxisRightText &&
                r &&
                y.push({
                  text: this.data.xAxisRightText,
                  fill: this.themeConfig.quadrantXAxisTextFill,
                  x: h + f + (m ? f / 2 : 0),
                  y:
                    t === "top"
                      ? this.config.xAxisLabelPadding + o.top
                      : this.config.xAxisLabelPadding +
                        d +
                        u +
                        this.config.quadrantPadding,
                  fontSize: this.config.xAxisLabelFontSize,
                  verticalPos: m ? "center" : "left",
                  horizontalPos: "top",
                  rotation: 0,
                }),
              this.data.yAxisBottomText &&
                n &&
                y.push({
                  text: this.data.yAxisBottomText,
                  fill: this.themeConfig.quadrantYAxisTextFill,
                  x:
                    this.config.yAxisPosition === "left"
                      ? this.config.yAxisLabelPadding
                      : this.config.yAxisLabelPadding +
                        h +
                        p +
                        this.config.quadrantPadding,
                  y: d + u - (g ? l / 2 : 0),
                  fontSize: this.config.yAxisLabelFontSize,
                  verticalPos: g ? "center" : "left",
                  horizontalPos: "top",
                  rotation: -90,
                }),
              this.data.yAxisTopText &&
                n &&
                y.push({
                  text: this.data.yAxisTopText,
                  fill: this.themeConfig.quadrantYAxisTextFill,
                  x:
                    this.config.yAxisPosition === "left"
                      ? this.config.yAxisLabelPadding
                      : this.config.yAxisLabelPadding +
                        h +
                        p +
                        this.config.quadrantPadding,
                  y: d + l - (g ? l / 2 : 0),
                  fontSize: this.config.yAxisLabelFontSize,
                  verticalPos: g ? "center" : "left",
                  horizontalPos: "top",
                  rotation: -90,
                }),
              y
            );
          }
          getQuadrants(t) {
            let { quadrantSpace: r } = t,
              {
                quadrantHalfHeight: n,
                quadrantLeft: i,
                quadrantHalfWidth: s,
                quadrantTop: o,
              } = r,
              l = [
                {
                  text: {
                    text: this.data.quadrant1Text,
                    fill: this.themeConfig.quadrant1TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: "center",
                    horizontalPos: "middle",
                    rotation: 0,
                  },
                  x: i + s,
                  y: o,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant1Fill,
                },
                {
                  text: {
                    text: this.data.quadrant2Text,
                    fill: this.themeConfig.quadrant2TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: "center",
                    horizontalPos: "middle",
                    rotation: 0,
                  },
                  x: i,
                  y: o,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant2Fill,
                },
                {
                  text: {
                    text: this.data.quadrant3Text,
                    fill: this.themeConfig.quadrant3TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: "center",
                    horizontalPos: "middle",
                    rotation: 0,
                  },
                  x: i,
                  y: o + n,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant3Fill,
                },
                {
                  text: {
                    text: this.data.quadrant4Text,
                    fill: this.themeConfig.quadrant4TextFill,
                    x: 0,
                    y: 0,
                    fontSize: this.config.quadrantLabelFontSize,
                    verticalPos: "center",
                    horizontalPos: "middle",
                    rotation: 0,
                  },
                  x: i + s,
                  y: o + n,
                  width: s,
                  height: n,
                  fill: this.themeConfig.quadrant4Fill,
                },
              ];
            for (let u of l)
              ((u.text.x = u.x + u.width / 2),
                this.data.points.length === 0
                  ? ((u.text.y = u.y + u.height / 2),
                    (u.text.horizontalPos = "middle"))
                  : ((u.text.y = u.y + this.config.quadrantTextTopPadding),
                    (u.text.horizontalPos = "top")));
            return l;
          }
          getQuadrantPoints(t) {
            let { quadrantSpace: r } = t,
              {
                quadrantHeight: n,
                quadrantLeft: i,
                quadrantTop: s,
                quadrantWidth: o,
              } = r,
              l = Ra()
                .domain([0, 1])
                .range([i, o + i]),
              u = Ra()
                .domain([0, 1])
                .range([n + s, s]);
            return this.data.points.map((f) => {
              let d = this.classes.get(f.className);
              return (
                d && (f = { ...d, ...f }),
                {
                  x: l(f.x),
                  y: u(f.y),
                  fill: f.color ?? this.themeConfig.quadrantPointFill,
                  radius: f.radius ?? this.config.pointRadius,
                  text: {
                    text: f.text,
                    fill: this.themeConfig.quadrantPointTextFill,
                    x: l(f.x),
                    y: u(f.y) + this.config.pointTextPadding,
                    verticalPos: "center",
                    horizontalPos: "top",
                    fontSize: this.config.pointLabelFontSize,
                    rotation: 0,
                  },
                  strokeColor:
                    f.strokeColor ?? this.themeConfig.quadrantPointFill,
                  strokeWidth: f.strokeWidth ?? "0px",
                }
              );
            });
          }
          getBorders(t) {
            let r = this.config.quadrantExternalBorderStrokeWidth / 2,
              { quadrantSpace: n } = t,
              {
                quadrantHalfHeight: i,
                quadrantHeight: s,
                quadrantLeft: o,
                quadrantHalfWidth: l,
                quadrantTop: u,
                quadrantWidth: h,
              } = n;
            return [
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o - r,
                y1: u,
                x2: o + h + r,
                y2: u,
              },
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o + h,
                y1: u + r,
                x2: o + h,
                y2: u + s - r,
              },
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o - r,
                y1: u + s,
                x2: o + h + r,
                y2: u + s,
              },
              {
                strokeFill: this.themeConfig.quadrantExternalBorderStrokeFill,
                strokeWidth: this.config.quadrantExternalBorderStrokeWidth,
                x1: o,
                y1: u + r,
                x2: o,
                y2: u + s - r,
              },
              {
                strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
                strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
                x1: o + l,
                y1: u + r,
                x2: o + l,
                y2: u + s - r,
              },
              {
                strokeFill: this.themeConfig.quadrantInternalBorderStrokeFill,
                strokeWidth: this.config.quadrantInternalBorderStrokeWidth,
                x1: o + r,
                y1: u + i,
                x2: o + h - r,
                y2: u + i,
              },
            ];
          }
          getTitle(t) {
            if (t)
              return {
                text: this.data.titleText,
                fill: this.themeConfig.quadrantTitleFill,
                fontSize: this.config.titleFontSize,
                horizontalPos: "top",
                verticalPos: "center",
                rotation: 0,
                y: this.config.titlePadding,
                x: this.config.chartWidth / 2,
              };
          }
          build() {
            let t =
                this.config.showXAxis &&
                !!(this.data.xAxisLeftText || this.data.xAxisRightText),
              r =
                this.config.showYAxis &&
                !!(this.data.yAxisTopText || this.data.yAxisBottomText),
              n = this.config.showTitle && !!this.data.titleText,
              i =
                this.data.points.length > 0
                  ? "bottom"
                  : this.config.xAxisPosition,
              s = this.calculateSpace(i, t, r, n);
            return {
              points: this.getQuadrantPoints(s),
              quadrants: this.getQuadrants(s),
              axisLabels: this.getAxisLabels(i, t, r, s),
              borderLines: this.getBorders(s),
              title: this.getTitle(n),
            };
          }
        }));
    });
  function tN(e) {
    return !/^#?([\dA-Fa-f]{6}|[\dA-Fa-f]{3})$/.test(e);
  }
  function Mrt(e) {
    return !/^\d+$/.test(e);
  }
  function Ort(e) {
    return !/^\d+px$/.test(e);
  }
  var Xh,
    Prt = x(() => {
      "use strict";
      Xh = class extends Error {
        static {
          a(this, "InvalidStyleError");
        }
        constructor(t, r, n) {
          (super(`value for ${t} ${r} is invalid, please use a valid ${n}`),
            (this.name = "InvalidStyleError"));
        }
      };
      a(tN, "validateHexCode");
      a(Mrt, "validateNumber");
      a(Ort, "validateSizeInPixels");
    });
  function $l(e) {
    return Ie(e.trim(), $Lt);
  }
  function GLt(e) {
    di.setData({ quadrant1Text: $l(e.text) });
  }
  function VLt(e) {
    di.setData({ quadrant2Text: $l(e.text) });
  }
  function zLt(e) {
    di.setData({ quadrant3Text: $l(e.text) });
  }
  function WLt(e) {
    di.setData({ quadrant4Text: $l(e.text) });
  }
  function ULt(e) {
    di.setData({ xAxisLeftText: $l(e.text) });
  }
  function jLt(e) {
    di.setData({ xAxisRightText: $l(e.text) });
  }
  function qLt(e) {
    di.setData({ yAxisTopText: $l(e.text) });
  }
  function HLt(e) {
    di.setData({ yAxisBottomText: $l(e.text) });
  }
  function eN(e) {
    let t = {};
    for (let r of e) {
      let [n, i] = r.trim().split(/\s*:\s*/);
      if (n === "radius") {
        if (Mrt(i)) throw new Xh(n, i, "number");
        t.radius = parseInt(i);
      } else if (n === "color") {
        if (tN(i)) throw new Xh(n, i, "hex code");
        t.color = i;
      } else if (n === "stroke-color") {
        if (tN(i)) throw new Xh(n, i, "hex code");
        t.strokeColor = i;
      } else if (n === "stroke-width") {
        if (Ort(i)) throw new Xh(n, i, "number of pixels (eg. 10px)");
        t.strokeWidth = i;
      } else throw new Error(`style named ${n} is not supported.`);
    }
    return t;
  }
  function YLt(e, t, r, n, i) {
    let s = eN(i);
    di.addPoints([{ x: r, y: n, text: $l(e.text), className: t, ...s }]);
  }
  function XLt(e, t) {
    di.addClass(e, eN(t));
  }
  function KLt(e) {
    di.setConfig({ chartWidth: e });
  }
  function QLt(e) {
    di.setConfig({ chartHeight: e });
  }
  function ZLt() {
    let e = K(),
      { themeVariables: t, quadrantChart: r } = e;
    return (
      r && di.setConfig(r),
      di.setThemeConfig({
        quadrant1Fill: t.quadrant1Fill,
        quadrant2Fill: t.quadrant2Fill,
        quadrant3Fill: t.quadrant3Fill,
        quadrant4Fill: t.quadrant4Fill,
        quadrant1TextFill: t.quadrant1TextFill,
        quadrant2TextFill: t.quadrant2TextFill,
        quadrant3TextFill: t.quadrant3TextFill,
        quadrant4TextFill: t.quadrant4TextFill,
        quadrantPointFill: t.quadrantPointFill,
        quadrantPointTextFill: t.quadrantPointTextFill,
        quadrantXAxisTextFill: t.quadrantXAxisTextFill,
        quadrantYAxisTextFill: t.quadrantYAxisTextFill,
        quadrantExternalBorderStrokeFill: t.quadrantExternalBorderStrokeFill,
        quadrantInternalBorderStrokeFill: t.quadrantInternalBorderStrokeFill,
        quadrantTitleFill: t.quadrantTitleFill,
      }),
      di.setData({ titleText: nr() }),
      di.build()
    );
  }
  var $Lt,
    di,
    JLt,
    Brt,
    Frt = x(() => {
      "use strict";
      pe();
      Be();
      yn();
      Irt();
      Prt();
      $Lt = K();
      a($l, "textSanitizer");
      di = new S_();
      a(GLt, "setQuadrant1Text");
      a(VLt, "setQuadrant2Text");
      a(zLt, "setQuadrant3Text");
      a(WLt, "setQuadrant4Text");
      a(ULt, "setXAxisLeftText");
      a(jLt, "setXAxisRightText");
      a(qLt, "setYAxisTopText");
      a(HLt, "setYAxisBottomText");
      a(eN, "parseStyles");
      a(YLt, "addPoint");
      a(XLt, "addClass");
      a(KLt, "setWidth");
      a(QLt, "setHeight");
      a(ZLt, "getQuadrantData");
      ((JLt = a(function () {
        (di.clear(), Ye());
      }, "clear")),
        (Brt = {
          setWidth: KLt,
          setHeight: QLt,
          setQuadrant1Text: GLt,
          setQuadrant2Text: VLt,
          setQuadrant3Text: zLt,
          setQuadrant4Text: WLt,
          setXAxisLeftText: ULt,
          setXAxisRightText: jLt,
          setYAxisTopText: qLt,
          setYAxisBottomText: HLt,
          parseStyles: eN,
          addPoint: YLt,
          addClass: XLt,
          getQuadrantData: ZLt,
          clear: JLt,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          getAccDescription: rr,
          setAccDescription: er,
        }));
    });
  var tRt,
    $rt,
    Grt = x(() => {
      "use strict";
      Ge();
      pe();
      Vt();
      On();
      ((tRt = a((e, t, r, n) => {
        function i(E) {
          return E === "top" ? "hanging" : "middle";
        }
        a(i, "getDominantBaseLine");
        function s(E) {
          return E === "left" ? "start" : "middle";
        }
        a(s, "getTextAnchor");
        function o(E) {
          return `translate(${E.x}, ${E.y}) rotate(${E.rotation || 0})`;
        }
        a(o, "getTransformation");
        let l = K();
        P.debug(
          `Rendering quadrant chart
` + e,
        );
        let u = l.securityLevel,
          h;
        u === "sandbox" && (h = xt("#i" + t));
        let d = (
            u === "sandbox" ? xt(h.nodes()[0].contentDocument.body) : xt("body")
          ).select(`[id="${t}"]`),
          p = d.append("g").attr("class", "main"),
          m = l.quadrantChart?.chartWidth ?? 500,
          g = l.quadrantChart?.chartHeight ?? 500;
        (Ar(d, g, m, l.quadrantChart?.useMaxWidth ?? !0),
          d.attr("viewBox", "0 0 " + m + " " + g),
          n.db.setHeight(g),
          n.db.setWidth(m));
        let y = n.db.getQuadrantData(),
          b = p.append("g").attr("class", "quadrants"),
          k = p.append("g").attr("class", "border"),
          T = p.append("g").attr("class", "data-points"),
          C = p.append("g").attr("class", "labels"),
          L = p.append("g").attr("class", "title");
        (y.title &&
          L.append("text")
            .attr("x", 0)
            .attr("y", 0)
            .attr("fill", y.title.fill)
            .attr("font-size", y.title.fontSize)
            .attr("dominant-baseline", i(y.title.horizontalPos))
            .attr("text-anchor", s(y.title.verticalPos))
            .attr("transform", o(y.title))
            .text(y.title.text),
          y.borderLines &&
            k
              .selectAll("line")
              .data(y.borderLines)
              .enter()
              .append("line")
              .attr("x1", (E) => E.x1)
              .attr("y1", (E) => E.y1)
              .attr("x2", (E) => E.x2)
              .attr("y2", (E) => E.y2)
              .style("stroke", (E) => E.strokeFill)
              .style("stroke-width", (E) => E.strokeWidth));
        let w = b
          .selectAll("g.quadrant")
          .data(y.quadrants)
          .enter()
          .append("g")
          .attr("class", "quadrant");
        (w
          .append("rect")
          .attr("x", (E) => E.x)
          .attr("y", (E) => E.y)
          .attr("width", (E) => E.width)
          .attr("height", (E) => E.height)
          .attr("fill", (E) => E.fill),
          w
            .append("text")
            .attr("x", 0)
            .attr("y", 0)
            .attr("fill", (E) => E.text.fill)
            .attr("font-size", (E) => E.text.fontSize)
            .attr("dominant-baseline", (E) => i(E.text.horizontalPos))
            .attr("text-anchor", (E) => s(E.text.verticalPos))
            .attr("transform", (E) => o(E.text))
            .text((E) => E.text.text),
          C.selectAll("g.label")
            .data(y.axisLabels)
            .enter()
            .append("g")
            .attr("class", "label")
            .append("text")
            .attr("x", 0)
            .attr("y", 0)
            .text((E) => E.text)
            .attr("fill", (E) => E.fill)
            .attr("font-size", (E) => E.fontSize)
            .attr("dominant-baseline", (E) => i(E.horizontalPos))
            .attr("text-anchor", (E) => s(E.verticalPos))
            .attr("transform", (E) => o(E)));
        let G = T.selectAll("g.data-point")
          .data(y.points)
          .enter()
          .append("g")
          .attr("class", "data-point");
        (G.append("circle")
          .attr("cx", (E) => E.x)
          .attr("cy", (E) => E.y)
          .attr("r", (E) => E.radius)
          .attr("fill", (E) => E.fill)
          .attr("stroke", (E) => E.strokeColor)
          .attr("stroke-width", (E) => E.strokeWidth),
          G.append("text")
            .attr("x", 0)
            .attr("y", 0)
            .text((E) => E.text.text)
            .attr("fill", (E) => E.text.fill)
            .attr("font-size", (E) => E.text.fontSize)
            .attr("dominant-baseline", (E) => i(E.text.horizontalPos))
            .attr("text-anchor", (E) => s(E.text.verticalPos))
            .attr("transform", (E) => o(E.text)));
      }, "draw")),
        ($rt = { draw: tRt }));
    });
  var Vrt = {};
  Oe(Vrt, { diagram: () => eRt });
  var eRt,
    zrt = x(() => {
      "use strict";
      Nrt();
      Frt();
      Grt();
      eRt = {
        parser: Drt,
        db: Brt,
        renderer: $rt,
        styles: a(() => "", "styles"),
      };
    });
  var rN,
    jrt,
    qrt = x(() => {
      "use strict";
      rN = (function () {
        var e = a(function (A, N, B, M) {
            for (B = B || {}, M = A.length; M--; B[A[M]] = N);
            return B;
          }, "o"),
          t = [1, 10, 12, 14, 16, 18, 19, 21, 23],
          r = [2, 6],
          n = [1, 3],
          i = [1, 5],
          s = [1, 6],
          o = [1, 7],
          l = [1, 5, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36],
          u = [1, 25],
          h = [1, 26],
          f = [1, 28],
          d = [1, 29],
          p = [1, 30],
          m = [1, 31],
          g = [1, 32],
          y = [1, 33],
          b = [1, 34],
          k = [1, 35],
          T = [1, 36],
          C = [1, 37],
          L = [1, 43],
          w = [1, 42],
          D = [1, 47],
          G = [1, 50],
          E = [1, 10, 12, 14, 16, 18, 19, 21, 23, 34, 35, 36],
          R = [1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36],
          F = [
            1, 10, 12, 14, 16, 18, 19, 21, 23, 24, 26, 27, 28, 34, 35, 36, 41,
            42, 43, 44, 45, 46, 47, 48, 49, 50,
          ],
          S = [1, 64],
          O = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              eol: 4,
              XYCHART: 5,
              chartConfig: 6,
              document: 7,
              CHART_ORIENTATION: 8,
              statement: 9,
              title: 10,
              text: 11,
              X_AXIS: 12,
              parseXAxis: 13,
              Y_AXIS: 14,
              parseYAxis: 15,
              LINE: 16,
              plotData: 17,
              BAR: 18,
              acc_title: 19,
              acc_title_value: 20,
              acc_descr: 21,
              acc_descr_value: 22,
              acc_descr_multiline_value: 23,
              SQUARE_BRACES_START: 24,
              commaSeparatedNumbers: 25,
              SQUARE_BRACES_END: 26,
              NUMBER_WITH_DECIMAL: 27,
              COMMA: 28,
              xAxisData: 29,
              bandData: 30,
              ARROW_DELIMITER: 31,
              commaSeparatedTexts: 32,
              yAxisData: 33,
              NEWLINE: 34,
              SEMI: 35,
              EOF: 36,
              alphaNum: 37,
              STR: 38,
              MD_STR: 39,
              alphaNumToken: 40,
              AMP: 41,
              NUM: 42,
              ALPHA: 43,
              PLUS: 44,
              EQUALS: 45,
              MULT: 46,
              DOT: 47,
              BRKT: 48,
              MINUS: 49,
              UNDERSCORE: 50,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              5: "XYCHART",
              8: "CHART_ORIENTATION",
              10: "title",
              12: "X_AXIS",
              14: "Y_AXIS",
              16: "LINE",
              18: "BAR",
              19: "acc_title",
              20: "acc_title_value",
              21: "acc_descr",
              22: "acc_descr_value",
              23: "acc_descr_multiline_value",
              24: "SQUARE_BRACES_START",
              26: "SQUARE_BRACES_END",
              27: "NUMBER_WITH_DECIMAL",
              28: "COMMA",
              31: "ARROW_DELIMITER",
              34: "NEWLINE",
              35: "SEMI",
              36: "EOF",
              38: "STR",
              39: "MD_STR",
              41: "AMP",
              42: "NUM",
              43: "ALPHA",
              44: "PLUS",
              45: "EQUALS",
              46: "MULT",
              47: "DOT",
              48: "BRKT",
              49: "MINUS",
              50: "UNDERSCORE",
            },
            productions_: [
              0,
              [3, 2],
              [3, 3],
              [3, 2],
              [3, 1],
              [6, 1],
              [7, 0],
              [7, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 3],
              [9, 2],
              [9, 3],
              [9, 2],
              [9, 2],
              [9, 1],
              [17, 3],
              [25, 3],
              [25, 1],
              [13, 1],
              [13, 2],
              [13, 1],
              [29, 1],
              [29, 3],
              [30, 3],
              [32, 3],
              [32, 1],
              [15, 1],
              [15, 2],
              [15, 1],
              [33, 3],
              [4, 1],
              [4, 1],
              [4, 1],
              [11, 1],
              [11, 1],
              [11, 1],
              [37, 1],
              [37, 2],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
              [40, 1],
            ],
            performAction: a(function (N, B, M, I, V, $, q) {
              var tt = $.length - 1;
              switch (V) {
                case 5:
                  I.setOrientation($[tt]);
                  break;
                case 9:
                  I.setDiagramTitle($[tt].text.trim());
                  break;
                case 12:
                  I.setLineData({ text: "", type: "text" }, $[tt]);
                  break;
                case 13:
                  I.setLineData($[tt - 1], $[tt]);
                  break;
                case 14:
                  I.setBarData({ text: "", type: "text" }, $[tt]);
                  break;
                case 15:
                  I.setBarData($[tt - 1], $[tt]);
                  break;
                case 16:
                  ((this.$ = $[tt].trim()), I.setAccTitle(this.$));
                  break;
                case 17:
                case 18:
                  ((this.$ = $[tt].trim()), I.setAccDescription(this.$));
                  break;
                case 19:
                  this.$ = $[tt - 1];
                  break;
                case 20:
                  this.$ = [Number($[tt - 2]), ...$[tt]];
                  break;
                case 21:
                  this.$ = [Number($[tt])];
                  break;
                case 22:
                  I.setXAxisTitle($[tt]);
                  break;
                case 23:
                  I.setXAxisTitle($[tt - 1]);
                  break;
                case 24:
                  I.setXAxisTitle({ type: "text", text: "" });
                  break;
                case 25:
                  I.setXAxisBand($[tt]);
                  break;
                case 26:
                  I.setXAxisRangeData(Number($[tt - 2]), Number($[tt]));
                  break;
                case 27:
                  this.$ = $[tt - 1];
                  break;
                case 28:
                  this.$ = [$[tt - 2], ...$[tt]];
                  break;
                case 29:
                  this.$ = [$[tt]];
                  break;
                case 30:
                  I.setYAxisTitle($[tt]);
                  break;
                case 31:
                  I.setYAxisTitle($[tt - 1]);
                  break;
                case 32:
                  I.setYAxisTitle({ type: "text", text: "" });
                  break;
                case 33:
                  I.setYAxisRangeData(Number($[tt - 2]), Number($[tt]));
                  break;
                case 37:
                  this.$ = { text: $[tt], type: "text" };
                  break;
                case 38:
                  this.$ = { text: $[tt], type: "text" };
                  break;
                case 39:
                  this.$ = { text: $[tt], type: "markdown" };
                  break;
                case 40:
                  this.$ = $[tt];
                  break;
                case 41:
                  this.$ = $[tt - 1] + "" + $[tt];
                  break;
              }
            }, "anonymous"),
            table: [
              e(t, r, { 3: 1, 4: 2, 7: 4, 5: n, 34: i, 35: s, 36: o }),
              { 1: [3] },
              e(t, r, { 4: 2, 7: 4, 3: 8, 5: n, 34: i, 35: s, 36: o }),
              e(t, r, {
                4: 2,
                7: 4,
                6: 9,
                3: 10,
                5: n,
                8: [1, 11],
                34: i,
                35: s,
                36: o,
              }),
              {
                1: [2, 4],
                9: 12,
                10: [1, 13],
                12: [1, 14],
                14: [1, 15],
                16: [1, 16],
                18: [1, 17],
                19: [1, 18],
                21: [1, 19],
                23: [1, 20],
              },
              e(l, [2, 34]),
              e(l, [2, 35]),
              e(l, [2, 36]),
              { 1: [2, 1] },
              e(t, r, { 4: 2, 7: 4, 3: 21, 5: n, 34: i, 35: s, 36: o }),
              { 1: [2, 3] },
              e(l, [2, 5]),
              e(t, [2, 7], { 4: 22, 34: i, 35: s, 36: o }),
              {
                11: 23,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 39,
                13: 38,
                24: L,
                27: w,
                29: 40,
                30: 41,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 45,
                15: 44,
                27: D,
                33: 46,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 49,
                17: 48,
                24: G,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              {
                11: 52,
                17: 51,
                24: G,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              { 20: [1, 53] },
              { 22: [1, 54] },
              e(E, [2, 18]),
              { 1: [2, 2] },
              e(E, [2, 8]),
              e(E, [2, 9]),
              e(R, [2, 37], {
                40: 55,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              }),
              e(R, [2, 38]),
              e(R, [2, 39]),
              e(F, [2, 40]),
              e(F, [2, 42]),
              e(F, [2, 43]),
              e(F, [2, 44]),
              e(F, [2, 45]),
              e(F, [2, 46]),
              e(F, [2, 47]),
              e(F, [2, 48]),
              e(F, [2, 49]),
              e(F, [2, 50]),
              e(F, [2, 51]),
              e(E, [2, 10]),
              e(E, [2, 22], { 30: 41, 29: 56, 24: L, 27: w }),
              e(E, [2, 24]),
              e(E, [2, 25]),
              { 31: [1, 57] },
              {
                11: 59,
                32: 58,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              e(E, [2, 11]),
              e(E, [2, 30], { 33: 60, 27: D }),
              e(E, [2, 32]),
              { 31: [1, 61] },
              e(E, [2, 12]),
              { 17: 62, 24: G },
              { 25: 63, 27: S },
              e(E, [2, 14]),
              { 17: 65, 24: G },
              e(E, [2, 16]),
              e(E, [2, 17]),
              e(F, [2, 41]),
              e(E, [2, 23]),
              { 27: [1, 66] },
              { 26: [1, 67] },
              { 26: [2, 29], 28: [1, 68] },
              e(E, [2, 31]),
              { 27: [1, 69] },
              e(E, [2, 13]),
              { 26: [1, 70] },
              { 26: [2, 21], 28: [1, 71] },
              e(E, [2, 15]),
              e(E, [2, 26]),
              e(E, [2, 27]),
              {
                11: 59,
                32: 72,
                37: 24,
                38: u,
                39: h,
                40: 27,
                41: f,
                42: d,
                43: p,
                44: m,
                45: g,
                46: y,
                47: b,
                48: k,
                49: T,
                50: C,
              },
              e(E, [2, 33]),
              e(E, [2, 19]),
              { 25: 73, 27: S },
              { 26: [2, 28] },
              { 26: [2, 20] },
            ],
            defaultActions: {
              8: [2, 1],
              10: [2, 3],
              21: [2, 2],
              72: [2, 28],
              73: [2, 20],
            },
            parseError: a(function (N, B) {
              if (B.recoverable) this.trace(N);
              else {
                var M = new Error(N);
                throw ((M.hash = B), M);
              }
            }, "parseError"),
            parse: a(function (N) {
              var B = this,
                M = [0],
                I = [],
                V = [null],
                $ = [],
                q = this.table,
                tt = "",
                ht = 0,
                H = 0,
                kt = 0,
                ft = 2,
                yt = 1,
                ot = $.slice.call(arguments, 1),
                dt = Object.create(this.lexer),
                nt = { yy: {} };
              for (var Q in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, Q) &&
                  (nt.yy[Q] = this.yy[Q]);
              (dt.setInput(N, nt.yy),
                (nt.yy.lexer = dt),
                (nt.yy.parser = this),
                typeof dt.yylloc > "u" && (dt.yylloc = {}));
              var et = dt.yylloc;
              $.push(et);
              var X = dt.options && dt.options.ranges;
              typeof nt.yy.parseError == "function"
                ? (this.parseError = nt.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function st(Z) {
                ((M.length = M.length - 2 * Z),
                  (V.length = V.length - Z),
                  ($.length = $.length - Z));
              }
              a(st, "popStack");
              function U() {
                var Z;
                return (
                  (Z = I.pop() || dt.lex() || yt),
                  typeof Z != "number" &&
                    (Z instanceof Array && ((I = Z), (Z = I.pop())),
                    (Z = B.symbols_[Z] || Z)),
                  Z
                );
              }
              a(U, "lex");
              for (var gt, z, ge, lt, jt, Me, se = {}, Nt, At, bt, ct; ; ) {
                if (
                  ((ge = M[M.length - 1]),
                  this.defaultActions[ge]
                    ? (lt = this.defaultActions[ge])
                    : ((gt === null || typeof gt > "u") && (gt = U()),
                      (lt = q[ge] && q[ge][gt])),
                  typeof lt > "u" || !lt.length || !lt[0])
                ) {
                  var Lt = "";
                  ct = [];
                  for (Nt in q[ge])
                    this.terminals_[Nt] &&
                      Nt > ft &&
                      ct.push("'" + this.terminals_[Nt] + "'");
                  (dt.showPosition
                    ? (Lt =
                        "Parse error on line " +
                        (ht + 1) +
                        `:
` +
                        dt.showPosition() +
                        `
Expecting ` +
                        ct.join(", ") +
                        ", got '" +
                        (this.terminals_[gt] || gt) +
                        "'")
                    : (Lt =
                        "Parse error on line " +
                        (ht + 1) +
                        ": Unexpected " +
                        (gt == yt
                          ? "end of input"
                          : "'" + (this.terminals_[gt] || gt) + "'")),
                    this.parseError(Lt, {
                      text: dt.match,
                      token: this.terminals_[gt] || gt,
                      line: dt.yylineno,
                      loc: et,
                      expected: ct,
                    }));
                }
                if (lt[0] instanceof Array && lt.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      ge +
                      ", token: " +
                      gt,
                  );
                switch (lt[0]) {
                  case 1:
                    (M.push(gt),
                      V.push(dt.yytext),
                      $.push(dt.yylloc),
                      M.push(lt[1]),
                      (gt = null),
                      z
                        ? ((gt = z), (z = null))
                        : ((H = dt.yyleng),
                          (tt = dt.yytext),
                          (ht = dt.yylineno),
                          (et = dt.yylloc),
                          kt > 0 && kt--));
                    break;
                  case 2:
                    if (
                      ((At = this.productions_[lt[1]][1]),
                      (se.$ = V[V.length - At]),
                      (se._$ = {
                        first_line: $[$.length - (At || 1)].first_line,
                        last_line: $[$.length - 1].last_line,
                        first_column: $[$.length - (At || 1)].first_column,
                        last_column: $[$.length - 1].last_column,
                      }),
                      X &&
                        (se._$.range = [
                          $[$.length - (At || 1)].range[0],
                          $[$.length - 1].range[1],
                        ]),
                      (Me = this.performAction.apply(
                        se,
                        [tt, H, ht, nt.yy, lt[1], V, $].concat(ot),
                      )),
                      typeof Me < "u")
                    )
                      return Me;
                    (At &&
                      ((M = M.slice(0, -1 * At * 2)),
                      (V = V.slice(0, -1 * At)),
                      ($ = $.slice(0, -1 * At))),
                      M.push(this.productions_[lt[1]][0]),
                      V.push(se.$),
                      $.push(se._$),
                      (bt = q[M[M.length - 2]][M[M.length - 1]]),
                      M.push(bt));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          v = (function () {
            var A = {
              EOF: 1,
              parseError: a(function (B, M) {
                if (this.yy.parser) this.yy.parser.parseError(B, M);
                else throw new Error(B);
              }, "parseError"),
              setInput: a(function (N, B) {
                return (
                  (this.yy = B || this.yy || {}),
                  (this._input = N),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var N = this._input[0];
                ((this.yytext += N),
                  this.yyleng++,
                  this.offset++,
                  (this.match += N),
                  (this.matched += N));
                var B = N.match(/(?:\r\n?|\n).*/g);
                return (
                  B
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  N
                );
              }, "input"),
              unput: a(function (N) {
                var B = N.length,
                  M = N.split(/(?:\r\n?|\n)/g);
                ((this._input = N + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - B)),
                  (this.offset -= B));
                var I = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  M.length - 1 && (this.yylineno -= M.length - 1));
                var V = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: M
                      ? (M.length === I.length ? this.yylloc.first_column : 0) +
                        I[I.length - M.length].length -
                        M[0].length
                      : this.yylloc.first_column - B,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [V[0], V[0] + this.yyleng - B]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (N) {
                this.unput(this.match.slice(N));
              }, "less"),
              pastInput: a(function () {
                var N = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (N.length > 20 ? "..." : "") +
                  N.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var N = this.match;
                return (
                  N.length < 20 && (N += this._input.substr(0, 20 - N.length)),
                  (N.substr(0, 20) + (N.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var N = this.pastInput(),
                  B = new Array(N.length + 1).join("-");
                return (
                  N +
                  this.upcomingInput() +
                  `
` +
                  B +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (N, B) {
                var M, I, V;
                if (
                  (this.options.backtrack_lexer &&
                    ((V = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (V.yylloc.range = this.yylloc.range.slice(0))),
                  (I = N[0].match(/(?:\r\n?|\n).*/g)),
                  I && (this.yylineno += I.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: I
                      ? I[I.length - 1].length -
                        I[I.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + N[0].length,
                  }),
                  (this.yytext += N[0]),
                  (this.match += N[0]),
                  (this.matches = N),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(N[0].length)),
                  (this.matched += N[0]),
                  (M = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    B,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  M)
                )
                  return M;
                if (this._backtrack) {
                  for (var $ in V) this[$] = V[$];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var N, B, M, I;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var V = this._currentRules(), $ = 0; $ < V.length; $++)
                  if (
                    ((M = this._input.match(this.rules[V[$]])),
                    M && (!B || M[0].length > B[0].length))
                  ) {
                    if (((B = M), (I = $), this.options.backtrack_lexer)) {
                      if (((N = this.test_match(M, V[$])), N !== !1)) return N;
                      if (this._backtrack) {
                        B = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return B
                  ? ((N = this.test_match(B, V[I])), N !== !1 ? N : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var B = this.next();
                return B || this.lex();
              }, "lex"),
              begin: a(function (B) {
                this.conditionStack.push(B);
              }, "begin"),
              popState: a(function () {
                var B = this.conditionStack.length - 1;
                return B > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (B) {
                return (
                  (B = this.conditionStack.length - 1 - Math.abs(B || 0)),
                  B >= 0 ? this.conditionStack[B] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (B) {
                this.begin(B);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (B, M, I, V) {
                var $ = V;
                switch (I) {
                  case 0:
                    break;
                  case 1:
                    break;
                  case 2:
                    return (this.popState(), 34);
                    break;
                  case 3:
                    return (this.popState(), 34);
                    break;
                  case 4:
                    return 34;
                  case 5:
                    break;
                  case 6:
                    return 10;
                  case 7:
                    return (this.pushState("acc_title"), 19);
                    break;
                  case 8:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 9:
                    return (this.pushState("acc_descr"), 21);
                    break;
                  case 10:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 11:
                    this.pushState("acc_descr_multiline");
                    break;
                  case 12:
                    this.popState();
                    break;
                  case 13:
                    return "acc_descr_multiline_value";
                  case 14:
                    return 5;
                  case 15:
                    return 5;
                  case 16:
                    return 8;
                  case 17:
                    return (this.pushState("axis_data"), "X_AXIS");
                    break;
                  case 18:
                    return (this.pushState("axis_data"), "Y_AXIS");
                    break;
                  case 19:
                    return (this.pushState("axis_band_data"), 24);
                    break;
                  case 20:
                    return 31;
                  case 21:
                    return (this.pushState("data"), 16);
                    break;
                  case 22:
                    return (this.pushState("data"), 18);
                    break;
                  case 23:
                    return (this.pushState("data_inner"), 24);
                    break;
                  case 24:
                    return 27;
                  case 25:
                    return (this.popState(), 26);
                    break;
                  case 26:
                    this.popState();
                    break;
                  case 27:
                    this.pushState("string");
                    break;
                  case 28:
                    this.popState();
                    break;
                  case 29:
                    return "STR";
                  case 30:
                    return 24;
                  case 31:
                    return 26;
                  case 32:
                    return 43;
                  case 33:
                    return "COLON";
                  case 34:
                    return 44;
                  case 35:
                    return 28;
                  case 36:
                    return 45;
                  case 37:
                    return 46;
                  case 38:
                    return 48;
                  case 39:
                    return 50;
                  case 40:
                    return 47;
                  case 41:
                    return 41;
                  case 42:
                    return 49;
                  case 43:
                    return 42;
                  case 44:
                    break;
                  case 45:
                    return 35;
                  case 46:
                    return 36;
                }
              }, "anonymous"),
              rules: [
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:(\r?\n))/i,
                /^(?:(\r?\n))/i,
                /^(?:[\n\r]+)/i,
                /^(?:%%[^\n]*)/i,
                /^(?:title\b)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:\{)/i,
                /^(?:[^\}]*)/i,
                /^(?:xychart-beta\b)/i,
                /^(?:xychart\b)/i,
                /^(?:(?:vertical|horizontal))/i,
                /^(?:x-axis\b)/i,
                /^(?:y-axis\b)/i,
                /^(?:\[)/i,
                /^(?:-->)/i,
                /^(?:line\b)/i,
                /^(?:bar\b)/i,
                /^(?:\[)/i,
                /^(?:[+-]?(?:\d+(?:\.\d+)?|\.\d+))/i,
                /^(?:\])/i,
                /^(?:(?:`\)                                    \{ this\.pushState\(md_string\); \}\n<md_string>\(\?:\(\?!`"\)\.\)\+                  \{ return MD_STR; \}\n<md_string>\(\?:`))/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:\[)/i,
                /^(?:\])/i,
                /^(?:[A-Za-z]+)/i,
                /^(?::)/i,
                /^(?:\+)/i,
                /^(?:,)/i,
                /^(?:=)/i,
                /^(?:\*)/i,
                /^(?:#)/i,
                /^(?:[\_])/i,
                /^(?:\.)/i,
                /^(?:&)/i,
                /^(?:-)/i,
                /^(?:[0-9]+)/i,
                /^(?:\s+)/i,
                /^(?:;)/i,
                /^(?:$)/i,
              ],
              conditions: {
                data_inner: {
                  rules: [
                    0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 24, 25,
                    26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
                    43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
                data: {
                  rules: [
                    0, 1, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 23,
                    26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42,
                    43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
                axis_band_data: {
                  rules: [
                    0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 25, 26,
                    27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,
                    44, 45, 46,
                  ],
                  inclusive: !0,
                },
                axis_data: {
                  rules: [
                    0, 1, 2, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19, 20, 21,
                    22, 24, 26, 27, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                    41, 42, 43, 44, 45, 46,
                  ],
                  inclusive: !0,
                },
                acc_descr_multiline: { rules: [12, 13], inclusive: !1 },
                acc_descr: { rules: [10], inclusive: !1 },
                acc_title: { rules: [8], inclusive: !1 },
                title: { rules: [], inclusive: !1 },
                md_string: { rules: [], inclusive: !1 },
                string: { rules: [28, 29], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 21, 22, 26, 27,
                    30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44,
                    45, 46,
                  ],
                  inclusive: !0,
                },
              },
            };
            return A;
          })();
        O.lexer = v;
        function _() {
          this.yy = {};
        }
        return (a(_, "Parser"), (_.prototype = O), (O.Parser = _), new _());
      })();
      rN.parser = rN;
      jrt = rN;
    });
  function nN(e) {
    return e.type === "bar";
  }
  function __(e) {
    return e.type === "band";
  }
  function km(e) {
    return e.type === "linear";
  }
  var C_ = x(() => {
    "use strict";
    a(nN, "isBarPlot");
    a(__, "isBandAxisData");
    a(km, "isLinearAxisData");
  });
  var Tm,
    iN = x(() => {
      "use strict";
      Ga();
      Tm = class {
        constructor(t) {
          this.parentGroup = t;
        }
        static {
          a(this, "TextDimensionCalculatorWithFont");
        }
        getMaxDimension(t, r) {
          if (!this.parentGroup)
            return {
              width: t.reduce((s, o) => Math.max(o.length, s), 0) * r,
              height: r,
            };
          let n = { width: 0, height: 0 },
            i = this.parentGroup
              .append("g")
              .attr("visibility", "hidden")
              .attr("font-size", r);
          for (let s of t) {
            let o = mV(i, 1, s),
              l = o ? o.width : s.length * r,
              u = o ? o.height : r;
            ((n.width = Math.max(n.width, l)),
              (n.height = Math.max(n.height, u)));
          }
          return (i.remove(), n);
        }
      };
    });
  var Sm,
    sN = x(() => {
      "use strict";
      Sm = class {
        constructor(t, r, n, i) {
          this.axisConfig = t;
          this.title = r;
          this.textDimensionCalculator = n;
          this.axisThemeConfig = i;
          this.boundingRect = { x: 0, y: 0, width: 0, height: 0 };
          this.axisPosition = "left";
          this.showTitle = !1;
          this.showLabel = !1;
          this.showTick = !1;
          this.showAxisLine = !1;
          this.outerPadding = 0;
          this.titleTextHeight = 0;
          this.labelTextHeight = 0;
          ((this.range = [0, 10]),
            (this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }),
            (this.axisPosition = "left"));
        }
        static {
          a(this, "BaseAxis");
        }
        setRange(t) {
          ((this.range = t),
            this.axisPosition === "left" || this.axisPosition === "right"
              ? (this.boundingRect.height = t[1] - t[0])
              : (this.boundingRect.width = t[1] - t[0]),
            this.recalculateScale());
        }
        getRange() {
          return [
            this.range[0] + this.outerPadding,
            this.range[1] - this.outerPadding,
          ];
        }
        setAxisPosition(t) {
          ((this.axisPosition = t), this.setRange(this.range));
        }
        getTickDistance() {
          let t = this.getRange();
          return Math.abs(t[0] - t[1]) / this.getTickValues().length;
        }
        getAxisOuterPadding() {
          return this.outerPadding;
        }
        getLabelDimension() {
          return this.textDimensionCalculator.getMaxDimension(
            this.getTickValues().map((t) => t.toString()),
            this.axisConfig.labelFontSize,
          );
        }
        recalculateOuterPaddingToDrawBar() {
          (0.7 * this.getTickDistance() > this.outerPadding * 2 &&
            (this.outerPadding = Math.floor(
              (0.7 * this.getTickDistance()) / 2,
            )),
            this.recalculateScale());
        }
        calculateSpaceIfDrawnHorizontally(t) {
          let r = t.height;
          if (
            (this.axisConfig.showAxisLine &&
              r > this.axisConfig.axisLineWidth &&
              ((r -= this.axisConfig.axisLineWidth), (this.showAxisLine = !0)),
            this.axisConfig.showLabel)
          ) {
            let n = this.getLabelDimension(),
              i = 0.2 * t.width;
            this.outerPadding = Math.min(n.width / 2, i);
            let s = n.height + this.axisConfig.labelPadding * 2;
            ((this.labelTextHeight = n.height),
              s <= r && ((r -= s), (this.showLabel = !0)));
          }
          if (
            (this.axisConfig.showTick &&
              r >= this.axisConfig.tickLength &&
              ((this.showTick = !0), (r -= this.axisConfig.tickLength)),
            this.axisConfig.showTitle && this.title)
          ) {
            let n = this.textDimensionCalculator.getMaxDimension(
                [this.title],
                this.axisConfig.titleFontSize,
              ),
              i = n.height + this.axisConfig.titlePadding * 2;
            ((this.titleTextHeight = n.height),
              i <= r && ((r -= i), (this.showTitle = !0)));
          }
          ((this.boundingRect.width = t.width),
            (this.boundingRect.height = t.height - r));
        }
        calculateSpaceIfDrawnVertical(t) {
          let r = t.width;
          if (
            (this.axisConfig.showAxisLine &&
              r > this.axisConfig.axisLineWidth &&
              ((r -= this.axisConfig.axisLineWidth), (this.showAxisLine = !0)),
            this.axisConfig.showLabel)
          ) {
            let n = this.getLabelDimension(),
              i = 0.2 * t.height;
            this.outerPadding = Math.min(n.height / 2, i);
            let s = n.width + this.axisConfig.labelPadding * 2;
            s <= r && ((r -= s), (this.showLabel = !0));
          }
          if (
            (this.axisConfig.showTick &&
              r >= this.axisConfig.tickLength &&
              ((this.showTick = !0), (r -= this.axisConfig.tickLength)),
            this.axisConfig.showTitle && this.title)
          ) {
            let n = this.textDimensionCalculator.getMaxDimension(
                [this.title],
                this.axisConfig.titleFontSize,
              ),
              i = n.height + this.axisConfig.titlePadding * 2;
            ((this.titleTextHeight = n.height),
              i <= r && ((r -= i), (this.showTitle = !0)));
          }
          ((this.boundingRect.width = t.width - r),
            (this.boundingRect.height = t.height));
        }
        calculateSpace(t) {
          return (
            this.axisPosition === "left" || this.axisPosition === "right"
              ? this.calculateSpaceIfDrawnVertical(t)
              : this.calculateSpaceIfDrawnHorizontally(t),
            this.recalculateScale(),
            { width: this.boundingRect.width, height: this.boundingRect.height }
          );
        }
        setBoundingBoxXY(t) {
          ((this.boundingRect.x = t.x), (this.boundingRect.y = t.y));
        }
        getDrawableElementsForLeftAxis() {
          let t = [];
          if (this.showAxisLine) {
            let r =
              this.boundingRect.x +
              this.boundingRect.width -
              this.axisConfig.axisLineWidth / 2;
            t.push({
              type: "path",
              groupTexts: ["left-axis", "axisl-line"],
              data: [
                {
                  path: `M ${r},${this.boundingRect.y} L ${r},${this.boundingRect.y + this.boundingRect.height} `,
                  strokeFill: this.axisThemeConfig.axisLineColor,
                  strokeWidth: this.axisConfig.axisLineWidth,
                },
              ],
            });
          }
          if (
            (this.showLabel &&
              t.push({
                type: "text",
                groupTexts: ["left-axis", "label"],
                data: this.getTickValues().map((r) => ({
                  text: r.toString(),
                  x:
                    this.boundingRect.x +
                    this.boundingRect.width -
                    (this.showLabel ? this.axisConfig.labelPadding : 0) -
                    (this.showTick ? this.axisConfig.tickLength : 0) -
                    (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
                  y: this.getScaleValue(r),
                  fill: this.axisThemeConfig.labelColor,
                  fontSize: this.axisConfig.labelFontSize,
                  rotation: 0,
                  verticalPos: "middle",
                  horizontalPos: "right",
                })),
              }),
            this.showTick)
          ) {
            let r =
              this.boundingRect.x +
              this.boundingRect.width -
              (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
            t.push({
              type: "path",
              groupTexts: ["left-axis", "ticks"],
              data: this.getTickValues().map((n) => ({
                path: `M ${r},${this.getScaleValue(n)} L ${r - this.axisConfig.tickLength},${this.getScaleValue(n)}`,
                strokeFill: this.axisThemeConfig.tickColor,
                strokeWidth: this.axisConfig.tickWidth,
              })),
            });
          }
          return (
            this.showTitle &&
              t.push({
                type: "text",
                groupTexts: ["left-axis", "title"],
                data: [
                  {
                    text: this.title,
                    x: this.boundingRect.x + this.axisConfig.titlePadding,
                    y: this.boundingRect.y + this.boundingRect.height / 2,
                    fill: this.axisThemeConfig.titleColor,
                    fontSize: this.axisConfig.titleFontSize,
                    rotation: 270,
                    verticalPos: "top",
                    horizontalPos: "center",
                  },
                ],
              }),
            t
          );
        }
        getDrawableElementsForBottomAxis() {
          let t = [];
          if (this.showAxisLine) {
            let r = this.boundingRect.y + this.axisConfig.axisLineWidth / 2;
            t.push({
              type: "path",
              groupTexts: ["bottom-axis", "axis-line"],
              data: [
                {
                  path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
                  strokeFill: this.axisThemeConfig.axisLineColor,
                  strokeWidth: this.axisConfig.axisLineWidth,
                },
              ],
            });
          }
          if (
            (this.showLabel &&
              t.push({
                type: "text",
                groupTexts: ["bottom-axis", "label"],
                data: this.getTickValues().map((r) => ({
                  text: r.toString(),
                  x: this.getScaleValue(r),
                  y:
                    this.boundingRect.y +
                    this.axisConfig.labelPadding +
                    (this.showTick ? this.axisConfig.tickLength : 0) +
                    (this.showAxisLine ? this.axisConfig.axisLineWidth : 0),
                  fill: this.axisThemeConfig.labelColor,
                  fontSize: this.axisConfig.labelFontSize,
                  rotation: 0,
                  verticalPos: "top",
                  horizontalPos: "center",
                })),
              }),
            this.showTick)
          ) {
            let r =
              this.boundingRect.y +
              (this.showAxisLine ? this.axisConfig.axisLineWidth : 0);
            t.push({
              type: "path",
              groupTexts: ["bottom-axis", "ticks"],
              data: this.getTickValues().map((n) => ({
                path: `M ${this.getScaleValue(n)},${r} L ${this.getScaleValue(n)},${r + this.axisConfig.tickLength}`,
                strokeFill: this.axisThemeConfig.tickColor,
                strokeWidth: this.axisConfig.tickWidth,
              })),
            });
          }
          return (
            this.showTitle &&
              t.push({
                type: "text",
                groupTexts: ["bottom-axis", "title"],
                data: [
                  {
                    text: this.title,
                    x: this.range[0] + (this.range[1] - this.range[0]) / 2,
                    y:
                      this.boundingRect.y +
                      this.boundingRect.height -
                      this.axisConfig.titlePadding -
                      this.titleTextHeight,
                    fill: this.axisThemeConfig.titleColor,
                    fontSize: this.axisConfig.titleFontSize,
                    rotation: 0,
                    verticalPos: "top",
                    horizontalPos: "center",
                  },
                ],
              }),
            t
          );
        }
        getDrawableElementsForTopAxis() {
          let t = [];
          if (this.showAxisLine) {
            let r =
              this.boundingRect.y +
              this.boundingRect.height -
              this.axisConfig.axisLineWidth / 2;
            t.push({
              type: "path",
              groupTexts: ["top-axis", "axis-line"],
              data: [
                {
                  path: `M ${this.boundingRect.x},${r} L ${this.boundingRect.x + this.boundingRect.width},${r}`,
                  strokeFill: this.axisThemeConfig.axisLineColor,
                  strokeWidth: this.axisConfig.axisLineWidth,
                },
              ],
            });
          }
          if (
            (this.showLabel &&
              t.push({
                type: "text",
                groupTexts: ["top-axis", "label"],
                data: this.getTickValues().map((r) => ({
                  text: r.toString(),
                  x: this.getScaleValue(r),
                  y:
                    this.boundingRect.y +
                    (this.showTitle
                      ? this.titleTextHeight + this.axisConfig.titlePadding * 2
                      : 0) +
                    this.axisConfig.labelPadding,
                  fill: this.axisThemeConfig.labelColor,
                  fontSize: this.axisConfig.labelFontSize,
                  rotation: 0,
                  verticalPos: "top",
                  horizontalPos: "center",
                })),
              }),
            this.showTick)
          ) {
            let r = this.boundingRect.y;
            t.push({
              type: "path",
              groupTexts: ["top-axis", "ticks"],
              data: this.getTickValues().map((n) => ({
                path: `M ${this.getScaleValue(n)},${r + this.boundingRect.height - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)} L ${this.getScaleValue(n)},${r + this.boundingRect.height - this.axisConfig.tickLength - (this.showAxisLine ? this.axisConfig.axisLineWidth : 0)}`,
                strokeFill: this.axisThemeConfig.tickColor,
                strokeWidth: this.axisConfig.tickWidth,
              })),
            });
          }
          return (
            this.showTitle &&
              t.push({
                type: "text",
                groupTexts: ["top-axis", "title"],
                data: [
                  {
                    text: this.title,
                    x: this.boundingRect.x + this.boundingRect.width / 2,
                    y: this.boundingRect.y + this.axisConfig.titlePadding,
                    fill: this.axisThemeConfig.titleColor,
                    fontSize: this.axisConfig.titleFontSize,
                    rotation: 0,
                    verticalPos: "top",
                    horizontalPos: "center",
                  },
                ],
              }),
            t
          );
        }
        getDrawableElements() {
          if (this.axisPosition === "left")
            return this.getDrawableElementsForLeftAxis();
          if (this.axisPosition === "right")
            throw Error("Drawing of right axis is not implemented");
          return this.axisPosition === "bottom"
            ? this.getDrawableElementsForBottomAxis()
            : this.axisPosition === "top"
              ? this.getDrawableElementsForTopAxis()
              : [];
        }
      };
    });
  var w_,
    Hrt = x(() => {
      "use strict";
      Ge();
      Vt();
      sN();
      w_ = class extends Sm {
        static {
          a(this, "BandAxis");
        }
        constructor(t, r, n, i, s) {
          (super(t, i, s, r),
            (this.categories = n),
            (this.scale = Df().domain(this.categories).range(this.getRange())));
        }
        setRange(t) {
          super.setRange(t);
        }
        recalculateScale() {
          ((this.scale = Df()
            .domain(this.categories)
            .range(this.getRange())
            .paddingInner(1)
            .paddingOuter(0)
            .align(0.5)),
            P.trace(
              "BandAxis axis final categories, range: ",
              this.categories,
              this.getRange(),
            ));
        }
        getTickValues() {
          return this.categories;
        }
        getScaleValue(t) {
          return this.scale(t) ?? this.getRange()[0];
        }
      };
    });
  var v_,
    Yrt = x(() => {
      "use strict";
      Ge();
      sN();
      v_ = class extends Sm {
        static {
          a(this, "LinearAxis");
        }
        constructor(t, r, n, i, s) {
          (super(t, i, s, r),
            (this.domain = n),
            (this.scale = Ra().domain(this.domain).range(this.getRange())));
        }
        getTickValues() {
          return this.scale.ticks();
        }
        recalculateScale() {
          let t = [...this.domain];
          (this.axisPosition === "left" && t.reverse(),
            (this.scale = Ra().domain(t).range(this.getRange())));
        }
        getScaleValue(t) {
          return this.scale(t);
        }
      };
    });
  function aN(e, t, r, n) {
    let i = new Tm(n);
    return __(e)
      ? new w_(t, r, e.categories, e.title, i)
      : new v_(t, r, [e.min, e.max], e.title, i);
  }
  var Xrt = x(() => {
    "use strict";
    C_();
    iN();
    Hrt();
    Yrt();
    a(aN, "getAxis");
  });
  function Krt(e, t, r, n) {
    let i = new Tm(n);
    return new oN(i, e, t, r);
  }
  var oN,
    Qrt = x(() => {
      "use strict";
      iN();
      oN = class {
        constructor(t, r, n, i) {
          this.textDimensionCalculator = t;
          this.chartConfig = r;
          this.chartData = n;
          this.chartThemeConfig = i;
          ((this.boundingRect = { x: 0, y: 0, width: 0, height: 0 }),
            (this.showChartTitle = !1));
        }
        static {
          a(this, "ChartTitle");
        }
        setBoundingBoxXY(t) {
          ((this.boundingRect.x = t.x), (this.boundingRect.y = t.y));
        }
        calculateSpace(t) {
          let r = this.textDimensionCalculator.getMaxDimension(
              [this.chartData.title],
              this.chartConfig.titleFontSize,
            ),
            n = Math.max(r.width, t.width),
            i = r.height + 2 * this.chartConfig.titlePadding;
          return (
            r.width <= n &&
              r.height <= i &&
              this.chartConfig.showTitle &&
              this.chartData.title &&
              ((this.boundingRect.width = n),
              (this.boundingRect.height = i),
              (this.showChartTitle = !0)),
            { width: this.boundingRect.width, height: this.boundingRect.height }
          );
        }
        getDrawableElements() {
          let t = [];
          return (
            this.showChartTitle &&
              t.push({
                groupTexts: ["chart-title"],
                type: "text",
                data: [
                  {
                    fontSize: this.chartConfig.titleFontSize,
                    text: this.chartData.title,
                    verticalPos: "middle",
                    horizontalPos: "center",
                    x: this.boundingRect.x + this.boundingRect.width / 2,
                    y: this.boundingRect.y + this.boundingRect.height / 2,
                    fill: this.chartThemeConfig.titleColor,
                    rotation: 0,
                  },
                ],
              }),
            t
          );
        }
      };
      a(Krt, "getChartTitleComponent");
    });
  var E_,
    Zrt = x(() => {
      "use strict";
      Ge();
      E_ = class {
        constructor(t, r, n, i, s) {
          this.plotData = t;
          this.xAxis = r;
          this.yAxis = n;
          this.orientation = i;
          this.plotIndex = s;
        }
        static {
          a(this, "LinePlot");
        }
        getDrawableElement() {
          let t = this.plotData.data.map((n) => [
              this.xAxis.getScaleValue(n[0]),
              this.yAxis.getScaleValue(n[1]),
            ]),
            r;
          return (
            this.orientation === "horizontal"
              ? (r = Oa()
                  .y((n) => n[0])
                  .x((n) => n[1])(t))
              : (r = Oa()
                  .x((n) => n[0])
                  .y((n) => n[1])(t)),
            r
              ? [
                  {
                    groupTexts: ["plot", `line-plot-${this.plotIndex}`],
                    type: "path",
                    data: [
                      {
                        path: r,
                        strokeFill: this.plotData.strokeFill,
                        strokeWidth: this.plotData.strokeWidth,
                      },
                    ],
                  },
                ]
              : []
          );
        }
      };
    });
  var A_,
    Jrt = x(() => {
      "use strict";
      A_ = class {
        constructor(t, r, n, i, s, o) {
          this.barData = t;
          this.boundingRect = r;
          this.xAxis = n;
          this.yAxis = i;
          this.orientation = s;
          this.plotIndex = o;
        }
        static {
          a(this, "BarPlot");
        }
        getDrawableElement() {
          let t = this.barData.data.map((s) => [
              this.xAxis.getScaleValue(s[0]),
              this.yAxis.getScaleValue(s[1]),
            ]),
            n =
              Math.min(
                this.xAxis.getAxisOuterPadding() * 2,
                this.xAxis.getTickDistance(),
              ) *
              (1 - 0.05),
            i = n / 2;
          return this.orientation === "horizontal"
            ? [
                {
                  groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
                  type: "rect",
                  data: t.map((s) => ({
                    x: this.boundingRect.x,
                    y: s[0] - i,
                    height: n,
                    width: s[1] - this.boundingRect.x,
                    fill: this.barData.fill,
                    strokeWidth: 0,
                    strokeFill: this.barData.fill,
                  })),
                },
              ]
            : [
                {
                  groupTexts: ["plot", `bar-plot-${this.plotIndex}`],
                  type: "rect",
                  data: t.map((s) => ({
                    x: s[0] - i,
                    y: s[1],
                    width: n,
                    height:
                      this.boundingRect.y + this.boundingRect.height - s[1],
                    fill: this.barData.fill,
                    strokeWidth: 0,
                    strokeFill: this.barData.fill,
                  })),
                },
              ];
        }
      };
    });
  function tnt(e, t, r) {
    return new lN(e, t, r);
  }
  var lN,
    ent = x(() => {
      "use strict";
      Zrt();
      Jrt();
      lN = class {
        constructor(t, r, n) {
          this.chartConfig = t;
          this.chartData = r;
          this.chartThemeConfig = n;
          this.boundingRect = { x: 0, y: 0, width: 0, height: 0 };
        }
        static {
          a(this, "BasePlot");
        }
        setAxes(t, r) {
          ((this.xAxis = t), (this.yAxis = r));
        }
        setBoundingBoxXY(t) {
          ((this.boundingRect.x = t.x), (this.boundingRect.y = t.y));
        }
        calculateSpace(t) {
          return (
            (this.boundingRect.width = t.width),
            (this.boundingRect.height = t.height),
            { width: this.boundingRect.width, height: this.boundingRect.height }
          );
        }
        getDrawableElements() {
          if (!(this.xAxis && this.yAxis))
            throw Error("Axes must be passed to render Plots");
          let t = [];
          for (let [r, n] of this.chartData.plots.entries())
            switch (n.type) {
              case "line":
                {
                  let i = new E_(
                    n,
                    this.xAxis,
                    this.yAxis,
                    this.chartConfig.chartOrientation,
                    r,
                  );
                  t.push(...i.getDrawableElement());
                }
                break;
              case "bar":
                {
                  let i = new A_(
                    n,
                    this.boundingRect,
                    this.xAxis,
                    this.yAxis,
                    this.chartConfig.chartOrientation,
                    r,
                  );
                  t.push(...i.getDrawableElement());
                }
                break;
            }
          return t;
        }
      };
      a(tnt, "getPlotComponent");
    });
  var L_,
    rnt = x(() => {
      "use strict";
      Xrt();
      Qrt();
      ent();
      C_();
      L_ = class {
        constructor(t, r, n, i) {
          this.chartConfig = t;
          this.chartData = r;
          this.componentStore = {
            title: Krt(t, r, n, i),
            plot: tnt(t, r, n),
            xAxis: aN(
              r.xAxis,
              t.xAxis,
              {
                titleColor: n.xAxisTitleColor,
                labelColor: n.xAxisLabelColor,
                tickColor: n.xAxisTickColor,
                axisLineColor: n.xAxisLineColor,
              },
              i,
            ),
            yAxis: aN(
              r.yAxis,
              t.yAxis,
              {
                titleColor: n.yAxisTitleColor,
                labelColor: n.yAxisLabelColor,
                tickColor: n.yAxisTickColor,
                axisLineColor: n.yAxisLineColor,
              },
              i,
            ),
          };
        }
        static {
          a(this, "Orchestrator");
        }
        calculateVerticalSpace() {
          let t = this.chartConfig.width,
            r = this.chartConfig.height,
            n = 0,
            i = 0,
            s = Math.floor(
              (t * this.chartConfig.plotReservedSpacePercent) / 100,
            ),
            o = Math.floor(
              (r * this.chartConfig.plotReservedSpacePercent) / 100,
            ),
            l = this.componentStore.plot.calculateSpace({
              width: s,
              height: o,
            });
          ((t -= l.width),
            (r -= l.height),
            (l = this.componentStore.title.calculateSpace({
              width: this.chartConfig.width,
              height: r,
            })),
            (i = l.height),
            (r -= l.height),
            this.componentStore.xAxis.setAxisPosition("bottom"),
            (l = this.componentStore.xAxis.calculateSpace({
              width: t,
              height: r,
            })),
            (r -= l.height),
            this.componentStore.yAxis.setAxisPosition("left"),
            (l = this.componentStore.yAxis.calculateSpace({
              width: t,
              height: r,
            })),
            (n = l.width),
            (t -= l.width),
            t > 0 && ((s += t), (t = 0)),
            r > 0 && ((o += r), (r = 0)),
            this.componentStore.plot.calculateSpace({ width: s, height: o }),
            this.componentStore.plot.setBoundingBoxXY({ x: n, y: i }),
            this.componentStore.xAxis.setRange([n, n + s]),
            this.componentStore.xAxis.setBoundingBoxXY({ x: n, y: i + o }),
            this.componentStore.yAxis.setRange([i, i + o]),
            this.componentStore.yAxis.setBoundingBoxXY({ x: 0, y: i }),
            this.chartData.plots.some((u) => nN(u)) &&
              this.componentStore.xAxis.recalculateOuterPaddingToDrawBar());
        }
        calculateHorizontalSpace() {
          let t = this.chartConfig.width,
            r = this.chartConfig.height,
            n = 0,
            i = 0,
            s = 0,
            o = Math.floor(
              (t * this.chartConfig.plotReservedSpacePercent) / 100,
            ),
            l = Math.floor(
              (r * this.chartConfig.plotReservedSpacePercent) / 100,
            ),
            u = this.componentStore.plot.calculateSpace({
              width: o,
              height: l,
            });
          ((t -= u.width),
            (r -= u.height),
            (u = this.componentStore.title.calculateSpace({
              width: this.chartConfig.width,
              height: r,
            })),
            (n = u.height),
            (r -= u.height),
            this.componentStore.xAxis.setAxisPosition("left"),
            (u = this.componentStore.xAxis.calculateSpace({
              width: t,
              height: r,
            })),
            (t -= u.width),
            (i = u.width),
            this.componentStore.yAxis.setAxisPosition("top"),
            (u = this.componentStore.yAxis.calculateSpace({
              width: t,
              height: r,
            })),
            (r -= u.height),
            (s = n + u.height),
            t > 0 && ((o += t), (t = 0)),
            r > 0 && ((l += r), (r = 0)),
            this.componentStore.plot.calculateSpace({ width: o, height: l }),
            this.componentStore.plot.setBoundingBoxXY({ x: i, y: s }),
            this.componentStore.yAxis.setRange([i, i + o]),
            this.componentStore.yAxis.setBoundingBoxXY({ x: i, y: n }),
            this.componentStore.xAxis.setRange([s, s + l]),
            this.componentStore.xAxis.setBoundingBoxXY({ x: 0, y: s }),
            this.chartData.plots.some((h) => nN(h)) &&
              this.componentStore.xAxis.recalculateOuterPaddingToDrawBar());
        }
        calculateSpace() {
          this.chartConfig.chartOrientation === "horizontal"
            ? this.calculateHorizontalSpace()
            : this.calculateVerticalSpace();
        }
        getDrawableElement() {
          this.calculateSpace();
          let t = [];
          this.componentStore.plot.setAxes(
            this.componentStore.xAxis,
            this.componentStore.yAxis,
          );
          for (let r of Object.values(this.componentStore))
            t.push(...r.getDrawableElements());
          return t;
        }
      };
    });
  var R_,
    nnt = x(() => {
      "use strict";
      rnt();
      R_ = class {
        static {
          a(this, "XYChartBuilder");
        }
        static build(t, r, n, i) {
          return new L_(t, r, n, i).getDrawableElement();
        }
      };
    });
  function snt() {
    let e = Hl(),
      t = ke();
    return on(e.xyChart, t.themeVariables.xyChart);
  }
  function ant() {
    let e = ke();
    return on(ze.xyChart, e.xyChart);
  }
  function ont() {
    return {
      yAxis: { type: "linear", title: "", min: 1 / 0, max: -1 / 0 },
      xAxis: { type: "band", title: "", categories: [] },
      title: "",
      plots: [],
    };
  }
  function hN(e) {
    let t = ke();
    return Ie(e.trim(), t);
  }
  function sRt(e) {
    int = e;
  }
  function aRt(e) {
    e === "horizontal"
      ? (Fy.chartOrientation = "horizontal")
      : (Fy.chartOrientation = "vertical");
  }
  function oRt(e) {
    vr.xAxis.title = hN(e.text);
  }
  function lnt(e, t) {
    ((vr.xAxis = { type: "linear", title: vr.xAxis.title, min: e, max: t }),
      (D_ = !0));
  }
  function lRt(e) {
    ((vr.xAxis = {
      type: "band",
      title: vr.xAxis.title,
      categories: e.map((t) => hN(t.text)),
    }),
      (D_ = !0));
  }
  function cRt(e) {
    vr.yAxis.title = hN(e.text);
  }
  function uRt(e, t) {
    ((vr.yAxis = { type: "linear", title: vr.yAxis.title, min: e, max: t }),
      (uN = !0));
  }
  function hRt(e) {
    let t = Math.min(...e),
      r = Math.max(...e),
      n = km(vr.yAxis) ? vr.yAxis.min : 1 / 0,
      i = km(vr.yAxis) ? vr.yAxis.max : -1 / 0;
    vr.yAxis = {
      type: "linear",
      title: vr.yAxis.title,
      min: Math.min(n, t),
      max: Math.max(i, r),
    };
  }
  function cnt(e) {
    let t = [];
    if (e.length === 0) return t;
    if (!D_) {
      let r = km(vr.xAxis) ? vr.xAxis.min : 1 / 0,
        n = km(vr.xAxis) ? vr.xAxis.max : -1 / 0;
      lnt(Math.min(r, 1), Math.max(n, e.length));
    }
    if (
      (uN || hRt(e),
      __(vr.xAxis) && (t = vr.xAxis.categories.map((r, n) => [r, e[n]])),
      km(vr.xAxis))
    ) {
      let r = vr.xAxis.min,
        n = vr.xAxis.max,
        i = (n - r) / (e.length - 1),
        s = [];
      for (let o = r; o <= n; o += i) s.push(`${o}`);
      t = s.map((o, l) => [o, e[l]]);
    }
    return t;
  }
  function unt(e) {
    return cN[e === 0 ? 0 : e % cN.length];
  }
  function fRt(e, t) {
    let r = cnt(t);
    (vr.plots.push({
      type: "line",
      strokeFill: unt(By),
      strokeWidth: 2,
      data: r,
    }),
      By++);
  }
  function dRt(e, t) {
    let r = cnt(t);
    (vr.plots.push({ type: "bar", fill: unt(By), data: r }), By++);
  }
  function pRt() {
    if (vr.plots.length === 0)
      throw Error("No Plot to render, please provide a plot with some data");
    return ((vr.title = nr()), R_.build(Fy, vr, $y, int));
  }
  function mRt() {
    return $y;
  }
  function gRt() {
    return Fy;
  }
  function yRt() {
    return vr;
  }
  var By,
    int,
    Fy,
    $y,
    vr,
    cN,
    D_,
    uN,
    xRt,
    hnt,
    fnt = x(() => {
      "use strict";
      un();
      Ss();
      Qm();
      _e();
      Be();
      yn();
      nnt();
      C_();
      ((By = 0),
        (Fy = ant()),
        ($y = snt()),
        (vr = ont()),
        (cN = $y.plotColorPalette.split(",").map((e) => e.trim())),
        (D_ = !1),
        (uN = !1));
      a(snt, "getChartDefaultThemeConfig");
      a(ant, "getChartDefaultConfig");
      a(ont, "getChartDefaultData");
      a(hN, "textSanitizer");
      a(sRt, "setTmpSVGG");
      a(aRt, "setOrientation");
      a(oRt, "setXAxisTitle");
      a(lnt, "setXAxisRangeData");
      a(lRt, "setXAxisBand");
      a(cRt, "setYAxisTitle");
      a(uRt, "setYAxisRangeData");
      a(hRt, "setYAxisRangeFromPlotData");
      a(cnt, "transformDataWithoutCategory");
      a(unt, "getPlotColorFromPalette");
      a(fRt, "setLineData");
      a(dRt, "setBarData");
      a(pRt, "getDrawableElem");
      a(mRt, "getChartThemeConfig");
      a(gRt, "getChartConfig");
      a(yRt, "getXYChartData");
      ((xRt = a(function () {
        (Ye(),
          (By = 0),
          (Fy = ant()),
          (vr = ont()),
          ($y = snt()),
          (cN = $y.plotColorPalette.split(",").map((e) => e.trim())),
          (D_ = !1),
          (uN = !1));
      }, "clear")),
        (hnt = {
          getDrawableElem: pRt,
          clear: xRt,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          getAccDescription: rr,
          setAccDescription: er,
          setOrientation: aRt,
          setXAxisTitle: oRt,
          setXAxisRangeData: lnt,
          setXAxisBand: lRt,
          setYAxisTitle: cRt,
          setYAxisRangeData: uRt,
          setLineData: fRt,
          setBarData: dRt,
          setTmpSVGG: sRt,
          getChartThemeConfig: mRt,
          getChartConfig: gRt,
          getXYChartData: yRt,
        }));
    });
  var bRt,
    dnt,
    pnt = x(() => {
      "use strict";
      Vt();
      Fl();
      On();
      ((bRt = a((e, t, r, n) => {
        let i = n.db,
          s = i.getChartThemeConfig(),
          o = i.getChartConfig(),
          l = i.getXYChartData().plots[0].data.map((C) => C[1]);
        function u(C) {
          return C === "top" ? "text-before-edge" : "middle";
        }
        a(u, "getDominantBaseLine");
        function h(C) {
          return C === "left" ? "start" : C === "right" ? "end" : "middle";
        }
        a(h, "getTextAnchor");
        function f(C) {
          return `translate(${C.x}, ${C.y}) rotate(${C.rotation || 0})`;
        }
        (a(f, "getTextTransformation"),
          P.debug(
            `Rendering xychart chart
` + e,
          ));
        let d = Ei(t),
          p = d.append("g").attr("class", "main"),
          m = p
            .append("rect")
            .attr("width", o.width)
            .attr("height", o.height)
            .attr("class", "background");
        (Ar(d, o.height, o.width, !0),
          d.attr("viewBox", `0 0 ${o.width} ${o.height}`),
          m.attr("fill", s.backgroundColor),
          i.setTmpSVGG(d.append("g").attr("class", "mermaid-tmp-group")));
        let g = i.getDrawableElem(),
          y = {};
        function b(C) {
          let L = p,
            w = "";
          for (let [D] of C.entries()) {
            let G = p;
            (D > 0 && y[w] && (G = y[w]),
              (w += C[D]),
              (L = y[w]),
              L || (L = y[w] = G.append("g").attr("class", C[D])));
          }
          return L;
        }
        a(b, "getGroup");
        for (let C of g) {
          if (C.data.length === 0) continue;
          let L = b(C.groupTexts);
          switch (C.type) {
            case "rect":
              if (
                (L.selectAll("rect")
                  .data(C.data)
                  .enter()
                  .append("rect")
                  .attr("x", (w) => w.x)
                  .attr("y", (w) => w.y)
                  .attr("width", (w) => w.width)
                  .attr("height", (w) => w.height)
                  .attr("fill", (w) => w.fill)
                  .attr("stroke", (w) => w.strokeFill)
                  .attr("stroke-width", (w) => w.strokeWidth),
                o.showDataLabel)
              )
                if (o.chartOrientation === "horizontal") {
                  let G = function (F, S) {
                    let { data: O, label: v } = F;
                    return S * v.length * 0.7 <= O.width - 10;
                  };
                  var k = G;
                  a(G, "fitsHorizontally");
                  let w = 0.7,
                    D = C.data
                      .map((F, S) => ({ data: F, label: l[S].toString() }))
                      .filter((F) => F.data.width > 0 && F.data.height > 0),
                    E = D.map((F) => {
                      let { data: S } = F,
                        O = S.height * 0.7;
                      for (; !G(F, O) && O > 0; ) O -= 1;
                      return O;
                    }),
                    R = Math.floor(Math.min(...E));
                  L.selectAll("text")
                    .data(D)
                    .enter()
                    .append("text")
                    .attr("x", (F) => F.data.x + F.data.width - 10)
                    .attr("y", (F) => F.data.y + F.data.height / 2)
                    .attr("text-anchor", "end")
                    .attr("dominant-baseline", "middle")
                    .attr("fill", "black")
                    .attr("font-size", `${R}px`)
                    .text((F) => F.label);
                } else {
                  let G = function (F, S, O) {
                    let { data: v, label: _ } = F,
                      N = S * _.length * 0.7,
                      B = v.x + v.width / 2,
                      M = B - N / 2,
                      I = B + N / 2,
                      V = M >= v.x && I <= v.x + v.width,
                      $ = v.y + O + S <= v.y + v.height;
                    return V && $;
                  };
                  var T = G;
                  a(G, "fitsInBar");
                  let w = 10,
                    D = C.data
                      .map((F, S) => ({ data: F, label: l[S].toString() }))
                      .filter((F) => F.data.width > 0 && F.data.height > 0),
                    E = D.map((F) => {
                      let { data: S, label: O } = F,
                        v = S.width / (O.length * 0.7);
                      for (; !G(F, v, 10) && v > 0; ) v -= 1;
                      return v;
                    }),
                    R = Math.floor(Math.min(...E));
                  L.selectAll("text")
                    .data(D)
                    .enter()
                    .append("text")
                    .attr("x", (F) => F.data.x + F.data.width / 2)
                    .attr("y", (F) => F.data.y + 10)
                    .attr("text-anchor", "middle")
                    .attr("dominant-baseline", "hanging")
                    .attr("fill", "black")
                    .attr("font-size", `${R}px`)
                    .text((F) => F.label);
                }
              break;
            case "text":
              L.selectAll("text")
                .data(C.data)
                .enter()
                .append("text")
                .attr("x", 0)
                .attr("y", 0)
                .attr("fill", (w) => w.fill)
                .attr("font-size", (w) => w.fontSize)
                .attr("dominant-baseline", (w) => u(w.verticalPos))
                .attr("text-anchor", (w) => h(w.horizontalPos))
                .attr("transform", (w) => f(w))
                .text((w) => w.text);
              break;
            case "path":
              L.selectAll("path")
                .data(C.data)
                .enter()
                .append("path")
                .attr("d", (w) => w.path)
                .attr("fill", (w) => (w.fill ? w.fill : "none"))
                .attr("stroke", (w) => w.strokeFill)
                .attr("stroke-width", (w) => w.strokeWidth);
              break;
          }
        }
      }, "draw")),
        (dnt = { draw: bRt }));
    });
  var mnt = {};
  Oe(mnt, { diagram: () => kRt });
  var kRt,
    gnt = x(() => {
      "use strict";
      qrt();
      fnt();
      pnt();
      kRt = { parser: jrt, db: hnt, renderer: dnt };
    });
  var fN,
    bnt,
    knt = x(() => {
      "use strict";
      fN = (function () {
        var e = a(function (Z, Mt, W, Gt) {
            for (W = W || {}, Gt = Z.length; Gt--; W[Z[Gt]] = Mt);
            return W;
          }, "o"),
          t = [1, 3],
          r = [1, 4],
          n = [1, 5],
          i = [1, 6],
          s = [
            5, 6, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72,
            74, 77, 89, 90,
          ],
          o = [1, 22],
          l = [2, 7],
          u = [1, 26],
          h = [1, 27],
          f = [1, 28],
          d = [1, 29],
          p = [1, 33],
          m = [1, 34],
          g = [1, 35],
          y = [1, 36],
          b = [1, 37],
          k = [1, 38],
          T = [1, 24],
          C = [1, 31],
          L = [1, 32],
          w = [1, 30],
          D = [1, 39],
          G = [1, 40],
          E = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74,
            77, 89, 90,
          ],
          R = [1, 61],
          F = [89, 90],
          S = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 29, 41, 42, 43, 44, 45, 46, 54,
            61, 63, 72, 74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89,
            90,
          ],
          O = [27, 29],
          v = [1, 70],
          _ = [1, 71],
          A = [1, 72],
          N = [1, 73],
          B = [1, 74],
          M = [1, 75],
          I = [1, 76],
          V = [1, 83],
          $ = [1, 80],
          q = [1, 84],
          tt = [1, 85],
          ht = [1, 86],
          H = [1, 87],
          kt = [1, 88],
          ft = [1, 89],
          yt = [1, 90],
          ot = [1, 91],
          dt = [1, 92],
          nt = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 27, 41, 42, 43, 44, 45, 46, 54, 72,
            74, 75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
          ],
          Q = [63, 64],
          et = [1, 101],
          X = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74,
            76, 77, 89, 90,
          ],
          st = [
            5, 8, 9, 11, 13, 21, 22, 23, 24, 41, 42, 43, 44, 45, 46, 54, 72, 74,
            75, 76, 77, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
          ],
          U = [1, 110],
          gt = [1, 106],
          z = [1, 107],
          ge = [1, 108],
          lt = [1, 109],
          jt = [1, 111],
          Me = [1, 116],
          se = [1, 117],
          Nt = [1, 114],
          At = [1, 115],
          bt = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              directive: 4,
              NEWLINE: 5,
              RD: 6,
              diagram: 7,
              EOF: 8,
              acc_title: 9,
              acc_title_value: 10,
              acc_descr: 11,
              acc_descr_value: 12,
              acc_descr_multiline_value: 13,
              requirementDef: 14,
              elementDef: 15,
              relationshipDef: 16,
              direction: 17,
              styleStatement: 18,
              classDefStatement: 19,
              classStatement: 20,
              direction_tb: 21,
              direction_bt: 22,
              direction_rl: 23,
              direction_lr: 24,
              requirementType: 25,
              requirementName: 26,
              STRUCT_START: 27,
              requirementBody: 28,
              STYLE_SEPARATOR: 29,
              idList: 30,
              ID: 31,
              COLONSEP: 32,
              id: 33,
              TEXT: 34,
              text: 35,
              RISK: 36,
              riskLevel: 37,
              VERIFYMTHD: 38,
              verifyType: 39,
              STRUCT_STOP: 40,
              REQUIREMENT: 41,
              FUNCTIONAL_REQUIREMENT: 42,
              INTERFACE_REQUIREMENT: 43,
              PERFORMANCE_REQUIREMENT: 44,
              PHYSICAL_REQUIREMENT: 45,
              DESIGN_CONSTRAINT: 46,
              LOW_RISK: 47,
              MED_RISK: 48,
              HIGH_RISK: 49,
              VERIFY_ANALYSIS: 50,
              VERIFY_DEMONSTRATION: 51,
              VERIFY_INSPECTION: 52,
              VERIFY_TEST: 53,
              ELEMENT: 54,
              elementName: 55,
              elementBody: 56,
              TYPE: 57,
              type: 58,
              DOCREF: 59,
              ref: 60,
              END_ARROW_L: 61,
              relationship: 62,
              LINE: 63,
              END_ARROW_R: 64,
              CONTAINS: 65,
              COPIES: 66,
              DERIVES: 67,
              SATISFIES: 68,
              VERIFIES: 69,
              REFINES: 70,
              TRACES: 71,
              CLASSDEF: 72,
              stylesOpt: 73,
              CLASS: 74,
              ALPHA: 75,
              COMMA: 76,
              STYLE: 77,
              style: 78,
              styleComponent: 79,
              NUM: 80,
              COLON: 81,
              UNIT: 82,
              SPACE: 83,
              BRKT: 84,
              PCT: 85,
              MINUS: 86,
              LABEL: 87,
              SEMICOLON: 88,
              unqString: 89,
              qString: 90,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              5: "NEWLINE",
              6: "RD",
              8: "EOF",
              9: "acc_title",
              10: "acc_title_value",
              11: "acc_descr",
              12: "acc_descr_value",
              13: "acc_descr_multiline_value",
              21: "direction_tb",
              22: "direction_bt",
              23: "direction_rl",
              24: "direction_lr",
              27: "STRUCT_START",
              29: "STYLE_SEPARATOR",
              31: "ID",
              32: "COLONSEP",
              34: "TEXT",
              36: "RISK",
              38: "VERIFYMTHD",
              40: "STRUCT_STOP",
              41: "REQUIREMENT",
              42: "FUNCTIONAL_REQUIREMENT",
              43: "INTERFACE_REQUIREMENT",
              44: "PERFORMANCE_REQUIREMENT",
              45: "PHYSICAL_REQUIREMENT",
              46: "DESIGN_CONSTRAINT",
              47: "LOW_RISK",
              48: "MED_RISK",
              49: "HIGH_RISK",
              50: "VERIFY_ANALYSIS",
              51: "VERIFY_DEMONSTRATION",
              52: "VERIFY_INSPECTION",
              53: "VERIFY_TEST",
              54: "ELEMENT",
              57: "TYPE",
              59: "DOCREF",
              61: "END_ARROW_L",
              63: "LINE",
              64: "END_ARROW_R",
              65: "CONTAINS",
              66: "COPIES",
              67: "DERIVES",
              68: "SATISFIES",
              69: "VERIFIES",
              70: "REFINES",
              71: "TRACES",
              72: "CLASSDEF",
              74: "CLASS",
              75: "ALPHA",
              76: "COMMA",
              77: "STYLE",
              80: "NUM",
              81: "COLON",
              82: "UNIT",
              83: "SPACE",
              84: "BRKT",
              85: "PCT",
              86: "MINUS",
              87: "LABEL",
              88: "SEMICOLON",
              89: "unqString",
              90: "qString",
            },
            productions_: [
              0,
              [3, 3],
              [3, 2],
              [3, 4],
              [4, 2],
              [4, 2],
              [4, 1],
              [7, 0],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [7, 2],
              [17, 1],
              [17, 1],
              [17, 1],
              [17, 1],
              [14, 5],
              [14, 7],
              [28, 5],
              [28, 5],
              [28, 5],
              [28, 5],
              [28, 2],
              [28, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [25, 1],
              [37, 1],
              [37, 1],
              [37, 1],
              [39, 1],
              [39, 1],
              [39, 1],
              [39, 1],
              [15, 5],
              [15, 7],
              [56, 5],
              [56, 5],
              [56, 2],
              [56, 1],
              [16, 5],
              [16, 5],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [62, 1],
              [19, 3],
              [20, 3],
              [20, 3],
              [30, 1],
              [30, 3],
              [30, 1],
              [30, 3],
              [18, 3],
              [73, 1],
              [73, 3],
              [78, 1],
              [78, 2],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [79, 1],
              [26, 1],
              [26, 1],
              [33, 1],
              [33, 1],
              [35, 1],
              [35, 1],
              [55, 1],
              [55, 1],
              [58, 1],
              [58, 1],
              [60, 1],
              [60, 1],
            ],
            performAction: a(function (Mt, W, Gt, j, Et, mt, Xt) {
              var Ft = mt.length - 1;
              switch (Et) {
                case 4:
                  ((this.$ = mt[Ft].trim()), j.setAccTitle(this.$));
                  break;
                case 5:
                case 6:
                  ((this.$ = mt[Ft].trim()), j.setAccDescription(this.$));
                  break;
                case 7:
                  this.$ = [];
                  break;
                case 17:
                  j.setDirection("TB");
                  break;
                case 18:
                  j.setDirection("BT");
                  break;
                case 19:
                  j.setDirection("RL");
                  break;
                case 20:
                  j.setDirection("LR");
                  break;
                case 21:
                  j.addRequirement(mt[Ft - 3], mt[Ft - 4]);
                  break;
                case 22:
                  (j.addRequirement(mt[Ft - 5], mt[Ft - 6]),
                    j.setClass([mt[Ft - 5]], mt[Ft - 3]));
                  break;
                case 23:
                  j.setNewReqId(mt[Ft - 2]);
                  break;
                case 24:
                  j.setNewReqText(mt[Ft - 2]);
                  break;
                case 25:
                  j.setNewReqRisk(mt[Ft - 2]);
                  break;
                case 26:
                  j.setNewReqVerifyMethod(mt[Ft - 2]);
                  break;
                case 29:
                  this.$ = j.RequirementType.REQUIREMENT;
                  break;
                case 30:
                  this.$ = j.RequirementType.FUNCTIONAL_REQUIREMENT;
                  break;
                case 31:
                  this.$ = j.RequirementType.INTERFACE_REQUIREMENT;
                  break;
                case 32:
                  this.$ = j.RequirementType.PERFORMANCE_REQUIREMENT;
                  break;
                case 33:
                  this.$ = j.RequirementType.PHYSICAL_REQUIREMENT;
                  break;
                case 34:
                  this.$ = j.RequirementType.DESIGN_CONSTRAINT;
                  break;
                case 35:
                  this.$ = j.RiskLevel.LOW_RISK;
                  break;
                case 36:
                  this.$ = j.RiskLevel.MED_RISK;
                  break;
                case 37:
                  this.$ = j.RiskLevel.HIGH_RISK;
                  break;
                case 38:
                  this.$ = j.VerifyType.VERIFY_ANALYSIS;
                  break;
                case 39:
                  this.$ = j.VerifyType.VERIFY_DEMONSTRATION;
                  break;
                case 40:
                  this.$ = j.VerifyType.VERIFY_INSPECTION;
                  break;
                case 41:
                  this.$ = j.VerifyType.VERIFY_TEST;
                  break;
                case 42:
                  j.addElement(mt[Ft - 3]);
                  break;
                case 43:
                  (j.addElement(mt[Ft - 5]),
                    j.setClass([mt[Ft - 5]], mt[Ft - 3]));
                  break;
                case 44:
                  j.setNewElementType(mt[Ft - 2]);
                  break;
                case 45:
                  j.setNewElementDocRef(mt[Ft - 2]);
                  break;
                case 48:
                  j.addRelationship(mt[Ft - 2], mt[Ft], mt[Ft - 4]);
                  break;
                case 49:
                  j.addRelationship(mt[Ft - 2], mt[Ft - 4], mt[Ft]);
                  break;
                case 50:
                  this.$ = j.Relationships.CONTAINS;
                  break;
                case 51:
                  this.$ = j.Relationships.COPIES;
                  break;
                case 52:
                  this.$ = j.Relationships.DERIVES;
                  break;
                case 53:
                  this.$ = j.Relationships.SATISFIES;
                  break;
                case 54:
                  this.$ = j.Relationships.VERIFIES;
                  break;
                case 55:
                  this.$ = j.Relationships.REFINES;
                  break;
                case 56:
                  this.$ = j.Relationships.TRACES;
                  break;
                case 57:
                  ((this.$ = mt[Ft - 2]), j.defineClass(mt[Ft - 1], mt[Ft]));
                  break;
                case 58:
                  j.setClass(mt[Ft - 1], mt[Ft]);
                  break;
                case 59:
                  j.setClass([mt[Ft - 2]], mt[Ft]);
                  break;
                case 60:
                case 62:
                  this.$ = [mt[Ft]];
                  break;
                case 61:
                case 63:
                  this.$ = mt[Ft - 2].concat([mt[Ft]]);
                  break;
                case 64:
                  ((this.$ = mt[Ft - 2]), j.setCssStyle(mt[Ft - 1], mt[Ft]));
                  break;
                case 65:
                  this.$ = [mt[Ft]];
                  break;
                case 66:
                  (mt[Ft - 2].push(mt[Ft]), (this.$ = mt[Ft - 2]));
                  break;
                case 68:
                  this.$ = mt[Ft - 1] + mt[Ft];
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: 2, 6: t, 9: r, 11: n, 13: i },
              { 1: [3] },
              { 3: 8, 4: 2, 5: [1, 7], 6: t, 9: r, 11: n, 13: i },
              { 5: [1, 9] },
              { 10: [1, 10] },
              { 12: [1, 11] },
              e(s, [2, 6]),
              { 3: 12, 4: 2, 6: t, 9: r, 11: n, 13: i },
              { 1: [2, 2] },
              {
                4: 17,
                5: o,
                7: 13,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              e(s, [2, 4]),
              e(s, [2, 5]),
              { 1: [2, 1] },
              { 8: [1, 41] },
              {
                4: 17,
                5: o,
                7: 42,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 43,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 44,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 45,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 46,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 47,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 48,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 49,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              {
                4: 17,
                5: o,
                7: 50,
                8: l,
                9: r,
                11: n,
                13: i,
                14: 14,
                15: 15,
                16: 16,
                17: 18,
                18: 19,
                19: 20,
                20: 21,
                21: u,
                22: h,
                23: f,
                24: d,
                25: 23,
                33: 25,
                41: p,
                42: m,
                43: g,
                44: y,
                45: b,
                46: k,
                54: T,
                72: C,
                74: L,
                77: w,
                89: D,
                90: G,
              },
              { 26: 51, 89: [1, 52], 90: [1, 53] },
              { 55: 54, 89: [1, 55], 90: [1, 56] },
              { 29: [1, 59], 61: [1, 57], 63: [1, 58] },
              e(E, [2, 17]),
              e(E, [2, 18]),
              e(E, [2, 19]),
              e(E, [2, 20]),
              { 30: 60, 33: 62, 75: R, 89: D, 90: G },
              { 30: 63, 33: 62, 75: R, 89: D, 90: G },
              { 30: 64, 33: 62, 75: R, 89: D, 90: G },
              e(F, [2, 29]),
              e(F, [2, 30]),
              e(F, [2, 31]),
              e(F, [2, 32]),
              e(F, [2, 33]),
              e(F, [2, 34]),
              e(S, [2, 81]),
              e(S, [2, 82]),
              { 1: [2, 3] },
              { 8: [2, 8] },
              { 8: [2, 9] },
              { 8: [2, 10] },
              { 8: [2, 11] },
              { 8: [2, 12] },
              { 8: [2, 13] },
              { 8: [2, 14] },
              { 8: [2, 15] },
              { 8: [2, 16] },
              { 27: [1, 65], 29: [1, 66] },
              e(O, [2, 79]),
              e(O, [2, 80]),
              { 27: [1, 67], 29: [1, 68] },
              e(O, [2, 85]),
              e(O, [2, 86]),
              { 62: 69, 65: v, 66: _, 67: A, 68: N, 69: B, 70: M, 71: I },
              { 62: 77, 65: v, 66: _, 67: A, 68: N, 69: B, 70: M, 71: I },
              { 30: 78, 33: 62, 75: R, 89: D, 90: G },
              {
                73: 79,
                75: V,
                76: $,
                78: 81,
                79: 82,
                80: q,
                81: tt,
                82: ht,
                83: H,
                84: kt,
                85: ft,
                86: yt,
                87: ot,
                88: dt,
              },
              e(nt, [2, 60]),
              e(nt, [2, 62]),
              {
                73: 93,
                75: V,
                76: $,
                78: 81,
                79: 82,
                80: q,
                81: tt,
                82: ht,
                83: H,
                84: kt,
                85: ft,
                86: yt,
                87: ot,
                88: dt,
              },
              { 30: 94, 33: 62, 75: R, 76: $, 89: D, 90: G },
              { 5: [1, 95] },
              { 30: 96, 33: 62, 75: R, 89: D, 90: G },
              { 5: [1, 97] },
              { 30: 98, 33: 62, 75: R, 89: D, 90: G },
              { 63: [1, 99] },
              e(Q, [2, 50]),
              e(Q, [2, 51]),
              e(Q, [2, 52]),
              e(Q, [2, 53]),
              e(Q, [2, 54]),
              e(Q, [2, 55]),
              e(Q, [2, 56]),
              { 64: [1, 100] },
              e(E, [2, 59], { 76: $ }),
              e(E, [2, 64], { 76: et }),
              { 33: 103, 75: [1, 102], 89: D, 90: G },
              e(X, [2, 65], {
                79: 104,
                75: V,
                80: q,
                81: tt,
                82: ht,
                83: H,
                84: kt,
                85: ft,
                86: yt,
                87: ot,
                88: dt,
              }),
              e(st, [2, 67]),
              e(st, [2, 69]),
              e(st, [2, 70]),
              e(st, [2, 71]),
              e(st, [2, 72]),
              e(st, [2, 73]),
              e(st, [2, 74]),
              e(st, [2, 75]),
              e(st, [2, 76]),
              e(st, [2, 77]),
              e(st, [2, 78]),
              e(E, [2, 57], { 76: et }),
              e(E, [2, 58], { 76: $ }),
              { 5: U, 28: 105, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 27: [1, 112], 76: $ },
              { 5: Me, 40: se, 56: 113, 57: Nt, 59: At },
              { 27: [1, 118], 76: $ },
              { 33: 119, 89: D, 90: G },
              { 33: 120, 89: D, 90: G },
              {
                75: V,
                78: 121,
                79: 82,
                80: q,
                81: tt,
                82: ht,
                83: H,
                84: kt,
                85: ft,
                86: yt,
                87: ot,
                88: dt,
              },
              e(nt, [2, 61]),
              e(nt, [2, 63]),
              e(st, [2, 68]),
              e(E, [2, 21]),
              { 32: [1, 122] },
              { 32: [1, 123] },
              { 32: [1, 124] },
              { 32: [1, 125] },
              { 5: U, 28: 126, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              e(E, [2, 28]),
              { 5: [1, 127] },
              e(E, [2, 42]),
              { 32: [1, 128] },
              { 32: [1, 129] },
              { 5: Me, 40: se, 56: 130, 57: Nt, 59: At },
              e(E, [2, 47]),
              { 5: [1, 131] },
              e(E, [2, 48]),
              e(E, [2, 49]),
              e(X, [2, 66], {
                79: 104,
                75: V,
                80: q,
                81: tt,
                82: ht,
                83: H,
                84: kt,
                85: ft,
                86: yt,
                87: ot,
                88: dt,
              }),
              { 33: 132, 89: D, 90: G },
              { 35: 133, 89: [1, 134], 90: [1, 135] },
              { 37: 136, 47: [1, 137], 48: [1, 138], 49: [1, 139] },
              {
                39: 140,
                50: [1, 141],
                51: [1, 142],
                52: [1, 143],
                53: [1, 144],
              },
              e(E, [2, 27]),
              { 5: U, 28: 145, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 58: 146, 89: [1, 147], 90: [1, 148] },
              { 60: 149, 89: [1, 150], 90: [1, 151] },
              e(E, [2, 46]),
              { 5: Me, 40: se, 56: 152, 57: Nt, 59: At },
              { 5: [1, 153] },
              { 5: [1, 154] },
              { 5: [2, 83] },
              { 5: [2, 84] },
              { 5: [1, 155] },
              { 5: [2, 35] },
              { 5: [2, 36] },
              { 5: [2, 37] },
              { 5: [1, 156] },
              { 5: [2, 38] },
              { 5: [2, 39] },
              { 5: [2, 40] },
              { 5: [2, 41] },
              e(E, [2, 22]),
              { 5: [1, 157] },
              { 5: [2, 87] },
              { 5: [2, 88] },
              { 5: [1, 158] },
              { 5: [2, 89] },
              { 5: [2, 90] },
              e(E, [2, 43]),
              { 5: U, 28: 159, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: U, 28: 160, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: U, 28: 161, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: U, 28: 162, 31: gt, 34: z, 36: ge, 38: lt, 40: jt },
              { 5: Me, 40: se, 56: 163, 57: Nt, 59: At },
              { 5: Me, 40: se, 56: 164, 57: Nt, 59: At },
              e(E, [2, 23]),
              e(E, [2, 24]),
              e(E, [2, 25]),
              e(E, [2, 26]),
              e(E, [2, 44]),
              e(E, [2, 45]),
            ],
            defaultActions: {
              8: [2, 2],
              12: [2, 1],
              41: [2, 3],
              42: [2, 8],
              43: [2, 9],
              44: [2, 10],
              45: [2, 11],
              46: [2, 12],
              47: [2, 13],
              48: [2, 14],
              49: [2, 15],
              50: [2, 16],
              134: [2, 83],
              135: [2, 84],
              137: [2, 35],
              138: [2, 36],
              139: [2, 37],
              141: [2, 38],
              142: [2, 39],
              143: [2, 40],
              144: [2, 41],
              147: [2, 87],
              148: [2, 88],
              150: [2, 89],
              151: [2, 90],
            },
            parseError: a(function (Mt, W) {
              if (W.recoverable) this.trace(Mt);
              else {
                var Gt = new Error(Mt);
                throw ((Gt.hash = W), Gt);
              }
            }, "parseError"),
            parse: a(function (Mt) {
              var W = this,
                Gt = [0],
                j = [],
                Et = [null],
                mt = [],
                Xt = this.table,
                Ft = "",
                _t = 0,
                Qe = 0,
                It = 0,
                xr = 2,
                Ze = 1,
                mn = mt.slice.call(arguments, 1),
                Ae = Object.create(this.lexer),
                Te = { yy: {} };
              for (var Je in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, Je) &&
                  (Te.yy[Je] = this.yy[Je]);
              (Ae.setInput(Mt, Te.yy),
                (Te.yy.lexer = Ae),
                (Te.yy.parser = this),
                typeof Ae.yylloc > "u" && (Ae.yylloc = {}));
              var Se = Ae.yylloc;
              mt.push(Se);
              var hr = Ae.options && Ae.options.ranges;
              typeof Te.yy.parseError == "function"
                ? (this.parseError = Te.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function Sn(Er) {
                ((Gt.length = Gt.length - 2 * Er),
                  (Et.length = Et.length - Er),
                  (mt.length = mt.length - Er));
              }
              a(Sn, "popStack");
              function Ee() {
                var Er;
                return (
                  (Er = j.pop() || Ae.lex() || Ze),
                  typeof Er != "number" &&
                    (Er instanceof Array && ((j = Er), (Er = j.pop())),
                    (Er = W.symbols_[Er] || Er)),
                  Er
                );
              }
              a(Ee, "lex");
              for (var $e, Le, xe, fe, ye, be, Ht = {}, Dn, ne, Li, gn; ; ) {
                if (
                  ((xe = Gt[Gt.length - 1]),
                  this.defaultActions[xe]
                    ? (fe = this.defaultActions[xe])
                    : (($e === null || typeof $e > "u") && ($e = Ee()),
                      (fe = Xt[xe] && Xt[xe][$e])),
                  typeof fe > "u" || !fe.length || !fe[0])
                ) {
                  var Br = "";
                  gn = [];
                  for (Dn in Xt[xe])
                    this.terminals_[Dn] &&
                      Dn > xr &&
                      gn.push("'" + this.terminals_[Dn] + "'");
                  (Ae.showPosition
                    ? (Br =
                        "Parse error on line " +
                        (_t + 1) +
                        `:
` +
                        Ae.showPosition() +
                        `
Expecting ` +
                        gn.join(", ") +
                        ", got '" +
                        (this.terminals_[$e] || $e) +
                        "'")
                    : (Br =
                        "Parse error on line " +
                        (_t + 1) +
                        ": Unexpected " +
                        ($e == Ze
                          ? "end of input"
                          : "'" + (this.terminals_[$e] || $e) + "'")),
                    this.parseError(Br, {
                      text: Ae.match,
                      token: this.terminals_[$e] || $e,
                      line: Ae.yylineno,
                      loc: Se,
                      expected: gn,
                    }));
                }
                if (fe[0] instanceof Array && fe.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      xe +
                      ", token: " +
                      $e,
                  );
                switch (fe[0]) {
                  case 1:
                    (Gt.push($e),
                      Et.push(Ae.yytext),
                      mt.push(Ae.yylloc),
                      Gt.push(fe[1]),
                      ($e = null),
                      Le
                        ? (($e = Le), (Le = null))
                        : ((Qe = Ae.yyleng),
                          (Ft = Ae.yytext),
                          (_t = Ae.yylineno),
                          (Se = Ae.yylloc),
                          It > 0 && It--));
                    break;
                  case 2:
                    if (
                      ((ne = this.productions_[fe[1]][1]),
                      (Ht.$ = Et[Et.length - ne]),
                      (Ht._$ = {
                        first_line: mt[mt.length - (ne || 1)].first_line,
                        last_line: mt[mt.length - 1].last_line,
                        first_column: mt[mt.length - (ne || 1)].first_column,
                        last_column: mt[mt.length - 1].last_column,
                      }),
                      hr &&
                        (Ht._$.range = [
                          mt[mt.length - (ne || 1)].range[0],
                          mt[mt.length - 1].range[1],
                        ]),
                      (be = this.performAction.apply(
                        Ht,
                        [Ft, Qe, _t, Te.yy, fe[1], Et, mt].concat(mn),
                      )),
                      typeof be < "u")
                    )
                      return be;
                    (ne &&
                      ((Gt = Gt.slice(0, -1 * ne * 2)),
                      (Et = Et.slice(0, -1 * ne)),
                      (mt = mt.slice(0, -1 * ne))),
                      Gt.push(this.productions_[fe[1]][0]),
                      Et.push(Ht.$),
                      mt.push(Ht._$),
                      (Li = Xt[Gt[Gt.length - 2]][Gt[Gt.length - 1]]),
                      Gt.push(Li));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          ct = (function () {
            var Z = {
              EOF: 1,
              parseError: a(function (W, Gt) {
                if (this.yy.parser) this.yy.parser.parseError(W, Gt);
                else throw new Error(W);
              }, "parseError"),
              setInput: a(function (Mt, W) {
                return (
                  (this.yy = W || this.yy || {}),
                  (this._input = Mt),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var Mt = this._input[0];
                ((this.yytext += Mt),
                  this.yyleng++,
                  this.offset++,
                  (this.match += Mt),
                  (this.matched += Mt));
                var W = Mt.match(/(?:\r\n?|\n).*/g);
                return (
                  W
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  Mt
                );
              }, "input"),
              unput: a(function (Mt) {
                var W = Mt.length,
                  Gt = Mt.split(/(?:\r\n?|\n)/g);
                ((this._input = Mt + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - W)),
                  (this.offset -= W));
                var j = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  Gt.length - 1 && (this.yylineno -= Gt.length - 1));
                var Et = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: Gt
                      ? (Gt.length === j.length
                          ? this.yylloc.first_column
                          : 0) +
                        j[j.length - Gt.length].length -
                        Gt[0].length
                      : this.yylloc.first_column - W,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [Et[0], Et[0] + this.yyleng - W]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (Mt) {
                this.unput(this.match.slice(Mt));
              }, "less"),
              pastInput: a(function () {
                var Mt = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (Mt.length > 20 ? "..." : "") +
                  Mt.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var Mt = this.match;
                return (
                  Mt.length < 20 &&
                    (Mt += this._input.substr(0, 20 - Mt.length)),
                  (Mt.substr(0, 20) + (Mt.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var Mt = this.pastInput(),
                  W = new Array(Mt.length + 1).join("-");
                return (
                  Mt +
                  this.upcomingInput() +
                  `
` +
                  W +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (Mt, W) {
                var Gt, j, Et;
                if (
                  (this.options.backtrack_lexer &&
                    ((Et = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (Et.yylloc.range = this.yylloc.range.slice(0))),
                  (j = Mt[0].match(/(?:\r\n?|\n).*/g)),
                  j && (this.yylineno += j.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: j
                      ? j[j.length - 1].length -
                        j[j.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + Mt[0].length,
                  }),
                  (this.yytext += Mt[0]),
                  (this.match += Mt[0]),
                  (this.matches = Mt),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(Mt[0].length)),
                  (this.matched += Mt[0]),
                  (Gt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    W,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  Gt)
                )
                  return Gt;
                if (this._backtrack) {
                  for (var mt in Et) this[mt] = Et[mt];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var Mt, W, Gt, j;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (
                  var Et = this._currentRules(), mt = 0;
                  mt < Et.length;
                  mt++
                )
                  if (
                    ((Gt = this._input.match(this.rules[Et[mt]])),
                    Gt && (!W || Gt[0].length > W[0].length))
                  ) {
                    if (((W = Gt), (j = mt), this.options.backtrack_lexer)) {
                      if (((Mt = this.test_match(Gt, Et[mt])), Mt !== !1))
                        return Mt;
                      if (this._backtrack) {
                        W = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return W
                  ? ((Mt = this.test_match(W, Et[j])), Mt !== !1 ? Mt : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var W = this.next();
                return W || this.lex();
              }, "lex"),
              begin: a(function (W) {
                this.conditionStack.push(W);
              }, "begin"),
              popState: a(function () {
                var W = this.conditionStack.length - 1;
                return W > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (W) {
                return (
                  (W = this.conditionStack.length - 1 - Math.abs(W || 0)),
                  W >= 0 ? this.conditionStack[W] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (W) {
                this.begin(W);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (W, Gt, j, Et) {
                var mt = Et;
                switch (j) {
                  case 0:
                    return "title";
                  case 1:
                    return (this.begin("acc_title"), 9);
                    break;
                  case 2:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 3:
                    return (this.begin("acc_descr"), 11);
                    break;
                  case 4:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 5:
                    this.begin("acc_descr_multiline");
                    break;
                  case 6:
                    this.popState();
                    break;
                  case 7:
                    return "acc_descr_multiline_value";
                  case 8:
                    return 21;
                  case 9:
                    return 22;
                  case 10:
                    return 23;
                  case 11:
                    return 24;
                  case 12:
                    return 5;
                  case 13:
                    break;
                  case 14:
                    break;
                  case 15:
                    break;
                  case 16:
                    return 8;
                  case 17:
                    return 6;
                  case 18:
                    return 27;
                  case 19:
                    return 40;
                  case 20:
                    return 29;
                  case 21:
                    return 32;
                  case 22:
                    return 31;
                  case 23:
                    return 34;
                  case 24:
                    return 36;
                  case 25:
                    return 38;
                  case 26:
                    return 41;
                  case 27:
                    return 42;
                  case 28:
                    return 43;
                  case 29:
                    return 44;
                  case 30:
                    return 45;
                  case 31:
                    return 46;
                  case 32:
                    return 47;
                  case 33:
                    return 48;
                  case 34:
                    return 49;
                  case 35:
                    return 50;
                  case 36:
                    return 51;
                  case 37:
                    return 52;
                  case 38:
                    return 53;
                  case 39:
                    return 54;
                  case 40:
                    return 65;
                  case 41:
                    return 66;
                  case 42:
                    return 67;
                  case 43:
                    return 68;
                  case 44:
                    return 69;
                  case 45:
                    return 70;
                  case 46:
                    return 71;
                  case 47:
                    return 57;
                  case 48:
                    return 59;
                  case 49:
                    return (this.begin("style"), 77);
                    break;
                  case 50:
                    return 75;
                  case 51:
                    return 81;
                  case 52:
                    return 88;
                  case 53:
                    return "PERCENT";
                  case 54:
                    return 86;
                  case 55:
                    return 84;
                  case 56:
                    break;
                  case 57:
                    this.begin("string");
                    break;
                  case 58:
                    this.popState();
                    break;
                  case 59:
                    return (this.begin("style"), 72);
                    break;
                  case 60:
                    return (this.begin("style"), 74);
                    break;
                  case 61:
                    return 61;
                  case 62:
                    return 64;
                  case 63:
                    return 63;
                  case 64:
                    this.begin("string");
                    break;
                  case 65:
                    this.popState();
                    break;
                  case 66:
                    return "qString";
                  case 67:
                    return ((Gt.yytext = Gt.yytext.trim()), 89);
                    break;
                  case 68:
                    return 75;
                  case 69:
                    return 80;
                  case 70:
                    return 76;
                }
              }, "anonymous"),
              rules: [
                /^(?:title\s[^#\n;]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:(\r?\n)+)/i,
                /^(?:\s+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:%[^\n]*)/i,
                /^(?:$)/i,
                /^(?:requirementDiagram\b)/i,
                /^(?:\{)/i,
                /^(?:\})/i,
                /^(?::{3})/i,
                /^(?::)/i,
                /^(?:id\b)/i,
                /^(?:text\b)/i,
                /^(?:risk\b)/i,
                /^(?:verifyMethod\b)/i,
                /^(?:requirement\b)/i,
                /^(?:functionalRequirement\b)/i,
                /^(?:interfaceRequirement\b)/i,
                /^(?:performanceRequirement\b)/i,
                /^(?:physicalRequirement\b)/i,
                /^(?:designConstraint\b)/i,
                /^(?:low\b)/i,
                /^(?:medium\b)/i,
                /^(?:high\b)/i,
                /^(?:analysis\b)/i,
                /^(?:demonstration\b)/i,
                /^(?:inspection\b)/i,
                /^(?:test\b)/i,
                /^(?:element\b)/i,
                /^(?:contains\b)/i,
                /^(?:copies\b)/i,
                /^(?:derives\b)/i,
                /^(?:satisfies\b)/i,
                /^(?:verifies\b)/i,
                /^(?:refines\b)/i,
                /^(?:traces\b)/i,
                /^(?:type\b)/i,
                /^(?:docref\b)/i,
                /^(?:style\b)/i,
                /^(?:\w+)/i,
                /^(?::)/i,
                /^(?:;)/i,
                /^(?:%)/i,
                /^(?:-)/i,
                /^(?:#)/i,
                /^(?: )/i,
                /^(?:["])/i,
                /^(?:\n)/i,
                /^(?:classDef\b)/i,
                /^(?:class\b)/i,
                /^(?:<-)/i,
                /^(?:->)/i,
                /^(?:-)/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[\w][^:,\r\n\{\<\>\-\=]*)/i,
                /^(?:\w+)/i,
                /^(?:[0-9]+)/i,
                /^(?:,)/i,
              ],
              conditions: {
                acc_descr_multiline: {
                  rules: [6, 7, 68, 69, 70],
                  inclusive: !1,
                },
                acc_descr: { rules: [4, 68, 69, 70], inclusive: !1 },
                acc_title: { rules: [2, 68, 69, 70], inclusive: !1 },
                style: {
                  rules: [50, 51, 52, 53, 54, 55, 56, 57, 58, 68, 69, 70],
                  inclusive: !1,
                },
                unqString: { rules: [68, 69, 70], inclusive: !1 },
                token: { rules: [68, 69, 70], inclusive: !1 },
                string: { rules: [65, 66, 68, 69, 70], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 3, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
                    20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34,
                    35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
                    59, 60, 61, 62, 63, 64, 67, 68, 69, 70,
                  ],
                  inclusive: !0,
                },
              },
            };
            return Z;
          })();
        bt.lexer = ct;
        function Lt() {
          this.yy = {};
        }
        return (
          a(Lt, "Parser"),
          (Lt.prototype = bt),
          (bt.Parser = Lt),
          new Lt()
        );
      })();
      fN.parser = fN;
      bnt = fN;
    });
  var N_,
    Tnt = x(() => {
      "use strict";
      pe();
      Vt();
      yn();
      N_ = class {
        constructor() {
          this.relations = [];
          this.latestRequirement = this.getInitialRequirement();
          this.requirements = new Map();
          this.latestElement = this.getInitialElement();
          this.elements = new Map();
          this.classes = new Map();
          this.direction = "TB";
          this.RequirementType = {
            REQUIREMENT: "Requirement",
            FUNCTIONAL_REQUIREMENT: "Functional Requirement",
            INTERFACE_REQUIREMENT: "Interface Requirement",
            PERFORMANCE_REQUIREMENT: "Performance Requirement",
            PHYSICAL_REQUIREMENT: "Physical Requirement",
            DESIGN_CONSTRAINT: "Design Constraint",
          };
          this.RiskLevel = {
            LOW_RISK: "Low",
            MED_RISK: "Medium",
            HIGH_RISK: "High",
          };
          this.VerifyType = {
            VERIFY_ANALYSIS: "Analysis",
            VERIFY_DEMONSTRATION: "Demonstration",
            VERIFY_INSPECTION: "Inspection",
            VERIFY_TEST: "Test",
          };
          this.Relationships = {
            CONTAINS: "contains",
            COPIES: "copies",
            DERIVES: "derives",
            SATISFIES: "satisfies",
            VERIFIES: "verifies",
            REFINES: "refines",
            TRACES: "traces",
          };
          this.setAccTitle = Xe;
          this.getAccTitle = tr;
          this.setAccDescription = er;
          this.getAccDescription = rr;
          this.setDiagramTitle = lr;
          this.getDiagramTitle = nr;
          this.getConfig = a(() => K().requirement, "getConfig");
          (this.clear(),
            (this.setDirection = this.setDirection.bind(this)),
            (this.addRequirement = this.addRequirement.bind(this)),
            (this.setNewReqId = this.setNewReqId.bind(this)),
            (this.setNewReqRisk = this.setNewReqRisk.bind(this)),
            (this.setNewReqText = this.setNewReqText.bind(this)),
            (this.setNewReqVerifyMethod =
              this.setNewReqVerifyMethod.bind(this)),
            (this.addElement = this.addElement.bind(this)),
            (this.setNewElementType = this.setNewElementType.bind(this)),
            (this.setNewElementDocRef = this.setNewElementDocRef.bind(this)),
            (this.addRelationship = this.addRelationship.bind(this)),
            (this.setCssStyle = this.setCssStyle.bind(this)),
            (this.setClass = this.setClass.bind(this)),
            (this.defineClass = this.defineClass.bind(this)),
            (this.setAccTitle = this.setAccTitle.bind(this)),
            (this.setAccDescription = this.setAccDescription.bind(this)));
        }
        static {
          a(this, "RequirementDB");
        }
        getDirection() {
          return this.direction;
        }
        setDirection(t) {
          this.direction = t;
        }
        resetLatestRequirement() {
          this.latestRequirement = this.getInitialRequirement();
        }
        resetLatestElement() {
          this.latestElement = this.getInitialElement();
        }
        getInitialRequirement() {
          return {
            requirementId: "",
            text: "",
            risk: "",
            verifyMethod: "",
            name: "",
            type: "",
            cssStyles: [],
            classes: ["default"],
          };
        }
        getInitialElement() {
          return {
            name: "",
            type: "",
            docRef: "",
            cssStyles: [],
            classes: ["default"],
          };
        }
        addRequirement(t, r) {
          return (
            this.requirements.has(t) ||
              this.requirements.set(t, {
                name: t,
                type: r,
                requirementId: this.latestRequirement.requirementId,
                text: this.latestRequirement.text,
                risk: this.latestRequirement.risk,
                verifyMethod: this.latestRequirement.verifyMethod,
                cssStyles: [],
                classes: ["default"],
              }),
            this.resetLatestRequirement(),
            this.requirements.get(t)
          );
        }
        getRequirements() {
          return this.requirements;
        }
        setNewReqId(t) {
          this.latestRequirement !== void 0 &&
            (this.latestRequirement.requirementId = t);
        }
        setNewReqText(t) {
          this.latestRequirement !== void 0 &&
            (this.latestRequirement.text = t);
        }
        setNewReqRisk(t) {
          this.latestRequirement !== void 0 &&
            (this.latestRequirement.risk = t);
        }
        setNewReqVerifyMethod(t) {
          this.latestRequirement !== void 0 &&
            (this.latestRequirement.verifyMethod = t);
        }
        addElement(t) {
          return (
            this.elements.has(t) ||
              (this.elements.set(t, {
                name: t,
                type: this.latestElement.type,
                docRef: this.latestElement.docRef,
                cssStyles: [],
                classes: ["default"],
              }),
              P.info("Added new element: ", t)),
            this.resetLatestElement(),
            this.elements.get(t)
          );
        }
        getElements() {
          return this.elements;
        }
        setNewElementType(t) {
          this.latestElement !== void 0 && (this.latestElement.type = t);
        }
        setNewElementDocRef(t) {
          this.latestElement !== void 0 && (this.latestElement.docRef = t);
        }
        addRelationship(t, r, n) {
          this.relations.push({ type: t, src: r, dst: n });
        }
        getRelationships() {
          return this.relations;
        }
        clear() {
          ((this.relations = []),
            this.resetLatestRequirement(),
            (this.requirements = new Map()),
            this.resetLatestElement(),
            (this.elements = new Map()),
            (this.classes = new Map()),
            Ye());
        }
        setCssStyle(t, r) {
          for (let n of t) {
            let i = this.requirements.get(n) ?? this.elements.get(n);
            if (!r || !i) return;
            for (let s of r)
              s.includes(",")
                ? i.cssStyles.push(...s.split(","))
                : i.cssStyles.push(s);
          }
        }
        setClass(t, r) {
          for (let n of t) {
            let i = this.requirements.get(n) ?? this.elements.get(n);
            if (i)
              for (let s of r) {
                i.classes.push(s);
                let o = this.classes.get(s)?.styles;
                o && i.cssStyles.push(...o);
              }
          }
        }
        defineClass(t, r) {
          for (let n of t) {
            let i = this.classes.get(n);
            (i === void 0 &&
              ((i = { id: n, styles: [], textStyles: [] }),
              this.classes.set(n, i)),
              r &&
                r.forEach(function (s) {
                  if (/color/.exec(s)) {
                    let o = s.replace("fill", "bgFill");
                    i.textStyles.push(o);
                  }
                  i.styles.push(s);
                }),
              this.requirements.forEach((s) => {
                s.classes.includes(n) &&
                  s.cssStyles.push(...r.flatMap((o) => o.split(",")));
              }),
              this.elements.forEach((s) => {
                s.classes.includes(n) &&
                  s.cssStyles.push(...r.flatMap((o) => o.split(",")));
              }));
          }
        }
        getClasses() {
          return this.classes;
        }
        getData() {
          let t = K(),
            r = [],
            n = [];
          for (let i of this.requirements.values()) {
            let s = i;
            ((s.id = i.name),
              (s.cssStyles = i.cssStyles),
              (s.cssClasses = i.classes.join(" ")),
              (s.shape = "requirementBox"),
              (s.look = t.look),
              r.push(s));
          }
          for (let i of this.elements.values()) {
            let s = i;
            ((s.shape = "requirementBox"),
              (s.look = t.look),
              (s.id = i.name),
              (s.cssStyles = i.cssStyles),
              (s.cssClasses = i.classes.join(" ")),
              r.push(s));
          }
          for (let i of this.relations) {
            let s = 0,
              o = i.type === this.Relationships.CONTAINS,
              l = {
                id: `${i.src}-${i.dst}-${s}`,
                start:
                  this.requirements.get(i.src)?.name ??
                  this.elements.get(i.src)?.name,
                end:
                  this.requirements.get(i.dst)?.name ??
                  this.elements.get(i.dst)?.name,
                label: `&lt;&lt;${i.type}&gt;&gt;`,
                classes: "relationshipLine",
                style: ["fill:none", o ? "" : "stroke-dasharray: 10,7"],
                labelpos: "c",
                thickness: "normal",
                type: "normal",
                pattern: o ? "normal" : "dashed",
                arrowTypeStart: o ? "requirement_contains" : "",
                arrowTypeEnd: o ? "" : "requirement_arrow",
                look: t.look,
              };
            (n.push(l), s++);
          }
          return {
            nodes: r,
            edges: n,
            other: {},
            config: t,
            direction: this.getDirection(),
          };
        }
      };
    });
  var CRt,
    Snt,
    _nt = x(() => {
      "use strict";
      ((CRt = a(
        (e) => `

  marker {
    fill: ${e.relationColor};
    stroke: ${e.relationColor};
  }

  marker.cross {
    stroke: ${e.lineColor};
  }

  svg {
    font-family: ${e.fontFamily};
    font-size: ${e.fontSize};
  }

  .reqBox {
    fill: ${e.requirementBackground};
    fill-opacity: 1.0;
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  
  .reqTitle, .reqLabel{
    fill:  ${e.requirementTextColor};
  }
  .reqLabelBox {
    fill: ${e.relationLabelBackground};
    fill-opacity: 1.0;
  }

  .req-title-line {
    stroke: ${e.requirementBorderColor};
    stroke-width: ${e.requirementBorderSize};
  }
  .relationshipLine {
    stroke: ${e.relationColor};
    stroke-width: 1;
  }
  .relationshipLabel {
    fill: ${e.relationLabelColor};
  }
  .divider {
    stroke: ${e.nodeBorder};
    stroke-width: 1;
  }
  .label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .label text,span {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }
  .labelBkg {
    background-color: ${e.edgeLabelBackground};
  }

`,
        "getStyles",
      )),
        (Snt = CRt));
    });
  var dN = {};
  Oe(dN, { draw: () => wRt });
  var wRt,
    Cnt = x(() => {
      "use strict";
      pe();
      Vt();
      hd();
      ph();
      mh();
      _e();
      wRt = a(async function (e, t, r, n) {
        (P.info("REF0:"), P.info("Drawing requirement diagram (unified)", t));
        let { securityLevel: i, state: s, layout: o } = K(),
          l = n.db.getData(),
          u = _o(t, i);
        ((l.type = n.type),
          (l.layoutAlgorithm = Vc(o)),
          (l.nodeSpacing = s?.nodeSpacing ?? 50),
          (l.rankSpacing = s?.rankSpacing ?? 50),
          (l.markers = ["requirement_contains", "requirement_arrow"]),
          (l.diagramId = t),
          await No(l, u));
        let h = 8;
        (le.insertTitle(
          u,
          "requirementDiagramTitleText",
          s?.titleTopMargin ?? 25,
          n.db.getDiagramTitle(),
        ),
          la(u, h, "requirementDiagram", s?.useMaxWidth ?? !0));
      }, "draw");
    });
  var wnt = {};
  Oe(wnt, { diagram: () => vRt });
  var vRt,
    vnt = x(() => {
      "use strict";
      knt();
      Tnt();
      _nt();
      Cnt();
      vRt = {
        parser: bnt,
        get db() {
          return new N_();
        },
        renderer: dN,
        styles: Snt,
      };
    });
  var pN,
    Lnt,
    Rnt = x(() => {
      "use strict";
      pN = (function () {
        var e = a(function (dt, nt, Q, et) {
            for (Q = Q || {}, et = dt.length; et--; Q[dt[et]] = nt);
            return Q;
          }, "o"),
          t = [1, 2],
          r = [1, 3],
          n = [1, 4],
          i = [2, 4],
          s = [1, 9],
          o = [1, 11],
          l = [1, 13],
          u = [1, 14],
          h = [1, 16],
          f = [1, 17],
          d = [1, 18],
          p = [1, 24],
          m = [1, 25],
          g = [1, 26],
          y = [1, 27],
          b = [1, 28],
          k = [1, 29],
          T = [1, 30],
          C = [1, 31],
          L = [1, 32],
          w = [1, 33],
          D = [1, 34],
          G = [1, 35],
          E = [1, 36],
          R = [1, 37],
          F = [1, 38],
          S = [1, 39],
          O = [1, 41],
          v = [1, 42],
          _ = [1, 43],
          A = [1, 44],
          N = [1, 45],
          B = [1, 46],
          M = [
            1, 4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39,
            41, 43, 44, 46, 47, 48, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71,
          ],
          I = [2, 71],
          V = [4, 5, 16, 50, 52, 53],
          $ = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39,
            41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71,
          ],
          q = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39,
            41, 43, 44, 46, 49, 50, 52, 53, 55, 60, 61, 62, 63, 71,
          ],
          tt = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39,
            41, 43, 44, 46, 48, 50, 52, 53, 55, 60, 61, 62, 63, 71,
          ],
          ht = [
            4, 5, 13, 14, 16, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38, 39,
            41, 43, 44, 46, 47, 50, 52, 53, 55, 60, 61, 62, 63, 71,
          ],
          H = [69, 70, 71],
          kt = [1, 127],
          ft = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              SPACE: 4,
              NEWLINE: 5,
              SD: 6,
              document: 7,
              line: 8,
              statement: 9,
              box_section: 10,
              box_line: 11,
              participant_statement: 12,
              create: 13,
              box: 14,
              restOfLine: 15,
              end: 16,
              signal: 17,
              autonumber: 18,
              NUM: 19,
              off: 20,
              activate: 21,
              actor: 22,
              deactivate: 23,
              note_statement: 24,
              links_statement: 25,
              link_statement: 26,
              properties_statement: 27,
              details_statement: 28,
              title: 29,
              legacy_title: 30,
              acc_title: 31,
              acc_title_value: 32,
              acc_descr: 33,
              acc_descr_value: 34,
              acc_descr_multiline_value: 35,
              loop: 36,
              rect: 37,
              opt: 38,
              alt: 39,
              else_sections: 40,
              par: 41,
              par_sections: 42,
              par_over: 43,
              critical: 44,
              option_sections: 45,
              break: 46,
              option: 47,
              and: 48,
              else: 49,
              participant: 50,
              AS: 51,
              participant_actor: 52,
              destroy: 53,
              actor_with_config: 54,
              note: 55,
              placement: 56,
              text2: 57,
              over: 58,
              actor_pair: 59,
              links: 60,
              link: 61,
              properties: 62,
              details: 63,
              spaceList: 64,
              ",": 65,
              left_of: 66,
              right_of: 67,
              signaltype: 68,
              "+": 69,
              "-": 70,
              ACTOR: 71,
              config_object: 72,
              CONFIG_START: 73,
              CONFIG_CONTENT: 74,
              CONFIG_END: 75,
              SOLID_OPEN_ARROW: 76,
              DOTTED_OPEN_ARROW: 77,
              SOLID_ARROW: 78,
              BIDIRECTIONAL_SOLID_ARROW: 79,
              DOTTED_ARROW: 80,
              BIDIRECTIONAL_DOTTED_ARROW: 81,
              SOLID_CROSS: 82,
              DOTTED_CROSS: 83,
              SOLID_POINT: 84,
              DOTTED_POINT: 85,
              TXT: 86,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "SPACE",
              5: "NEWLINE",
              6: "SD",
              13: "create",
              14: "box",
              15: "restOfLine",
              16: "end",
              18: "autonumber",
              19: "NUM",
              20: "off",
              21: "activate",
              23: "deactivate",
              29: "title",
              30: "legacy_title",
              31: "acc_title",
              32: "acc_title_value",
              33: "acc_descr",
              34: "acc_descr_value",
              35: "acc_descr_multiline_value",
              36: "loop",
              37: "rect",
              38: "opt",
              39: "alt",
              41: "par",
              43: "par_over",
              44: "critical",
              46: "break",
              47: "option",
              48: "and",
              49: "else",
              50: "participant",
              51: "AS",
              52: "participant_actor",
              53: "destroy",
              55: "note",
              58: "over",
              60: "links",
              61: "link",
              62: "properties",
              63: "details",
              65: ",",
              66: "left_of",
              67: "right_of",
              69: "+",
              70: "-",
              71: "ACTOR",
              73: "CONFIG_START",
              74: "CONFIG_CONTENT",
              75: "CONFIG_END",
              76: "SOLID_OPEN_ARROW",
              77: "DOTTED_OPEN_ARROW",
              78: "SOLID_ARROW",
              79: "BIDIRECTIONAL_SOLID_ARROW",
              80: "DOTTED_ARROW",
              81: "BIDIRECTIONAL_DOTTED_ARROW",
              82: "SOLID_CROSS",
              83: "DOTTED_CROSS",
              84: "SOLID_POINT",
              85: "DOTTED_POINT",
              86: "TXT",
            },
            productions_: [
              0,
              [3, 2],
              [3, 2],
              [3, 2],
              [7, 0],
              [7, 2],
              [8, 2],
              [8, 1],
              [8, 1],
              [10, 0],
              [10, 2],
              [11, 2],
              [11, 1],
              [11, 1],
              [9, 1],
              [9, 2],
              [9, 4],
              [9, 2],
              [9, 4],
              [9, 3],
              [9, 3],
              [9, 2],
              [9, 3],
              [9, 3],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [9, 4],
              [45, 1],
              [45, 4],
              [42, 1],
              [42, 4],
              [40, 1],
              [40, 4],
              [12, 5],
              [12, 3],
              [12, 5],
              [12, 3],
              [12, 3],
              [12, 3],
              [24, 4],
              [24, 4],
              [25, 3],
              [26, 3],
              [27, 3],
              [28, 3],
              [64, 2],
              [64, 1],
              [59, 3],
              [59, 1],
              [56, 1],
              [56, 1],
              [17, 5],
              [17, 5],
              [17, 4],
              [54, 2],
              [72, 3],
              [22, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [68, 1],
              [57, 1],
            ],
            performAction: a(function (nt, Q, et, X, st, U, gt) {
              var z = U.length - 1;
              switch (st) {
                case 3:
                  return (X.apply(U[z]), U[z]);
                  break;
                case 4:
                case 9:
                  this.$ = [];
                  break;
                case 5:
                case 10:
                  (U[z - 1].push(U[z]), (this.$ = U[z - 1]));
                  break;
                case 6:
                case 7:
                case 11:
                case 12:
                  this.$ = U[z];
                  break;
                case 8:
                case 13:
                  this.$ = [];
                  break;
                case 15:
                  ((U[z].type = "createParticipant"), (this.$ = U[z]));
                  break;
                case 16:
                  (U[z - 1].unshift({
                    type: "boxStart",
                    boxData: X.parseBoxData(U[z - 2]),
                  }),
                    U[z - 1].push({ type: "boxEnd", boxText: U[z - 2] }),
                    (this.$ = U[z - 1]));
                  break;
                case 18:
                  this.$ = {
                    type: "sequenceIndex",
                    sequenceIndex: Number(U[z - 2]),
                    sequenceIndexStep: Number(U[z - 1]),
                    sequenceVisible: !0,
                    signalType: X.LINETYPE.AUTONUMBER,
                  };
                  break;
                case 19:
                  this.$ = {
                    type: "sequenceIndex",
                    sequenceIndex: Number(U[z - 1]),
                    sequenceIndexStep: 1,
                    sequenceVisible: !0,
                    signalType: X.LINETYPE.AUTONUMBER,
                  };
                  break;
                case 20:
                  this.$ = {
                    type: "sequenceIndex",
                    sequenceVisible: !1,
                    signalType: X.LINETYPE.AUTONUMBER,
                  };
                  break;
                case 21:
                  this.$ = {
                    type: "sequenceIndex",
                    sequenceVisible: !0,
                    signalType: X.LINETYPE.AUTONUMBER,
                  };
                  break;
                case 22:
                  this.$ = {
                    type: "activeStart",
                    signalType: X.LINETYPE.ACTIVE_START,
                    actor: U[z - 1].actor,
                  };
                  break;
                case 23:
                  this.$ = {
                    type: "activeEnd",
                    signalType: X.LINETYPE.ACTIVE_END,
                    actor: U[z - 1].actor,
                  };
                  break;
                case 29:
                  (X.setDiagramTitle(U[z].substring(6)),
                    (this.$ = U[z].substring(6)));
                  break;
                case 30:
                  (X.setDiagramTitle(U[z].substring(7)),
                    (this.$ = U[z].substring(7)));
                  break;
                case 31:
                  ((this.$ = U[z].trim()), X.setAccTitle(this.$));
                  break;
                case 32:
                case 33:
                  ((this.$ = U[z].trim()), X.setAccDescription(this.$));
                  break;
                case 34:
                  (U[z - 1].unshift({
                    type: "loopStart",
                    loopText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.LOOP_START,
                  }),
                    U[z - 1].push({
                      type: "loopEnd",
                      loopText: U[z - 2],
                      signalType: X.LINETYPE.LOOP_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 35:
                  (U[z - 1].unshift({
                    type: "rectStart",
                    color: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.RECT_START,
                  }),
                    U[z - 1].push({
                      type: "rectEnd",
                      color: X.parseMessage(U[z - 2]),
                      signalType: X.LINETYPE.RECT_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 36:
                  (U[z - 1].unshift({
                    type: "optStart",
                    optText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.OPT_START,
                  }),
                    U[z - 1].push({
                      type: "optEnd",
                      optText: X.parseMessage(U[z - 2]),
                      signalType: X.LINETYPE.OPT_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 37:
                  (U[z - 1].unshift({
                    type: "altStart",
                    altText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.ALT_START,
                  }),
                    U[z - 1].push({
                      type: "altEnd",
                      signalType: X.LINETYPE.ALT_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 38:
                  (U[z - 1].unshift({
                    type: "parStart",
                    parText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.PAR_START,
                  }),
                    U[z - 1].push({
                      type: "parEnd",
                      signalType: X.LINETYPE.PAR_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 39:
                  (U[z - 1].unshift({
                    type: "parStart",
                    parText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.PAR_OVER_START,
                  }),
                    U[z - 1].push({
                      type: "parEnd",
                      signalType: X.LINETYPE.PAR_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 40:
                  (U[z - 1].unshift({
                    type: "criticalStart",
                    criticalText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.CRITICAL_START,
                  }),
                    U[z - 1].push({
                      type: "criticalEnd",
                      signalType: X.LINETYPE.CRITICAL_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 41:
                  (U[z - 1].unshift({
                    type: "breakStart",
                    breakText: X.parseMessage(U[z - 2]),
                    signalType: X.LINETYPE.BREAK_START,
                  }),
                    U[z - 1].push({
                      type: "breakEnd",
                      optText: X.parseMessage(U[z - 2]),
                      signalType: X.LINETYPE.BREAK_END,
                    }),
                    (this.$ = U[z - 1]));
                  break;
                case 43:
                  this.$ = U[z - 3].concat([
                    {
                      type: "option",
                      optionText: X.parseMessage(U[z - 1]),
                      signalType: X.LINETYPE.CRITICAL_OPTION,
                    },
                    U[z],
                  ]);
                  break;
                case 45:
                  this.$ = U[z - 3].concat([
                    {
                      type: "and",
                      parText: X.parseMessage(U[z - 1]),
                      signalType: X.LINETYPE.PAR_AND,
                    },
                    U[z],
                  ]);
                  break;
                case 47:
                  this.$ = U[z - 3].concat([
                    {
                      type: "else",
                      altText: X.parseMessage(U[z - 1]),
                      signalType: X.LINETYPE.ALT_ELSE,
                    },
                    U[z],
                  ]);
                  break;
                case 48:
                  ((U[z - 3].draw = "participant"),
                    (U[z - 3].type = "addParticipant"),
                    (U[z - 3].description = X.parseMessage(U[z - 1])),
                    (this.$ = U[z - 3]));
                  break;
                case 49:
                  ((U[z - 1].draw = "participant"),
                    (U[z - 1].type = "addParticipant"),
                    (this.$ = U[z - 1]));
                  break;
                case 50:
                  ((U[z - 3].draw = "actor"),
                    (U[z - 3].type = "addParticipant"),
                    (U[z - 3].description = X.parseMessage(U[z - 1])),
                    (this.$ = U[z - 3]));
                  break;
                case 51:
                  ((U[z - 1].draw = "actor"),
                    (U[z - 1].type = "addParticipant"),
                    (this.$ = U[z - 1]));
                  break;
                case 52:
                  ((U[z - 1].type = "destroyParticipant"), (this.$ = U[z - 1]));
                  break;
                case 53:
                  ((U[z - 1].draw = "participant"),
                    (U[z - 1].type = "addParticipant"),
                    (this.$ = U[z - 1]));
                  break;
                case 54:
                  this.$ = [
                    U[z - 1],
                    {
                      type: "addNote",
                      placement: U[z - 2],
                      actor: U[z - 1].actor,
                      text: U[z],
                    },
                  ];
                  break;
                case 55:
                  ((U[z - 2] = [].concat(U[z - 1], U[z - 1]).slice(0, 2)),
                    (U[z - 2][0] = U[z - 2][0].actor),
                    (U[z - 2][1] = U[z - 2][1].actor),
                    (this.$ = [
                      U[z - 1],
                      {
                        type: "addNote",
                        placement: X.PLACEMENT.OVER,
                        actor: U[z - 2].slice(0, 2),
                        text: U[z],
                      },
                    ]));
                  break;
                case 56:
                  this.$ = [
                    U[z - 1],
                    { type: "addLinks", actor: U[z - 1].actor, text: U[z] },
                  ];
                  break;
                case 57:
                  this.$ = [
                    U[z - 1],
                    { type: "addALink", actor: U[z - 1].actor, text: U[z] },
                  ];
                  break;
                case 58:
                  this.$ = [
                    U[z - 1],
                    {
                      type: "addProperties",
                      actor: U[z - 1].actor,
                      text: U[z],
                    },
                  ];
                  break;
                case 59:
                  this.$ = [
                    U[z - 1],
                    { type: "addDetails", actor: U[z - 1].actor, text: U[z] },
                  ];
                  break;
                case 62:
                  this.$ = [U[z - 2], U[z]];
                  break;
                case 63:
                  this.$ = U[z];
                  break;
                case 64:
                  this.$ = X.PLACEMENT.LEFTOF;
                  break;
                case 65:
                  this.$ = X.PLACEMENT.RIGHTOF;
                  break;
                case 66:
                  this.$ = [
                    U[z - 4],
                    U[z - 1],
                    {
                      type: "addMessage",
                      from: U[z - 4].actor,
                      to: U[z - 1].actor,
                      signalType: U[z - 3],
                      msg: U[z],
                      activate: !0,
                    },
                    {
                      type: "activeStart",
                      signalType: X.LINETYPE.ACTIVE_START,
                      actor: U[z - 1].actor,
                    },
                  ];
                  break;
                case 67:
                  this.$ = [
                    U[z - 4],
                    U[z - 1],
                    {
                      type: "addMessage",
                      from: U[z - 4].actor,
                      to: U[z - 1].actor,
                      signalType: U[z - 3],
                      msg: U[z],
                    },
                    {
                      type: "activeEnd",
                      signalType: X.LINETYPE.ACTIVE_END,
                      actor: U[z - 4].actor,
                    },
                  ];
                  break;
                case 68:
                  this.$ = [
                    U[z - 3],
                    U[z - 1],
                    {
                      type: "addMessage",
                      from: U[z - 3].actor,
                      to: U[z - 1].actor,
                      signalType: U[z - 2],
                      msg: U[z],
                    },
                  ];
                  break;
                case 69:
                  this.$ = {
                    type: "addParticipant",
                    actor: U[z - 1],
                    config: U[z],
                  };
                  break;
                case 70:
                  this.$ = U[z - 1].trim();
                  break;
                case 71:
                  this.$ = { type: "addParticipant", actor: U[z] };
                  break;
                case 72:
                  this.$ = X.LINETYPE.SOLID_OPEN;
                  break;
                case 73:
                  this.$ = X.LINETYPE.DOTTED_OPEN;
                  break;
                case 74:
                  this.$ = X.LINETYPE.SOLID;
                  break;
                case 75:
                  this.$ = X.LINETYPE.BIDIRECTIONAL_SOLID;
                  break;
                case 76:
                  this.$ = X.LINETYPE.DOTTED;
                  break;
                case 77:
                  this.$ = X.LINETYPE.BIDIRECTIONAL_DOTTED;
                  break;
                case 78:
                  this.$ = X.LINETYPE.SOLID_CROSS;
                  break;
                case 79:
                  this.$ = X.LINETYPE.DOTTED_CROSS;
                  break;
                case 80:
                  this.$ = X.LINETYPE.SOLID_POINT;
                  break;
                case 81:
                  this.$ = X.LINETYPE.DOTTED_POINT;
                  break;
                case 82:
                  this.$ = X.parseMessage(U[z].trim().substring(1));
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: t, 5: r, 6: n },
              { 1: [3] },
              { 3: 5, 4: t, 5: r, 6: n },
              { 3: 6, 4: t, 5: r, 6: n },
              e(
                [
                  1, 4, 5, 13, 14, 18, 21, 23, 29, 30, 31, 33, 35, 36, 37, 38,
                  39, 41, 43, 44, 46, 50, 52, 53, 55, 60, 61, 62, 63, 71,
                ],
                i,
                { 7: 7 },
              ),
              { 1: [2, 1] },
              { 1: [2, 2] },
              {
                1: [2, 3],
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              e(M, [2, 5]),
              {
                9: 47,
                12: 12,
                13: l,
                14: u,
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              e(M, [2, 7]),
              e(M, [2, 8]),
              e(M, [2, 14]),
              { 12: 48, 50: R, 52: F, 53: S },
              { 15: [1, 49] },
              { 5: [1, 50] },
              { 5: [1, 53], 19: [1, 51], 20: [1, 52] },
              { 22: 54, 71: B },
              { 22: 55, 71: B },
              { 5: [1, 56] },
              { 5: [1, 57] },
              { 5: [1, 58] },
              { 5: [1, 59] },
              { 5: [1, 60] },
              e(M, [2, 29]),
              e(M, [2, 30]),
              { 32: [1, 61] },
              { 34: [1, 62] },
              e(M, [2, 33]),
              { 15: [1, 63] },
              { 15: [1, 64] },
              { 15: [1, 65] },
              { 15: [1, 66] },
              { 15: [1, 67] },
              { 15: [1, 68] },
              { 15: [1, 69] },
              { 15: [1, 70] },
              { 22: 71, 54: 72, 71: [1, 73] },
              { 22: 74, 71: B },
              { 22: 75, 71: B },
              {
                68: 76,
                76: [1, 77],
                77: [1, 78],
                78: [1, 79],
                79: [1, 80],
                80: [1, 81],
                81: [1, 82],
                82: [1, 83],
                83: [1, 84],
                84: [1, 85],
                85: [1, 86],
              },
              { 56: 87, 58: [1, 88], 66: [1, 89], 67: [1, 90] },
              { 22: 91, 71: B },
              { 22: 92, 71: B },
              { 22: 93, 71: B },
              { 22: 94, 71: B },
              e([5, 51, 65, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86], I),
              e(M, [2, 6]),
              e(M, [2, 15]),
              e(V, [2, 9], { 10: 95 }),
              e(M, [2, 17]),
              { 5: [1, 97], 19: [1, 96] },
              { 5: [1, 98] },
              e(M, [2, 21]),
              { 5: [1, 99] },
              { 5: [1, 100] },
              e(M, [2, 24]),
              e(M, [2, 25]),
              e(M, [2, 26]),
              e(M, [2, 27]),
              e(M, [2, 28]),
              e(M, [2, 31]),
              e(M, [2, 32]),
              e($, i, { 7: 101 }),
              e($, i, { 7: 102 }),
              e($, i, { 7: 103 }),
              e(q, i, { 40: 104, 7: 105 }),
              e(tt, i, { 42: 106, 7: 107 }),
              e(tt, i, { 7: 107, 42: 108 }),
              e(ht, i, { 45: 109, 7: 110 }),
              e($, i, { 7: 111 }),
              { 5: [1, 113], 51: [1, 112] },
              { 5: [1, 114] },
              e([5, 51], I, { 72: 115, 73: [1, 116] }),
              { 5: [1, 118], 51: [1, 117] },
              { 5: [1, 119] },
              { 22: 122, 69: [1, 120], 70: [1, 121], 71: B },
              e(H, [2, 72]),
              e(H, [2, 73]),
              e(H, [2, 74]),
              e(H, [2, 75]),
              e(H, [2, 76]),
              e(H, [2, 77]),
              e(H, [2, 78]),
              e(H, [2, 79]),
              e(H, [2, 80]),
              e(H, [2, 81]),
              { 22: 123, 71: B },
              { 22: 125, 59: 124, 71: B },
              { 71: [2, 64] },
              { 71: [2, 65] },
              { 57: 126, 86: kt },
              { 57: 128, 86: kt },
              { 57: 129, 86: kt },
              { 57: 130, 86: kt },
              {
                4: [1, 133],
                5: [1, 135],
                11: 132,
                12: 134,
                16: [1, 131],
                50: R,
                52: F,
                53: S,
              },
              { 5: [1, 136] },
              e(M, [2, 19]),
              e(M, [2, 20]),
              e(M, [2, 22]),
              e(M, [2, 23]),
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 137],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 138],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 139],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              { 16: [1, 140] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [2, 46],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                49: [1, 141],
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              { 16: [1, 142] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [2, 44],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                48: [1, 143],
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              { 16: [1, 144] },
              { 16: [1, 145] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [2, 42],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                47: [1, 146],
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                12: 12,
                13: l,
                14: u,
                16: [1, 147],
                17: 15,
                18: h,
                21: f,
                22: 40,
                23: d,
                24: 19,
                25: 20,
                26: 21,
                27: 22,
                28: 23,
                29: p,
                30: m,
                31: g,
                33: y,
                35: b,
                36: k,
                37: T,
                38: C,
                39: L,
                41: w,
                43: D,
                44: G,
                46: E,
                50: R,
                52: F,
                53: S,
                55: O,
                60: v,
                61: _,
                62: A,
                63: N,
                71: B,
              },
              { 15: [1, 148] },
              e(M, [2, 49]),
              e(M, [2, 53]),
              { 5: [2, 69] },
              { 74: [1, 149] },
              { 15: [1, 150] },
              e(M, [2, 51]),
              e(M, [2, 52]),
              { 22: 151, 71: B },
              { 22: 152, 71: B },
              { 57: 153, 86: kt },
              { 57: 154, 86: kt },
              { 57: 155, 86: kt },
              { 65: [1, 156], 86: [2, 63] },
              { 5: [2, 56] },
              { 5: [2, 82] },
              { 5: [2, 57] },
              { 5: [2, 58] },
              { 5: [2, 59] },
              e(M, [2, 16]),
              e(V, [2, 10]),
              { 12: 157, 50: R, 52: F, 53: S },
              e(V, [2, 12]),
              e(V, [2, 13]),
              e(M, [2, 18]),
              e(M, [2, 34]),
              e(M, [2, 35]),
              e(M, [2, 36]),
              e(M, [2, 37]),
              { 15: [1, 158] },
              e(M, [2, 38]),
              { 15: [1, 159] },
              e(M, [2, 39]),
              e(M, [2, 40]),
              { 15: [1, 160] },
              e(M, [2, 41]),
              { 5: [1, 161] },
              { 75: [1, 162] },
              { 5: [1, 163] },
              { 57: 164, 86: kt },
              { 57: 165, 86: kt },
              { 5: [2, 68] },
              { 5: [2, 54] },
              { 5: [2, 55] },
              { 22: 166, 71: B },
              e(V, [2, 11]),
              e(q, i, { 7: 105, 40: 167 }),
              e(tt, i, { 7: 107, 42: 168 }),
              e(ht, i, { 7: 110, 45: 169 }),
              e(M, [2, 48]),
              { 5: [2, 70] },
              e(M, [2, 50]),
              { 5: [2, 66] },
              { 5: [2, 67] },
              { 86: [2, 62] },
              { 16: [2, 47] },
              { 16: [2, 45] },
              { 16: [2, 43] },
            ],
            defaultActions: {
              5: [2, 1],
              6: [2, 2],
              89: [2, 64],
              90: [2, 65],
              115: [2, 69],
              126: [2, 56],
              127: [2, 82],
              128: [2, 57],
              129: [2, 58],
              130: [2, 59],
              153: [2, 68],
              154: [2, 54],
              155: [2, 55],
              162: [2, 70],
              164: [2, 66],
              165: [2, 67],
              166: [2, 62],
              167: [2, 47],
              168: [2, 45],
              169: [2, 43],
            },
            parseError: a(function (nt, Q) {
              if (Q.recoverable) this.trace(nt);
              else {
                var et = new Error(nt);
                throw ((et.hash = Q), et);
              }
            }, "parseError"),
            parse: a(function (nt) {
              var Q = this,
                et = [0],
                X = [],
                st = [null],
                U = [],
                gt = this.table,
                z = "",
                ge = 0,
                lt = 0,
                jt = 0,
                Me = 2,
                se = 1,
                Nt = U.slice.call(arguments, 1),
                At = Object.create(this.lexer),
                bt = { yy: {} };
              for (var ct in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, ct) &&
                  (bt.yy[ct] = this.yy[ct]);
              (At.setInput(nt, bt.yy),
                (bt.yy.lexer = At),
                (bt.yy.parser = this),
                typeof At.yylloc > "u" && (At.yylloc = {}));
              var Lt = At.yylloc;
              U.push(Lt);
              var Z = At.options && At.options.ranges;
              typeof bt.yy.parseError == "function"
                ? (this.parseError = bt.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function Mt(Ae) {
                ((et.length = et.length - 2 * Ae),
                  (st.length = st.length - Ae),
                  (U.length = U.length - Ae));
              }
              a(Mt, "popStack");
              function W() {
                var Ae;
                return (
                  (Ae = X.pop() || At.lex() || se),
                  typeof Ae != "number" &&
                    (Ae instanceof Array && ((X = Ae), (Ae = X.pop())),
                    (Ae = Q.symbols_[Ae] || Ae)),
                  Ae
                );
              }
              a(W, "lex");
              for (var Gt, j, Et, mt, Xt, Ft, _t = {}, Qe, It, xr, Ze; ; ) {
                if (
                  ((Et = et[et.length - 1]),
                  this.defaultActions[Et]
                    ? (mt = this.defaultActions[Et])
                    : ((Gt === null || typeof Gt > "u") && (Gt = W()),
                      (mt = gt[Et] && gt[Et][Gt])),
                  typeof mt > "u" || !mt.length || !mt[0])
                ) {
                  var mn = "";
                  Ze = [];
                  for (Qe in gt[Et])
                    this.terminals_[Qe] &&
                      Qe > Me &&
                      Ze.push("'" + this.terminals_[Qe] + "'");
                  (At.showPosition
                    ? (mn =
                        "Parse error on line " +
                        (ge + 1) +
                        `:
` +
                        At.showPosition() +
                        `
Expecting ` +
                        Ze.join(", ") +
                        ", got '" +
                        (this.terminals_[Gt] || Gt) +
                        "'")
                    : (mn =
                        "Parse error on line " +
                        (ge + 1) +
                        ": Unexpected " +
                        (Gt == se
                          ? "end of input"
                          : "'" + (this.terminals_[Gt] || Gt) + "'")),
                    this.parseError(mn, {
                      text: At.match,
                      token: this.terminals_[Gt] || Gt,
                      line: At.yylineno,
                      loc: Lt,
                      expected: Ze,
                    }));
                }
                if (mt[0] instanceof Array && mt.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      Et +
                      ", token: " +
                      Gt,
                  );
                switch (mt[0]) {
                  case 1:
                    (et.push(Gt),
                      st.push(At.yytext),
                      U.push(At.yylloc),
                      et.push(mt[1]),
                      (Gt = null),
                      j
                        ? ((Gt = j), (j = null))
                        : ((lt = At.yyleng),
                          (z = At.yytext),
                          (ge = At.yylineno),
                          (Lt = At.yylloc),
                          jt > 0 && jt--));
                    break;
                  case 2:
                    if (
                      ((It = this.productions_[mt[1]][1]),
                      (_t.$ = st[st.length - It]),
                      (_t._$ = {
                        first_line: U[U.length - (It || 1)].first_line,
                        last_line: U[U.length - 1].last_line,
                        first_column: U[U.length - (It || 1)].first_column,
                        last_column: U[U.length - 1].last_column,
                      }),
                      Z &&
                        (_t._$.range = [
                          U[U.length - (It || 1)].range[0],
                          U[U.length - 1].range[1],
                        ]),
                      (Ft = this.performAction.apply(
                        _t,
                        [z, lt, ge, bt.yy, mt[1], st, U].concat(Nt),
                      )),
                      typeof Ft < "u")
                    )
                      return Ft;
                    (It &&
                      ((et = et.slice(0, -1 * It * 2)),
                      (st = st.slice(0, -1 * It)),
                      (U = U.slice(0, -1 * It))),
                      et.push(this.productions_[mt[1]][0]),
                      st.push(_t.$),
                      U.push(_t._$),
                      (xr = gt[et[et.length - 2]][et[et.length - 1]]),
                      et.push(xr));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          yt = (function () {
            var dt = {
              EOF: 1,
              parseError: a(function (Q, et) {
                if (this.yy.parser) this.yy.parser.parseError(Q, et);
                else throw new Error(Q);
              }, "parseError"),
              setInput: a(function (nt, Q) {
                return (
                  (this.yy = Q || this.yy || {}),
                  (this._input = nt),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var nt = this._input[0];
                ((this.yytext += nt),
                  this.yyleng++,
                  this.offset++,
                  (this.match += nt),
                  (this.matched += nt));
                var Q = nt.match(/(?:\r\n?|\n).*/g);
                return (
                  Q
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  nt
                );
              }, "input"),
              unput: a(function (nt) {
                var Q = nt.length,
                  et = nt.split(/(?:\r\n?|\n)/g);
                ((this._input = nt + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - Q)),
                  (this.offset -= Q));
                var X = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  et.length - 1 && (this.yylineno -= et.length - 1));
                var st = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: et
                      ? (et.length === X.length
                          ? this.yylloc.first_column
                          : 0) +
                        X[X.length - et.length].length -
                        et[0].length
                      : this.yylloc.first_column - Q,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [st[0], st[0] + this.yyleng - Q]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (nt) {
                this.unput(this.match.slice(nt));
              }, "less"),
              pastInput: a(function () {
                var nt = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (nt.length > 20 ? "..." : "") +
                  nt.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var nt = this.match;
                return (
                  nt.length < 20 &&
                    (nt += this._input.substr(0, 20 - nt.length)),
                  (nt.substr(0, 20) + (nt.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var nt = this.pastInput(),
                  Q = new Array(nt.length + 1).join("-");
                return (
                  nt +
                  this.upcomingInput() +
                  `
` +
                  Q +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (nt, Q) {
                var et, X, st;
                if (
                  (this.options.backtrack_lexer &&
                    ((st = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (st.yylloc.range = this.yylloc.range.slice(0))),
                  (X = nt[0].match(/(?:\r\n?|\n).*/g)),
                  X && (this.yylineno += X.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: X
                      ? X[X.length - 1].length -
                        X[X.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + nt[0].length,
                  }),
                  (this.yytext += nt[0]),
                  (this.match += nt[0]),
                  (this.matches = nt),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(nt[0].length)),
                  (this.matched += nt[0]),
                  (et = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    Q,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  et)
                )
                  return et;
                if (this._backtrack) {
                  for (var U in st) this[U] = st[U];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var nt, Q, et, X;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var st = this._currentRules(), U = 0; U < st.length; U++)
                  if (
                    ((et = this._input.match(this.rules[st[U]])),
                    et && (!Q || et[0].length > Q[0].length))
                  ) {
                    if (((Q = et), (X = U), this.options.backtrack_lexer)) {
                      if (((nt = this.test_match(et, st[U])), nt !== !1))
                        return nt;
                      if (this._backtrack) {
                        Q = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return Q
                  ? ((nt = this.test_match(Q, st[X])), nt !== !1 ? nt : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var Q = this.next();
                return Q || this.lex();
              }, "lex"),
              begin: a(function (Q) {
                this.conditionStack.push(Q);
              }, "begin"),
              popState: a(function () {
                var Q = this.conditionStack.length - 1;
                return Q > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (Q) {
                return (
                  (Q = this.conditionStack.length - 1 - Math.abs(Q || 0)),
                  Q >= 0 ? this.conditionStack[Q] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (Q) {
                this.begin(Q);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (Q, et, X, st) {
                var U = st;
                switch (X) {
                  case 0:
                    return 5;
                  case 1:
                    break;
                  case 2:
                    break;
                  case 3:
                    break;
                  case 4:
                    break;
                  case 5:
                    break;
                  case 6:
                    return 19;
                  case 7:
                    return (this.begin("CONFIG"), 73);
                    break;
                  case 8:
                    return 74;
                  case 9:
                    return (this.popState(), this.popState(), 75);
                    break;
                  case 10:
                    return ((et.yytext = et.yytext.trim()), 71);
                    break;
                  case 11:
                    return (
                      (et.yytext = et.yytext.trim()),
                      this.begin("ALIAS"),
                      71
                    );
                    break;
                  case 12:
                    return (this.begin("LINE"), 14);
                    break;
                  case 13:
                    return (this.begin("ID"), 50);
                    break;
                  case 14:
                    return (this.begin("ID"), 52);
                    break;
                  case 15:
                    return 13;
                  case 16:
                    return (this.begin("ID"), 53);
                    break;
                  case 17:
                    return (
                      (et.yytext = et.yytext.trim()),
                      this.begin("ALIAS"),
                      71
                    );
                    break;
                  case 18:
                    return (
                      this.popState(),
                      this.popState(),
                      this.begin("LINE"),
                      51
                    );
                    break;
                  case 19:
                    return (this.popState(), this.popState(), 5);
                    break;
                  case 20:
                    return (this.begin("LINE"), 36);
                    break;
                  case 21:
                    return (this.begin("LINE"), 37);
                    break;
                  case 22:
                    return (this.begin("LINE"), 38);
                    break;
                  case 23:
                    return (this.begin("LINE"), 39);
                    break;
                  case 24:
                    return (this.begin("LINE"), 49);
                    break;
                  case 25:
                    return (this.begin("LINE"), 41);
                    break;
                  case 26:
                    return (this.begin("LINE"), 43);
                    break;
                  case 27:
                    return (this.begin("LINE"), 48);
                    break;
                  case 28:
                    return (this.begin("LINE"), 44);
                    break;
                  case 29:
                    return (this.begin("LINE"), 47);
                    break;
                  case 30:
                    return (this.begin("LINE"), 46);
                    break;
                  case 31:
                    return (this.popState(), 15);
                    break;
                  case 32:
                    return 16;
                  case 33:
                    return 66;
                  case 34:
                    return 67;
                  case 35:
                    return 60;
                  case 36:
                    return 61;
                  case 37:
                    return 62;
                  case 38:
                    return 63;
                  case 39:
                    return 58;
                  case 40:
                    return 55;
                  case 41:
                    return (this.begin("ID"), 21);
                    break;
                  case 42:
                    return (this.begin("ID"), 23);
                    break;
                  case 43:
                    return 29;
                  case 44:
                    return 30;
                  case 45:
                    return (this.begin("acc_title"), 31);
                    break;
                  case 46:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 47:
                    return (this.begin("acc_descr"), 33);
                    break;
                  case 48:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 49:
                    this.begin("acc_descr_multiline");
                    break;
                  case 50:
                    this.popState();
                    break;
                  case 51:
                    return "acc_descr_multiline_value";
                  case 52:
                    return 6;
                  case 53:
                    return 18;
                  case 54:
                    return 20;
                  case 55:
                    return 65;
                  case 56:
                    return 5;
                  case 57:
                    return ((et.yytext = et.yytext.trim()), 71);
                    break;
                  case 58:
                    return 78;
                  case 59:
                    return 79;
                  case 60:
                    return 80;
                  case 61:
                    return 81;
                  case 62:
                    return 76;
                  case 63:
                    return 77;
                  case 64:
                    return 82;
                  case 65:
                    return 83;
                  case 66:
                    return 84;
                  case 67:
                    return 85;
                  case 68:
                    return 86;
                  case 69:
                    return 86;
                  case 70:
                    return 69;
                  case 71:
                    return 70;
                  case 72:
                    return 5;
                  case 73:
                    return "INVALID";
                }
              }, "anonymous"),
              rules: [
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:((?!\n)\s)+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[0-9]+(?=[ \n]+))/i,
                /^(?:@\{)/i,
                /^(?:[^\}]+)/i,
                /^(?:\})/i,
                /^(?:[^\<->\->:\n,;@\s]+(?=@\{))/i,
                /^(?:[^\<->\->:\n,;@]+?([\-]*[^\<->\->:\n,;@]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,
                /^(?:box\b)/i,
                /^(?:participant\b)/i,
                /^(?:actor\b)/i,
                /^(?:create\b)/i,
                /^(?:destroy\b)/i,
                /^(?:[^<\->\->:\n,;]+?([\-]*[^<\->\->:\n,;]+?)*?(?=((?!\n)\s)+as(?!\n)\s|[#\n;]|$))/i,
                /^(?:as\b)/i,
                /^(?:(?:))/i,
                /^(?:loop\b)/i,
                /^(?:rect\b)/i,
                /^(?:opt\b)/i,
                /^(?:alt\b)/i,
                /^(?:else\b)/i,
                /^(?:par\b)/i,
                /^(?:par_over\b)/i,
                /^(?:and\b)/i,
                /^(?:critical\b)/i,
                /^(?:option\b)/i,
                /^(?:break\b)/i,
                /^(?:(?:[:]?(?:no)?wrap)?[^#\n;]*)/i,
                /^(?:end\b)/i,
                /^(?:left of\b)/i,
                /^(?:right of\b)/i,
                /^(?:links\b)/i,
                /^(?:link\b)/i,
                /^(?:properties\b)/i,
                /^(?:details\b)/i,
                /^(?:over\b)/i,
                /^(?:note\b)/i,
                /^(?:activate\b)/i,
                /^(?:deactivate\b)/i,
                /^(?:title\s[^#\n;]+)/i,
                /^(?:title:\s[^#\n;]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:sequenceDiagram\b)/i,
                /^(?:autonumber\b)/i,
                /^(?:off\b)/i,
                /^(?:,)/i,
                /^(?:;)/i,
                /^(?:[^+<\->\->:\n,;]+((?!(-x|--x|-\)|--\)))[\-]*[^\+<\->\->:\n,;]+)*)/i,
                /^(?:->>)/i,
                /^(?:<<->>)/i,
                /^(?:-->>)/i,
                /^(?:<<-->>)/i,
                /^(?:->)/i,
                /^(?:-->)/i,
                /^(?:-[x])/i,
                /^(?:--[x])/i,
                /^(?:-[\)])/i,
                /^(?:--[\)])/i,
                /^(?::(?:(?:no)?wrap)?[^#\n;]*)/i,
                /^(?::)/i,
                /^(?:\+)/i,
                /^(?:-)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [50, 51], inclusive: !1 },
                acc_descr: { rules: [48], inclusive: !1 },
                acc_title: { rules: [46], inclusive: !1 },
                ID: { rules: [2, 3, 7, 10, 11, 17], inclusive: !1 },
                ALIAS: { rules: [2, 3, 18, 19], inclusive: !1 },
                LINE: { rules: [2, 3, 31], inclusive: !1 },
                CONFIG: { rules: [8, 9], inclusive: !1 },
                CONFIG_DATA: { rules: [], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 3, 4, 5, 6, 12, 13, 14, 15, 16, 20, 21, 22, 23, 24,
                    25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40,
                    41, 42, 43, 44, 45, 47, 49, 52, 53, 54, 55, 56, 57, 58, 59,
                    60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73,
                  ],
                  inclusive: !0,
                },
              },
            };
            return dt;
          })();
        ft.lexer = yt;
        function ot() {
          this.yy = {};
        }
        return (
          a(ot, "Parser"),
          (ot.prototype = ft),
          (ft.Parser = ot),
          new ot()
        );
      })();
      pN.parser = pN;
      Lnt = pN;
    });
  var RRt,
    DRt,
    NRt,
    Gy,
    I_,
    mN = x(() => {
      "use strict";
      pe();
      v0();
      Vt();
      ED();
      Be();
      yn();
      ((RRt = {
        SOLID: 0,
        DOTTED: 1,
        NOTE: 2,
        SOLID_CROSS: 3,
        DOTTED_CROSS: 4,
        SOLID_OPEN: 5,
        DOTTED_OPEN: 6,
        LOOP_START: 10,
        LOOP_END: 11,
        ALT_START: 12,
        ALT_ELSE: 13,
        ALT_END: 14,
        OPT_START: 15,
        OPT_END: 16,
        ACTIVE_START: 17,
        ACTIVE_END: 18,
        PAR_START: 19,
        PAR_AND: 20,
        PAR_END: 21,
        RECT_START: 22,
        RECT_END: 23,
        SOLID_POINT: 24,
        DOTTED_POINT: 25,
        AUTONUMBER: 26,
        CRITICAL_START: 27,
        CRITICAL_OPTION: 28,
        CRITICAL_END: 29,
        BREAK_START: 30,
        BREAK_END: 31,
        PAR_OVER_START: 32,
        BIDIRECTIONAL_SOLID: 33,
        BIDIRECTIONAL_DOTTED: 34,
      }),
        (DRt = { FILLED: 0, OPEN: 1 }),
        (NRt = { LEFTOF: 0, RIGHTOF: 1, OVER: 2 }),
        (Gy = {
          ACTOR: "actor",
          BOUNDARY: "boundary",
          COLLECTIONS: "collections",
          CONTROL: "control",
          DATABASE: "database",
          ENTITY: "entity",
          PARTICIPANT: "participant",
          QUEUE: "queue",
        }),
        (I_ = class {
          constructor() {
            this.state = new ym(() => ({
              prevActor: void 0,
              actors: new Map(),
              createdActors: new Map(),
              destroyedActors: new Map(),
              boxes: [],
              messages: [],
              notes: [],
              sequenceNumbersEnabled: !1,
              wrapEnabled: void 0,
              currentBox: void 0,
              lastCreated: void 0,
              lastDestroyed: void 0,
            }));
            this.setAccTitle = Xe;
            this.setAccDescription = er;
            this.setDiagramTitle = lr;
            this.getAccTitle = tr;
            this.getAccDescription = rr;
            this.getDiagramTitle = nr;
            ((this.apply = this.apply.bind(this)),
              (this.parseBoxData = this.parseBoxData.bind(this)),
              (this.parseMessage = this.parseMessage.bind(this)),
              this.clear(),
              this.setWrap(K().wrap),
              (this.LINETYPE = RRt),
              (this.ARROWTYPE = DRt),
              (this.PLACEMENT = NRt));
          }
          static {
            a(this, "SequenceDB");
          }
          addBox(t) {
            (this.state.records.boxes.push({
              name: t.text,
              wrap: t.wrap ?? this.autoWrap(),
              fill: t.color,
              actorKeys: [],
            }),
              (this.state.records.currentBox =
                this.state.records.boxes.slice(-1)[0]));
          }
          addActor(t, r, n, i, s) {
            let o = this.state.records.currentBox,
              l;
            if (s !== void 0) {
              let h;
              (s.includes(`
`)
                ? (h =
                    s +
                    `
`)
                : (h =
                    `{
` +
                    s +
                    `
}`),
                (l = wc(h, { schema: Cc })));
            }
            i = l?.type ?? i;
            let u = this.state.records.actors.get(t);
            if (u) {
              if (
                this.state.records.currentBox &&
                u.box &&
                this.state.records.currentBox !== u.box
              )
                throw new Error(
                  `A same participant should only be defined in one Box: ${u.name} can't be in '${u.box.name}' and in '${this.state.records.currentBox.name}' at the same time.`,
                );
              if (
                ((o = u.box ? u.box : this.state.records.currentBox),
                (u.box = o),
                u && r === u.name && n == null)
              )
                return;
            }
            if (
              (n?.text == null && (n = { text: r, type: i }),
              (i == null || n.text == null) && (n = { text: r, type: i }),
              this.state.records.actors.set(t, {
                box: o,
                name: r,
                description: n.text,
                wrap: n.wrap ?? this.autoWrap(),
                prevActor: this.state.records.prevActor,
                links: {},
                properties: {},
                actorCnt: null,
                rectData: null,
                type: i ?? "participant",
              }),
              this.state.records.prevActor)
            ) {
              let h = this.state.records.actors.get(
                this.state.records.prevActor,
              );
              h && (h.nextActor = t);
            }
            (this.state.records.currentBox &&
              this.state.records.currentBox.actorKeys.push(t),
              (this.state.records.prevActor = t));
          }
          activationCount(t) {
            let r,
              n = 0;
            if (!t) return 0;
            for (r = 0; r < this.state.records.messages.length; r++)
              (this.state.records.messages[r].type ===
                this.LINETYPE.ACTIVE_START &&
                this.state.records.messages[r].from === t &&
                n++,
                this.state.records.messages[r].type ===
                  this.LINETYPE.ACTIVE_END &&
                  this.state.records.messages[r].from === t &&
                  n--);
            return n;
          }
          addMessage(t, r, n, i) {
            this.state.records.messages.push({
              id: this.state.records.messages.length.toString(),
              from: t,
              to: r,
              message: n.text,
              wrap: n.wrap ?? this.autoWrap(),
              answer: i,
            });
          }
          addSignal(t, r, n, i, s = !1) {
            if (
              i === this.LINETYPE.ACTIVE_END &&
              this.activationCount(t ?? "") < 1
            ) {
              let l = new Error(
                "Trying to inactivate an inactive participant (" + t + ")",
              );
              throw (
                (l.hash = {
                  text: "->>-",
                  token: "->>-",
                  line: "1",
                  loc: {
                    first_line: 1,
                    last_line: 1,
                    first_column: 1,
                    last_column: 1,
                  },
                  expected: ["'ACTIVE_PARTICIPANT'"],
                }),
                l
              );
            }
            return (
              this.state.records.messages.push({
                id: this.state.records.messages.length.toString(),
                from: t,
                to: r,
                message: n?.text ?? "",
                wrap: n?.wrap ?? this.autoWrap(),
                type: i,
                activate: s,
              }),
              !0
            );
          }
          hasAtLeastOneBox() {
            return this.state.records.boxes.length > 0;
          }
          hasAtLeastOneBoxWithTitle() {
            return this.state.records.boxes.some((t) => t.name);
          }
          getMessages() {
            return this.state.records.messages;
          }
          getBoxes() {
            return this.state.records.boxes;
          }
          getActors() {
            return this.state.records.actors;
          }
          getCreatedActors() {
            return this.state.records.createdActors;
          }
          getDestroyedActors() {
            return this.state.records.destroyedActors;
          }
          getActor(t) {
            return this.state.records.actors.get(t);
          }
          getActorKeys() {
            return [...this.state.records.actors.keys()];
          }
          enableSequenceNumbers() {
            this.state.records.sequenceNumbersEnabled = !0;
          }
          disableSequenceNumbers() {
            this.state.records.sequenceNumbersEnabled = !1;
          }
          showSequenceNumbers() {
            return this.state.records.sequenceNumbersEnabled;
          }
          setWrap(t) {
            this.state.records.wrapEnabled = t;
          }
          extractWrap(t) {
            if (t === void 0) return {};
            t = t.trim();
            let r =
              /^:?wrap:/.exec(t) !== null
                ? !0
                : /^:?nowrap:/.exec(t) !== null
                  ? !1
                  : void 0;
            return {
              cleanedText: (r === void 0
                ? t
                : t.replace(/^:?(?:no)?wrap:/, "")
              ).trim(),
              wrap: r,
            };
          }
          autoWrap() {
            return this.state.records.wrapEnabled !== void 0
              ? this.state.records.wrapEnabled
              : (K().sequence?.wrap ?? !1);
          }
          clear() {
            (this.state.reset(), Ye());
          }
          parseMessage(t) {
            let r = t.trim(),
              { wrap: n, cleanedText: i } = this.extractWrap(r),
              s = { text: i, wrap: n };
            return (P.debug(`parseMessage: ${JSON.stringify(s)}`), s);
          }
          parseBoxData(t) {
            let r = /^((?:rgba?|hsla?)\s*\(.*\)|\w*)(.*)$/.exec(t),
              n = r?.[1] ? r[1].trim() : "transparent",
              i = r?.[2] ? r[2].trim() : void 0;
            if (window?.CSS)
              window.CSS.supports("color", n) ||
                ((n = "transparent"), (i = t.trim()));
            else {
              let l = new Option().style;
              ((l.color = n),
                l.color !== n && ((n = "transparent"), (i = t.trim())));
            }
            let { wrap: s, cleanedText: o } = this.extractWrap(i);
            return { text: o ? Ie(o, K()) : void 0, color: n, wrap: s };
          }
          addNote(t, r, n) {
            let i = {
                actor: t,
                placement: r,
                message: n.text,
                wrap: n.wrap ?? this.autoWrap(),
              },
              s = [].concat(t, t);
            (this.state.records.notes.push(i),
              this.state.records.messages.push({
                id: this.state.records.messages.length.toString(),
                from: s[0],
                to: s[1],
                message: n.text,
                wrap: n.wrap ?? this.autoWrap(),
                type: this.LINETYPE.NOTE,
                placement: r,
              }));
          }
          addLinks(t, r) {
            let n = this.getActor(t);
            try {
              let i = Ie(r.text, K());
              ((i = i.replace(/&equals;/g, "=")),
                (i = i.replace(/&amp;/g, "&")));
              let s = JSON.parse(i);
              this.insertLinks(n, s);
            } catch (i) {
              P.error("error while parsing actor link text", i);
            }
          }
          addALink(t, r) {
            let n = this.getActor(t);
            try {
              let i = {},
                s = Ie(r.text, K()),
                o = s.indexOf("@");
              ((s = s.replace(/&equals;/g, "=")),
                (s = s.replace(/&amp;/g, "&")));
              let l = s.slice(0, o - 1).trim(),
                u = s.slice(o + 1).trim();
              ((i[l] = u), this.insertLinks(n, i));
            } catch (i) {
              P.error("error while parsing actor link text", i);
            }
          }
          insertLinks(t, r) {
            if (t.links == null) t.links = r;
            else for (let n in r) t.links[n] = r[n];
          }
          addProperties(t, r) {
            let n = this.getActor(t);
            try {
              let i = Ie(r.text, K()),
                s = JSON.parse(i);
              this.insertProperties(n, s);
            } catch (i) {
              P.error("error while parsing actor properties text", i);
            }
          }
          insertProperties(t, r) {
            if (t.properties == null) t.properties = r;
            else for (let n in r) t.properties[n] = r[n];
          }
          boxEnd() {
            this.state.records.currentBox = void 0;
          }
          addDetails(t, r) {
            let n = this.getActor(t),
              i = document.getElementById(r.text);
            try {
              let s = i.innerHTML,
                o = JSON.parse(s);
              (o.properties && this.insertProperties(n, o.properties),
                o.links && this.insertLinks(n, o.links));
            } catch (s) {
              P.error("error while parsing actor details text", s);
            }
          }
          getActorProperty(t, r) {
            if (t?.properties !== void 0) return t.properties[r];
          }
          apply(t) {
            if (Array.isArray(t))
              t.forEach((r) => {
                this.apply(r);
              });
            else
              switch (t.type) {
                case "sequenceIndex":
                  this.state.records.messages.push({
                    id: this.state.records.messages.length.toString(),
                    from: void 0,
                    to: void 0,
                    message: {
                      start: t.sequenceIndex,
                      step: t.sequenceIndexStep,
                      visible: t.sequenceVisible,
                    },
                    wrap: !1,
                    type: t.signalType,
                  });
                  break;
                case "addParticipant":
                  this.addActor(
                    t.actor,
                    t.actor,
                    t.description,
                    t.draw,
                    t.config,
                  );
                  break;
                case "createParticipant":
                  if (this.state.records.actors.has(t.actor))
                    throw new Error(
                      "It is not possible to have actors with the same id, even if one is destroyed before the next is created. Use 'AS' aliases to simulate the behavior",
                    );
                  ((this.state.records.lastCreated = t.actor),
                    this.addActor(
                      t.actor,
                      t.actor,
                      t.description,
                      t.draw,
                      t.config,
                    ),
                    this.state.records.createdActors.set(
                      t.actor,
                      this.state.records.messages.length,
                    ));
                  break;
                case "destroyParticipant":
                  ((this.state.records.lastDestroyed = t.actor),
                    this.state.records.destroyedActors.set(
                      t.actor,
                      this.state.records.messages.length,
                    ));
                  break;
                case "activeStart":
                  this.addSignal(t.actor, void 0, void 0, t.signalType);
                  break;
                case "activeEnd":
                  this.addSignal(t.actor, void 0, void 0, t.signalType);
                  break;
                case "addNote":
                  this.addNote(t.actor, t.placement, t.text);
                  break;
                case "addLinks":
                  this.addLinks(t.actor, t.text);
                  break;
                case "addALink":
                  this.addALink(t.actor, t.text);
                  break;
                case "addProperties":
                  this.addProperties(t.actor, t.text);
                  break;
                case "addDetails":
                  this.addDetails(t.actor, t.text);
                  break;
                case "addMessage":
                  if (this.state.records.lastCreated) {
                    if (t.to !== this.state.records.lastCreated)
                      throw new Error(
                        "The created participant " +
                          this.state.records.lastCreated.name +
                          " does not have an associated creating message after its declaration. Please check the sequence diagram.",
                      );
                    this.state.records.lastCreated = void 0;
                  } else if (this.state.records.lastDestroyed) {
                    if (
                      t.to !== this.state.records.lastDestroyed &&
                      t.from !== this.state.records.lastDestroyed
                    )
                      throw new Error(
                        "The destroyed participant " +
                          this.state.records.lastDestroyed.name +
                          " does not have an associated destroying message after its declaration. Please check the sequence diagram.",
                      );
                    this.state.records.lastDestroyed = void 0;
                  }
                  this.addSignal(t.from, t.to, t.msg, t.signalType, t.activate);
                  break;
                case "boxStart":
                  this.addBox(t.boxData);
                  break;
                case "boxEnd":
                  this.boxEnd();
                  break;
                case "loopStart":
                  this.addSignal(void 0, void 0, t.loopText, t.signalType);
                  break;
                case "loopEnd":
                  this.addSignal(void 0, void 0, void 0, t.signalType);
                  break;
                case "rectStart":
                  this.addSignal(void 0, void 0, t.color, t.signalType);
                  break;
                case "rectEnd":
                  this.addSignal(void 0, void 0, void 0, t.signalType);
                  break;
                case "optStart":
                  this.addSignal(void 0, void 0, t.optText, t.signalType);
                  break;
                case "optEnd":
                  this.addSignal(void 0, void 0, void 0, t.signalType);
                  break;
                case "altStart":
                  this.addSignal(void 0, void 0, t.altText, t.signalType);
                  break;
                case "else":
                  this.addSignal(void 0, void 0, t.altText, t.signalType);
                  break;
                case "altEnd":
                  this.addSignal(void 0, void 0, void 0, t.signalType);
                  break;
                case "setAccTitle":
                  Xe(t.text);
                  break;
                case "parStart":
                  this.addSignal(void 0, void 0, t.parText, t.signalType);
                  break;
                case "and":
                  this.addSignal(void 0, void 0, t.parText, t.signalType);
                  break;
                case "parEnd":
                  this.addSignal(void 0, void 0, void 0, t.signalType);
                  break;
                case "criticalStart":
                  this.addSignal(void 0, void 0, t.criticalText, t.signalType);
                  break;
                case "option":
                  this.addSignal(void 0, void 0, t.optionText, t.signalType);
                  break;
                case "criticalEnd":
                  this.addSignal(void 0, void 0, void 0, t.signalType);
                  break;
                case "breakStart":
                  this.addSignal(void 0, void 0, t.breakText, t.signalType);
                  break;
                case "breakEnd":
                  this.addSignal(void 0, void 0, void 0, t.signalType);
                  break;
              }
          }
          getConfig() {
            return K().sequence;
          }
        }));
    });
  var IRt,
    Dnt,
    Nnt = x(() => {
      "use strict";
      ((IRt = a(
        (e) => `.actor {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }

  text.actor > tspan {
    fill: ${e.actorTextColor};
    stroke: none;
  }

  .actor-line {
    stroke: ${e.actorLineColor};
  }
  
  .innerArc {
    stroke-width: 1.5;
    stroke-dasharray: none;
  }

  .messageLine0 {
    stroke-width: 1.5;
    stroke-dasharray: none;
    stroke: ${e.signalColor};
  }

  .messageLine1 {
    stroke-width: 1.5;
    stroke-dasharray: 2, 2;
    stroke: ${e.signalColor};
  }

  #arrowhead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .sequenceNumber {
    fill: ${e.sequenceNumberColor};
  }

  #sequencenumber {
    fill: ${e.signalColor};
  }

  #crosshead path {
    fill: ${e.signalColor};
    stroke: ${e.signalColor};
  }

  .messageText {
    fill: ${e.signalTextColor};
    stroke: none;
  }

  .labelBox {
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBkgColor};
  }

  .labelText, .labelText > tspan {
    fill: ${e.labelTextColor};
    stroke: none;
  }

  .loopText, .loopText > tspan {
    fill: ${e.loopTextColor};
    stroke: none;
  }

  .loopLine {
    stroke-width: 2px;
    stroke-dasharray: 2, 2;
    stroke: ${e.labelBoxBorderColor};
    fill: ${e.labelBoxBorderColor};
  }

  .note {
    //stroke: #decc93;
    stroke: ${e.noteBorderColor};
    fill: ${e.noteBkgColor};
  }

  .noteText, .noteText > tspan {
    fill: ${e.noteTextColor};
    stroke: none;
  }

  .activation0 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation1 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .activation2 {
    fill: ${e.activationBkgColor};
    stroke: ${e.activationBorderColor};
  }

  .actorPopupMenu {
    position: absolute;
  }

  .actorPopupMenuPanel {
    position: absolute;
    fill: ${e.actorBkg};
    box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    filter: drop-shadow(3px 5px 2px rgb(0 0 0 / 0.4));
}
  .actor-man line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
  }
  .actor-man circle, line {
    stroke: ${e.actorBorder};
    fill: ${e.actorBkg};
    stroke-width: 2px;
  }

`,
        "getStyles",
      )),
        (Dnt = IRt));
    });
  var gN,
    tu,
    ru,
    nu,
    M_,
    eu,
    Vy,
    MRt,
    O_,
    zy,
    Kh,
    Int,
    Ke,
    yN,
    ORt,
    PRt,
    BRt,
    FRt,
    $Rt,
    GRt,
    VRt,
    zRt,
    WRt,
    URt,
    jRt,
    qRt,
    HRt,
    Mnt,
    YRt,
    XRt,
    KRt,
    QRt,
    ZRt,
    JRt,
    tDt,
    Ont,
    eDt,
    Gl,
    rDt,
    pn,
    Pnt = x(() => {
      "use strict";
      gN = Ts(Vf(), 1);
      un();
      _e();
      Be();
      a0();
      ((tu = 18 * 2),
        (ru = "actor-top"),
        (nu = "actor-bottom"),
        (M_ = "actor-box"),
        (eu = "actor-man"),
        (Vy = a(function (e, t) {
          return Vu(e, t);
        }, "drawRect")),
        (MRt = a(function (e, t, r, n, i) {
          if (
            t.links === void 0 ||
            t.links === null ||
            Object.keys(t.links).length === 0
          )
            return { height: 0, width: 0 };
          let s = t.links,
            o = t.actorCnt,
            l = t.rectData;
          var u = "none";
          i && (u = "block !important");
          let h = e.append("g");
          (h.attr("id", "actor" + o + "_popup"),
            h.attr("class", "actorPopupMenu"),
            h.attr("display", u));
          var f = "";
          l.class !== void 0 && (f = " " + l.class);
          let d = l.width > r ? l.width : r,
            p = h.append("rect");
          if (
            (p.attr("class", "actorPopupMenuPanel" + f),
            p.attr("x", l.x),
            p.attr("y", l.height),
            p.attr("fill", l.fill),
            p.attr("stroke", l.stroke),
            p.attr("width", d),
            p.attr("height", l.height),
            p.attr("rx", l.rx),
            p.attr("ry", l.ry),
            s != null)
          ) {
            var m = 20;
            for (let b in s) {
              var g = h.append("a"),
                y = (0, gN.sanitizeUrl)(s[b]);
              (g.attr("xlink:href", y),
                g.attr("target", "_blank"),
                rDt(n)(
                  b,
                  g,
                  l.x + 10,
                  l.height + m,
                  d,
                  20,
                  { class: "actor" },
                  n,
                ),
                (m += 30));
            }
          }
          return (p.attr("height", m), { height: l.height + m, width: d });
        }, "drawPopup")),
        (O_ = a(function (e) {
          return (
            "var pu = document.getElementById('" +
            e +
            "'); if (pu != null) { pu.style.display = pu.style.display == 'block' ? 'none' : 'block'; }"
          );
        }, "popupMenuToggle")),
        (zy = a(async function (e, t, r = null) {
          let n = e.append("foreignObject"),
            i = await Kl(t.text, ke()),
            o = n
              .append("xhtml:div")
              .attr("style", "width: fit-content;")
              .attr("xmlns", "http://www.w3.org/1999/xhtml")
              .html(i)
              .node()
              .getBoundingClientRect();
          if (
            (n
              .attr("height", Math.round(o.height))
              .attr("width", Math.round(o.width)),
            t.class === "noteText")
          ) {
            let l = e.node().firstChild;
            l.setAttribute("height", o.height + 2 * t.textMargin);
            let u = l.getBBox();
            n.attr("x", Math.round(u.x + u.width / 2 - o.width / 2)).attr(
              "y",
              Math.round(u.y + u.height / 2 - o.height / 2),
            );
          } else if (r) {
            let { startx: l, stopx: u, starty: h } = r;
            if (l > u) {
              let f = l;
              ((l = u), (u = f));
            }
            (n.attr("x", Math.round(l + Math.abs(l - u) / 2 - o.width / 2)),
              t.class === "loopText"
                ? n.attr("y", Math.round(h))
                : n.attr("y", Math.round(h - o.height)));
          }
          return [n];
        }, "drawKatex")),
        (Kh = a(function (e, t) {
          let r = 0,
            n = 0,
            i = t.text.split(Rt.lineBreakRegex),
            [s, o] = xo(t.fontSize),
            l = [],
            u = 0,
            h = a(() => t.y, "yfunc");
          if (
            t.valign !== void 0 &&
            t.textMargin !== void 0 &&
            t.textMargin > 0
          )
            switch (t.valign) {
              case "top":
              case "start":
                h = a(() => Math.round(t.y + t.textMargin), "yfunc");
                break;
              case "middle":
              case "center":
                h = a(
                  () => Math.round(t.y + (r + n + t.textMargin) / 2),
                  "yfunc",
                );
                break;
              case "bottom":
              case "end":
                h = a(
                  () =>
                    Math.round(t.y + (r + n + 2 * t.textMargin) - t.textMargin),
                  "yfunc",
                );
                break;
            }
          if (
            t.anchor !== void 0 &&
            t.textMargin !== void 0 &&
            t.width !== void 0
          )
            switch (t.anchor) {
              case "left":
              case "start":
                ((t.x = Math.round(t.x + t.textMargin)),
                  (t.anchor = "start"),
                  (t.dominantBaseline = "middle"),
                  (t.alignmentBaseline = "middle"));
                break;
              case "middle":
              case "center":
                ((t.x = Math.round(t.x + t.width / 2)),
                  (t.anchor = "middle"),
                  (t.dominantBaseline = "middle"),
                  (t.alignmentBaseline = "middle"));
                break;
              case "right":
              case "end":
                ((t.x = Math.round(t.x + t.width - t.textMargin)),
                  (t.anchor = "end"),
                  (t.dominantBaseline = "middle"),
                  (t.alignmentBaseline = "middle"));
                break;
            }
          for (let [f, d] of i.entries()) {
            t.textMargin !== void 0 &&
              t.textMargin === 0 &&
              s !== void 0 &&
              (u = f * s);
            let p = e.append("text");
            (p.attr("x", t.x),
              p.attr("y", h()),
              t.anchor !== void 0 &&
                p
                  .attr("text-anchor", t.anchor)
                  .attr("dominant-baseline", t.dominantBaseline)
                  .attr("alignment-baseline", t.alignmentBaseline),
              t.fontFamily !== void 0 && p.style("font-family", t.fontFamily),
              o !== void 0 && p.style("font-size", o),
              t.fontWeight !== void 0 && p.style("font-weight", t.fontWeight),
              t.fill !== void 0 && p.attr("fill", t.fill),
              t.class !== void 0 && p.attr("class", t.class),
              t.dy !== void 0
                ? p.attr("dy", t.dy)
                : u !== 0 && p.attr("dy", u));
            let m = d || C4;
            if (t.tspan) {
              let g = p.append("tspan");
              (g.attr("x", t.x),
                t.fill !== void 0 && g.attr("fill", t.fill),
                g.text(m));
            } else p.text(m);
            (t.valign !== void 0 &&
              t.textMargin !== void 0 &&
              t.textMargin > 0 &&
              ((n += (p._groups || p)[0][0].getBBox().height), (r = n)),
              l.push(p));
          }
          return l;
        }, "drawText")),
        (Int = a(function (e, t) {
          function r(i, s, o, l, u) {
            return (
              i +
              "," +
              s +
              " " +
              (i + o) +
              "," +
              s +
              " " +
              (i + o) +
              "," +
              (s + l - u) +
              " " +
              (i + o - u * 1.2) +
              "," +
              (s + l) +
              " " +
              i +
              "," +
              (s + l)
            );
          }
          a(r, "genPoints");
          let n = e.append("polygon");
          return (
            n.attr("points", r(t.x, t.y, t.width, t.height, 7)),
            n.attr("class", "labelBox"),
            (t.y = t.y + t.height / 2),
            Kh(e, t),
            n
          );
        }, "drawLabel")),
        (Ke = -1),
        (yN = a((e, t, r, n) => {
          e.select &&
            r.forEach((i) => {
              let s = t.get(i),
                o = e.select("#actor" + s.actorCnt);
              !n.mirrorActors && s.stopy
                ? o.attr("y2", s.stopy + s.height / 2)
                : n.mirrorActors && o.attr("y2", s.stopy);
            });
        }, "fixLifeLineHeights")),
        (ORt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height,
            l = e.append("g").lower();
          var u = l;
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u
                .attr("onclick", O_(`actor${Ke}_popup`))
                .attr("cursor", "pointer"),
            u
              .append("line")
              .attr("id", "actor" + Ke)
              .attr("x1", s)
              .attr("y1", o)
              .attr("x2", s)
              .attr("y2", 2e3)
              .attr("class", "actor-line 200")
              .attr("stroke-width", "0.5px")
              .attr("stroke", "#999")
              .attr("name", t.name),
            (u = l.append("g")),
            (t.actorCnt = Ke),
            t.links != null && u.attr("id", "root-" + Ke));
          let h = ri();
          var f = "actor";
          (t.properties?.class
            ? (f = t.properties.class)
            : (h.fill = "#eaeaea"),
            n ? (f += ` ${nu}`) : (f += ` ${ru}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.rx = 3),
            (h.ry = 3),
            (h.name = t.name));
          let d = Vy(u, h);
          if (((t.rectData = h), t.properties?.icon)) {
            let m = t.properties.icon.trim();
            m.charAt(0) === "@"
              ? q2(u, h.x + h.width - 20, h.y + 10, m.substr(1))
              : j2(u, h.x + h.width - 20, h.y + 10, m);
          }
          Gl(r, $r(t.description))(
            t.description,
            u,
            h.x,
            h.y,
            h.width,
            h.height,
            { class: `actor ${M_}` },
            r,
          );
          let p = t.height;
          if (d.node) {
            let m = d.node().getBBox();
            ((t.height = m.height), (p = m.height));
          }
          return p;
        }, "drawActorTypeParticipant")),
        (PRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height,
            l = e.append("g").lower();
          var u = l;
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u
                .attr("onclick", O_(`actor${Ke}_popup`))
                .attr("cursor", "pointer"),
            u
              .append("line")
              .attr("id", "actor" + Ke)
              .attr("x1", s)
              .attr("y1", o)
              .attr("x2", s)
              .attr("y2", 2e3)
              .attr("class", "actor-line 200")
              .attr("stroke-width", "0.5px")
              .attr("stroke", "#999")
              .attr("name", t.name),
            (u = l.append("g")),
            (t.actorCnt = Ke),
            t.links != null && u.attr("id", "root-" + Ke));
          let h = ri();
          var f = "actor";
          (t.properties?.class
            ? (f = t.properties.class)
            : (h.fill = "#eaeaea"),
            n ? (f += ` ${nu}`) : (f += ` ${ru}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.name = t.name));
          let d = 6,
            p = { ...h, x: h.x + -d, y: h.y + +d, class: "actor" },
            m = Vy(u, h);
          if ((Vy(u, p), (t.rectData = h), t.properties?.icon)) {
            let y = t.properties.icon.trim();
            y.charAt(0) === "@"
              ? q2(u, h.x + h.width - 20, h.y + 10, y.substr(1))
              : j2(u, h.x + h.width - 20, h.y + 10, y);
          }
          Gl(r, $r(t.description))(
            t.description,
            u,
            h.x - d,
            h.y + d,
            h.width,
            h.height,
            { class: `actor ${M_}` },
            r,
          );
          let g = t.height;
          if (m.node) {
            let y = m.node().getBBox();
            ((t.height = y.height), (g = y.height));
          }
          return g;
        }, "drawActorTypeCollections")),
        (BRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height,
            l = e.append("g").lower(),
            u = l;
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u
                .attr("onclick", O_(`actor${Ke}_popup`))
                .attr("cursor", "pointer"),
            u
              .append("line")
              .attr("id", "actor" + Ke)
              .attr("x1", s)
              .attr("y1", o)
              .attr("x2", s)
              .attr("y2", 2e3)
              .attr("class", "actor-line 200")
              .attr("stroke-width", "0.5px")
              .attr("stroke", "#999")
              .attr("name", t.name),
            (u = l.append("g")),
            (t.actorCnt = Ke),
            t.links != null && u.attr("id", "root-" + Ke));
          let h = ri(),
            f = "actor";
          (t.properties?.class
            ? (f = t.properties.class)
            : (h.fill = "#eaeaea"),
            n ? (f += ` ${nu}`) : (f += ` ${ru}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.name = t.name));
          let d = h.height / 2,
            p = d / (2.5 + h.height / 50),
            m = u.append("g"),
            g = u.append("g");
          if (
            (m
              .append("path")
              .attr(
                "d",
                `M ${h.x},${h.y + d}
    a ${p},${d} 0 0 0 0,${h.height}
    h ${h.width - 2 * p}
    a ${p},${d} 0 0 0 0,-${h.height}
    Z
  `,
              )
              .attr("class", f),
            g
              .append("path")
              .attr(
                "d",
                `M ${h.x},${h.y + d}
      a ${p},${d} 0 0 0 0,${h.height}`,
              )
              .attr("stroke", "#666")
              .attr("stroke-width", "1px")
              .attr("class", f),
            m.attr("transform", `translate(${p}, ${-(h.height / 2)})`),
            g.attr("transform", `translate(${h.width - p}, ${-h.height / 2})`),
            (t.rectData = h),
            t.properties?.icon)
          ) {
            let k = t.properties.icon.trim(),
              T = h.x + h.width - 20,
              C = h.y + 10;
            k.charAt(0) === "@" ? q2(u, T, C, k.substr(1)) : j2(u, T, C, k);
          }
          Gl(r, $r(t.description))(
            t.description,
            u,
            h.x,
            h.y,
            h.width,
            h.height,
            { class: `actor ${M_}` },
            r,
          );
          let y = t.height,
            b = m.select("path:last-child");
          if (b.node()) {
            let k = b.node().getBBox();
            ((t.height = k.height), (y = k.height));
          }
          return y;
        }, "drawActorTypeQueue")),
        (FRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 75,
            l = e.append("g").lower();
          n ||
            (Ke++,
            l
              .append("line")
              .attr("id", "actor" + Ke)
              .attr("x1", s)
              .attr("y1", o)
              .attr("x2", s)
              .attr("y2", 2e3)
              .attr("class", "actor-line 200")
              .attr("stroke-width", "0.5px")
              .attr("stroke", "#999")
              .attr("name", t.name),
            (t.actorCnt = Ke));
          let u = e.append("g"),
            h = eu;
          (n ? (h += ` ${nu}`) : (h += ` ${ru}`),
            u.attr("class", h),
            u.attr("name", t.name));
          let f = ri();
          ((f.x = t.x),
            (f.y = i),
            (f.fill = "#eaeaea"),
            (f.width = t.width),
            (f.height = t.height),
            (f.class = "actor"));
          let d = t.x + t.width / 2,
            p = i + 30,
            m = 18;
          (u
            .append("defs")
            .append("marker")
            .attr("id", "filled-head-control")
            .attr("refX", 11)
            .attr("refY", 5.8)
            .attr("markerWidth", 20)
            .attr("markerHeight", 28)
            .attr("orient", "172.5")
            .append("path")
            .attr("d", "M 14.4 5.6 L 7.2 10.4 L 8.8 5.6 L 7.2 0.8 Z"),
            u
              .append("circle")
              .attr("cx", d)
              .attr("cy", p)
              .attr("r", m)
              .attr("fill", "#eaeaf7")
              .attr("stroke", "#666")
              .attr("stroke-width", 1.2),
            u
              .append("line")
              .attr("marker-end", "url(#filled-head-control)")
              .attr("transform", `translate(${d}, ${p - m})`));
          let g = u.node().getBBox();
          return (
            (t.height = g.height + 2 * (r?.sequence?.labelBoxHeight ?? 0)),
            Gl(r, $r(t.description))(
              t.description,
              u,
              f.x,
              f.y + m + (n ? 5 : 10),
              f.width,
              f.height,
              { class: `actor ${eu}` },
              r,
            ),
            t.height
          );
        }, "drawActorTypeControl")),
        ($Rt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 75,
            l = e.append("g").lower(),
            u = e.append("g"),
            h = eu;
          (n ? (h += ` ${nu}`) : (h += ` ${ru}`),
            u.attr("class", h),
            u.attr("name", t.name));
          let f = ri();
          ((f.x = t.x),
            (f.y = i),
            (f.fill = "#eaeaea"),
            (f.width = t.width),
            (f.height = t.height),
            (f.class = "actor"));
          let d = t.x + t.width / 2,
            p = i + (n ? 10 : 25),
            m = 18;
          (u
            .append("circle")
            .attr("cx", d)
            .attr("cy", p)
            .attr("r", m)
            .attr("width", t.width)
            .attr("height", t.height),
            u
              .append("line")
              .attr("x1", d - m)
              .attr("x2", d + m)
              .attr("y1", p + m)
              .attr("y2", p + m)
              .attr("stroke", "#333")
              .attr("stroke-width", 2));
          let g = u.node().getBBox();
          return (
            (t.height = g.height + (r?.sequence?.labelBoxHeight ?? 0)),
            n ||
              (Ke++,
              l
                .append("line")
                .attr("id", "actor" + Ke)
                .attr("x1", s)
                .attr("y1", o)
                .attr("x2", s)
                .attr("y2", 2e3)
                .attr("class", "actor-line 200")
                .attr("stroke-width", "0.5px")
                .attr("stroke", "#999")
                .attr("name", t.name),
              (t.actorCnt = Ke)),
            Gl(r, $r(t.description))(
              t.description,
              u,
              f.x,
              f.y + (n ? (p - i + m - 5) / 2 : (p + m - i) / 2),
              f.width,
              f.height,
              { class: `actor ${eu}` },
              r,
            ),
            n
              ? u.attr("transform", `translate(0, ${m / 2})`)
              : u.attr("transform", `translate(0, ${m / 2})`),
            t.height
          );
        }, "drawActorTypeEntity")),
        (GRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + t.height + 2 * r.boxTextMargin,
            l = e.append("g").lower(),
            u = l;
          n ||
            (Ke++,
            Object.keys(t.links || {}).length &&
              !r.forceMenus &&
              u
                .attr("onclick", O_(`actor${Ke}_popup`))
                .attr("cursor", "pointer"),
            u
              .append("line")
              .attr("id", "actor" + Ke)
              .attr("x1", s)
              .attr("y1", o)
              .attr("x2", s)
              .attr("y2", 2e3)
              .attr("class", "actor-line 200")
              .attr("stroke-width", "0.5px")
              .attr("stroke", "#999")
              .attr("name", t.name),
            (u = l.append("g")),
            (t.actorCnt = Ke),
            t.links != null && u.attr("id", "root-" + Ke));
          let h = ri(),
            f = "actor";
          (t.properties?.class
            ? (f = t.properties.class)
            : (h.fill = "#eaeaea"),
            n ? (f += ` ${nu}`) : (f += ` ${ru}`),
            (h.x = t.x),
            (h.y = i),
            (h.width = t.width),
            (h.height = t.height),
            (h.class = f),
            (h.name = t.name),
            (h.x = t.x),
            (h.y = i));
          let d = h.width / 4,
            p = h.width / 4,
            m = d / 2,
            g = m / (2.5 + d / 50),
            y = u.append("g"),
            b = `
  M ${h.x},${h.y + g}
  a ${m},${g} 0 0 0 ${d},0
  a ${m},${g} 0 0 0 -${d},0
  l 0,${p - 2 * g}
  a ${m},${g} 0 0 0 ${d},0
  l 0,-${p - 2 * g}
`;
          (y
            .append("path")
            .attr("d", b)
            .attr("fill", "#eaeaea")
            .attr("stroke", "#000")
            .attr("stroke-width", 1)
            .attr("class", f),
            n
              ? y.attr(
                  "transform",
                  `translate(${d * 1.5}, ${h.height / 4 - 2 * g})`,
                )
              : y.attr(
                  "transform",
                  `translate(${d * 1.5}, ${(h.height + g) / 4})`,
                ),
            (t.rectData = h),
            Gl(r, $r(t.description))(
              t.description,
              u,
              h.x,
              h.y + (n ? (h.height + p) / 4 : (h.height + g) / 2),
              h.width,
              h.height,
              { class: `actor ${M_}` },
              r,
            ));
          let k = y.select("path:last-child");
          if (k.node()) {
            let T = k.node().getBBox();
            t.height = T.height + (r.sequence.labelBoxHeight ?? 0);
          }
          return t.height;
        }, "drawActorTypeDatabase")),
        (VRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 80,
            l = 30,
            u = e.append("g").lower();
          n ||
            (Ke++,
            u
              .append("line")
              .attr("id", "actor" + Ke)
              .attr("x1", s)
              .attr("y1", o)
              .attr("x2", s)
              .attr("y2", 2e3)
              .attr("class", "actor-line 200")
              .attr("stroke-width", "0.5px")
              .attr("stroke", "#999")
              .attr("name", t.name),
            (t.actorCnt = Ke));
          let h = e.append("g"),
            f = eu;
          (n ? (f += ` ${nu}`) : (f += ` ${ru}`),
            h.attr("class", f),
            h.attr("name", t.name));
          let d = ri();
          ((d.x = t.x),
            (d.y = i),
            (d.fill = "#eaeaea"),
            (d.width = t.width),
            (d.height = t.height),
            (d.class = "actor"),
            h
              .append("line")
              .attr("id", "actor-man-torso" + Ke)
              .attr("x1", t.x + t.width / 2 - l * 2.5)
              .attr("y1", i + 10)
              .attr("x2", t.x + t.width / 2 - 15)
              .attr("y2", i + 10),
            h
              .append("line")
              .attr("id", "actor-man-arms" + Ke)
              .attr("x1", t.x + t.width / 2 - l * 2.5)
              .attr("y1", i + 0)
              .attr("x2", t.x + t.width / 2 - l * 2.5)
              .attr("y2", i + 20),
            h
              .append("circle")
              .attr("cx", t.x + t.width / 2)
              .attr("cy", i + 10)
              .attr("r", l));
          let p = h.node().getBBox();
          return (
            (t.height = p.height + (r.sequence.labelBoxHeight ?? 0)),
            Gl(r, $r(t.description))(
              t.description,
              h,
              d.x,
              d.y + (n ? l / 2 - 4 : l / 2 + 3),
              d.width,
              d.height,
              { class: `actor ${eu}` },
              r,
            ),
            n
              ? h.attr("transform", `translate(0,${l / 2 + 7})`)
              : h.attr("transform", `translate(0,${l / 2 + 7})`),
            t.height
          );
        }, "drawActorTypeBoundary")),
        (zRt = a(function (e, t, r, n) {
          let i = n ? t.stopy : t.starty,
            s = t.x + t.width / 2,
            o = i + 80,
            l = e.append("g").lower();
          n ||
            (Ke++,
            l
              .append("line")
              .attr("id", "actor" + Ke)
              .attr("x1", s)
              .attr("y1", o)
              .attr("x2", s)
              .attr("y2", 2e3)
              .attr("class", "actor-line 200")
              .attr("stroke-width", "0.5px")
              .attr("stroke", "#999")
              .attr("name", t.name),
            (t.actorCnt = Ke));
          let u = e.append("g"),
            h = eu;
          (n ? (h += ` ${nu}`) : (h += ` ${ru}`),
            u.attr("class", h),
            u.attr("name", t.name));
          let f = ri();
          ((f.x = t.x),
            (f.y = i),
            (f.fill = "#eaeaea"),
            (f.width = t.width),
            (f.height = t.height),
            (f.class = "actor"),
            (f.rx = 3),
            (f.ry = 3),
            u
              .append("line")
              .attr("id", "actor-man-torso" + Ke)
              .attr("x1", s)
              .attr("y1", i + 25)
              .attr("x2", s)
              .attr("y2", i + 45),
            u
              .append("line")
              .attr("id", "actor-man-arms" + Ke)
              .attr("x1", s - tu / 2)
              .attr("y1", i + 33)
              .attr("x2", s + tu / 2)
              .attr("y2", i + 33),
            u
              .append("line")
              .attr("x1", s - tu / 2)
              .attr("y1", i + 60)
              .attr("x2", s)
              .attr("y2", i + 45),
            u
              .append("line")
              .attr("x1", s)
              .attr("y1", i + 45)
              .attr("x2", s + tu / 2 - 2)
              .attr("y2", i + 60));
          let d = u.append("circle");
          (d.attr("cx", t.x + t.width / 2),
            d.attr("cy", i + 10),
            d.attr("r", 15),
            d.attr("width", t.width),
            d.attr("height", t.height));
          let p = u.node().getBBox();
          return (
            (t.height = p.height),
            Gl(r, $r(t.description))(
              t.description,
              u,
              f.x,
              f.y + 35,
              f.width,
              f.height,
              { class: `actor ${eu}` },
              r,
            ),
            t.height
          );
        }, "drawActorTypeActor")),
        (WRt = a(async function (e, t, r, n) {
          switch (t.type) {
            case "actor":
              return await zRt(e, t, r, n);
            case "participant":
              return await ORt(e, t, r, n);
            case "boundary":
              return await VRt(e, t, r, n);
            case "control":
              return await FRt(e, t, r, n);
            case "entity":
              return await $Rt(e, t, r, n);
            case "database":
              return await GRt(e, t, r, n);
            case "collections":
              return await PRt(e, t, r, n);
            case "queue":
              return await BRt(e, t, r, n);
          }
        }, "drawActor")),
        (URt = a(function (e, t, r) {
          let i = e.append("g");
          (Mnt(i, t),
            t.name &&
              Gl(r)(
                t.name,
                i,
                t.x,
                t.y + r.boxTextMargin + (t.textMaxHeight || 0) / 2,
                t.width,
                0,
                { class: "text" },
                r,
              ),
            i.lower());
        }, "drawBox")),
        (jRt = a(function (e) {
          return e.append("g");
        }, "anchorElement")),
        (qRt = a(function (e, t, r, n, i) {
          let s = ri(),
            o = t.anchored;
          ((s.x = t.startx),
            (s.y = t.starty),
            (s.class = "activation" + (i % 3)),
            (s.width = t.stopx - t.startx),
            (s.height = r - t.starty),
            Vy(o, s));
        }, "drawActivation")),
        (HRt = a(async function (e, t, r, n) {
          let {
              boxMargin: i,
              boxTextMargin: s,
              labelBoxHeight: o,
              labelBoxWidth: l,
              messageFontFamily: u,
              messageFontSize: h,
              messageFontWeight: f,
            } = n,
            d = e.append("g"),
            p = a(function (y, b, k, T) {
              return d
                .append("line")
                .attr("x1", y)
                .attr("y1", b)
                .attr("x2", k)
                .attr("y2", T)
                .attr("class", "loopLine");
            }, "drawLoopLine");
          (p(t.startx, t.starty, t.stopx, t.starty),
            p(t.stopx, t.starty, t.stopx, t.stopy),
            p(t.startx, t.stopy, t.stopx, t.stopy),
            p(t.startx, t.starty, t.startx, t.stopy),
            t.sections !== void 0 &&
              t.sections.forEach(function (y) {
                p(t.startx, y.y, t.stopx, y.y).style(
                  "stroke-dasharray",
                  "3, 3",
                );
              }));
          let m = s0();
          ((m.text = r),
            (m.x = t.startx),
            (m.y = t.starty),
            (m.fontFamily = u),
            (m.fontSize = h),
            (m.fontWeight = f),
            (m.anchor = "middle"),
            (m.valign = "middle"),
            (m.tspan = !1),
            (m.width = l || 50),
            (m.height = o || 20),
            (m.textMargin = s),
            (m.class = "labelText"),
            Int(d, m),
            (m = Ont()),
            (m.text = t.title),
            (m.x = t.startx + l / 2 + (t.stopx - t.startx) / 2),
            (m.y = t.starty + i + s),
            (m.anchor = "middle"),
            (m.valign = "middle"),
            (m.textMargin = s),
            (m.class = "loopText"),
            (m.fontFamily = u),
            (m.fontSize = h),
            (m.fontWeight = f),
            (m.wrap = !0));
          let g = $r(m.text) ? await zy(d, m, t) : Kh(d, m);
          if (t.sectionTitles !== void 0) {
            for (let [y, b] of Object.entries(t.sectionTitles))
              if (b.message) {
                ((m.text = b.message),
                  (m.x = t.startx + (t.stopx - t.startx) / 2),
                  (m.y = t.sections[y].y + i + s),
                  (m.class = "loopText"),
                  (m.anchor = "middle"),
                  (m.valign = "middle"),
                  (m.tspan = !1),
                  (m.fontFamily = u),
                  (m.fontSize = h),
                  (m.fontWeight = f),
                  (m.wrap = t.wrap),
                  $r(m.text)
                    ? ((t.starty = t.sections[y].y), await zy(d, m, t))
                    : Kh(d, m));
                let k = Math.round(
                  g
                    .map((T) => (T._groups || T)[0][0].getBBox().height)
                    .reduce((T, C) => T + C),
                );
                t.sections[y].height += k - (i + s);
              }
          }
          return ((t.height = Math.round(t.stopy - t.starty)), d);
        }, "drawLoop")),
        (Mnt = a(function (e, t) {
          U2(e, t);
        }, "drawBackgroundRect")),
        (YRt = a(function (e) {
          e.append("defs")
            .append("symbol")
            .attr("id", "database")
            .attr("fill-rule", "evenodd")
            .attr("clip-rule", "evenodd")
            .append("path")
            .attr("transform", "scale(.5)")
            .attr(
              "d",
              "M12.258.001l.256.004.255.005.253.008.251.01.249.012.247.015.246.016.242.019.241.02.239.023.236.024.233.027.231.028.229.031.225.032.223.034.22.036.217.038.214.04.211.041.208.043.205.045.201.046.198.048.194.05.191.051.187.053.183.054.18.056.175.057.172.059.168.06.163.061.16.063.155.064.15.066.074.033.073.033.071.034.07.034.069.035.068.035.067.035.066.035.064.036.064.036.062.036.06.036.06.037.058.037.058.037.055.038.055.038.053.038.052.038.051.039.05.039.048.039.047.039.045.04.044.04.043.04.041.04.04.041.039.041.037.041.036.041.034.041.033.042.032.042.03.042.029.042.027.042.026.043.024.043.023.043.021.043.02.043.018.044.017.043.015.044.013.044.012.044.011.045.009.044.007.045.006.045.004.045.002.045.001.045v17l-.001.045-.002.045-.004.045-.006.045-.007.045-.009.044-.011.045-.012.044-.013.044-.015.044-.017.043-.018.044-.02.043-.021.043-.023.043-.024.043-.026.043-.027.042-.029.042-.03.042-.032.042-.033.042-.034.041-.036.041-.037.041-.039.041-.04.041-.041.04-.043.04-.044.04-.045.04-.047.039-.048.039-.05.039-.051.039-.052.038-.053.038-.055.038-.055.038-.058.037-.058.037-.06.037-.06.036-.062.036-.064.036-.064.036-.066.035-.067.035-.068.035-.069.035-.07.034-.071.034-.073.033-.074.033-.15.066-.155.064-.16.063-.163.061-.168.06-.172.059-.175.057-.18.056-.183.054-.187.053-.191.051-.194.05-.198.048-.201.046-.205.045-.208.043-.211.041-.214.04-.217.038-.22.036-.223.034-.225.032-.229.031-.231.028-.233.027-.236.024-.239.023-.241.02-.242.019-.246.016-.247.015-.249.012-.251.01-.253.008-.255.005-.256.004-.258.001-.258-.001-.256-.004-.255-.005-.253-.008-.251-.01-.249-.012-.247-.015-.245-.016-.243-.019-.241-.02-.238-.023-.236-.024-.234-.027-.231-.028-.228-.031-.226-.032-.223-.034-.22-.036-.217-.038-.214-.04-.211-.041-.208-.043-.204-.045-.201-.046-.198-.048-.195-.05-.19-.051-.187-.053-.184-.054-.179-.056-.176-.057-.172-.059-.167-.06-.164-.061-.159-.063-.155-.064-.151-.066-.074-.033-.072-.033-.072-.034-.07-.034-.069-.035-.068-.035-.067-.035-.066-.035-.064-.036-.063-.036-.062-.036-.061-.036-.06-.037-.058-.037-.057-.037-.056-.038-.055-.038-.053-.038-.052-.038-.051-.039-.049-.039-.049-.039-.046-.039-.046-.04-.044-.04-.043-.04-.041-.04-.04-.041-.039-.041-.037-.041-.036-.041-.034-.041-.033-.042-.032-.042-.03-.042-.029-.042-.027-.042-.026-.043-.024-.043-.023-.043-.021-.043-.02-.043-.018-.044-.017-.043-.015-.044-.013-.044-.012-.044-.011-.045-.009-.044-.007-.045-.006-.045-.004-.045-.002-.045-.001-.045v-17l.001-.045.002-.045.004-.045.006-.045.007-.045.009-.044.011-.045.012-.044.013-.044.015-.044.017-.043.018-.044.02-.043.021-.043.023-.043.024-.043.026-.043.027-.042.029-.042.03-.042.032-.042.033-.042.034-.041.036-.041.037-.041.039-.041.04-.041.041-.04.043-.04.044-.04.046-.04.046-.039.049-.039.049-.039.051-.039.052-.038.053-.038.055-.038.056-.038.057-.037.058-.037.06-.037.061-.036.062-.036.063-.036.064-.036.066-.035.067-.035.068-.035.069-.035.07-.034.072-.034.072-.033.074-.033.151-.066.155-.064.159-.063.164-.061.167-.06.172-.059.176-.057.179-.056.184-.054.187-.053.19-.051.195-.05.198-.048.201-.046.204-.045.208-.043.211-.041.214-.04.217-.038.22-.036.223-.034.226-.032.228-.031.231-.028.234-.027.236-.024.238-.023.241-.02.243-.019.245-.016.247-.015.249-.012.251-.01.253-.008.255-.005.256-.004.258-.001.258.001zm-9.258 20.499v.01l.001.021.003.021.004.022.005.021.006.022.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.023.018.024.019.024.021.024.022.025.023.024.024.025.052.049.056.05.061.051.066.051.07.051.075.051.079.052.084.052.088.052.092.052.097.052.102.051.105.052.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.048.144.049.147.047.152.047.155.047.16.045.163.045.167.043.171.043.176.041.178.041.183.039.187.039.19.037.194.035.197.035.202.033.204.031.209.03.212.029.216.027.219.025.222.024.226.021.23.02.233.018.236.016.24.015.243.012.246.01.249.008.253.005.256.004.259.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.021.224-.024.22-.026.216-.027.212-.028.21-.031.205-.031.202-.034.198-.034.194-.036.191-.037.187-.039.183-.04.179-.04.175-.042.172-.043.168-.044.163-.045.16-.046.155-.046.152-.047.148-.048.143-.049.139-.049.136-.05.131-.05.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.053.083-.051.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.05.023-.024.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.023.01-.022.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.127l-.077.055-.08.053-.083.054-.085.053-.087.052-.09.052-.093.051-.095.05-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.045-.118.044-.12.043-.122.042-.124.042-.126.041-.128.04-.13.04-.132.038-.134.038-.135.037-.138.037-.139.035-.142.035-.143.034-.144.033-.147.032-.148.031-.15.03-.151.03-.153.029-.154.027-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.01-.179.008-.179.008-.181.006-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.006-.179-.008-.179-.008-.178-.01-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.027-.153-.029-.151-.03-.15-.03-.148-.031-.146-.032-.145-.033-.143-.034-.141-.035-.14-.035-.137-.037-.136-.037-.134-.038-.132-.038-.13-.04-.128-.04-.126-.041-.124-.042-.122-.042-.12-.044-.117-.043-.116-.045-.113-.045-.112-.046-.109-.047-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.05-.093-.052-.09-.051-.087-.052-.085-.053-.083-.054-.08-.054-.077-.054v4.127zm0-5.654v.011l.001.021.003.021.004.021.005.022.006.022.007.022.009.022.01.022.011.023.012.023.013.023.015.024.016.023.017.024.018.024.019.024.021.024.022.024.023.025.024.024.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.052.11.051.114.051.119.052.123.05.127.051.131.05.135.049.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.044.171.042.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.022.23.02.233.018.236.016.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.012.241-.015.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.048.139-.05.136-.049.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.051.051-.049.023-.025.023-.024.021-.025.02-.024.019-.024.018-.024.017-.024.015-.023.014-.023.013-.024.012-.022.01-.023.01-.023.008-.022.006-.022.006-.022.004-.021.004-.022.001-.021.001-.021v-4.139l-.077.054-.08.054-.083.054-.085.052-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.049-.105.048-.106.047-.109.047-.111.046-.114.045-.115.044-.118.044-.12.044-.122.042-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.035-.143.033-.144.033-.147.033-.148.031-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.025-.161.024-.162.023-.163.022-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.011-.178.009-.179.009-.179.007-.181.007-.182.005-.182.004-.184.003-.184.002h-.37l-.184-.002-.184-.003-.182-.004-.182-.005-.181-.007-.179-.007-.179-.009-.178-.009-.176-.011-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.022-.162-.023-.161-.024-.159-.025-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.031-.146-.033-.145-.033-.143-.033-.141-.035-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.04-.126-.041-.124-.042-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.047-.105-.048-.102-.049-.1-.049-.097-.05-.095-.051-.093-.051-.09-.051-.087-.053-.085-.052-.083-.054-.08-.054-.077-.054v4.139zm0-5.666v.011l.001.02.003.022.004.021.005.022.006.021.007.022.009.023.01.022.011.023.012.023.013.023.015.023.016.024.017.024.018.023.019.024.021.025.022.024.023.024.024.025.052.05.056.05.061.05.066.051.07.051.075.052.079.051.084.052.088.052.092.052.097.052.102.052.105.051.11.052.114.051.119.051.123.051.127.05.131.05.135.05.139.049.144.048.147.048.152.047.155.046.16.045.163.045.167.043.171.043.176.042.178.04.183.04.187.038.19.037.194.036.197.034.202.033.204.032.209.03.212.028.216.027.219.025.222.024.226.021.23.02.233.018.236.017.24.014.243.012.246.01.249.008.253.006.256.003.259.001.26-.001.257-.003.254-.006.25-.008.247-.01.244-.013.241-.014.237-.016.233-.018.231-.02.226-.022.224-.024.22-.025.216-.027.212-.029.21-.03.205-.032.202-.033.198-.035.194-.036.191-.037.187-.039.183-.039.179-.041.175-.042.172-.043.168-.044.163-.045.16-.045.155-.047.152-.047.148-.048.143-.049.139-.049.136-.049.131-.051.126-.05.123-.051.118-.052.114-.051.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.052.07-.051.065-.051.06-.051.056-.05.051-.049.023-.025.023-.025.021-.024.02-.024.019-.024.018-.024.017-.024.015-.023.014-.024.013-.023.012-.023.01-.022.01-.023.008-.022.006-.022.006-.022.004-.022.004-.021.001-.021.001-.021v-4.153l-.077.054-.08.054-.083.053-.085.053-.087.053-.09.051-.093.051-.095.051-.097.05-.1.049-.102.048-.105.048-.106.048-.109.046-.111.046-.114.046-.115.044-.118.044-.12.043-.122.043-.124.042-.126.041-.128.04-.13.039-.132.039-.134.038-.135.037-.138.036-.139.036-.142.034-.143.034-.144.033-.147.032-.148.032-.15.03-.151.03-.153.028-.154.028-.156.027-.158.026-.159.024-.161.024-.162.023-.163.023-.165.021-.166.02-.167.019-.169.018-.169.017-.171.016-.173.015-.173.014-.175.013-.175.012-.177.01-.178.01-.179.009-.179.007-.181.006-.182.006-.182.004-.184.003-.184.001-.185.001-.185-.001-.184-.001-.184-.003-.182-.004-.182-.006-.181-.006-.179-.007-.179-.009-.178-.01-.176-.01-.176-.012-.175-.013-.173-.014-.172-.015-.171-.016-.17-.017-.169-.018-.167-.019-.166-.02-.165-.021-.163-.023-.162-.023-.161-.024-.159-.024-.157-.026-.156-.027-.155-.028-.153-.028-.151-.03-.15-.03-.148-.032-.146-.032-.145-.033-.143-.034-.141-.034-.14-.036-.137-.036-.136-.037-.134-.038-.132-.039-.13-.039-.128-.041-.126-.041-.124-.041-.122-.043-.12-.043-.117-.044-.116-.044-.113-.046-.112-.046-.109-.046-.106-.048-.105-.048-.102-.048-.1-.05-.097-.049-.095-.051-.093-.051-.09-.052-.087-.052-.085-.053-.083-.053-.08-.054-.077-.054v4.153zm8.74-8.179l-.257.004-.254.005-.25.008-.247.011-.244.012-.241.014-.237.016-.233.018-.231.021-.226.022-.224.023-.22.026-.216.027-.212.028-.21.031-.205.032-.202.033-.198.034-.194.036-.191.038-.187.038-.183.04-.179.041-.175.042-.172.043-.168.043-.163.045-.16.046-.155.046-.152.048-.148.048-.143.048-.139.049-.136.05-.131.05-.126.051-.123.051-.118.051-.114.052-.11.052-.106.052-.101.052-.096.052-.092.052-.088.052-.083.052-.079.052-.074.051-.07.052-.065.051-.06.05-.056.05-.051.05-.023.025-.023.024-.021.024-.02.025-.019.024-.018.024-.017.023-.015.024-.014.023-.013.023-.012.023-.01.023-.01.022-.008.022-.006.023-.006.021-.004.022-.004.021-.001.021-.001.021.001.021.001.021.004.021.004.022.006.021.006.023.008.022.01.022.01.023.012.023.013.023.014.023.015.024.017.023.018.024.019.024.02.025.021.024.023.024.023.025.051.05.056.05.06.05.065.051.07.052.074.051.079.052.083.052.088.052.092.052.096.052.101.052.106.052.11.052.114.052.118.051.123.051.126.051.131.05.136.05.139.049.143.048.148.048.152.048.155.046.16.046.163.045.168.043.172.043.175.042.179.041.183.04.187.038.191.038.194.036.198.034.202.033.205.032.21.031.212.028.216.027.22.026.224.023.226.022.231.021.233.018.237.016.241.014.244.012.247.011.25.008.254.005.257.004.26.001.26-.001.257-.004.254-.005.25-.008.247-.011.244-.012.241-.014.237-.016.233-.018.231-.021.226-.022.224-.023.22-.026.216-.027.212-.028.21-.031.205-.032.202-.033.198-.034.194-.036.191-.038.187-.038.183-.04.179-.041.175-.042.172-.043.168-.043.163-.045.16-.046.155-.046.152-.048.148-.048.143-.048.139-.049.136-.05.131-.05.126-.051.123-.051.118-.051.114-.052.11-.052.106-.052.101-.052.096-.052.092-.052.088-.052.083-.052.079-.052.074-.051.07-.052.065-.051.06-.05.056-.05.051-.05.023-.025.023-.024.021-.024.02-.025.019-.024.018-.024.017-.023.015-.024.014-.023.013-.023.012-.023.01-.023.01-.022.008-.022.006-.023.006-.021.004-.022.004-.021.001-.021.001-.021-.001-.021-.001-.021-.004-.021-.004-.022-.006-.021-.006-.023-.008-.022-.01-.022-.01-.023-.012-.023-.013-.023-.014-.023-.015-.024-.017-.023-.018-.024-.019-.024-.02-.025-.021-.024-.023-.024-.023-.025-.051-.05-.056-.05-.06-.05-.065-.051-.07-.052-.074-.051-.079-.052-.083-.052-.088-.052-.092-.052-.096-.052-.101-.052-.106-.052-.11-.052-.114-.052-.118-.051-.123-.051-.126-.051-.131-.05-.136-.05-.139-.049-.143-.048-.148-.048-.152-.048-.155-.046-.16-.046-.163-.045-.168-.043-.172-.043-.175-.042-.179-.041-.183-.04-.187-.038-.191-.038-.194-.036-.198-.034-.202-.033-.205-.032-.21-.031-.212-.028-.216-.027-.22-.026-.224-.023-.226-.022-.231-.021-.233-.018-.237-.016-.241-.014-.244-.012-.247-.011-.25-.008-.254-.005-.257-.004-.26-.001-.26.001z",
            );
        }, "insertDatabaseIcon")),
        (XRt = a(function (e) {
          e.append("defs")
            .append("symbol")
            .attr("id", "computer")
            .attr("width", "24")
            .attr("height", "24")
            .append("path")
            .attr("transform", "scale(.5)")
            .attr(
              "d",
              "M2 2v13h20v-13h-20zm18 11h-16v-9h16v9zm-10.228 6l.466-1h3.524l.467 1h-4.457zm14.228 3h-24l2-6h2.104l-1.33 4h18.45l-1.297-4h2.073l2 6zm-5-10h-14v-7h14v7z",
            );
        }, "insertComputerIcon")),
        (KRt = a(function (e) {
          e.append("defs")
            .append("symbol")
            .attr("id", "clock")
            .attr("width", "24")
            .attr("height", "24")
            .append("path")
            .attr("transform", "scale(.5)")
            .attr(
              "d",
              "M12 2c5.514 0 10 4.486 10 10s-4.486 10-10 10-10-4.486-10-10 4.486-10 10-10zm0-2c-6.627 0-12 5.373-12 12s5.373 12 12 12 12-5.373 12-12-5.373-12-12-12zm5.848 12.459c.202.038.202.333.001.372-1.907.361-6.045 1.111-6.547 1.111-.719 0-1.301-.582-1.301-1.301 0-.512.77-5.447 1.125-7.445.034-.192.312-.181.343.014l.985 6.238 5.394 1.011z",
            );
        }, "insertClockIcon")),
        (QRt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 7.9)
            .attr("refY", 5)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto-start-reverse")
            .append("path")
            .attr("d", "M -1 0 L 10 5 L 0 10 z");
        }, "insertArrowHead")),
        (ZRt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "filled-head")
            .attr("refX", 15.5)
            .attr("refY", 7)
            .attr("markerWidth", 20)
            .attr("markerHeight", 28)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 18,7 L9,13 L14,7 L9,1 Z");
        }, "insertArrowFilledHead")),
        (JRt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "sequencenumber")
            .attr("refX", 15)
            .attr("refY", 15)
            .attr("markerWidth", 60)
            .attr("markerHeight", 40)
            .attr("orient", "auto")
            .append("circle")
            .attr("cx", 15)
            .attr("cy", 15)
            .attr("r", 6);
        }, "insertSequenceNumber")),
        (tDt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "crosshead")
            .attr("markerWidth", 15)
            .attr("markerHeight", 8)
            .attr("orient", "auto")
            .attr("refX", 4)
            .attr("refY", 4.5)
            .append("path")
            .attr("fill", "none")
            .attr("stroke", "#000000")
            .style("stroke-dasharray", "0, 0")
            .attr("stroke-width", "1pt")
            .attr("d", "M 1,2 L 6,7 M 6,2 L 1,7");
        }, "insertArrowCrossHead")),
        (Ont = a(function () {
          return {
            x: 0,
            y: 0,
            fill: void 0,
            anchor: void 0,
            style: "#666",
            width: void 0,
            height: void 0,
            textMargin: 0,
            rx: 0,
            ry: 0,
            tspan: !0,
            valign: void 0,
          };
        }, "getTextObj")),
        (eDt = a(function () {
          return {
            x: 0,
            y: 0,
            fill: "#EDF2AE",
            stroke: "#666",
            width: 100,
            anchor: "start",
            height: 100,
            rx: 0,
            ry: 0,
          };
        }, "getNoteRect")),
        (Gl = (function () {
          function e(s, o, l, u, h, f, d) {
            let p = o
              .append("text")
              .attr("x", l + h / 2)
              .attr("y", u + f / 2 + 5)
              .style("text-anchor", "middle")
              .text(s);
            i(p, d);
          }
          a(e, "byText");
          function t(s, o, l, u, h, f, d, p) {
            let {
                actorFontSize: m,
                actorFontFamily: g,
                actorFontWeight: y,
              } = p,
              [b, k] = xo(m),
              T = s.split(Rt.lineBreakRegex);
            for (let C = 0; C < T.length; C++) {
              let L = C * b - (b * (T.length - 1)) / 2,
                w = o
                  .append("text")
                  .attr("x", l + h / 2)
                  .attr("y", u)
                  .style("text-anchor", "middle")
                  .style("font-size", k)
                  .style("font-weight", y)
                  .style("font-family", g);
              (w
                .append("tspan")
                .attr("x", l + h / 2)
                .attr("dy", L)
                .text(T[C]),
                w
                  .attr("y", u + f / 2)
                  .attr("dominant-baseline", "central")
                  .attr("alignment-baseline", "central"),
                i(w, d));
            }
          }
          a(t, "byTspan");
          function r(s, o, l, u, h, f, d, p) {
            let m = o.append("switch"),
              y = m
                .append("foreignObject")
                .attr("x", l)
                .attr("y", u)
                .attr("width", h)
                .attr("height", f)
                .append("xhtml:div")
                .style("display", "table")
                .style("height", "100%")
                .style("width", "100%");
            (y
              .append("div")
              .style("display", "table-cell")
              .style("text-align", "center")
              .style("vertical-align", "middle")
              .text(s),
              t(s, m, l, u, h, f, d, p),
              i(y, d));
          }
          a(r, "byFo");
          async function n(s, o, l, u, h, f, d, p) {
            let m = await xu(s, ke()),
              g = o.append("switch"),
              b = g
                .append("foreignObject")
                .attr("x", l + h / 2 - m.width / 2)
                .attr("y", u + f / 2 - m.height / 2)
                .attr("width", m.width)
                .attr("height", m.height)
                .append("xhtml:div")
                .style("height", "100%")
                .style("width", "100%");
            (b
              .append("div")
              .style("text-align", "center")
              .style("vertical-align", "middle")
              .html(await Kl(s, ke())),
              t(s, g, l, u, h, f, d, p),
              i(b, d));
          }
          a(n, "byKatex");
          function i(s, o) {
            for (let l in o) o.hasOwnProperty(l) && s.attr(l, o[l]);
          }
          return (
            a(i, "_setTextAttrs"),
            function (s, o = !1) {
              return o
                ? n
                : s.textPlacement === "fo"
                  ? r
                  : s.textPlacement === "old"
                    ? e
                    : t;
            }
          );
        })()),
        (rDt = (function () {
          function e(i, s, o, l, u, h, f) {
            let d = s
              .append("text")
              .attr("x", o)
              .attr("y", l)
              .style("text-anchor", "start")
              .text(i);
            n(d, f);
          }
          a(e, "byText");
          function t(i, s, o, l, u, h, f, d) {
            let {
                actorFontSize: p,
                actorFontFamily: m,
                actorFontWeight: g,
              } = d,
              y = i.split(Rt.lineBreakRegex);
            for (let b = 0; b < y.length; b++) {
              let k = b * p - (p * (y.length - 1)) / 2,
                T = s
                  .append("text")
                  .attr("x", o)
                  .attr("y", l)
                  .style("text-anchor", "start")
                  .style("font-size", p)
                  .style("font-weight", g)
                  .style("font-family", m);
              (T.append("tspan").attr("x", o).attr("dy", k).text(y[b]),
                T.attr("y", l + h / 2)
                  .attr("dominant-baseline", "central")
                  .attr("alignment-baseline", "central"),
                n(T, f));
            }
          }
          a(t, "byTspan");
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append("switch"),
              g = p
                .append("foreignObject")
                .attr("x", o)
                .attr("y", l)
                .attr("width", u)
                .attr("height", h)
                .append("xhtml:div")
                .style("display", "table")
                .style("height", "100%")
                .style("width", "100%");
            (g
              .append("div")
              .style("display", "table-cell")
              .style("text-align", "center")
              .style("vertical-align", "middle")
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f));
          }
          a(r, "byFo");
          function n(i, s) {
            for (let o in s) s.hasOwnProperty(o) && i.attr(o, s[o]);
          }
          return (
            a(n, "_setTextAttrs"),
            function (i) {
              return i.textPlacement === "fo"
                ? r
                : i.textPlacement === "old"
                  ? e
                  : t;
            }
          );
        })()),
        (pn = {
          drawRect: Vy,
          drawText: Kh,
          drawLabel: Int,
          drawActor: WRt,
          drawBox: URt,
          drawPopup: MRt,
          anchorElement: jRt,
          drawActivation: qRt,
          drawLoop: HRt,
          drawBackgroundRect: Mnt,
          insertArrowHead: QRt,
          insertArrowFilledHead: ZRt,
          insertSequenceNumber: JRt,
          insertArrowCrossHead: tDt,
          insertDatabaseIcon: YRt,
          insertComputerIcon: XRt,
          insertClockIcon: KRt,
          getTextObj: Ont,
          getNoteRect: eDt,
          fixLifeLineHeights: yN,
          sanitizeUrl: gN.sanitizeUrl,
        }));
    });
  async function iDt(e, t) {
    Pt.bumpVerticalPos(10);
    let { startx: r, stopx: n, message: i } = t,
      s = Rt.splitBreaks(i).length,
      o = $r(i),
      l = o ? await xu(i, K()) : le.calculateTextDimensions(i, Qh(at));
    if (!o) {
      let d = l.height / s;
      ((t.height += d), Pt.bumpVerticalPos(d));
    }
    let u,
      h = l.height - 10,
      f = l.width;
    if (r === n) {
      ((u = Pt.getVerticalPos() + h),
        at.rightAngles || ((h += at.boxMargin), (u = Pt.getVerticalPos() + h)),
        (h += 30));
      let d = Rt.getMax(f / 2, at.width / 2);
      Pt.insert(
        r - d,
        Pt.getVerticalPos() - 10 + h,
        n + d,
        Pt.getVerticalPos() + 30 + h,
      );
    } else
      ((h += at.boxMargin),
        (u = Pt.getVerticalPos() + h),
        Pt.insert(r, u - 10, n, u));
    return (
      Pt.bumpVerticalPos(h),
      (t.height += h),
      (t.stopy = t.starty + t.height),
      Pt.insert(t.fromBounds, t.starty, t.toBounds, t.stopy),
      u
    );
  }
  function Xo(e, t, r, n, i) {
    Pt.bumpVerticalPos(r);
    let s = n;
    if (t.id && t.message && e[t.id]) {
      let o = e[t.id].width,
        l = Qh(at);
      ((t.message = le.wrapLabel(`[${t.message}]`, o - 2 * at.wrapPadding, l)),
        (t.width = o),
        (t.wrap = !0));
      let u = le.calculateTextDimensions(t.message, l),
        h = Rt.getMax(u.height, at.labelBoxHeight);
      ((s = n + h), P.debug(`${h} - ${t.message}`));
    }
    (i(t), Pt.bumpVerticalPos(s));
  }
  function oDt(e, t, r, n, i, s, o) {
    function l(f, d) {
      f.x < i.get(e.from).x
        ? (Pt.insert(
            t.stopx - d,
            t.starty,
            t.startx,
            t.stopy + f.height / 2 + at.noteMargin,
          ),
          (t.stopx = t.stopx + d))
        : (Pt.insert(
            t.startx,
            t.starty,
            t.stopx + d,
            t.stopy + f.height / 2 + at.noteMargin,
          ),
          (t.stopx = t.stopx - d));
    }
    a(l, "receiverAdjustment");
    function u(f, d) {
      f.x < i.get(e.to).x
        ? (Pt.insert(
            t.startx - d,
            t.starty,
            t.stopx,
            t.stopy + f.height / 2 + at.noteMargin,
          ),
          (t.startx = t.startx + d))
        : (Pt.insert(
            t.stopx,
            t.starty,
            t.startx + d,
            t.stopy + f.height / 2 + at.noteMargin,
          ),
          (t.startx = t.startx - d));
    }
    a(u, "senderAdjustment");
    let h = [Gy.ACTOR, Gy.CONTROL, Gy.ENTITY, Gy.DATABASE];
    if (s.get(e.to) == n) {
      let f = i.get(e.to),
        d = h.includes(f.type) ? tu / 2 + 3 : f.width / 2 + 3;
      (l(f, d),
        (f.starty = r - f.height / 2),
        Pt.bumpVerticalPos(f.height / 2));
    } else if (o.get(e.from) == n) {
      let f = i.get(e.from);
      if (at.mirrorActors) {
        let d = h.includes(f.type) ? tu / 2 : f.width / 2;
        u(f, d);
      }
      ((f.stopy = r - f.height / 2), Pt.bumpVerticalPos(f.height / 2));
    } else if (o.get(e.to) == n) {
      let f = i.get(e.to);
      if (at.mirrorActors) {
        let d = h.includes(f.type) ? tu / 2 + 3 : f.width / 2 + 3;
        l(f, d);
      }
      ((f.stopy = r - f.height / 2), Pt.bumpVerticalPos(f.height / 2));
    }
  }
  async function cDt(e, t, r) {
    let n = {};
    for (let i of t)
      if (e.get(i.to) && e.get(i.from)) {
        let s = e.get(i.to);
        if (
          (i.placement === r.db.PLACEMENT.LEFTOF && !s.prevActor) ||
          (i.placement === r.db.PLACEMENT.RIGHTOF && !s.nextActor)
        )
          continue;
        let o = i.placement !== void 0,
          l = !o,
          u = o ? _m(at) : Qh(at),
          h = i.wrap
            ? le.wrapLabel(i.message, at.width - 2 * at.wrapPadding, u)
            : i.message,
          d =
            ($r(h)
              ? await xu(i.message, K())
              : le.calculateTextDimensions(h, u)
            ).width +
            2 * at.wrapPadding;
        l && i.from === s.nextActor
          ? (n[i.to] = Rt.getMax(n[i.to] || 0, d))
          : l && i.from === s.prevActor
            ? (n[i.from] = Rt.getMax(n[i.from] || 0, d))
            : l && i.from === i.to
              ? ((n[i.from] = Rt.getMax(n[i.from] || 0, d / 2)),
                (n[i.to] = Rt.getMax(n[i.to] || 0, d / 2)))
              : i.placement === r.db.PLACEMENT.RIGHTOF
                ? (n[i.from] = Rt.getMax(n[i.from] || 0, d))
                : i.placement === r.db.PLACEMENT.LEFTOF
                  ? (n[s.prevActor] = Rt.getMax(n[s.prevActor] || 0, d))
                  : i.placement === r.db.PLACEMENT.OVER &&
                    (s.prevActor &&
                      (n[s.prevActor] = Rt.getMax(n[s.prevActor] || 0, d / 2)),
                    s.nextActor &&
                      (n[i.from] = Rt.getMax(n[i.from] || 0, d / 2)));
      }
    return (P.debug("maxMessageWidthPerActor:", n), n);
  }
  async function hDt(e, t, r) {
    let n = 0;
    for (let s of e.keys()) {
      let o = e.get(s);
      o.wrap &&
        (o.description = le.wrapLabel(
          o.description,
          at.width - 2 * at.wrapPadding,
          xN(at),
        ));
      let l = $r(o.description)
        ? await xu(o.description, K())
        : le.calculateTextDimensions(o.description, xN(at));
      ((o.width = o.wrap
        ? at.width
        : Rt.getMax(at.width, l.width + 2 * at.wrapPadding)),
        (o.height = o.wrap ? Rt.getMax(l.height, at.height) : at.height),
        (n = Rt.getMax(n, o.height)));
    }
    for (let s in t) {
      let o = e.get(s);
      if (!o) continue;
      let l = e.get(o.nextActor);
      if (!l) {
        let d = t[s] + at.actorMargin - o.width / 2;
        o.margin = Rt.getMax(d, at.actorMargin);
        continue;
      }
      let h = t[s] + at.actorMargin - o.width / 2 - l.width / 2;
      o.margin = Rt.getMax(h, at.actorMargin);
    }
    let i = 0;
    return (
      r.forEach((s) => {
        let o = Qh(at),
          l = s.actorKeys.reduce(
            (d, p) => (d += e.get(p).width + (e.get(p).margin || 0)),
            0,
          ),
          u = at.boxMargin * 8;
        ((l += u),
          (l -= 2 * at.boxTextMargin),
          s.wrap && (s.name = le.wrapLabel(s.name, l - 2 * at.wrapPadding, o)));
        let h = le.calculateTextDimensions(s.name, o);
        i = Rt.getMax(h.height, i);
        let f = Rt.getMax(l, h.width + 2 * at.wrapPadding);
        if (((s.margin = at.boxTextMargin), l < f)) {
          let d = (f - l) / 2;
          s.margin += d;
        }
      }),
      r.forEach((s) => (s.textMaxHeight = i)),
      Rt.getMax(n, at.height)
    );
  }
  var at,
    Pt,
    nDt,
    Qh,
    _m,
    xN,
    sDt,
    aDt,
    bN,
    Fnt,
    $nt,
    P_,
    Bnt,
    lDt,
    uDt,
    fDt,
    dDt,
    pDt,
    Gnt,
    Vnt = x(() => {
      "use strict";
      Ge();
      Pnt();
      Vt();
      Be();
      Be();
      a0();
      pe();
      of();
      _e();
      On();
      mN();
      ((at = {}),
        (Pt = {
          data: {
            startx: void 0,
            stopx: void 0,
            starty: void 0,
            stopy: void 0,
          },
          verticalPos: 0,
          sequenceItems: [],
          activations: [],
          models: {
            getHeight: a(function () {
              return (
                Math.max.apply(
                  null,
                  this.actors.length === 0
                    ? [0]
                    : this.actors.map((e) => e.height || 0),
                ) +
                (this.loops.length === 0
                  ? 0
                  : this.loops
                      .map((e) => e.height || 0)
                      .reduce((e, t) => e + t)) +
                (this.messages.length === 0
                  ? 0
                  : this.messages
                      .map((e) => e.height || 0)
                      .reduce((e, t) => e + t)) +
                (this.notes.length === 0
                  ? 0
                  : this.notes
                      .map((e) => e.height || 0)
                      .reduce((e, t) => e + t))
              );
            }, "getHeight"),
            clear: a(function () {
              ((this.actors = []),
                (this.boxes = []),
                (this.loops = []),
                (this.messages = []),
                (this.notes = []));
            }, "clear"),
            addBox: a(function (e) {
              this.boxes.push(e);
            }, "addBox"),
            addActor: a(function (e) {
              this.actors.push(e);
            }, "addActor"),
            addLoop: a(function (e) {
              this.loops.push(e);
            }, "addLoop"),
            addMessage: a(function (e) {
              this.messages.push(e);
            }, "addMessage"),
            addNote: a(function (e) {
              this.notes.push(e);
            }, "addNote"),
            lastActor: a(function () {
              return this.actors[this.actors.length - 1];
            }, "lastActor"),
            lastLoop: a(function () {
              return this.loops[this.loops.length - 1];
            }, "lastLoop"),
            lastMessage: a(function () {
              return this.messages[this.messages.length - 1];
            }, "lastMessage"),
            lastNote: a(function () {
              return this.notes[this.notes.length - 1];
            }, "lastNote"),
            actors: [],
            boxes: [],
            loops: [],
            messages: [],
            notes: [],
          },
          init: a(function () {
            ((this.sequenceItems = []),
              (this.activations = []),
              this.models.clear(),
              (this.data = {
                startx: void 0,
                stopx: void 0,
                starty: void 0,
                stopy: void 0,
              }),
              (this.verticalPos = 0),
              $nt(K()));
          }, "init"),
          updateVal: a(function (e, t, r, n) {
            e[t] === void 0 ? (e[t] = r) : (e[t] = n(r, e[t]));
          }, "updateVal"),
          updateBounds: a(function (e, t, r, n) {
            let i = this,
              s = 0;
            function o(l) {
              return a(function (h) {
                s++;
                let f = i.sequenceItems.length - s + 1;
                (i.updateVal(h, "starty", t - f * at.boxMargin, Math.min),
                  i.updateVal(h, "stopy", n + f * at.boxMargin, Math.max),
                  i.updateVal(
                    Pt.data,
                    "startx",
                    e - f * at.boxMargin,
                    Math.min,
                  ),
                  i.updateVal(Pt.data, "stopx", r + f * at.boxMargin, Math.max),
                  l !== "activation" &&
                    (i.updateVal(h, "startx", e - f * at.boxMargin, Math.min),
                    i.updateVal(h, "stopx", r + f * at.boxMargin, Math.max),
                    i.updateVal(
                      Pt.data,
                      "starty",
                      t - f * at.boxMargin,
                      Math.min,
                    ),
                    i.updateVal(
                      Pt.data,
                      "stopy",
                      n + f * at.boxMargin,
                      Math.max,
                    )));
              }, "updateItemBounds");
            }
            (a(o, "updateFn"),
              this.sequenceItems.forEach(o()),
              this.activations.forEach(o("activation")));
          }, "updateBounds"),
          insert: a(function (e, t, r, n) {
            let i = Rt.getMin(e, r),
              s = Rt.getMax(e, r),
              o = Rt.getMin(t, n),
              l = Rt.getMax(t, n);
            (this.updateVal(Pt.data, "startx", i, Math.min),
              this.updateVal(Pt.data, "starty", o, Math.min),
              this.updateVal(Pt.data, "stopx", s, Math.max),
              this.updateVal(Pt.data, "stopy", l, Math.max),
              this.updateBounds(i, o, s, l));
          }, "insert"),
          newActivation: a(function (e, t, r) {
            let n = r.get(e.from),
              i = P_(e.from).length || 0,
              s = n.x + n.width / 2 + ((i - 1) * at.activationWidth) / 2;
            this.activations.push({
              startx: s,
              starty: this.verticalPos + 2,
              stopx: s + at.activationWidth,
              stopy: void 0,
              actor: e.from,
              anchored: pn.anchorElement(t),
            });
          }, "newActivation"),
          endActivation: a(function (e) {
            let t = this.activations
              .map(function (r) {
                return r.actor;
              })
              .lastIndexOf(e.from);
            return this.activations.splice(t, 1)[0];
          }, "endActivation"),
          createLoop: a(function (
            e = { message: void 0, wrap: !1, width: void 0 },
            t,
          ) {
            return {
              startx: void 0,
              starty: this.verticalPos,
              stopx: void 0,
              stopy: void 0,
              title: e.message,
              wrap: e.wrap,
              width: e.width,
              height: 0,
              fill: t,
            };
          }, "createLoop"),
          newLoop: a(function (
            e = { message: void 0, wrap: !1, width: void 0 },
            t,
          ) {
            this.sequenceItems.push(this.createLoop(e, t));
          }, "newLoop"),
          endLoop: a(function () {
            return this.sequenceItems.pop();
          }, "endLoop"),
          isLoopOverlap: a(function () {
            return this.sequenceItems.length
              ? this.sequenceItems[this.sequenceItems.length - 1].overlap
              : !1;
          }, "isLoopOverlap"),
          addSectionToLoop: a(function (e) {
            let t = this.sequenceItems.pop();
            ((t.sections = t.sections || []),
              (t.sectionTitles = t.sectionTitles || []),
              t.sections.push({ y: Pt.getVerticalPos(), height: 0 }),
              t.sectionTitles.push(e),
              this.sequenceItems.push(t));
          }, "addSectionToLoop"),
          saveVerticalPos: a(function () {
            this.isLoopOverlap() && (this.savedVerticalPos = this.verticalPos);
          }, "saveVerticalPos"),
          resetVerticalPos: a(function () {
            this.isLoopOverlap() && (this.verticalPos = this.savedVerticalPos);
          }, "resetVerticalPos"),
          bumpVerticalPos: a(function (e) {
            ((this.verticalPos = this.verticalPos + e),
              (this.data.stopy = Rt.getMax(this.data.stopy, this.verticalPos)));
          }, "bumpVerticalPos"),
          getVerticalPos: a(function () {
            return this.verticalPos;
          }, "getVerticalPos"),
          getBounds: a(function () {
            return { bounds: this.data, models: this.models };
          }, "getBounds"),
        }),
        (nDt = a(async function (e, t) {
          (Pt.bumpVerticalPos(at.boxMargin),
            (t.height = at.boxMargin),
            (t.starty = Pt.getVerticalPos()));
          let r = ri();
          ((r.x = t.startx),
            (r.y = t.starty),
            (r.width = t.width || at.width),
            (r.class = "note"));
          let n = e.append("g"),
            i = pn.drawRect(n, r),
            s = s0();
          ((s.x = t.startx),
            (s.y = t.starty),
            (s.width = r.width),
            (s.dy = "1em"),
            (s.text = t.message),
            (s.class = "noteText"),
            (s.fontFamily = at.noteFontFamily),
            (s.fontSize = at.noteFontSize),
            (s.fontWeight = at.noteFontWeight),
            (s.anchor = at.noteAlign),
            (s.textMargin = at.noteMargin),
            (s.valign = "center"));
          let o = $r(s.text) ? await zy(n, s) : Kh(n, s),
            l = Math.round(
              o
                .map((u) => (u._groups || u)[0][0].getBBox().height)
                .reduce((u, h) => u + h),
            );
          (i.attr("height", l + 2 * at.noteMargin),
            (t.height += l + 2 * at.noteMargin),
            Pt.bumpVerticalPos(l + 2 * at.noteMargin),
            (t.stopy = t.starty + l + 2 * at.noteMargin),
            (t.stopx = t.startx + r.width),
            Pt.insert(t.startx, t.starty, t.stopx, t.stopy),
            Pt.models.addNote(t));
        }, "drawNote")),
        (Qh = a(
          (e) => ({
            fontFamily: e.messageFontFamily,
            fontSize: e.messageFontSize,
            fontWeight: e.messageFontWeight,
          }),
          "messageFont",
        )),
        (_m = a(
          (e) => ({
            fontFamily: e.noteFontFamily,
            fontSize: e.noteFontSize,
            fontWeight: e.noteFontWeight,
          }),
          "noteFont",
        )),
        (xN = a(
          (e) => ({
            fontFamily: e.actorFontFamily,
            fontSize: e.actorFontSize,
            fontWeight: e.actorFontWeight,
          }),
          "actorFont",
        )));
      a(iDt, "boundMessage");
      ((sDt = a(async function (e, t, r, n) {
        let {
            startx: i,
            stopx: s,
            starty: o,
            message: l,
            type: u,
            sequenceIndex: h,
            sequenceVisible: f,
          } = t,
          d = le.calculateTextDimensions(l, Qh(at)),
          p = s0();
        ((p.x = i),
          (p.y = o + 10),
          (p.width = s - i),
          (p.class = "messageText"),
          (p.dy = "1em"),
          (p.text = l),
          (p.fontFamily = at.messageFontFamily),
          (p.fontSize = at.messageFontSize),
          (p.fontWeight = at.messageFontWeight),
          (p.anchor = at.messageAlign),
          (p.valign = "center"),
          (p.textMargin = at.wrapPadding),
          (p.tspan = !1),
          $r(p.text)
            ? await zy(e, p, { startx: i, stopx: s, starty: r })
            : Kh(e, p));
        let m = d.width,
          g;
        (i === s
          ? at.rightAngles
            ? (g = e
                .append("path")
                .attr(
                  "d",
                  `M  ${i},${r} H ${i + Rt.getMax(at.width / 2, m / 2)} V ${r + 25} H ${i}`,
                ))
            : (g = e
                .append("path")
                .attr(
                  "d",
                  "M " +
                    i +
                    "," +
                    r +
                    " C " +
                    (i + 60) +
                    "," +
                    (r - 10) +
                    " " +
                    (i + 60) +
                    "," +
                    (r + 30) +
                    " " +
                    i +
                    "," +
                    (r + 20),
                ))
          : ((g = e.append("line")),
            g.attr("x1", i),
            g.attr("y1", r),
            g.attr("x2", s),
            g.attr("y2", r)),
          u === n.db.LINETYPE.DOTTED ||
          u === n.db.LINETYPE.DOTTED_CROSS ||
          u === n.db.LINETYPE.DOTTED_POINT ||
          u === n.db.LINETYPE.DOTTED_OPEN ||
          u === n.db.LINETYPE.BIDIRECTIONAL_DOTTED
            ? (g.style("stroke-dasharray", "3, 3"),
              g.attr("class", "messageLine1"))
            : g.attr("class", "messageLine0"));
        let y = "";
        (at.arrowMarkerAbsolute && (y = tl(!0)),
          g.attr("stroke-width", 2),
          g.attr("stroke", "none"),
          g.style("fill", "none"),
          (u === n.db.LINETYPE.SOLID || u === n.db.LINETYPE.DOTTED) &&
            g.attr("marker-end", "url(" + y + "#arrowhead)"),
          (u === n.db.LINETYPE.BIDIRECTIONAL_SOLID ||
            u === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) &&
            (g.attr("marker-start", "url(" + y + "#arrowhead)"),
            g.attr("marker-end", "url(" + y + "#arrowhead)")),
          (u === n.db.LINETYPE.SOLID_POINT ||
            u === n.db.LINETYPE.DOTTED_POINT) &&
            g.attr("marker-end", "url(" + y + "#filled-head)"),
          (u === n.db.LINETYPE.SOLID_CROSS ||
            u === n.db.LINETYPE.DOTTED_CROSS) &&
            g.attr("marker-end", "url(" + y + "#crosshead)"),
          (f || at.showSequenceNumbers) &&
            ((u === n.db.LINETYPE.BIDIRECTIONAL_SOLID ||
              u === n.db.LINETYPE.BIDIRECTIONAL_DOTTED) &&
              (i < s ? g.attr("x1", i + 2 * 6) : g.attr("x1", i + 6)),
            e
              .append("line")
              .attr("x1", i)
              .attr("y1", r)
              .attr("x2", i)
              .attr("y2", r)
              .attr("stroke-width", 0)
              .attr("marker-start", "url(" + y + "#sequencenumber)"),
            e
              .append("text")
              .attr("x", i)
              .attr("y", r + 4)
              .attr("font-family", "sans-serif")
              .attr("font-size", "12px")
              .attr("text-anchor", "middle")
              .attr("class", "sequenceNumber")
              .text(h)));
      }, "drawMessage")),
        (aDt = a(function (e, t, r, n, i, s, o) {
          let l = 0,
            u = 0,
            h,
            f = 0;
          for (let d of n) {
            let p = t.get(d),
              m = p.box;
            (h &&
              h != m &&
              (o || Pt.models.addBox(h), (u += at.boxMargin + h.margin)),
              m && m != h && (o || ((m.x = l + u), (m.y = i)), (u += m.margin)),
              (p.width = p.width || at.width),
              (p.height = Rt.getMax(p.height || at.height, at.height)),
              (p.margin = p.margin || at.actorMargin),
              (f = Rt.getMax(f, p.height)),
              r.get(p.name) && (u += p.width / 2),
              (p.x = l + u),
              (p.starty = Pt.getVerticalPos()),
              Pt.insert(p.x, i, p.x + p.width, p.height),
              (l += p.width + u),
              p.box && (p.box.width = l + m.margin - p.box.x),
              (u = p.margin),
              (h = p.box),
              Pt.models.addActor(p));
          }
          (h && !o && Pt.models.addBox(h), Pt.bumpVerticalPos(f));
        }, "addActorRenderingData")),
        (bN = a(async function (e, t, r, n) {
          if (n) {
            let i = 0;
            Pt.bumpVerticalPos(at.boxMargin * 2);
            for (let s of r) {
              let o = t.get(s);
              o.stopy || (o.stopy = Pt.getVerticalPos());
              let l = await pn.drawActor(e, o, at, !0);
              i = Rt.getMax(i, l);
            }
            Pt.bumpVerticalPos(i + at.boxMargin);
          } else
            for (let i of r) {
              let s = t.get(i);
              await pn.drawActor(e, s, at, !1);
            }
        }, "drawActors")),
        (Fnt = a(function (e, t, r, n) {
          let i = 0,
            s = 0;
          for (let o of r) {
            let l = t.get(o),
              u = uDt(l),
              h = pn.drawPopup(e, l, u, at, at.forceMenus, n);
            (h.height > i && (i = h.height),
              h.width + l.x > s && (s = h.width + l.x));
          }
          return { maxHeight: i, maxWidth: s };
        }, "drawActorsPopup")),
        ($nt = a(function (e) {
          (Xr(at, e),
            e.fontFamily &&
              (at.actorFontFamily =
                at.noteFontFamily =
                at.messageFontFamily =
                  e.fontFamily),
            e.fontSize &&
              (at.actorFontSize =
                at.noteFontSize =
                at.messageFontSize =
                  e.fontSize),
            e.fontWeight &&
              (at.actorFontWeight =
                at.noteFontWeight =
                at.messageFontWeight =
                  e.fontWeight));
        }, "setConf")),
        (P_ = a(function (e) {
          return Pt.activations.filter(function (t) {
            return t.actor === e;
          });
        }, "actorActivations")),
        (Bnt = a(function (e, t) {
          let r = t.get(e),
            n = P_(e),
            i = n.reduce(
              function (o, l) {
                return Rt.getMin(o, l.startx);
              },
              r.x + r.width / 2 - 1,
            ),
            s = n.reduce(
              function (o, l) {
                return Rt.getMax(o, l.stopx);
              },
              r.x + r.width / 2 + 1,
            );
          return [i, s];
        }, "activationBounds")));
      a(Xo, "adjustLoopHeightForWrap");
      a(oDt, "adjustCreatedDestroyedData");
      lDt = a(async function (e, t, r, n) {
        let { securityLevel: i, sequence: s } = K();
        at = s;
        let o;
        i === "sandbox" && (o = xt("#i" + t));
        let l =
            i === "sandbox"
              ? xt(o.nodes()[0].contentDocument.body)
              : xt("body"),
          u = i === "sandbox" ? o.nodes()[0].contentDocument : document;
        (Pt.init(), P.debug(n.db));
        let h = i === "sandbox" ? l.select(`[id="${t}"]`) : xt(`[id="${t}"]`),
          f = n.db.getActors(),
          d = n.db.getCreatedActors(),
          p = n.db.getDestroyedActors(),
          m = n.db.getBoxes(),
          g = n.db.getActorKeys(),
          y = n.db.getMessages(),
          b = n.db.getDiagramTitle(),
          k = n.db.hasAtLeastOneBox(),
          T = n.db.hasAtLeastOneBoxWithTitle(),
          C = await cDt(f, y, n);
        if (
          ((at.height = await hDt(f, C, m)),
          pn.insertComputerIcon(h),
          pn.insertDatabaseIcon(h),
          pn.insertClockIcon(h),
          k &&
            (Pt.bumpVerticalPos(at.boxMargin),
            T && Pt.bumpVerticalPos(m[0].textMaxHeight)),
          at.hideUnusedParticipants === !0)
        ) {
          let M = new Set();
          (y.forEach((I) => {
            (M.add(I.from), M.add(I.to));
          }),
            (g = g.filter((I) => M.has(I))));
        }
        aDt(h, f, d, g, 0, y, !1);
        let L = await pDt(y, f, C, n);
        (pn.insertArrowHead(h),
          pn.insertArrowCrossHead(h),
          pn.insertArrowFilledHead(h),
          pn.insertSequenceNumber(h));
        function w(M, I) {
          let V = Pt.endActivation(M);
          (V.starty + 18 > I && ((V.starty = I - 6), (I += 12)),
            pn.drawActivation(h, V, I, at, P_(M.from).length),
            Pt.insert(V.startx, I - 10, V.stopx, I));
        }
        a(w, "activeEnd");
        let D = 1,
          G = 1,
          E = [],
          R = [],
          F = 0;
        for (let M of y) {
          let I, V, $;
          switch (M.type) {
            case n.db.LINETYPE.NOTE:
              (Pt.resetVerticalPos(), (V = M.noteModel), await nDt(h, V));
              break;
            case n.db.LINETYPE.ACTIVE_START:
              Pt.newActivation(M, h, f);
              break;
            case n.db.LINETYPE.ACTIVE_END:
              w(M, Pt.getVerticalPos());
              break;
            case n.db.LINETYPE.LOOP_START:
              Xo(L, M, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) =>
                Pt.newLoop(q),
              );
              break;
            case n.db.LINETYPE.LOOP_END:
              ((I = Pt.endLoop()),
                await pn.drawLoop(h, I, "loop", at),
                Pt.bumpVerticalPos(I.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(I));
              break;
            case n.db.LINETYPE.RECT_START:
              Xo(L, M, at.boxMargin, at.boxMargin, (q) =>
                Pt.newLoop(void 0, q.message),
              );
              break;
            case n.db.LINETYPE.RECT_END:
              ((I = Pt.endLoop()),
                R.push(I),
                Pt.models.addLoop(I),
                Pt.bumpVerticalPos(I.stopy - Pt.getVerticalPos()));
              break;
            case n.db.LINETYPE.OPT_START:
              Xo(L, M, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) =>
                Pt.newLoop(q),
              );
              break;
            case n.db.LINETYPE.OPT_END:
              ((I = Pt.endLoop()),
                await pn.drawLoop(h, I, "opt", at),
                Pt.bumpVerticalPos(I.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(I));
              break;
            case n.db.LINETYPE.ALT_START:
              Xo(L, M, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) =>
                Pt.newLoop(q),
              );
              break;
            case n.db.LINETYPE.ALT_ELSE:
              Xo(L, M, at.boxMargin + at.boxTextMargin, at.boxMargin, (q) =>
                Pt.addSectionToLoop(q),
              );
              break;
            case n.db.LINETYPE.ALT_END:
              ((I = Pt.endLoop()),
                await pn.drawLoop(h, I, "alt", at),
                Pt.bumpVerticalPos(I.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(I));
              break;
            case n.db.LINETYPE.PAR_START:
            case n.db.LINETYPE.PAR_OVER_START:
              (Xo(L, M, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) =>
                Pt.newLoop(q),
              ),
                Pt.saveVerticalPos());
              break;
            case n.db.LINETYPE.PAR_AND:
              Xo(L, M, at.boxMargin + at.boxTextMargin, at.boxMargin, (q) =>
                Pt.addSectionToLoop(q),
              );
              break;
            case n.db.LINETYPE.PAR_END:
              ((I = Pt.endLoop()),
                await pn.drawLoop(h, I, "par", at),
                Pt.bumpVerticalPos(I.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(I));
              break;
            case n.db.LINETYPE.AUTONUMBER:
              ((D = M.message.start || D),
                (G = M.message.step || G),
                M.message.visible
                  ? n.db.enableSequenceNumbers()
                  : n.db.disableSequenceNumbers());
              break;
            case n.db.LINETYPE.CRITICAL_START:
              Xo(L, M, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) =>
                Pt.newLoop(q),
              );
              break;
            case n.db.LINETYPE.CRITICAL_OPTION:
              Xo(L, M, at.boxMargin + at.boxTextMargin, at.boxMargin, (q) =>
                Pt.addSectionToLoop(q),
              );
              break;
            case n.db.LINETYPE.CRITICAL_END:
              ((I = Pt.endLoop()),
                await pn.drawLoop(h, I, "critical", at),
                Pt.bumpVerticalPos(I.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(I));
              break;
            case n.db.LINETYPE.BREAK_START:
              Xo(L, M, at.boxMargin, at.boxMargin + at.boxTextMargin, (q) =>
                Pt.newLoop(q),
              );
              break;
            case n.db.LINETYPE.BREAK_END:
              ((I = Pt.endLoop()),
                await pn.drawLoop(h, I, "break", at),
                Pt.bumpVerticalPos(I.stopy - Pt.getVerticalPos()),
                Pt.models.addLoop(I));
              break;
            default:
              try {
                (($ = M.msgModel),
                  ($.starty = Pt.getVerticalPos()),
                  ($.sequenceIndex = D),
                  ($.sequenceVisible = n.db.showSequenceNumbers()));
                let q = await iDt(h, $);
                (oDt(M, $, q, F, f, d, p),
                  E.push({ messageModel: $, lineStartY: q }),
                  Pt.models.addMessage($));
              } catch (q) {
                P.error("error while drawing message", q);
              }
          }
          ([
            n.db.LINETYPE.SOLID_OPEN,
            n.db.LINETYPE.DOTTED_OPEN,
            n.db.LINETYPE.SOLID,
            n.db.LINETYPE.DOTTED,
            n.db.LINETYPE.SOLID_CROSS,
            n.db.LINETYPE.DOTTED_CROSS,
            n.db.LINETYPE.SOLID_POINT,
            n.db.LINETYPE.DOTTED_POINT,
            n.db.LINETYPE.BIDIRECTIONAL_SOLID,
            n.db.LINETYPE.BIDIRECTIONAL_DOTTED,
          ].includes(M.type) && (D = D + G),
            F++);
        }
        (P.debug("createdActors", d),
          P.debug("destroyedActors", p),
          await bN(h, f, g, !1));
        for (let M of E) await sDt(h, M.messageModel, M.lineStartY, n);
        (at.mirrorActors && (await bN(h, f, g, !0)),
          R.forEach((M) => pn.drawBackgroundRect(h, M)),
          yN(h, f, g, at));
        for (let M of Pt.models.boxes) {
          ((M.height = Pt.getVerticalPos() - M.y),
            Pt.insert(M.x, M.y, M.x + M.width, M.height));
          let I = at.boxMargin * 2;
          ((M.startx = M.x - I),
            (M.starty = M.y - I * 0.25),
            (M.stopx = M.startx + M.width + 2 * I),
            (M.stopy = M.starty + M.height + I * 0.75),
            (M.stroke = "rgb(0,0,0, 0.5)"),
            pn.drawBox(h, M, at));
        }
        k && Pt.bumpVerticalPos(at.boxMargin);
        let S = Fnt(h, f, g, u),
          { bounds: O } = Pt.getBounds();
        (O.startx === void 0 && (O.startx = 0),
          O.starty === void 0 && (O.starty = 0),
          O.stopx === void 0 && (O.stopx = 0),
          O.stopy === void 0 && (O.stopy = 0));
        let v = O.stopy - O.starty;
        v < S.maxHeight && (v = S.maxHeight);
        let _ = v + 2 * at.diagramMarginY;
        at.mirrorActors && (_ = _ - at.boxMargin + at.bottomMarginAdj);
        let A = O.stopx - O.startx;
        A < S.maxWidth && (A = S.maxWidth);
        let N = A + 2 * at.diagramMarginX;
        (b &&
          h
            .append("text")
            .text(b)
            .attr("x", (O.stopx - O.startx) / 2 - 2 * at.diagramMarginX)
            .attr("y", -25),
          Ar(h, _, N, at.useMaxWidth));
        let B = b ? 40 : 0;
        (h.attr(
          "viewBox",
          O.startx -
            at.diagramMarginX +
            " -" +
            (at.diagramMarginY + B) +
            " " +
            N +
            " " +
            (_ + B),
        ),
          P.debug("models:", Pt.models));
      }, "draw");
      a(cDt, "getMaxMessageWidthPerActor");
      uDt = a(function (e) {
        let t = 0,
          r = xN(at);
        for (let n in e.links) {
          let s =
            le.calculateTextDimensions(n, r).width +
            2 * at.wrapPadding +
            2 * at.boxMargin;
          t < s && (t = s);
        }
        return t;
      }, "getRequiredPopupWidth");
      a(hDt, "calculateActorMargins");
      ((fDt = a(async function (e, t, r) {
        let n = t.get(e.from),
          i = t.get(e.to),
          s = n.x,
          o = i.x,
          l = e.wrap && e.message,
          u = $r(e.message)
            ? await xu(e.message, K())
            : le.calculateTextDimensions(
                l ? le.wrapLabel(e.message, at.width, _m(at)) : e.message,
                _m(at),
              ),
          h = {
            width: l
              ? at.width
              : Rt.getMax(at.width, u.width + 2 * at.noteMargin),
            height: 0,
            startx: n.x,
            stopx: 0,
            starty: 0,
            stopy: 0,
            message: e.message,
          };
        return (
          e.placement === r.db.PLACEMENT.RIGHTOF
            ? ((h.width = l
                ? Rt.getMax(at.width, u.width)
                : Rt.getMax(
                    n.width / 2 + i.width / 2,
                    u.width + 2 * at.noteMargin,
                  )),
              (h.startx = s + (n.width + at.actorMargin) / 2))
            : e.placement === r.db.PLACEMENT.LEFTOF
              ? ((h.width = l
                  ? Rt.getMax(at.width, u.width + 2 * at.noteMargin)
                  : Rt.getMax(
                      n.width / 2 + i.width / 2,
                      u.width + 2 * at.noteMargin,
                    )),
                (h.startx = s - h.width + (n.width - at.actorMargin) / 2))
              : e.to === e.from
                ? ((u = le.calculateTextDimensions(
                    l
                      ? le.wrapLabel(
                          e.message,
                          Rt.getMax(at.width, n.width),
                          _m(at),
                        )
                      : e.message,
                    _m(at),
                  )),
                  (h.width = l
                    ? Rt.getMax(at.width, n.width)
                    : Rt.getMax(
                        n.width,
                        at.width,
                        u.width + 2 * at.noteMargin,
                      )),
                  (h.startx = s + (n.width - h.width) / 2))
                : ((h.width =
                    Math.abs(s + n.width / 2 - (o + i.width / 2)) +
                    at.actorMargin),
                  (h.startx =
                    s < o
                      ? s + n.width / 2 - at.actorMargin / 2
                      : o + i.width / 2 - at.actorMargin / 2)),
          l &&
            (h.message = le.wrapLabel(
              e.message,
              h.width - 2 * at.wrapPadding,
              _m(at),
            )),
          P.debug(
            `NM:[${h.startx},${h.stopx},${h.starty},${h.stopy}:${h.width},${h.height}=${e.message}]`,
          ),
          h
        );
      }, "buildNoteModel")),
        (dDt = a(function (e, t, r) {
          if (
            ![
              r.db.LINETYPE.SOLID_OPEN,
              r.db.LINETYPE.DOTTED_OPEN,
              r.db.LINETYPE.SOLID,
              r.db.LINETYPE.DOTTED,
              r.db.LINETYPE.SOLID_CROSS,
              r.db.LINETYPE.DOTTED_CROSS,
              r.db.LINETYPE.SOLID_POINT,
              r.db.LINETYPE.DOTTED_POINT,
              r.db.LINETYPE.BIDIRECTIONAL_SOLID,
              r.db.LINETYPE.BIDIRECTIONAL_DOTTED,
            ].includes(e.type)
          )
            return {};
          let [n, i] = Bnt(e.from, t),
            [s, o] = Bnt(e.to, t),
            l = n <= s,
            u = l ? i : n,
            h = l ? s : o,
            f = Math.abs(s - o) > 2,
            d = a((y) => (l ? -y : y), "adjustValue");
          e.from === e.to
            ? (h = u)
            : (e.activate && !f && (h += d(at.activationWidth / 2 - 1)),
              [r.db.LINETYPE.SOLID_OPEN, r.db.LINETYPE.DOTTED_OPEN].includes(
                e.type,
              ) || (h += d(3)),
              [
                r.db.LINETYPE.BIDIRECTIONAL_SOLID,
                r.db.LINETYPE.BIDIRECTIONAL_DOTTED,
              ].includes(e.type) && (u -= d(3)));
          let p = [n, i, s, o],
            m = Math.abs(u - h);
          e.wrap &&
            e.message &&
            (e.message = le.wrapLabel(
              e.message,
              Rt.getMax(m + 2 * at.wrapPadding, at.width),
              Qh(at),
            ));
          let g = le.calculateTextDimensions(e.message, Qh(at));
          return {
            width: Rt.getMax(
              e.wrap ? 0 : g.width + 2 * at.wrapPadding,
              m + 2 * at.wrapPadding,
              at.width,
            ),
            height: 0,
            startx: u,
            stopx: h,
            starty: 0,
            stopy: 0,
            message: e.message,
            type: e.type,
            wrap: e.wrap,
            fromBounds: Math.min.apply(null, p),
            toBounds: Math.max.apply(null, p),
          };
        }, "buildMessageModel")),
        (pDt = a(async function (e, t, r, n) {
          let i = {},
            s = [],
            o,
            l,
            u;
          for (let h of e) {
            switch (h.type) {
              case n.db.LINETYPE.LOOP_START:
              case n.db.LINETYPE.ALT_START:
              case n.db.LINETYPE.OPT_START:
              case n.db.LINETYPE.PAR_START:
              case n.db.LINETYPE.PAR_OVER_START:
              case n.db.LINETYPE.CRITICAL_START:
              case n.db.LINETYPE.BREAK_START:
                s.push({
                  id: h.id,
                  msg: h.message,
                  from: Number.MAX_SAFE_INTEGER,
                  to: Number.MIN_SAFE_INTEGER,
                  width: 0,
                });
                break;
              case n.db.LINETYPE.ALT_ELSE:
              case n.db.LINETYPE.PAR_AND:
              case n.db.LINETYPE.CRITICAL_OPTION:
                h.message &&
                  ((o = s.pop()), (i[o.id] = o), (i[h.id] = o), s.push(o));
                break;
              case n.db.LINETYPE.LOOP_END:
              case n.db.LINETYPE.ALT_END:
              case n.db.LINETYPE.OPT_END:
              case n.db.LINETYPE.PAR_END:
              case n.db.LINETYPE.CRITICAL_END:
              case n.db.LINETYPE.BREAK_END:
                ((o = s.pop()), (i[o.id] = o));
                break;
              case n.db.LINETYPE.ACTIVE_START:
                {
                  let d = t.get(h.from ? h.from : h.to.actor),
                    p = P_(h.from ? h.from : h.to.actor).length,
                    m = d.x + d.width / 2 + ((p - 1) * at.activationWidth) / 2,
                    g = {
                      startx: m,
                      stopx: m + at.activationWidth,
                      actor: h.from,
                      enabled: !0,
                    };
                  Pt.activations.push(g);
                }
                break;
              case n.db.LINETYPE.ACTIVE_END:
                {
                  let d = Pt.activations
                    .map((p) => p.actor)
                    .lastIndexOf(h.from);
                  Pt.activations.splice(d, 1).splice(0, 1);
                }
                break;
            }
            h.placement !== void 0
              ? ((l = await fDt(h, t, n)),
                (h.noteModel = l),
                s.forEach((d) => {
                  ((o = d),
                    (o.from = Rt.getMin(o.from, l.startx)),
                    (o.to = Rt.getMax(o.to, l.startx + l.width)),
                    (o.width =
                      Rt.getMax(o.width, Math.abs(o.from - o.to)) -
                      at.labelBoxWidth));
                }))
              : ((u = dDt(h, t, n)),
                (h.msgModel = u),
                u.startx &&
                  u.stopx &&
                  s.length > 0 &&
                  s.forEach((d) => {
                    if (((o = d), u.startx === u.stopx)) {
                      let p = t.get(h.from),
                        m = t.get(h.to);
                      ((o.from = Rt.getMin(
                        p.x - u.width / 2,
                        p.x - p.width / 2,
                        o.from,
                      )),
                        (o.to = Rt.getMax(
                          m.x + u.width / 2,
                          m.x + p.width / 2,
                          o.to,
                        )),
                        (o.width =
                          Rt.getMax(o.width, Math.abs(o.to - o.from)) -
                          at.labelBoxWidth));
                    } else
                      ((o.from = Rt.getMin(u.startx, o.from)),
                        (o.to = Rt.getMax(u.stopx, o.to)),
                        (o.width =
                          Rt.getMax(o.width, u.width) - at.labelBoxWidth));
                  }));
          }
          return ((Pt.activations = []), P.debug("Loop type widths:", i), i);
        }, "calculateLoopBounds")),
        (Gnt = {
          bounds: Pt,
          drawActors: bN,
          drawActorsPopup: Fnt,
          setConf: $nt,
          draw: lDt,
        }));
    });
  var znt = {};
  Oe(znt, { diagram: () => mDt });
  var mDt,
    Wnt = x(() => {
      "use strict";
      Rnt();
      mN();
      Nnt();
      pe();
      Vnt();
      mDt = {
        parser: Lnt,
        get db() {
          return new I_();
        },
        renderer: Gnt,
        styles: Dnt,
        init: a((e) => {
          (e.sequence || (e.sequence = {}),
            e.wrap &&
              ((e.sequence.wrap = e.wrap), og({ sequence: { wrap: e.wrap } })));
        }, "init"),
      };
    });
  var kN,
    B_,
    TN = x(() => {
      "use strict";
      kN = (function () {
        var e = a(function (At, bt, ct, Lt) {
            for (ct = ct || {}, Lt = At.length; Lt--; ct[At[Lt]] = bt);
            return ct;
          }, "o"),
          t = [1, 18],
          r = [1, 19],
          n = [1, 20],
          i = [1, 41],
          s = [1, 42],
          o = [1, 26],
          l = [1, 24],
          u = [1, 25],
          h = [1, 32],
          f = [1, 33],
          d = [1, 34],
          p = [1, 45],
          m = [1, 35],
          g = [1, 36],
          y = [1, 37],
          b = [1, 38],
          k = [1, 27],
          T = [1, 28],
          C = [1, 29],
          L = [1, 30],
          w = [1, 31],
          D = [1, 44],
          G = [1, 46],
          E = [1, 43],
          R = [1, 47],
          F = [1, 9],
          S = [1, 8, 9],
          O = [1, 58],
          v = [1, 59],
          _ = [1, 60],
          A = [1, 61],
          N = [1, 62],
          B = [1, 63],
          M = [1, 64],
          I = [1, 8, 9, 41],
          V = [1, 76],
          $ = [
            1, 8, 9, 12, 13, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73, 74, 79, 81,
          ],
          q = [
            1, 8, 9, 12, 13, 18, 20, 22, 39, 41, 44, 50, 60, 68, 69, 70, 71, 72,
            73, 74, 79, 81, 86, 100, 102, 103,
          ],
          tt = [13, 60, 86, 100, 102, 103],
          ht = [13, 60, 73, 74, 86, 100, 102, 103],
          H = [13, 60, 68, 69, 70, 71, 72, 86, 100, 102, 103],
          kt = [1, 100],
          ft = [1, 117],
          yt = [1, 113],
          ot = [1, 109],
          dt = [1, 115],
          nt = [1, 110],
          Q = [1, 111],
          et = [1, 112],
          X = [1, 114],
          st = [1, 116],
          U = [22, 48, 60, 61, 82, 86, 87, 88, 89, 90],
          gt = [1, 8, 9, 39, 41, 44],
          z = [1, 8, 9, 22],
          ge = [1, 145],
          lt = [1, 8, 9, 61],
          jt = [1, 8, 9, 22, 48, 60, 61, 82, 86, 87, 88, 89, 90],
          Me = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              mermaidDoc: 4,
              statements: 5,
              graphConfig: 6,
              CLASS_DIAGRAM: 7,
              NEWLINE: 8,
              EOF: 9,
              statement: 10,
              classLabel: 11,
              SQS: 12,
              STR: 13,
              SQE: 14,
              namespaceName: 15,
              alphaNumToken: 16,
              classLiteralName: 17,
              DOT: 18,
              className: 19,
              GENERICTYPE: 20,
              relationStatement: 21,
              LABEL: 22,
              namespaceStatement: 23,
              classStatement: 24,
              memberStatement: 25,
              annotationStatement: 26,
              clickStatement: 27,
              styleStatement: 28,
              cssClassStatement: 29,
              noteStatement: 30,
              classDefStatement: 31,
              direction: 32,
              acc_title: 33,
              acc_title_value: 34,
              acc_descr: 35,
              acc_descr_value: 36,
              acc_descr_multiline_value: 37,
              namespaceIdentifier: 38,
              STRUCT_START: 39,
              classStatements: 40,
              STRUCT_STOP: 41,
              NAMESPACE: 42,
              classIdentifier: 43,
              STYLE_SEPARATOR: 44,
              members: 45,
              CLASS: 46,
              emptyBody: 47,
              SPACE: 48,
              ANNOTATION_START: 49,
              ANNOTATION_END: 50,
              MEMBER: 51,
              SEPARATOR: 52,
              relation: 53,
              NOTE_FOR: 54,
              noteText: 55,
              NOTE: 56,
              CLASSDEF: 57,
              classList: 58,
              stylesOpt: 59,
              ALPHA: 60,
              COMMA: 61,
              direction_tb: 62,
              direction_bt: 63,
              direction_rl: 64,
              direction_lr: 65,
              relationType: 66,
              lineType: 67,
              AGGREGATION: 68,
              EXTENSION: 69,
              COMPOSITION: 70,
              DEPENDENCY: 71,
              LOLLIPOP: 72,
              LINE: 73,
              DOTTED_LINE: 74,
              CALLBACK: 75,
              LINK: 76,
              LINK_TARGET: 77,
              CLICK: 78,
              CALLBACK_NAME: 79,
              CALLBACK_ARGS: 80,
              HREF: 81,
              STYLE: 82,
              CSSCLASS: 83,
              style: 84,
              styleComponent: 85,
              NUM: 86,
              COLON: 87,
              UNIT: 88,
              BRKT: 89,
              PCT: 90,
              commentToken: 91,
              textToken: 92,
              graphCodeTokens: 93,
              textNoTagsToken: 94,
              TAGSTART: 95,
              TAGEND: 96,
              "==": 97,
              "--": 98,
              DEFAULT: 99,
              MINUS: 100,
              keywords: 101,
              UNICODE_TEXT: 102,
              BQUOTE_STR: 103,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              7: "CLASS_DIAGRAM",
              8: "NEWLINE",
              9: "EOF",
              12: "SQS",
              13: "STR",
              14: "SQE",
              18: "DOT",
              20: "GENERICTYPE",
              22: "LABEL",
              33: "acc_title",
              34: "acc_title_value",
              35: "acc_descr",
              36: "acc_descr_value",
              37: "acc_descr_multiline_value",
              39: "STRUCT_START",
              41: "STRUCT_STOP",
              42: "NAMESPACE",
              44: "STYLE_SEPARATOR",
              46: "CLASS",
              48: "SPACE",
              49: "ANNOTATION_START",
              50: "ANNOTATION_END",
              51: "MEMBER",
              52: "SEPARATOR",
              54: "NOTE_FOR",
              56: "NOTE",
              57: "CLASSDEF",
              60: "ALPHA",
              61: "COMMA",
              62: "direction_tb",
              63: "direction_bt",
              64: "direction_rl",
              65: "direction_lr",
              68: "AGGREGATION",
              69: "EXTENSION",
              70: "COMPOSITION",
              71: "DEPENDENCY",
              72: "LOLLIPOP",
              73: "LINE",
              74: "DOTTED_LINE",
              75: "CALLBACK",
              76: "LINK",
              77: "LINK_TARGET",
              78: "CLICK",
              79: "CALLBACK_NAME",
              80: "CALLBACK_ARGS",
              81: "HREF",
              82: "STYLE",
              83: "CSSCLASS",
              86: "NUM",
              87: "COLON",
              88: "UNIT",
              89: "BRKT",
              90: "PCT",
              93: "graphCodeTokens",
              95: "TAGSTART",
              96: "TAGEND",
              97: "==",
              98: "--",
              99: "DEFAULT",
              100: "MINUS",
              101: "keywords",
              102: "UNICODE_TEXT",
              103: "BQUOTE_STR",
            },
            productions_: [
              0,
              [3, 1],
              [3, 1],
              [4, 1],
              [6, 4],
              [5, 1],
              [5, 2],
              [5, 3],
              [11, 3],
              [15, 1],
              [15, 1],
              [15, 3],
              [15, 2],
              [19, 1],
              [19, 3],
              [19, 1],
              [19, 2],
              [19, 2],
              [19, 2],
              [10, 1],
              [10, 2],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 2],
              [10, 2],
              [10, 1],
              [23, 4],
              [23, 5],
              [38, 2],
              [40, 1],
              [40, 2],
              [40, 3],
              [24, 1],
              [24, 3],
              [24, 4],
              [24, 3],
              [24, 6],
              [43, 2],
              [43, 3],
              [47, 0],
              [47, 2],
              [47, 2],
              [26, 4],
              [45, 1],
              [45, 2],
              [25, 1],
              [25, 2],
              [25, 1],
              [25, 1],
              [21, 3],
              [21, 4],
              [21, 4],
              [21, 5],
              [30, 3],
              [30, 2],
              [31, 3],
              [58, 1],
              [58, 3],
              [32, 1],
              [32, 1],
              [32, 1],
              [32, 1],
              [53, 3],
              [53, 2],
              [53, 2],
              [53, 1],
              [66, 1],
              [66, 1],
              [66, 1],
              [66, 1],
              [66, 1],
              [67, 1],
              [67, 1],
              [27, 3],
              [27, 4],
              [27, 3],
              [27, 4],
              [27, 4],
              [27, 5],
              [27, 3],
              [27, 4],
              [27, 4],
              [27, 5],
              [27, 4],
              [27, 5],
              [27, 5],
              [27, 6],
              [28, 3],
              [29, 3],
              [59, 1],
              [59, 3],
              [84, 1],
              [84, 2],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [85, 1],
              [91, 1],
              [91, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [92, 1],
              [94, 1],
              [94, 1],
              [94, 1],
              [94, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [16, 1],
              [17, 1],
              [55, 1],
            ],
            performAction: a(function (bt, ct, Lt, Z, Mt, W, Gt) {
              var j = W.length - 1;
              switch (Mt) {
                case 8:
                  this.$ = W[j - 1];
                  break;
                case 9:
                case 10:
                case 13:
                case 15:
                  this.$ = W[j];
                  break;
                case 11:
                case 14:
                  this.$ = W[j - 2] + "." + W[j];
                  break;
                case 12:
                case 16:
                  this.$ = W[j - 1] + W[j];
                  break;
                case 17:
                case 18:
                  this.$ = W[j - 1] + "~" + W[j] + "~";
                  break;
                case 19:
                  Z.addRelation(W[j]);
                  break;
                case 20:
                  ((W[j - 1].title = Z.cleanupLabel(W[j])),
                    Z.addRelation(W[j - 1]));
                  break;
                case 31:
                  ((this.$ = W[j].trim()), Z.setAccTitle(this.$));
                  break;
                case 32:
                case 33:
                  ((this.$ = W[j].trim()), Z.setAccDescription(this.$));
                  break;
                case 34:
                  Z.addClassesToNamespace(W[j - 3], W[j - 1]);
                  break;
                case 35:
                  Z.addClassesToNamespace(W[j - 4], W[j - 1]);
                  break;
                case 36:
                  ((this.$ = W[j]), Z.addNamespace(W[j]));
                  break;
                case 37:
                  this.$ = [W[j]];
                  break;
                case 38:
                  this.$ = [W[j - 1]];
                  break;
                case 39:
                  (W[j].unshift(W[j - 2]), (this.$ = W[j]));
                  break;
                case 41:
                  Z.setCssClass(W[j - 2], W[j]);
                  break;
                case 42:
                  Z.addMembers(W[j - 3], W[j - 1]);
                  break;
                case 44:
                  (Z.setCssClass(W[j - 5], W[j - 3]),
                    Z.addMembers(W[j - 5], W[j - 1]));
                  break;
                case 45:
                  ((this.$ = W[j]), Z.addClass(W[j]));
                  break;
                case 46:
                  ((this.$ = W[j - 1]),
                    Z.addClass(W[j - 1]),
                    Z.setClassLabel(W[j - 1], W[j]));
                  break;
                case 50:
                  Z.addAnnotation(W[j], W[j - 2]);
                  break;
                case 51:
                case 64:
                  this.$ = [W[j]];
                  break;
                case 52:
                  (W[j].push(W[j - 1]), (this.$ = W[j]));
                  break;
                case 53:
                  break;
                case 54:
                  Z.addMember(W[j - 1], Z.cleanupLabel(W[j]));
                  break;
                case 55:
                  break;
                case 56:
                  break;
                case 57:
                  this.$ = {
                    id1: W[j - 2],
                    id2: W[j],
                    relation: W[j - 1],
                    relationTitle1: "none",
                    relationTitle2: "none",
                  };
                  break;
                case 58:
                  this.$ = {
                    id1: W[j - 3],
                    id2: W[j],
                    relation: W[j - 1],
                    relationTitle1: W[j - 2],
                    relationTitle2: "none",
                  };
                  break;
                case 59:
                  this.$ = {
                    id1: W[j - 3],
                    id2: W[j],
                    relation: W[j - 2],
                    relationTitle1: "none",
                    relationTitle2: W[j - 1],
                  };
                  break;
                case 60:
                  this.$ = {
                    id1: W[j - 4],
                    id2: W[j],
                    relation: W[j - 2],
                    relationTitle1: W[j - 3],
                    relationTitle2: W[j - 1],
                  };
                  break;
                case 61:
                  Z.addNote(W[j], W[j - 1]);
                  break;
                case 62:
                  Z.addNote(W[j]);
                  break;
                case 63:
                  ((this.$ = W[j - 2]), Z.defineClass(W[j - 1], W[j]));
                  break;
                case 65:
                  this.$ = W[j - 2].concat([W[j]]);
                  break;
                case 66:
                  Z.setDirection("TB");
                  break;
                case 67:
                  Z.setDirection("BT");
                  break;
                case 68:
                  Z.setDirection("RL");
                  break;
                case 69:
                  Z.setDirection("LR");
                  break;
                case 70:
                  this.$ = { type1: W[j - 2], type2: W[j], lineType: W[j - 1] };
                  break;
                case 71:
                  this.$ = { type1: "none", type2: W[j], lineType: W[j - 1] };
                  break;
                case 72:
                  this.$ = { type1: W[j - 1], type2: "none", lineType: W[j] };
                  break;
                case 73:
                  this.$ = { type1: "none", type2: "none", lineType: W[j] };
                  break;
                case 74:
                  this.$ = Z.relationType.AGGREGATION;
                  break;
                case 75:
                  this.$ = Z.relationType.EXTENSION;
                  break;
                case 76:
                  this.$ = Z.relationType.COMPOSITION;
                  break;
                case 77:
                  this.$ = Z.relationType.DEPENDENCY;
                  break;
                case 78:
                  this.$ = Z.relationType.LOLLIPOP;
                  break;
                case 79:
                  this.$ = Z.lineType.LINE;
                  break;
                case 80:
                  this.$ = Z.lineType.DOTTED_LINE;
                  break;
                case 81:
                case 87:
                  ((this.$ = W[j - 2]), Z.setClickEvent(W[j - 1], W[j]));
                  break;
                case 82:
                case 88:
                  ((this.$ = W[j - 3]),
                    Z.setClickEvent(W[j - 2], W[j - 1]),
                    Z.setTooltip(W[j - 2], W[j]));
                  break;
                case 83:
                  ((this.$ = W[j - 2]), Z.setLink(W[j - 1], W[j]));
                  break;
                case 84:
                  ((this.$ = W[j - 3]), Z.setLink(W[j - 2], W[j - 1], W[j]));
                  break;
                case 85:
                  ((this.$ = W[j - 3]),
                    Z.setLink(W[j - 2], W[j - 1]),
                    Z.setTooltip(W[j - 2], W[j]));
                  break;
                case 86:
                  ((this.$ = W[j - 4]),
                    Z.setLink(W[j - 3], W[j - 2], W[j]),
                    Z.setTooltip(W[j - 3], W[j - 1]));
                  break;
                case 89:
                  ((this.$ = W[j - 3]),
                    Z.setClickEvent(W[j - 2], W[j - 1], W[j]));
                  break;
                case 90:
                  ((this.$ = W[j - 4]),
                    Z.setClickEvent(W[j - 3], W[j - 2], W[j - 1]),
                    Z.setTooltip(W[j - 3], W[j]));
                  break;
                case 91:
                  ((this.$ = W[j - 3]), Z.setLink(W[j - 2], W[j]));
                  break;
                case 92:
                  ((this.$ = W[j - 4]), Z.setLink(W[j - 3], W[j - 1], W[j]));
                  break;
                case 93:
                  ((this.$ = W[j - 4]),
                    Z.setLink(W[j - 3], W[j - 1]),
                    Z.setTooltip(W[j - 3], W[j]));
                  break;
                case 94:
                  ((this.$ = W[j - 5]),
                    Z.setLink(W[j - 4], W[j - 2], W[j]),
                    Z.setTooltip(W[j - 4], W[j - 1]));
                  break;
                case 95:
                  ((this.$ = W[j - 2]), Z.setCssStyle(W[j - 1], W[j]));
                  break;
                case 96:
                  Z.setCssClass(W[j - 1], W[j]);
                  break;
                case 97:
                  this.$ = [W[j]];
                  break;
                case 98:
                  (W[j - 2].push(W[j]), (this.$ = W[j - 2]));
                  break;
                case 100:
                  this.$ = W[j - 1] + W[j];
                  break;
              }
            }, "anonymous"),
            table: [
              {
                3: 1,
                4: 2,
                5: 3,
                6: 4,
                7: [1, 6],
                10: 5,
                16: 39,
                17: 40,
                19: 21,
                21: 7,
                23: 8,
                24: 9,
                25: 10,
                26: 11,
                27: 12,
                28: 13,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: t,
                35: r,
                37: n,
                38: 22,
                42: i,
                43: 23,
                46: s,
                49: o,
                51: l,
                52: u,
                54: h,
                56: f,
                57: d,
                60: p,
                62: m,
                63: g,
                64: y,
                65: b,
                75: k,
                76: T,
                78: C,
                82: L,
                83: w,
                86: D,
                100: G,
                102: E,
                103: R,
              },
              { 1: [3] },
              { 1: [2, 1] },
              { 1: [2, 2] },
              { 1: [2, 3] },
              e(F, [2, 5], { 8: [1, 48] }),
              { 8: [1, 49] },
              e(S, [2, 19], { 22: [1, 50] }),
              e(S, [2, 21]),
              e(S, [2, 22]),
              e(S, [2, 23]),
              e(S, [2, 24]),
              e(S, [2, 25]),
              e(S, [2, 26]),
              e(S, [2, 27]),
              e(S, [2, 28]),
              e(S, [2, 29]),
              e(S, [2, 30]),
              { 34: [1, 51] },
              { 36: [1, 52] },
              e(S, [2, 33]),
              e(S, [2, 53], {
                53: 53,
                66: 56,
                67: 57,
                13: [1, 54],
                22: [1, 55],
                68: O,
                69: v,
                70: _,
                71: A,
                72: N,
                73: B,
                74: M,
              }),
              { 39: [1, 65] },
              e(I, [2, 40], { 39: [1, 67], 44: [1, 66] }),
              e(S, [2, 55]),
              e(S, [2, 56]),
              { 16: 68, 60: p, 86: D, 100: G, 102: E },
              { 16: 39, 17: 40, 19: 69, 60: p, 86: D, 100: G, 102: E, 103: R },
              { 16: 39, 17: 40, 19: 70, 60: p, 86: D, 100: G, 102: E, 103: R },
              { 16: 39, 17: 40, 19: 71, 60: p, 86: D, 100: G, 102: E, 103: R },
              { 60: [1, 72] },
              { 13: [1, 73] },
              { 16: 39, 17: 40, 19: 74, 60: p, 86: D, 100: G, 102: E, 103: R },
              { 13: V, 55: 75 },
              { 58: 77, 60: [1, 78] },
              e(S, [2, 66]),
              e(S, [2, 67]),
              e(S, [2, 68]),
              e(S, [2, 69]),
              e($, [2, 13], {
                16: 39,
                17: 40,
                19: 80,
                18: [1, 79],
                20: [1, 81],
                60: p,
                86: D,
                100: G,
                102: E,
                103: R,
              }),
              e($, [2, 15], { 20: [1, 82] }),
              { 15: 83, 16: 84, 17: 85, 60: p, 86: D, 100: G, 102: E, 103: R },
              { 16: 39, 17: 40, 19: 86, 60: p, 86: D, 100: G, 102: E, 103: R },
              e(q, [2, 123]),
              e(q, [2, 124]),
              e(q, [2, 125]),
              e(q, [2, 126]),
              e(
                [
                  1, 8, 9, 12, 13, 20, 22, 39, 41, 44, 68, 69, 70, 71, 72, 73,
                  74, 79, 81,
                ],
                [2, 127],
              ),
              e(F, [2, 6], {
                10: 5,
                21: 7,
                23: 8,
                24: 9,
                25: 10,
                26: 11,
                27: 12,
                28: 13,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                19: 21,
                38: 22,
                43: 23,
                16: 39,
                17: 40,
                5: 87,
                33: t,
                35: r,
                37: n,
                42: i,
                46: s,
                49: o,
                51: l,
                52: u,
                54: h,
                56: f,
                57: d,
                60: p,
                62: m,
                63: g,
                64: y,
                65: b,
                75: k,
                76: T,
                78: C,
                82: L,
                83: w,
                86: D,
                100: G,
                102: E,
                103: R,
              }),
              {
                5: 88,
                10: 5,
                16: 39,
                17: 40,
                19: 21,
                21: 7,
                23: 8,
                24: 9,
                25: 10,
                26: 11,
                27: 12,
                28: 13,
                29: 14,
                30: 15,
                31: 16,
                32: 17,
                33: t,
                35: r,
                37: n,
                38: 22,
                42: i,
                43: 23,
                46: s,
                49: o,
                51: l,
                52: u,
                54: h,
                56: f,
                57: d,
                60: p,
                62: m,
                63: g,
                64: y,
                65: b,
                75: k,
                76: T,
                78: C,
                82: L,
                83: w,
                86: D,
                100: G,
                102: E,
                103: R,
              },
              e(S, [2, 20]),
              e(S, [2, 31]),
              e(S, [2, 32]),
              {
                13: [1, 90],
                16: 39,
                17: 40,
                19: 89,
                60: p,
                86: D,
                100: G,
                102: E,
                103: R,
              },
              {
                53: 91,
                66: 56,
                67: 57,
                68: O,
                69: v,
                70: _,
                71: A,
                72: N,
                73: B,
                74: M,
              },
              e(S, [2, 54]),
              { 67: 92, 73: B, 74: M },
              e(tt, [2, 73], { 66: 93, 68: O, 69: v, 70: _, 71: A, 72: N }),
              e(ht, [2, 74]),
              e(ht, [2, 75]),
              e(ht, [2, 76]),
              e(ht, [2, 77]),
              e(ht, [2, 78]),
              e(H, [2, 79]),
              e(H, [2, 80]),
              { 8: [1, 95], 24: 96, 40: 94, 43: 23, 46: s },
              { 16: 97, 60: p, 86: D, 100: G, 102: E },
              { 41: [1, 99], 45: 98, 51: kt },
              { 50: [1, 101] },
              { 13: [1, 102] },
              { 13: [1, 103] },
              { 79: [1, 104], 81: [1, 105] },
              {
                22: ft,
                48: yt,
                59: 106,
                60: ot,
                82: dt,
                84: 107,
                85: 108,
                86: nt,
                87: Q,
                88: et,
                89: X,
                90: st,
              },
              { 60: [1, 118] },
              { 13: V, 55: 119 },
              e(S, [2, 62]),
              e(S, [2, 128]),
              {
                22: ft,
                48: yt,
                59: 120,
                60: ot,
                61: [1, 121],
                82: dt,
                84: 107,
                85: 108,
                86: nt,
                87: Q,
                88: et,
                89: X,
                90: st,
              },
              e(U, [2, 64]),
              { 16: 39, 17: 40, 19: 122, 60: p, 86: D, 100: G, 102: E, 103: R },
              e($, [2, 16]),
              e($, [2, 17]),
              e($, [2, 18]),
              { 39: [2, 36] },
              {
                15: 124,
                16: 84,
                17: 85,
                18: [1, 123],
                39: [2, 9],
                60: p,
                86: D,
                100: G,
                102: E,
                103: R,
              },
              { 39: [2, 10] },
              e(gt, [2, 45], { 11: 125, 12: [1, 126] }),
              e(F, [2, 7]),
              { 9: [1, 127] },
              e(z, [2, 57]),
              { 16: 39, 17: 40, 19: 128, 60: p, 86: D, 100: G, 102: E, 103: R },
              {
                13: [1, 130],
                16: 39,
                17: 40,
                19: 129,
                60: p,
                86: D,
                100: G,
                102: E,
                103: R,
              },
              e(tt, [2, 72], { 66: 131, 68: O, 69: v, 70: _, 71: A, 72: N }),
              e(tt, [2, 71]),
              { 41: [1, 132] },
              { 24: 96, 40: 133, 43: 23, 46: s },
              { 8: [1, 134], 41: [2, 37] },
              e(I, [2, 41], { 39: [1, 135] }),
              { 41: [1, 136] },
              e(I, [2, 43]),
              { 41: [2, 51], 45: 137, 51: kt },
              { 16: 39, 17: 40, 19: 138, 60: p, 86: D, 100: G, 102: E, 103: R },
              e(S, [2, 81], { 13: [1, 139] }),
              e(S, [2, 83], { 13: [1, 141], 77: [1, 140] }),
              e(S, [2, 87], { 13: [1, 142], 80: [1, 143] }),
              { 13: [1, 144] },
              e(S, [2, 95], { 61: ge }),
              e(lt, [2, 97], {
                85: 146,
                22: ft,
                48: yt,
                60: ot,
                82: dt,
                86: nt,
                87: Q,
                88: et,
                89: X,
                90: st,
              }),
              e(jt, [2, 99]),
              e(jt, [2, 101]),
              e(jt, [2, 102]),
              e(jt, [2, 103]),
              e(jt, [2, 104]),
              e(jt, [2, 105]),
              e(jt, [2, 106]),
              e(jt, [2, 107]),
              e(jt, [2, 108]),
              e(jt, [2, 109]),
              e(S, [2, 96]),
              e(S, [2, 61]),
              e(S, [2, 63], { 61: ge }),
              { 60: [1, 147] },
              e($, [2, 14]),
              { 15: 148, 16: 84, 17: 85, 60: p, 86: D, 100: G, 102: E, 103: R },
              { 39: [2, 12] },
              e(gt, [2, 46]),
              { 13: [1, 149] },
              { 1: [2, 4] },
              e(z, [2, 59]),
              e(z, [2, 58]),
              { 16: 39, 17: 40, 19: 150, 60: p, 86: D, 100: G, 102: E, 103: R },
              e(tt, [2, 70]),
              e(S, [2, 34]),
              { 41: [1, 151] },
              { 24: 96, 40: 152, 41: [2, 38], 43: 23, 46: s },
              { 45: 153, 51: kt },
              e(I, [2, 42]),
              { 41: [2, 52] },
              e(S, [2, 50]),
              e(S, [2, 82]),
              e(S, [2, 84]),
              e(S, [2, 85], { 77: [1, 154] }),
              e(S, [2, 88]),
              e(S, [2, 89], { 13: [1, 155] }),
              e(S, [2, 91], { 13: [1, 157], 77: [1, 156] }),
              {
                22: ft,
                48: yt,
                60: ot,
                82: dt,
                84: 158,
                85: 108,
                86: nt,
                87: Q,
                88: et,
                89: X,
                90: st,
              },
              e(jt, [2, 100]),
              e(U, [2, 65]),
              { 39: [2, 11] },
              { 14: [1, 159] },
              e(z, [2, 60]),
              e(S, [2, 35]),
              { 41: [2, 39] },
              { 41: [1, 160] },
              e(S, [2, 86]),
              e(S, [2, 90]),
              e(S, [2, 92]),
              e(S, [2, 93], { 77: [1, 161] }),
              e(lt, [2, 98], {
                85: 146,
                22: ft,
                48: yt,
                60: ot,
                82: dt,
                86: nt,
                87: Q,
                88: et,
                89: X,
                90: st,
              }),
              e(gt, [2, 8]),
              e(I, [2, 44]),
              e(S, [2, 94]),
            ],
            defaultActions: {
              2: [2, 1],
              3: [2, 2],
              4: [2, 3],
              83: [2, 36],
              85: [2, 10],
              124: [2, 12],
              127: [2, 4],
              137: [2, 52],
              148: [2, 11],
              152: [2, 39],
            },
            parseError: a(function (bt, ct) {
              if (ct.recoverable) this.trace(bt);
              else {
                var Lt = new Error(bt);
                throw ((Lt.hash = ct), Lt);
              }
            }, "parseError"),
            parse: a(function (bt) {
              var ct = this,
                Lt = [0],
                Z = [],
                Mt = [null],
                W = [],
                Gt = this.table,
                j = "",
                Et = 0,
                mt = 0,
                Xt = 0,
                Ft = 2,
                _t = 1,
                Qe = W.slice.call(arguments, 1),
                It = Object.create(this.lexer),
                xr = { yy: {} };
              for (var Ze in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, Ze) &&
                  (xr.yy[Ze] = this.yy[Ze]);
              (It.setInput(bt, xr.yy),
                (xr.yy.lexer = It),
                (xr.yy.parser = this),
                typeof It.yylloc > "u" && (It.yylloc = {}));
              var mn = It.yylloc;
              W.push(mn);
              var Ae = It.options && It.options.ranges;
              typeof xr.yy.parseError == "function"
                ? (this.parseError = xr.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function Te(ne) {
                ((Lt.length = Lt.length - 2 * ne),
                  (Mt.length = Mt.length - ne),
                  (W.length = W.length - ne));
              }
              a(Te, "popStack");
              function Je() {
                var ne;
                return (
                  (ne = Z.pop() || It.lex() || _t),
                  typeof ne != "number" &&
                    (ne instanceof Array && ((Z = ne), (ne = Z.pop())),
                    (ne = ct.symbols_[ne] || ne)),
                  ne
                );
              }
              a(Je, "lex");
              for (var Se, hr, Sn, Ee, $e, Le, xe = {}, fe, ye, be, Ht; ; ) {
                if (
                  ((Sn = Lt[Lt.length - 1]),
                  this.defaultActions[Sn]
                    ? (Ee = this.defaultActions[Sn])
                    : ((Se === null || typeof Se > "u") && (Se = Je()),
                      (Ee = Gt[Sn] && Gt[Sn][Se])),
                  typeof Ee > "u" || !Ee.length || !Ee[0])
                ) {
                  var Dn = "";
                  Ht = [];
                  for (fe in Gt[Sn])
                    this.terminals_[fe] &&
                      fe > Ft &&
                      Ht.push("'" + this.terminals_[fe] + "'");
                  (It.showPosition
                    ? (Dn =
                        "Parse error on line " +
                        (Et + 1) +
                        `:
` +
                        It.showPosition() +
                        `
Expecting ` +
                        Ht.join(", ") +
                        ", got '" +
                        (this.terminals_[Se] || Se) +
                        "'")
                    : (Dn =
                        "Parse error on line " +
                        (Et + 1) +
                        ": Unexpected " +
                        (Se == _t
                          ? "end of input"
                          : "'" + (this.terminals_[Se] || Se) + "'")),
                    this.parseError(Dn, {
                      text: It.match,
                      token: this.terminals_[Se] || Se,
                      line: It.yylineno,
                      loc: mn,
                      expected: Ht,
                    }));
                }
                if (Ee[0] instanceof Array && Ee.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      Sn +
                      ", token: " +
                      Se,
                  );
                switch (Ee[0]) {
                  case 1:
                    (Lt.push(Se),
                      Mt.push(It.yytext),
                      W.push(It.yylloc),
                      Lt.push(Ee[1]),
                      (Se = null),
                      hr
                        ? ((Se = hr), (hr = null))
                        : ((mt = It.yyleng),
                          (j = It.yytext),
                          (Et = It.yylineno),
                          (mn = It.yylloc),
                          Xt > 0 && Xt--));
                    break;
                  case 2:
                    if (
                      ((ye = this.productions_[Ee[1]][1]),
                      (xe.$ = Mt[Mt.length - ye]),
                      (xe._$ = {
                        first_line: W[W.length - (ye || 1)].first_line,
                        last_line: W[W.length - 1].last_line,
                        first_column: W[W.length - (ye || 1)].first_column,
                        last_column: W[W.length - 1].last_column,
                      }),
                      Ae &&
                        (xe._$.range = [
                          W[W.length - (ye || 1)].range[0],
                          W[W.length - 1].range[1],
                        ]),
                      (Le = this.performAction.apply(
                        xe,
                        [j, mt, Et, xr.yy, Ee[1], Mt, W].concat(Qe),
                      )),
                      typeof Le < "u")
                    )
                      return Le;
                    (ye &&
                      ((Lt = Lt.slice(0, -1 * ye * 2)),
                      (Mt = Mt.slice(0, -1 * ye)),
                      (W = W.slice(0, -1 * ye))),
                      Lt.push(this.productions_[Ee[1]][0]),
                      Mt.push(xe.$),
                      W.push(xe._$),
                      (be = Gt[Lt[Lt.length - 2]][Lt[Lt.length - 1]]),
                      Lt.push(be));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          se = (function () {
            var At = {
              EOF: 1,
              parseError: a(function (ct, Lt) {
                if (this.yy.parser) this.yy.parser.parseError(ct, Lt);
                else throw new Error(ct);
              }, "parseError"),
              setInput: a(function (bt, ct) {
                return (
                  (this.yy = ct || this.yy || {}),
                  (this._input = bt),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var bt = this._input[0];
                ((this.yytext += bt),
                  this.yyleng++,
                  this.offset++,
                  (this.match += bt),
                  (this.matched += bt));
                var ct = bt.match(/(?:\r\n?|\n).*/g);
                return (
                  ct
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  bt
                );
              }, "input"),
              unput: a(function (bt) {
                var ct = bt.length,
                  Lt = bt.split(/(?:\r\n?|\n)/g);
                ((this._input = bt + this._input),
                  (this.yytext = this.yytext.substr(
                    0,
                    this.yytext.length - ct,
                  )),
                  (this.offset -= ct));
                var Z = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  Lt.length - 1 && (this.yylineno -= Lt.length - 1));
                var Mt = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: Lt
                      ? (Lt.length === Z.length
                          ? this.yylloc.first_column
                          : 0) +
                        Z[Z.length - Lt.length].length -
                        Lt[0].length
                      : this.yylloc.first_column - ct,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [Mt[0], Mt[0] + this.yyleng - ct]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (bt) {
                this.unput(this.match.slice(bt));
              }, "less"),
              pastInput: a(function () {
                var bt = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (bt.length > 20 ? "..." : "") +
                  bt.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var bt = this.match;
                return (
                  bt.length < 20 &&
                    (bt += this._input.substr(0, 20 - bt.length)),
                  (bt.substr(0, 20) + (bt.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var bt = this.pastInput(),
                  ct = new Array(bt.length + 1).join("-");
                return (
                  bt +
                  this.upcomingInput() +
                  `
` +
                  ct +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (bt, ct) {
                var Lt, Z, Mt;
                if (
                  (this.options.backtrack_lexer &&
                    ((Mt = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (Mt.yylloc.range = this.yylloc.range.slice(0))),
                  (Z = bt[0].match(/(?:\r\n?|\n).*/g)),
                  Z && (this.yylineno += Z.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: Z
                      ? Z[Z.length - 1].length -
                        Z[Z.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + bt[0].length,
                  }),
                  (this.yytext += bt[0]),
                  (this.match += bt[0]),
                  (this.matches = bt),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(bt[0].length)),
                  (this.matched += bt[0]),
                  (Lt = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    ct,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  Lt)
                )
                  return Lt;
                if (this._backtrack) {
                  for (var W in Mt) this[W] = Mt[W];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var bt, ct, Lt, Z;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var Mt = this._currentRules(), W = 0; W < Mt.length; W++)
                  if (
                    ((Lt = this._input.match(this.rules[Mt[W]])),
                    Lt && (!ct || Lt[0].length > ct[0].length))
                  ) {
                    if (((ct = Lt), (Z = W), this.options.backtrack_lexer)) {
                      if (((bt = this.test_match(Lt, Mt[W])), bt !== !1))
                        return bt;
                      if (this._backtrack) {
                        ct = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return ct
                  ? ((bt = this.test_match(ct, Mt[Z])), bt !== !1 ? bt : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var ct = this.next();
                return ct || this.lex();
              }, "lex"),
              begin: a(function (ct) {
                this.conditionStack.push(ct);
              }, "begin"),
              popState: a(function () {
                var ct = this.conditionStack.length - 1;
                return ct > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (ct) {
                return (
                  (ct = this.conditionStack.length - 1 - Math.abs(ct || 0)),
                  ct >= 0 ? this.conditionStack[ct] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (ct) {
                this.begin(ct);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: {},
              performAction: a(function (ct, Lt, Z, Mt) {
                var W = Mt;
                switch (Z) {
                  case 0:
                    return 62;
                  case 1:
                    return 63;
                  case 2:
                    return 64;
                  case 3:
                    return 65;
                  case 4:
                    break;
                  case 5:
                    break;
                  case 6:
                    return (this.begin("acc_title"), 33);
                    break;
                  case 7:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 8:
                    return (this.begin("acc_descr"), 35);
                    break;
                  case 9:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 10:
                    this.begin("acc_descr_multiline");
                    break;
                  case 11:
                    this.popState();
                    break;
                  case 12:
                    return "acc_descr_multiline_value";
                  case 13:
                    return 8;
                  case 14:
                    break;
                  case 15:
                    return 7;
                  case 16:
                    return 7;
                  case 17:
                    return "EDGE_STATE";
                  case 18:
                    this.begin("callback_name");
                    break;
                  case 19:
                    this.popState();
                    break;
                  case 20:
                    (this.popState(), this.begin("callback_args"));
                    break;
                  case 21:
                    return 79;
                  case 22:
                    this.popState();
                    break;
                  case 23:
                    return 80;
                  case 24:
                    this.popState();
                    break;
                  case 25:
                    return "STR";
                  case 26:
                    this.begin("string");
                    break;
                  case 27:
                    return 82;
                  case 28:
                    return 57;
                  case 29:
                    return (this.begin("namespace"), 42);
                    break;
                  case 30:
                    return (this.popState(), 8);
                    break;
                  case 31:
                    break;
                  case 32:
                    return (this.begin("namespace-body"), 39);
                    break;
                  case 33:
                    return (this.popState(), 41);
                    break;
                  case 34:
                    return "EOF_IN_STRUCT";
                  case 35:
                    return 8;
                  case 36:
                    break;
                  case 37:
                    return "EDGE_STATE";
                  case 38:
                    return (this.begin("class"), 46);
                    break;
                  case 39:
                    return (this.popState(), 8);
                    break;
                  case 40:
                    break;
                  case 41:
                    return (this.popState(), this.popState(), 41);
                    break;
                  case 42:
                    return (this.begin("class-body"), 39);
                    break;
                  case 43:
                    return (this.popState(), 41);
                    break;
                  case 44:
                    return "EOF_IN_STRUCT";
                  case 45:
                    return "EDGE_STATE";
                  case 46:
                    return "OPEN_IN_STRUCT";
                  case 47:
                    break;
                  case 48:
                    return "MEMBER";
                  case 49:
                    return 83;
                  case 50:
                    return 75;
                  case 51:
                    return 76;
                  case 52:
                    return 78;
                  case 53:
                    return 54;
                  case 54:
                    return 56;
                  case 55:
                    return 49;
                  case 56:
                    return 50;
                  case 57:
                    return 81;
                  case 58:
                    this.popState();
                    break;
                  case 59:
                    return "GENERICTYPE";
                  case 60:
                    this.begin("generic");
                    break;
                  case 61:
                    this.popState();
                    break;
                  case 62:
                    return "BQUOTE_STR";
                  case 63:
                    this.begin("bqstring");
                    break;
                  case 64:
                    return 77;
                  case 65:
                    return 77;
                  case 66:
                    return 77;
                  case 67:
                    return 77;
                  case 68:
                    return 69;
                  case 69:
                    return 69;
                  case 70:
                    return 71;
                  case 71:
                    return 71;
                  case 72:
                    return 70;
                  case 73:
                    return 68;
                  case 74:
                    return 72;
                  case 75:
                    return 73;
                  case 76:
                    return 74;
                  case 77:
                    return 22;
                  case 78:
                    return 44;
                  case 79:
                    return 100;
                  case 80:
                    return 18;
                  case 81:
                    return "PLUS";
                  case 82:
                    return 87;
                  case 83:
                    return 61;
                  case 84:
                    return 89;
                  case 85:
                    return 89;
                  case 86:
                    return 90;
                  case 87:
                    return "EQUALS";
                  case 88:
                    return "EQUALS";
                  case 89:
                    return 60;
                  case 90:
                    return 12;
                  case 91:
                    return 14;
                  case 92:
                    return "PUNCTUATION";
                  case 93:
                    return 86;
                  case 94:
                    return 102;
                  case 95:
                    return 48;
                  case 96:
                    return 48;
                  case 97:
                    return 9;
                }
              }, "anonymous"),
              rules: [
                /^(?:.*direction\s+TB[^\n]*)/,
                /^(?:.*direction\s+BT[^\n]*)/,
                /^(?:.*direction\s+RL[^\n]*)/,
                /^(?:.*direction\s+LR[^\n]*)/,
                /^(?:%%(?!\{)*[^\n]*(\r?\n?)+)/,
                /^(?:%%[^\n]*(\r?\n)*)/,
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:classDiagram-v2\b)/,
                /^(?:classDiagram\b)/,
                /^(?:\[\*\])/,
                /^(?:call[\s]+)/,
                /^(?:\([\s]*\))/,
                /^(?:\()/,
                /^(?:[^(]*)/,
                /^(?:\))/,
                /^(?:[^)]*)/,
                /^(?:["])/,
                /^(?:[^"]*)/,
                /^(?:["])/,
                /^(?:style\b)/,
                /^(?:classDef\b)/,
                /^(?:namespace\b)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:[{])/,
                /^(?:[}])/,
                /^(?:$)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:\[\*\])/,
                /^(?:class\b)/,
                /^(?:\s*(\r?\n)+)/,
                /^(?:\s+)/,
                /^(?:[}])/,
                /^(?:[{])/,
                /^(?:[}])/,
                /^(?:$)/,
                /^(?:\[\*\])/,
                /^(?:[{])/,
                /^(?:[\n])/,
                /^(?:[^{}\n]*)/,
                /^(?:cssClass\b)/,
                /^(?:callback\b)/,
                /^(?:link\b)/,
                /^(?:click\b)/,
                /^(?:note for\b)/,
                /^(?:note\b)/,
                /^(?:<<)/,
                /^(?:>>)/,
                /^(?:href\b)/,
                /^(?:[~])/,
                /^(?:[^~]*)/,
                /^(?:~)/,
                /^(?:[`])/,
                /^(?:[^`]+)/,
                /^(?:[`])/,
                /^(?:_self\b)/,
                /^(?:_blank\b)/,
                /^(?:_parent\b)/,
                /^(?:_top\b)/,
                /^(?:\s*<\|)/,
                /^(?:\s*\|>)/,
                /^(?:\s*>)/,
                /^(?:\s*<)/,
                /^(?:\s*\*)/,
                /^(?:\s*o\b)/,
                /^(?:\s*\(\))/,
                /^(?:--)/,
                /^(?:\.\.)/,
                /^(?::{1}[^:\n;]+)/,
                /^(?::{3})/,
                /^(?:-)/,
                /^(?:\.)/,
                /^(?:\+)/,
                /^(?::)/,
                /^(?:,)/,
                /^(?:#)/,
                /^(?:#)/,
                /^(?:%)/,
                /^(?:=)/,
                /^(?:=)/,
                /^(?:\w+)/,
                /^(?:\[)/,
                /^(?:\])/,
                /^(?:[!"#$%&'*+,-.`?\\/])/,
                /^(?:[0-9]+)/,
                /^(?:[\u00AA\u00B5\u00BA\u00C0-\u00D6\u00D8-\u00F6]|[\u00F8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377]|[\u037A-\u037D\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5]|[\u03F7-\u0481\u048A-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA]|[\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE]|[\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA]|[\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0]|[\u08A2-\u08AC\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0977]|[\u0979-\u097F\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2]|[\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A]|[\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39]|[\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8]|[\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0B05-\u0B0C]|[\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C]|[\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99]|[\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0]|[\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C33\u0C35-\u0C39\u0C3D]|[\u0C58\u0C59\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3]|[\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10]|[\u0D12-\u0D3A\u0D3D\u0D4E\u0D60\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1]|[\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81]|[\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3]|[\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6]|[\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A]|[\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081]|[\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D]|[\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0]|[\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310]|[\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F4\u1401-\u166C]|[\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u1700-\u170C\u170E-\u1711]|[\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7]|[\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191C]|[\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19C1-\u19C7\u1A00-\u1A16]|[\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF]|[\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC]|[\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D]|[\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D]|[\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3]|[\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F]|[\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128]|[\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184]|[\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3]|[\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6]|[\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE]|[\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C]|[\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D]|[\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FCC]|[\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B]|[\uA640-\uA66E\uA67F-\uA697\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788]|[\uA78B-\uA78E\uA790-\uA793\uA7A0-\uA7AA\uA7F8-\uA801\uA803-\uA805]|[\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB]|[\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uAA00-\uAA28]|[\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA80-\uAAAF\uAAB1\uAAB5]|[\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4]|[\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E]|[\uABC0-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D]|[\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36]|[\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D]|[\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC]|[\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF]|[\uFFD2-\uFFD7\uFFDA-\uFFDC])/,
                /^(?:\s)/,
                /^(?:\s)/,
                /^(?:$)/,
              ],
              conditions: {
                "namespace-body": {
                  rules: [
                    26, 33, 34, 35, 36, 37, 38, 49, 50, 51, 52, 53, 54, 55, 56,
                    57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
                    76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94,
                    95, 97,
                  ],
                  inclusive: !1,
                },
                namespace: {
                  rules: [
                    26, 29, 30, 31, 32, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60,
                    63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
                    78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                "class-body": {
                  rules: [
                    26, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56,
                    57, 60, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
                    76, 77, 78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94,
                    95, 97,
                  ],
                  inclusive: !1,
                },
                class: {
                  rules: [
                    26, 39, 40, 41, 42, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60,
                    63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77,
                    78, 79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                acc_descr_multiline: {
                  rules: [
                    11, 12, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64,
                    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
                    80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                acc_descr: {
                  rules: [
                    9, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65,
                    66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
                    81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                acc_title: {
                  rules: [
                    7, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65,
                    66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80,
                    81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                callback_args: {
                  rules: [
                    22, 23, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64,
                    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
                    80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                callback_name: {
                  rules: [
                    19, 20, 21, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63,
                    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78,
                    79, 80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                href: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66,
                    67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
                    86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                struct: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64, 65, 66,
                    67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81,
                    86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                generic: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 63, 64,
                    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
                    80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                bqstring: {
                  rules: [
                    26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 61, 62, 63, 64,
                    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
                    80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                string: {
                  rules: [
                    24, 25, 26, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64,
                    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
                    80, 81, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 97,
                  ],
                  inclusive: !1,
                },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 8, 10, 13, 14, 15, 16, 17, 18, 26, 27,
                    28, 29, 38, 49, 50, 51, 52, 53, 54, 55, 56, 57, 60, 63, 64,
                    65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79,
                    80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94,
                    95, 96, 97,
                  ],
                  inclusive: !0,
                },
              },
            };
            return At;
          })();
        Me.lexer = se;
        function Nt() {
          this.yy = {};
        }
        return (
          a(Nt, "Parser"),
          (Nt.prototype = Me),
          (Me.Parser = Nt),
          new Nt()
        );
      })();
      kN.parser = kN;
      B_ = kN;
    });
  var qnt,
    Wy,
    Hnt = x(() => {
      "use strict";
      pe();
      Be();
      ((qnt = ["#", "+", "~", "-", ""]),
        (Wy = class {
          static {
            a(this, "ClassMember");
          }
          constructor(t, r) {
            ((this.memberType = r),
              (this.visibility = ""),
              (this.classifier = ""),
              (this.text = ""));
            let n = Ie(t, K());
            this.parseMember(n);
          }
          getDisplayDetails() {
            let t = this.visibility + ro(this.id);
            (this.memberType === "method" &&
              ((t += `(${ro(this.parameters.trim())})`),
              this.returnType && (t += " : " + ro(this.returnType))),
              (t = t.trim()));
            let r = this.parseClassifier();
            return { displayText: t, cssStyle: r };
          }
          parseMember(t) {
            let r = "";
            if (this.memberType === "method") {
              let s = /([#+~-])?(.+)\((.*)\)([\s$*])?(.*)([$*])?/.exec(t);
              if (s) {
                let o = s[1] ? s[1].trim() : "";
                if (
                  (qnt.includes(o) && (this.visibility = o),
                  (this.id = s[2]),
                  (this.parameters = s[3] ? s[3].trim() : ""),
                  (r = s[4] ? s[4].trim() : ""),
                  (this.returnType = s[5] ? s[5].trim() : ""),
                  r === "")
                ) {
                  let l = this.returnType.substring(this.returnType.length - 1);
                  /[$*]/.exec(l) &&
                    ((r = l),
                    (this.returnType = this.returnType.substring(
                      0,
                      this.returnType.length - 1,
                    )));
                }
              }
            } else {
              let i = t.length,
                s = t.substring(0, 1),
                o = t.substring(i - 1);
              (qnt.includes(s) && (this.visibility = s),
                /[$*]/.exec(o) && (r = o),
                (this.id = t.substring(
                  this.visibility === "" ? 0 : 1,
                  r === "" ? i : i - 1,
                )));
            }
            ((this.classifier = r),
              (this.id = this.id.startsWith(" ")
                ? " " + this.id.trim()
                : this.id.trim()));
            let n = `${this.visibility ? "\\" + this.visibility : ""}${ro(this.id)}${this.memberType === "method" ? `(${ro(this.parameters)})${this.returnType ? " : " + ro(this.returnType) : ""}` : ""}`;
            ((this.text = n.replaceAll("<", "&lt;").replaceAll(">", "&gt;")),
              this.text.startsWith("\\&lt;") &&
                (this.text = this.text.replace("\\&lt;", "~")));
          }
          parseClassifier() {
            switch (this.classifier) {
              case "*":
                return "font-style:italic;";
              case "$":
                return "text-decoration:underline;";
              default:
                return "";
            }
          }
        }));
    });
  var F_,
    Ynt,
    Zh,
    Cm,
    SN = x(() => {
      "use strict";
      Ge();
      Vt();
      pe();
      Be();
      _e();
      yn();
      Hnt();
      ((F_ = "classId-"),
        (Ynt = 0),
        (Zh = a((e) => Rt.sanitizeText(e, K()), "sanitizeText")),
        (Cm = class {
          constructor() {
            this.relations = [];
            this.classes = new Map();
            this.styleClasses = new Map();
            this.notes = [];
            this.interfaces = [];
            this.namespaces = new Map();
            this.namespaceCounter = 0;
            this.functions = [];
            this.lineType = { LINE: 0, DOTTED_LINE: 1 };
            this.relationType = {
              AGGREGATION: 0,
              EXTENSION: 1,
              COMPOSITION: 2,
              DEPENDENCY: 3,
              LOLLIPOP: 4,
            };
            this.setupToolTips = a((t) => {
              let r = xt(".mermaidTooltip");
              ((r._groups || r)[0][0] === null &&
                (r = xt("body")
                  .append("div")
                  .attr("class", "mermaidTooltip")
                  .style("opacity", 0)),
                xt(t)
                  .select("svg")
                  .selectAll("g.node")
                  .on("mouseover", (s) => {
                    let o = xt(s.currentTarget);
                    if (o.attr("title") === null) return;
                    let u = this.getBoundingClientRect();
                    (r.transition().duration(200).style("opacity", ".9"),
                      r
                        .text(o.attr("title"))
                        .style(
                          "left",
                          window.scrollX +
                            u.left +
                            (u.right - u.left) / 2 +
                            "px",
                        )
                        .style(
                          "top",
                          window.scrollY +
                            u.top -
                            14 +
                            document.body.scrollTop +
                            "px",
                        ),
                      r.html(r.html().replace(/&lt;br\/&gt;/g, "<br/>")),
                      o.classed("hover", !0));
                  })
                  .on("mouseout", (s) => {
                    (r.transition().duration(500).style("opacity", 0),
                      xt(s.currentTarget).classed("hover", !1));
                  }));
            }, "setupToolTips");
            this.direction = "TB";
            this.setAccTitle = Xe;
            this.getAccTitle = tr;
            this.setAccDescription = er;
            this.getAccDescription = rr;
            this.setDiagramTitle = lr;
            this.getDiagramTitle = nr;
            this.getConfig = a(() => K().class, "getConfig");
            (this.functions.push(this.setupToolTips.bind(this)),
              this.clear(),
              (this.addRelation = this.addRelation.bind(this)),
              (this.addClassesToNamespace =
                this.addClassesToNamespace.bind(this)),
              (this.addNamespace = this.addNamespace.bind(this)),
              (this.setCssClass = this.setCssClass.bind(this)),
              (this.addMembers = this.addMembers.bind(this)),
              (this.addClass = this.addClass.bind(this)),
              (this.setClassLabel = this.setClassLabel.bind(this)),
              (this.addAnnotation = this.addAnnotation.bind(this)),
              (this.addMember = this.addMember.bind(this)),
              (this.cleanupLabel = this.cleanupLabel.bind(this)),
              (this.addNote = this.addNote.bind(this)),
              (this.defineClass = this.defineClass.bind(this)),
              (this.setDirection = this.setDirection.bind(this)),
              (this.setLink = this.setLink.bind(this)),
              (this.bindFunctions = this.bindFunctions.bind(this)),
              (this.clear = this.clear.bind(this)),
              (this.setTooltip = this.setTooltip.bind(this)),
              (this.setClickEvent = this.setClickEvent.bind(this)),
              (this.setCssStyle = this.setCssStyle.bind(this)));
          }
          static {
            a(this, "ClassDB");
          }
          splitClassNameAndType(t) {
            let r = Rt.sanitizeText(t, K()),
              n = "",
              i = r;
            if (r.indexOf("~") > 0) {
              let s = r.split("~");
              ((i = Zh(s[0])), (n = Zh(s[1])));
            }
            return { className: i, type: n };
          }
          setClassLabel(t, r) {
            let n = Rt.sanitizeText(t, K());
            r && (r = Zh(r));
            let { className: i } = this.splitClassNameAndType(n);
            ((this.classes.get(i).label = r),
              (this.classes.get(i).text =
                `${r}${this.classes.get(i).type ? `<${this.classes.get(i).type}>` : ""}`));
          }
          addClass(t) {
            let r = Rt.sanitizeText(t, K()),
              { className: n, type: i } = this.splitClassNameAndType(r);
            if (this.classes.has(n)) return;
            let s = Rt.sanitizeText(n, K());
            (this.classes.set(s, {
              id: s,
              type: i,
              label: s,
              text: `${s}${i ? `&lt;${i}&gt;` : ""}`,
              shape: "classBox",
              cssClasses: "default",
              methods: [],
              members: [],
              annotations: [],
              styles: [],
              domId: F_ + s + "-" + Ynt,
            }),
              Ynt++);
          }
          addInterface(t, r) {
            let n = {
              id: `interface${this.interfaces.length}`,
              label: t,
              classId: r,
            };
            this.interfaces.push(n);
          }
          lookUpDomId(t) {
            let r = Rt.sanitizeText(t, K());
            if (this.classes.has(r)) return this.classes.get(r).domId;
            throw new Error("Class not found: " + r);
          }
          clear() {
            ((this.relations = []),
              (this.classes = new Map()),
              (this.notes = []),
              (this.interfaces = []),
              (this.functions = []),
              this.functions.push(this.setupToolTips.bind(this)),
              (this.namespaces = new Map()),
              (this.namespaceCounter = 0),
              (this.direction = "TB"),
              Ye());
          }
          getClass(t) {
            return this.classes.get(t);
          }
          getClasses() {
            return this.classes;
          }
          getRelations() {
            return this.relations;
          }
          getNotes() {
            return this.notes;
          }
          addRelation(t) {
            P.debug("Adding relation: " + JSON.stringify(t));
            let r = [
              this.relationType.LOLLIPOP,
              this.relationType.AGGREGATION,
              this.relationType.COMPOSITION,
              this.relationType.DEPENDENCY,
              this.relationType.EXTENSION,
            ];
            (t.relation.type1 === this.relationType.LOLLIPOP &&
            !r.includes(t.relation.type2)
              ? (this.addClass(t.id2),
                this.addInterface(t.id1, t.id2),
                (t.id1 = `interface${this.interfaces.length - 1}`))
              : t.relation.type2 === this.relationType.LOLLIPOP &&
                  !r.includes(t.relation.type1)
                ? (this.addClass(t.id1),
                  this.addInterface(t.id2, t.id1),
                  (t.id2 = `interface${this.interfaces.length - 1}`))
                : (this.addClass(t.id1), this.addClass(t.id2)),
              (t.id1 = this.splitClassNameAndType(t.id1).className),
              (t.id2 = this.splitClassNameAndType(t.id2).className),
              (t.relationTitle1 = Rt.sanitizeText(
                t.relationTitle1.trim(),
                K(),
              )),
              (t.relationTitle2 = Rt.sanitizeText(
                t.relationTitle2.trim(),
                K(),
              )),
              this.relations.push(t));
          }
          addAnnotation(t, r) {
            let n = this.splitClassNameAndType(t).className;
            this.classes.get(n).annotations.push(r);
          }
          addMember(t, r) {
            this.addClass(t);
            let n = this.splitClassNameAndType(t).className,
              i = this.classes.get(n);
            if (typeof r == "string") {
              let s = r.trim();
              s.startsWith("<<") && s.endsWith(">>")
                ? i.annotations.push(Zh(s.substring(2, s.length - 2)))
                : s.indexOf(")") > 0
                  ? i.methods.push(new Wy(s, "method"))
                  : s && i.members.push(new Wy(s, "attribute"));
            }
          }
          addMembers(t, r) {
            Array.isArray(r) &&
              (r.reverse(), r.forEach((n) => this.addMember(t, n)));
          }
          addNote(t, r) {
            let n = { id: `note${this.notes.length}`, class: r, text: t };
            this.notes.push(n);
          }
          cleanupLabel(t) {
            return (t.startsWith(":") && (t = t.substring(1)), Zh(t.trim()));
          }
          setCssClass(t, r) {
            t.split(",").forEach((n) => {
              let i = n;
              /\d/.exec(n[0]) && (i = F_ + i);
              let s = this.classes.get(i);
              s && (s.cssClasses += " " + r);
            });
          }
          defineClass(t, r) {
            for (let n of t) {
              let i = this.styleClasses.get(n);
              (i === void 0 &&
                ((i = { id: n, styles: [], textStyles: [] }),
                this.styleClasses.set(n, i)),
                r &&
                  r.forEach((s) => {
                    if (/color/.exec(s)) {
                      let o = s.replace("fill", "bgFill");
                      i.textStyles.push(o);
                    }
                    i.styles.push(s);
                  }),
                this.classes.forEach((s) => {
                  s.cssClasses.includes(n) &&
                    s.styles.push(...r.flatMap((o) => o.split(",")));
                }));
            }
          }
          setTooltip(t, r) {
            t.split(",").forEach((n) => {
              r !== void 0 && (this.classes.get(n).tooltip = Zh(r));
            });
          }
          getTooltip(t, r) {
            return r && this.namespaces.has(r)
              ? this.namespaces.get(r).classes.get(t).tooltip
              : this.classes.get(t).tooltip;
          }
          setLink(t, r, n) {
            let i = K();
            (t.split(",").forEach((s) => {
              let o = s;
              /\d/.exec(s[0]) && (o = F_ + o);
              let l = this.classes.get(o);
              l &&
                ((l.link = le.formatUrl(r, i)),
                i.securityLevel === "sandbox"
                  ? (l.linkTarget = "_top")
                  : typeof n == "string"
                    ? (l.linkTarget = Zh(n))
                    : (l.linkTarget = "_blank"));
            }),
              this.setCssClass(t, "clickable"));
          }
          setClickEvent(t, r, n) {
            (t.split(",").forEach((i) => {
              (this.setClickFunc(i, r, n),
                (this.classes.get(i).haveCallback = !0));
            }),
              this.setCssClass(t, "clickable"));
          }
          setClickFunc(t, r, n) {
            let i = Rt.sanitizeText(t, K());
            if (K().securityLevel !== "loose" || r === void 0) return;
            let o = i;
            if (this.classes.has(o)) {
              let l = this.lookUpDomId(o),
                u = [];
              if (typeof n == "string") {
                u = n.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                for (let h = 0; h < u.length; h++) {
                  let f = u[h].trim();
                  (f.startsWith('"') &&
                    f.endsWith('"') &&
                    (f = f.substr(1, f.length - 2)),
                    (u[h] = f));
                }
              }
              (u.length === 0 && u.push(l),
                this.functions.push(() => {
                  let h = document.querySelector(`[id="${l}"]`);
                  h !== null &&
                    h.addEventListener(
                      "click",
                      () => {
                        le.runFunc(r, ...u);
                      },
                      !1,
                    );
                }));
            }
          }
          bindFunctions(t) {
            this.functions.forEach((r) => {
              r(t);
            });
          }
          getDirection() {
            return this.direction;
          }
          setDirection(t) {
            this.direction = t;
          }
          addNamespace(t) {
            this.namespaces.has(t) ||
              (this.namespaces.set(t, {
                id: t,
                classes: new Map(),
                children: {},
                domId: F_ + t + "-" + this.namespaceCounter,
              }),
              this.namespaceCounter++);
          }
          getNamespace(t) {
            return this.namespaces.get(t);
          }
          getNamespaces() {
            return this.namespaces;
          }
          addClassesToNamespace(t, r) {
            if (this.namespaces.has(t))
              for (let n of r) {
                let { className: i } = this.splitClassNameAndType(n);
                ((this.classes.get(i).parent = t),
                  this.namespaces.get(t).classes.set(i, this.classes.get(i)));
              }
          }
          setCssStyle(t, r) {
            let n = this.classes.get(t);
            if (!(!r || !n))
              for (let i of r)
                i.includes(",")
                  ? n.styles.push(...i.split(","))
                  : n.styles.push(i);
          }
          getArrowMarker(t) {
            let r;
            switch (t) {
              case 0:
                r = "aggregation";
                break;
              case 1:
                r = "extension";
                break;
              case 2:
                r = "composition";
                break;
              case 3:
                r = "dependency";
                break;
              case 4:
                r = "lollipop";
                break;
              default:
                r = "none";
            }
            return r;
          }
          getData() {
            let t = [],
              r = [],
              n = K();
            for (let s of this.namespaces.keys()) {
              let o = this.namespaces.get(s);
              if (o) {
                let l = {
                  id: o.id,
                  label: o.id,
                  isGroup: !0,
                  padding: n.class.padding ?? 16,
                  shape: "rect",
                  cssStyles: ["fill: none", "stroke: black"],
                  look: n.look,
                };
                t.push(l);
              }
            }
            for (let s of this.classes.keys()) {
              let o = this.classes.get(s);
              if (o) {
                let l = o;
                ((l.parentId = o.parent), (l.look = n.look), t.push(l));
              }
            }
            let i = 0;
            for (let s of this.notes) {
              i++;
              let o = {
                id: s.id,
                label: s.text,
                isGroup: !1,
                shape: "note",
                padding: n.class.padding ?? 6,
                cssStyles: [
                  "text-align: left",
                  "white-space: nowrap",
                  `fill: ${n.themeVariables.noteBkgColor}`,
                  `stroke: ${n.themeVariables.noteBorderColor}`,
                ],
                look: n.look,
              };
              t.push(o);
              let l = this.classes.get(s.class)?.id ?? "";
              if (l) {
                let u = {
                  id: `edgeNote${i}`,
                  start: s.id,
                  end: l,
                  type: "normal",
                  thickness: "normal",
                  classes: "relation",
                  arrowTypeStart: "none",
                  arrowTypeEnd: "none",
                  arrowheadStyle: "",
                  labelStyle: [""],
                  style: ["fill: none"],
                  pattern: "dotted",
                  look: n.look,
                };
                r.push(u);
              }
            }
            for (let s of this.interfaces) {
              let o = {
                id: s.id,
                label: s.label,
                isGroup: !1,
                shape: "rect",
                cssStyles: ["opacity: 0;"],
                look: n.look,
              };
              t.push(o);
            }
            i = 0;
            for (let s of this.relations) {
              i++;
              let o = {
                id: Tc(s.id1, s.id2, { prefix: "id", counter: i }),
                start: s.id1,
                end: s.id2,
                type: "normal",
                label: s.title,
                labelpos: "c",
                thickness: "normal",
                classes: "relation",
                arrowTypeStart: this.getArrowMarker(s.relation.type1),
                arrowTypeEnd: this.getArrowMarker(s.relation.type2),
                startLabelRight:
                  s.relationTitle1 === "none" ? "" : s.relationTitle1,
                endLabelLeft:
                  s.relationTitle2 === "none" ? "" : s.relationTitle2,
                arrowheadStyle: "",
                labelStyle: ["display: inline-block"],
                style: s.style || "",
                pattern: s.relation.lineType == 1 ? "dashed" : "solid",
                look: n.look,
              };
              r.push(o);
            }
            return {
              nodes: t,
              edges: r,
              other: {},
              config: n,
              direction: this.getDirection(),
            };
          }
        }));
    });
  var bDt,
    $_,
    _N = x(() => {
      "use strict";
      Md();
      ((bDt = a(
        (e) => `g.classGroup text {
  fill: ${e.nodeBorder || e.classText};
  stroke: none;
  font-family: ${e.fontFamily};
  font-size: 10px;

  .title {
    font-weight: bolder;
  }

}

.nodeLabel, .edgeLabel {
  color: ${e.classText};
}
.edgeLabel .label rect {
  fill: ${e.mainBkg};
}
.label text {
  fill: ${e.classText};
}

.labelBkg {
  background: ${e.mainBkg};
}
.edgeLabel .label span {
  background: ${e.mainBkg};
}

.classTitle {
  font-weight: bolder;
}
.node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }


.divider {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

g.clickable {
  cursor: pointer;
}

g.classGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.classGroup line {
  stroke: ${e.nodeBorder};
  stroke-width: 1;
}

.classLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.classLabel .label {
  fill: ${e.nodeBorder};
  font-size: 10px;
}

.relation {
  stroke: ${e.lineColor};
  stroke-width: 1;
  fill: none;
}

.dashed-line{
  stroke-dasharray: 3;
}

.dotted-line{
  stroke-dasharray: 1 2;
}

#compositionStart, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#compositionEnd, .composition {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#dependencyStart, .dependency {
  fill: ${e.lineColor} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionStart, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#extensionEnd, .extension {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationStart, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#aggregationEnd, .aggregation {
  fill: transparent !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopStart, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

#lollipopEnd, .lollipop {
  fill: ${e.mainBkg} !important;
  stroke: ${e.lineColor} !important;
  stroke-width: 1;
}

.edgeTerminals {
  font-size: 11px;
  line-height: initial;
}

.classTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
  ${Io()}
`,
        "getStyles",
      )),
        ($_ = bDt));
    });
  var kDt,
    TDt,
    SDt,
    G_,
    CN = x(() => {
      "use strict";
      pe();
      Vt();
      hd();
      ph();
      mh();
      _e();
      ((kDt = a((e, t = "TB") => {
        if (!e.doc) return t;
        let r = t;
        for (let n of e.doc) n.stmt === "dir" && (r = n.value);
        return r;
      }, "getDir")),
        (TDt = a(function (e, t) {
          return t.db.getClasses();
        }, "getClasses")),
        (SDt = a(async function (e, t, r, n) {
          (P.info("REF0:"), P.info("Drawing class diagram (v3)", t));
          let { securityLevel: i, state: s, layout: o } = K(),
            l = n.db.getData(),
            u = _o(t, i);
          ((l.type = n.type),
            (l.layoutAlgorithm = Vc(o)),
            (l.nodeSpacing = s?.nodeSpacing || 50),
            (l.rankSpacing = s?.rankSpacing || 50),
            (l.markers = [
              "aggregation",
              "extension",
              "composition",
              "dependency",
              "lollipop",
            ]),
            (l.diagramId = t),
            await No(l, u));
          let h = 8;
          (le.insertTitle(
            u,
            "classDiagramTitleText",
            s?.titleTopMargin ?? 25,
            n.db.getDiagramTitle(),
          ),
            la(u, h, "classDiagram", s?.useMaxWidth ?? !0));
        }, "draw")),
        (G_ = { getClasses: TDt, draw: SDt, getDir: kDt }));
    });
  var Xnt = {};
  Oe(Xnt, { diagram: () => _Dt });
  var _Dt,
    Knt = x(() => {
      "use strict";
      TN();
      SN();
      _N();
      CN();
      _Dt = {
        parser: B_,
        get db() {
          return new Cm();
        },
        renderer: G_,
        styles: $_,
        init: a((e) => {
          (e.class || (e.class = {}),
            (e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute));
        }, "init"),
      };
    });
  var Jnt = {};
  Oe(Jnt, { diagram: () => EDt });
  var EDt,
    tit = x(() => {
      "use strict";
      TN();
      SN();
      _N();
      CN();
      EDt = {
        parser: B_,
        get db() {
          return new Cm();
        },
        renderer: G_,
        styles: $_,
        init: a((e) => {
          (e.class || (e.class = {}),
            (e.class.arrowMarkerAbsolute = e.arrowMarkerAbsolute));
        }, "init"),
      };
    });
  var wN,
    V_,
    vN = x(() => {
      "use strict";
      wN = (function () {
        var e = a(function (I, V, $, q) {
            for ($ = $ || {}, q = I.length; q--; $[I[q]] = V);
            return $;
          }, "o"),
          t = [1, 2],
          r = [1, 3],
          n = [1, 4],
          i = [2, 4],
          s = [1, 9],
          o = [1, 11],
          l = [1, 16],
          u = [1, 17],
          h = [1, 18],
          f = [1, 19],
          d = [1, 33],
          p = [1, 20],
          m = [1, 21],
          g = [1, 22],
          y = [1, 23],
          b = [1, 24],
          k = [1, 26],
          T = [1, 27],
          C = [1, 28],
          L = [1, 29],
          w = [1, 30],
          D = [1, 31],
          G = [1, 32],
          E = [1, 35],
          R = [1, 36],
          F = [1, 37],
          S = [1, 38],
          O = [1, 34],
          v = [
            1, 4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38,
            41, 45, 48, 51, 52, 53, 54, 57,
          ],
          _ = [
            1, 4, 5, 14, 15, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35,
            37, 38, 39, 40, 41, 45, 48, 51, 52, 53, 54, 57,
          ],
          A = [
            4, 5, 16, 17, 19, 21, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37, 38,
            41, 45, 48, 51, 52, 53, 54, 57,
          ],
          N = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              SPACE: 4,
              NL: 5,
              SD: 6,
              document: 7,
              line: 8,
              statement: 9,
              classDefStatement: 10,
              styleStatement: 11,
              cssClassStatement: 12,
              idStatement: 13,
              DESCR: 14,
              "-->": 15,
              HIDE_EMPTY: 16,
              scale: 17,
              WIDTH: 18,
              COMPOSIT_STATE: 19,
              STRUCT_START: 20,
              STRUCT_STOP: 21,
              STATE_DESCR: 22,
              AS: 23,
              ID: 24,
              FORK: 25,
              JOIN: 26,
              CHOICE: 27,
              CONCURRENT: 28,
              note: 29,
              notePosition: 30,
              NOTE_TEXT: 31,
              direction: 32,
              acc_title: 33,
              acc_title_value: 34,
              acc_descr: 35,
              acc_descr_value: 36,
              acc_descr_multiline_value: 37,
              CLICK: 38,
              STRING: 39,
              HREF: 40,
              classDef: 41,
              CLASSDEF_ID: 42,
              CLASSDEF_STYLEOPTS: 43,
              DEFAULT: 44,
              style: 45,
              STYLE_IDS: 46,
              STYLEDEF_STYLEOPTS: 47,
              class: 48,
              CLASSENTITY_IDS: 49,
              STYLECLASS: 50,
              direction_tb: 51,
              direction_bt: 52,
              direction_rl: 53,
              direction_lr: 54,
              eol: 55,
              ";": 56,
              EDGE_STATE: 57,
              STYLE_SEPARATOR: 58,
              left_of: 59,
              right_of: 60,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "SPACE",
              5: "NL",
              6: "SD",
              14: "DESCR",
              15: "-->",
              16: "HIDE_EMPTY",
              17: "scale",
              18: "WIDTH",
              19: "COMPOSIT_STATE",
              20: "STRUCT_START",
              21: "STRUCT_STOP",
              22: "STATE_DESCR",
              23: "AS",
              24: "ID",
              25: "FORK",
              26: "JOIN",
              27: "CHOICE",
              28: "CONCURRENT",
              29: "note",
              31: "NOTE_TEXT",
              33: "acc_title",
              34: "acc_title_value",
              35: "acc_descr",
              36: "acc_descr_value",
              37: "acc_descr_multiline_value",
              38: "CLICK",
              39: "STRING",
              40: "HREF",
              41: "classDef",
              42: "CLASSDEF_ID",
              43: "CLASSDEF_STYLEOPTS",
              44: "DEFAULT",
              45: "style",
              46: "STYLE_IDS",
              47: "STYLEDEF_STYLEOPTS",
              48: "class",
              49: "CLASSENTITY_IDS",
              50: "STYLECLASS",
              51: "direction_tb",
              52: "direction_bt",
              53: "direction_rl",
              54: "direction_lr",
              56: ";",
              57: "EDGE_STATE",
              58: "STYLE_SEPARATOR",
              59: "left_of",
              60: "right_of",
            },
            productions_: [
              0,
              [3, 2],
              [3, 2],
              [3, 2],
              [7, 0],
              [7, 2],
              [8, 2],
              [8, 1],
              [8, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 2],
              [9, 3],
              [9, 4],
              [9, 1],
              [9, 2],
              [9, 1],
              [9, 4],
              [9, 3],
              [9, 6],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 4],
              [9, 4],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 5],
              [9, 5],
              [10, 3],
              [10, 3],
              [11, 3],
              [12, 3],
              [32, 1],
              [32, 1],
              [32, 1],
              [32, 1],
              [55, 1],
              [55, 1],
              [13, 1],
              [13, 1],
              [13, 3],
              [13, 3],
              [30, 1],
              [30, 1],
            ],
            performAction: a(function (V, $, q, tt, ht, H, kt) {
              var ft = H.length - 1;
              switch (ht) {
                case 3:
                  return (tt.setRootDoc(H[ft]), H[ft]);
                  break;
                case 4:
                  this.$ = [];
                  break;
                case 5:
                  H[ft] != "nl" &&
                    (H[ft - 1].push(H[ft]), (this.$ = H[ft - 1]));
                  break;
                case 6:
                case 7:
                  this.$ = H[ft];
                  break;
                case 8:
                  this.$ = "nl";
                  break;
                case 12:
                  this.$ = H[ft];
                  break;
                case 13:
                  let nt = H[ft - 1];
                  ((nt.description = tt.trimColon(H[ft])), (this.$ = nt));
                  break;
                case 14:
                  this.$ = {
                    stmt: "relation",
                    state1: H[ft - 2],
                    state2: H[ft],
                  };
                  break;
                case 15:
                  let Q = tt.trimColon(H[ft]);
                  this.$ = {
                    stmt: "relation",
                    state1: H[ft - 3],
                    state2: H[ft - 1],
                    description: Q,
                  };
                  break;
                case 19:
                  this.$ = {
                    stmt: "state",
                    id: H[ft - 3],
                    type: "default",
                    description: "",
                    doc: H[ft - 1],
                  };
                  break;
                case 20:
                  var yt = H[ft],
                    ot = H[ft - 2].trim();
                  if (H[ft].match(":")) {
                    var dt = H[ft].split(":");
                    ((yt = dt[0]), (ot = [ot, dt[1]]));
                  }
                  this.$ = {
                    stmt: "state",
                    id: yt,
                    type: "default",
                    description: ot,
                  };
                  break;
                case 21:
                  this.$ = {
                    stmt: "state",
                    id: H[ft - 3],
                    type: "default",
                    description: H[ft - 5],
                    doc: H[ft - 1],
                  };
                  break;
                case 22:
                  this.$ = { stmt: "state", id: H[ft], type: "fork" };
                  break;
                case 23:
                  this.$ = { stmt: "state", id: H[ft], type: "join" };
                  break;
                case 24:
                  this.$ = { stmt: "state", id: H[ft], type: "choice" };
                  break;
                case 25:
                  this.$ = {
                    stmt: "state",
                    id: tt.getDividerId(),
                    type: "divider",
                  };
                  break;
                case 26:
                  this.$ = {
                    stmt: "state",
                    id: H[ft - 1].trim(),
                    note: { position: H[ft - 2].trim(), text: H[ft].trim() },
                  };
                  break;
                case 29:
                  ((this.$ = H[ft].trim()), tt.setAccTitle(this.$));
                  break;
                case 30:
                case 31:
                  ((this.$ = H[ft].trim()), tt.setAccDescription(this.$));
                  break;
                case 32:
                  this.$ = {
                    stmt: "click",
                    id: H[ft - 3],
                    url: H[ft - 2],
                    tooltip: H[ft - 1],
                  };
                  break;
                case 33:
                  this.$ = {
                    stmt: "click",
                    id: H[ft - 3],
                    url: H[ft - 1],
                    tooltip: "",
                  };
                  break;
                case 34:
                case 35:
                  this.$ = {
                    stmt: "classDef",
                    id: H[ft - 1].trim(),
                    classes: H[ft].trim(),
                  };
                  break;
                case 36:
                  this.$ = {
                    stmt: "style",
                    id: H[ft - 1].trim(),
                    styleClass: H[ft].trim(),
                  };
                  break;
                case 37:
                  this.$ = {
                    stmt: "applyClass",
                    id: H[ft - 1].trim(),
                    styleClass: H[ft].trim(),
                  };
                  break;
                case 38:
                  (tt.setDirection("TB"),
                    (this.$ = { stmt: "dir", value: "TB" }));
                  break;
                case 39:
                  (tt.setDirection("BT"),
                    (this.$ = { stmt: "dir", value: "BT" }));
                  break;
                case 40:
                  (tt.setDirection("RL"),
                    (this.$ = { stmt: "dir", value: "RL" }));
                  break;
                case 41:
                  (tt.setDirection("LR"),
                    (this.$ = { stmt: "dir", value: "LR" }));
                  break;
                case 44:
                case 45:
                  this.$ = {
                    stmt: "state",
                    id: H[ft].trim(),
                    type: "default",
                    description: "",
                  };
                  break;
                case 46:
                  this.$ = {
                    stmt: "state",
                    id: H[ft - 2].trim(),
                    classes: [H[ft].trim()],
                    type: "default",
                    description: "",
                  };
                  break;
                case 47:
                  this.$ = {
                    stmt: "state",
                    id: H[ft - 2].trim(),
                    classes: [H[ft].trim()],
                    type: "default",
                    description: "",
                  };
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: t, 5: r, 6: n },
              { 1: [3] },
              { 3: 5, 4: t, 5: r, 6: n },
              { 3: 6, 4: t, 5: r, 6: n },
              e(
                [
                  1, 4, 5, 16, 17, 19, 22, 24, 25, 26, 27, 28, 29, 33, 35, 37,
                  38, 41, 45, 48, 51, 52, 53, 54, 57,
                ],
                i,
                { 7: 7 },
              ),
              { 1: [2, 1] },
              { 1: [2, 2] },
              {
                1: [2, 3],
                4: s,
                5: o,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: L,
                41: w,
                45: D,
                48: G,
                51: E,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(v, [2, 5]),
              {
                9: 39,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: L,
                41: w,
                45: D,
                48: G,
                51: E,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(v, [2, 7]),
              e(v, [2, 8]),
              e(v, [2, 9]),
              e(v, [2, 10]),
              e(v, [2, 11]),
              e(v, [2, 12], { 14: [1, 40], 15: [1, 41] }),
              e(v, [2, 16]),
              { 18: [1, 42] },
              e(v, [2, 18], { 20: [1, 43] }),
              { 23: [1, 44] },
              e(v, [2, 22]),
              e(v, [2, 23]),
              e(v, [2, 24]),
              e(v, [2, 25]),
              { 30: 45, 31: [1, 46], 59: [1, 47], 60: [1, 48] },
              e(v, [2, 28]),
              { 34: [1, 49] },
              { 36: [1, 50] },
              e(v, [2, 31]),
              { 13: 51, 24: d, 57: O },
              { 42: [1, 52], 44: [1, 53] },
              { 46: [1, 54] },
              { 49: [1, 55] },
              e(_, [2, 44], { 58: [1, 56] }),
              e(_, [2, 45], { 58: [1, 57] }),
              e(v, [2, 38]),
              e(v, [2, 39]),
              e(v, [2, 40]),
              e(v, [2, 41]),
              e(v, [2, 6]),
              e(v, [2, 13]),
              { 13: 58, 24: d, 57: O },
              e(v, [2, 17]),
              e(A, i, { 7: 59 }),
              { 24: [1, 60] },
              { 24: [1, 61] },
              { 23: [1, 62] },
              { 24: [2, 48] },
              { 24: [2, 49] },
              e(v, [2, 29]),
              e(v, [2, 30]),
              { 39: [1, 63], 40: [1, 64] },
              { 43: [1, 65] },
              { 43: [1, 66] },
              { 47: [1, 67] },
              { 50: [1, 68] },
              { 24: [1, 69] },
              { 24: [1, 70] },
              e(v, [2, 14], { 14: [1, 71] }),
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                21: [1, 72],
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: L,
                41: w,
                45: D,
                48: G,
                51: E,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(v, [2, 20], { 20: [1, 73] }),
              { 31: [1, 74] },
              { 24: [1, 75] },
              { 39: [1, 76] },
              { 39: [1, 77] },
              e(v, [2, 34]),
              e(v, [2, 35]),
              e(v, [2, 36]),
              e(v, [2, 37]),
              e(_, [2, 46]),
              e(_, [2, 47]),
              e(v, [2, 15]),
              e(v, [2, 19]),
              e(A, i, { 7: 78 }),
              e(v, [2, 26]),
              e(v, [2, 27]),
              { 5: [1, 79] },
              { 5: [1, 80] },
              {
                4: s,
                5: o,
                8: 8,
                9: 10,
                10: 12,
                11: 13,
                12: 14,
                13: 15,
                16: l,
                17: u,
                19: h,
                21: [1, 81],
                22: f,
                24: d,
                25: p,
                26: m,
                27: g,
                28: y,
                29: b,
                32: 25,
                33: k,
                35: T,
                37: C,
                38: L,
                41: w,
                45: D,
                48: G,
                51: E,
                52: R,
                53: F,
                54: S,
                57: O,
              },
              e(v, [2, 32]),
              e(v, [2, 33]),
              e(v, [2, 21]),
            ],
            defaultActions: { 5: [2, 1], 6: [2, 2], 47: [2, 48], 48: [2, 49] },
            parseError: a(function (V, $) {
              if ($.recoverable) this.trace(V);
              else {
                var q = new Error(V);
                throw ((q.hash = $), q);
              }
            }, "parseError"),
            parse: a(function (V) {
              var $ = this,
                q = [0],
                tt = [],
                ht = [null],
                H = [],
                kt = this.table,
                ft = "",
                yt = 0,
                ot = 0,
                dt = 0,
                nt = 2,
                Q = 1,
                et = H.slice.call(arguments, 1),
                X = Object.create(this.lexer),
                st = { yy: {} };
              for (var U in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, U) &&
                  (st.yy[U] = this.yy[U]);
              (X.setInput(V, st.yy),
                (st.yy.lexer = X),
                (st.yy.parser = this),
                typeof X.yylloc > "u" && (X.yylloc = {}));
              var gt = X.yylloc;
              H.push(gt);
              var z = X.options && X.options.ranges;
              typeof st.yy.parseError == "function"
                ? (this.parseError = st.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function ge(j) {
                ((q.length = q.length - 2 * j),
                  (ht.length = ht.length - j),
                  (H.length = H.length - j));
              }
              a(ge, "popStack");
              function lt() {
                var j;
                return (
                  (j = tt.pop() || X.lex() || Q),
                  typeof j != "number" &&
                    (j instanceof Array && ((tt = j), (j = tt.pop())),
                    (j = $.symbols_[j] || j)),
                  j
                );
              }
              a(lt, "lex");
              for (var jt, Me, se, Nt, At, bt, ct = {}, Lt, Z, Mt, W; ; ) {
                if (
                  ((se = q[q.length - 1]),
                  this.defaultActions[se]
                    ? (Nt = this.defaultActions[se])
                    : ((jt === null || typeof jt > "u") && (jt = lt()),
                      (Nt = kt[se] && kt[se][jt])),
                  typeof Nt > "u" || !Nt.length || !Nt[0])
                ) {
                  var Gt = "";
                  W = [];
                  for (Lt in kt[se])
                    this.terminals_[Lt] &&
                      Lt > nt &&
                      W.push("'" + this.terminals_[Lt] + "'");
                  (X.showPosition
                    ? (Gt =
                        "Parse error on line " +
                        (yt + 1) +
                        `:
` +
                        X.showPosition() +
                        `
Expecting ` +
                        W.join(", ") +
                        ", got '" +
                        (this.terminals_[jt] || jt) +
                        "'")
                    : (Gt =
                        "Parse error on line " +
                        (yt + 1) +
                        ": Unexpected " +
                        (jt == Q
                          ? "end of input"
                          : "'" + (this.terminals_[jt] || jt) + "'")),
                    this.parseError(Gt, {
                      text: X.match,
                      token: this.terminals_[jt] || jt,
                      line: X.yylineno,
                      loc: gt,
                      expected: W,
                    }));
                }
                if (Nt[0] instanceof Array && Nt.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      se +
                      ", token: " +
                      jt,
                  );
                switch (Nt[0]) {
                  case 1:
                    (q.push(jt),
                      ht.push(X.yytext),
                      H.push(X.yylloc),
                      q.push(Nt[1]),
                      (jt = null),
                      Me
                        ? ((jt = Me), (Me = null))
                        : ((ot = X.yyleng),
                          (ft = X.yytext),
                          (yt = X.yylineno),
                          (gt = X.yylloc),
                          dt > 0 && dt--));
                    break;
                  case 2:
                    if (
                      ((Z = this.productions_[Nt[1]][1]),
                      (ct.$ = ht[ht.length - Z]),
                      (ct._$ = {
                        first_line: H[H.length - (Z || 1)].first_line,
                        last_line: H[H.length - 1].last_line,
                        first_column: H[H.length - (Z || 1)].first_column,
                        last_column: H[H.length - 1].last_column,
                      }),
                      z &&
                        (ct._$.range = [
                          H[H.length - (Z || 1)].range[0],
                          H[H.length - 1].range[1],
                        ]),
                      (bt = this.performAction.apply(
                        ct,
                        [ft, ot, yt, st.yy, Nt[1], ht, H].concat(et),
                      )),
                      typeof bt < "u")
                    )
                      return bt;
                    (Z &&
                      ((q = q.slice(0, -1 * Z * 2)),
                      (ht = ht.slice(0, -1 * Z)),
                      (H = H.slice(0, -1 * Z))),
                      q.push(this.productions_[Nt[1]][0]),
                      ht.push(ct.$),
                      H.push(ct._$),
                      (Mt = kt[q[q.length - 2]][q[q.length - 1]]),
                      q.push(Mt));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          B = (function () {
            var I = {
              EOF: 1,
              parseError: a(function ($, q) {
                if (this.yy.parser) this.yy.parser.parseError($, q);
                else throw new Error($);
              }, "parseError"),
              setInput: a(function (V, $) {
                return (
                  (this.yy = $ || this.yy || {}),
                  (this._input = V),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var V = this._input[0];
                ((this.yytext += V),
                  this.yyleng++,
                  this.offset++,
                  (this.match += V),
                  (this.matched += V));
                var $ = V.match(/(?:\r\n?|\n).*/g);
                return (
                  $
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  V
                );
              }, "input"),
              unput: a(function (V) {
                var $ = V.length,
                  q = V.split(/(?:\r\n?|\n)/g);
                ((this._input = V + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - $)),
                  (this.offset -= $));
                var tt = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  q.length - 1 && (this.yylineno -= q.length - 1));
                var ht = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: q
                      ? (q.length === tt.length
                          ? this.yylloc.first_column
                          : 0) +
                        tt[tt.length - q.length].length -
                        q[0].length
                      : this.yylloc.first_column - $,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [ht[0], ht[0] + this.yyleng - $]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (V) {
                this.unput(this.match.slice(V));
              }, "less"),
              pastInput: a(function () {
                var V = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (V.length > 20 ? "..." : "") +
                  V.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var V = this.match;
                return (
                  V.length < 20 && (V += this._input.substr(0, 20 - V.length)),
                  (V.substr(0, 20) + (V.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var V = this.pastInput(),
                  $ = new Array(V.length + 1).join("-");
                return (
                  V +
                  this.upcomingInput() +
                  `
` +
                  $ +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (V, $) {
                var q, tt, ht;
                if (
                  (this.options.backtrack_lexer &&
                    ((ht = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (ht.yylloc.range = this.yylloc.range.slice(0))),
                  (tt = V[0].match(/(?:\r\n?|\n).*/g)),
                  tt && (this.yylineno += tt.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: tt
                      ? tt[tt.length - 1].length -
                        tt[tt.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + V[0].length,
                  }),
                  (this.yytext += V[0]),
                  (this.match += V[0]),
                  (this.matches = V),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(V[0].length)),
                  (this.matched += V[0]),
                  (q = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    $,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  q)
                )
                  return q;
                if (this._backtrack) {
                  for (var H in ht) this[H] = ht[H];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var V, $, q, tt;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var ht = this._currentRules(), H = 0; H < ht.length; H++)
                  if (
                    ((q = this._input.match(this.rules[ht[H]])),
                    q && (!$ || q[0].length > $[0].length))
                  ) {
                    if ((($ = q), (tt = H), this.options.backtrack_lexer)) {
                      if (((V = this.test_match(q, ht[H])), V !== !1)) return V;
                      if (this._backtrack) {
                        $ = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return $
                  ? ((V = this.test_match($, ht[tt])), V !== !1 ? V : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var $ = this.next();
                return $ || this.lex();
              }, "lex"),
              begin: a(function ($) {
                this.conditionStack.push($);
              }, "begin"),
              popState: a(function () {
                var $ = this.conditionStack.length - 1;
                return $ > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function ($) {
                return (
                  ($ = this.conditionStack.length - 1 - Math.abs($ || 0)),
                  $ >= 0 ? this.conditionStack[$] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function ($) {
                this.begin($);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function ($, q, tt, ht) {
                var H = ht;
                switch (tt) {
                  case 0:
                    return 38;
                  case 1:
                    return 40;
                  case 2:
                    return 39;
                  case 3:
                    return 44;
                  case 4:
                    return 51;
                  case 5:
                    return 52;
                  case 6:
                    return 53;
                  case 7:
                    return 54;
                  case 8:
                    break;
                  case 9:
                    break;
                  case 10:
                    return 5;
                  case 11:
                    break;
                  case 12:
                    break;
                  case 13:
                    break;
                  case 14:
                    break;
                  case 15:
                    return (this.pushState("SCALE"), 17);
                    break;
                  case 16:
                    return 18;
                  case 17:
                    this.popState();
                    break;
                  case 18:
                    return (this.begin("acc_title"), 33);
                    break;
                  case 19:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 20:
                    return (this.begin("acc_descr"), 35);
                    break;
                  case 21:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 22:
                    this.begin("acc_descr_multiline");
                    break;
                  case 23:
                    this.popState();
                    break;
                  case 24:
                    return "acc_descr_multiline_value";
                  case 25:
                    return (this.pushState("CLASSDEF"), 41);
                    break;
                  case 26:
                    return (
                      this.popState(),
                      this.pushState("CLASSDEFID"),
                      "DEFAULT_CLASSDEF_ID"
                    );
                    break;
                  case 27:
                    return (this.popState(), this.pushState("CLASSDEFID"), 42);
                    break;
                  case 28:
                    return (this.popState(), 43);
                    break;
                  case 29:
                    return (this.pushState("CLASS"), 48);
                    break;
                  case 30:
                    return (this.popState(), this.pushState("CLASS_STYLE"), 49);
                    break;
                  case 31:
                    return (this.popState(), 50);
                    break;
                  case 32:
                    return (this.pushState("STYLE"), 45);
                    break;
                  case 33:
                    return (
                      this.popState(),
                      this.pushState("STYLEDEF_STYLES"),
                      46
                    );
                    break;
                  case 34:
                    return (this.popState(), 47);
                    break;
                  case 35:
                    return (this.pushState("SCALE"), 17);
                    break;
                  case 36:
                    return 18;
                  case 37:
                    this.popState();
                    break;
                  case 38:
                    this.pushState("STATE");
                    break;
                  case 39:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.slice(0, -8).trim()),
                      25
                    );
                    break;
                  case 40:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.slice(0, -8).trim()),
                      26
                    );
                    break;
                  case 41:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.slice(0, -10).trim()),
                      27
                    );
                    break;
                  case 42:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.slice(0, -8).trim()),
                      25
                    );
                    break;
                  case 43:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.slice(0, -8).trim()),
                      26
                    );
                    break;
                  case 44:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.slice(0, -10).trim()),
                      27
                    );
                    break;
                  case 45:
                    return 51;
                  case 46:
                    return 52;
                  case 47:
                    return 53;
                  case 48:
                    return 54;
                  case 49:
                    this.pushState("STATE_STRING");
                    break;
                  case 50:
                    return (this.pushState("STATE_ID"), "AS");
                    break;
                  case 51:
                    return (this.popState(), "ID");
                    break;
                  case 52:
                    this.popState();
                    break;
                  case 53:
                    return "STATE_DESCR";
                  case 54:
                    return 19;
                  case 55:
                    this.popState();
                    break;
                  case 56:
                    return (this.popState(), this.pushState("struct"), 20);
                    break;
                  case 57:
                    break;
                  case 58:
                    return (this.popState(), 21);
                    break;
                  case 59:
                    break;
                  case 60:
                    return (this.begin("NOTE"), 29);
                    break;
                  case 61:
                    return (this.popState(), this.pushState("NOTE_ID"), 59);
                    break;
                  case 62:
                    return (this.popState(), this.pushState("NOTE_ID"), 60);
                    break;
                  case 63:
                    (this.popState(), this.pushState("FLOATING_NOTE"));
                    break;
                  case 64:
                    return (
                      this.popState(),
                      this.pushState("FLOATING_NOTE_ID"),
                      "AS"
                    );
                    break;
                  case 65:
                    break;
                  case 66:
                    return "NOTE_TEXT";
                  case 67:
                    return (this.popState(), "ID");
                    break;
                  case 68:
                    return (this.popState(), this.pushState("NOTE_TEXT"), 24);
                    break;
                  case 69:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.substr(2).trim()),
                      31
                    );
                    break;
                  case 70:
                    return (
                      this.popState(),
                      (q.yytext = q.yytext.slice(0, -8).trim()),
                      31
                    );
                    break;
                  case 71:
                    return 6;
                  case 72:
                    return 6;
                  case 73:
                    return 16;
                  case 74:
                    return 57;
                  case 75:
                    return 24;
                  case 76:
                    return ((q.yytext = q.yytext.trim()), 14);
                    break;
                  case 77:
                    return 15;
                  case 78:
                    return 28;
                  case 79:
                    return 58;
                  case 80:
                    return 5;
                  case 81:
                    return "INVALID";
                }
              }, "anonymous"),
              rules: [
                /^(?:click\b)/i,
                /^(?:href\b)/i,
                /^(?:"[^"]*")/i,
                /^(?:default\b)/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:[\s]+)/i,
                /^(?:((?!\n)\s)+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:%[^\n]*)/i,
                /^(?:scale\s+)/i,
                /^(?:\d+)/i,
                /^(?:\s+width\b)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:classDef\s+)/i,
                /^(?:DEFAULT\s+)/i,
                /^(?:\w+\s+)/i,
                /^(?:[^\n]*)/i,
                /^(?:class\s+)/i,
                /^(?:(\w+)+((,\s*\w+)*))/i,
                /^(?:[^\n]*)/i,
                /^(?:style\s+)/i,
                /^(?:[\w,]+\s+)/i,
                /^(?:[^\n]*)/i,
                /^(?:scale\s+)/i,
                /^(?:\d+)/i,
                /^(?:\s+width\b)/i,
                /^(?:state\s+)/i,
                /^(?:.*<<fork>>)/i,
                /^(?:.*<<join>>)/i,
                /^(?:.*<<choice>>)/i,
                /^(?:.*\[\[fork\]\])/i,
                /^(?:.*\[\[join\]\])/i,
                /^(?:.*\[\[choice\]\])/i,
                /^(?:.*direction\s+TB[^\n]*)/i,
                /^(?:.*direction\s+BT[^\n]*)/i,
                /^(?:.*direction\s+RL[^\n]*)/i,
                /^(?:.*direction\s+LR[^\n]*)/i,
                /^(?:["])/i,
                /^(?:\s*as\s+)/i,
                /^(?:[^\n\{]*)/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[^\n\s\{]+)/i,
                /^(?:\n)/i,
                /^(?:\{)/i,
                /^(?:%%(?!\{)[^\n]*)/i,
                /^(?:\})/i,
                /^(?:[\n])/i,
                /^(?:note\s+)/i,
                /^(?:left of\b)/i,
                /^(?:right of\b)/i,
                /^(?:")/i,
                /^(?:\s*as\s*)/i,
                /^(?:["])/i,
                /^(?:[^"]*)/i,
                /^(?:[^\n]*)/i,
                /^(?:\s*[^:\n\s\-]+)/i,
                /^(?:\s*:[^:\n;]+)/i,
                /^(?:[\s\S]*?end note\b)/i,
                /^(?:stateDiagram\s+)/i,
                /^(?:stateDiagram-v2\s+)/i,
                /^(?:hide empty description\b)/i,
                /^(?:\[\*\])/i,
                /^(?:[^:\n\s\-\{]+)/i,
                /^(?:\s*:[^:\n;]+)/i,
                /^(?:-->)/i,
                /^(?:--)/i,
                /^(?::::)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                LINE: { rules: [12, 13], inclusive: !1 },
                struct: {
                  rules: [
                    12, 13, 25, 29, 32, 38, 45, 46, 47, 48, 57, 58, 59, 60, 74,
                    75, 76, 77, 78,
                  ],
                  inclusive: !1,
                },
                FLOATING_NOTE_ID: { rules: [67], inclusive: !1 },
                FLOATING_NOTE: { rules: [64, 65, 66], inclusive: !1 },
                NOTE_TEXT: { rules: [69, 70], inclusive: !1 },
                NOTE_ID: { rules: [68], inclusive: !1 },
                NOTE: { rules: [61, 62, 63], inclusive: !1 },
                STYLEDEF_STYLEOPTS: { rules: [], inclusive: !1 },
                STYLEDEF_STYLES: { rules: [34], inclusive: !1 },
                STYLE_IDS: { rules: [], inclusive: !1 },
                STYLE: { rules: [33], inclusive: !1 },
                CLASS_STYLE: { rules: [31], inclusive: !1 },
                CLASS: { rules: [30], inclusive: !1 },
                CLASSDEFID: { rules: [28], inclusive: !1 },
                CLASSDEF: { rules: [26, 27], inclusive: !1 },
                acc_descr_multiline: { rules: [23, 24], inclusive: !1 },
                acc_descr: { rules: [21], inclusive: !1 },
                acc_title: { rules: [19], inclusive: !1 },
                SCALE: { rules: [16, 17, 36, 37], inclusive: !1 },
                ALIAS: { rules: [], inclusive: !1 },
                STATE_ID: { rules: [51], inclusive: !1 },
                STATE_STRING: { rules: [52, 53], inclusive: !1 },
                FORK_STATE: { rules: [], inclusive: !1 },
                STATE: {
                  rules: [12, 13, 39, 40, 41, 42, 43, 44, 49, 50, 54, 55, 56],
                  inclusive: !1,
                },
                ID: { rules: [12, 13], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 14, 15, 18, 20,
                    22, 25, 29, 32, 35, 38, 56, 60, 71, 72, 73, 74, 75, 76, 77,
                    79, 80, 81,
                  ],
                  inclusive: !0,
                },
              },
            };
            return I;
          })();
        N.lexer = B;
        function M() {
          this.yy = {};
        }
        return (a(M, "Parser"), (M.prototype = N), (N.Parser = M), new M());
      })();
      wN.parser = wN;
      V_ = wN;
    });
  var nit,
    z_,
    EN,
    iu,
    Jh,
    Uy,
    iit,
    sit,
    ait,
    tf,
    W_,
    AN,
    LN,
    RN,
    DN,
    NN,
    U_,
    j_,
    oit,
    lit,
    IN,
    MN,
    cit,
    uit,
    wm,
    DDt,
    hit,
    ON,
    NDt,
    IDt,
    fit,
    dit,
    MDt,
    pit,
    ODt,
    mit,
    PN,
    BN,
    git,
    q_,
    yit,
    FN,
    H_ = x(() => {
      "use strict";
      ((nit = "TB"),
        (z_ = "TB"),
        (EN = "dir"),
        (iu = "state"),
        (Jh = "root"),
        (Uy = "relation"),
        (iit = "classDef"),
        (sit = "style"),
        (ait = "applyClass"),
        (tf = "default"),
        (W_ = "divider"),
        (AN = "fill:none"),
        (LN = "fill: #333"),
        (RN = "c"),
        (DN = "text"),
        (NN = "normal"),
        (U_ = "rect"),
        (j_ = "rectWithTitle"),
        (oit = "stateStart"),
        (lit = "stateEnd"),
        (IN = "divider"),
        (MN = "roundedWithTitle"),
        (cit = "note"),
        (uit = "noteGroup"),
        (wm = "statediagram"),
        (DDt = "state"),
        (hit = `${wm}-${DDt}`),
        (ON = "transition"),
        (NDt = "note"),
        (IDt = "note-edge"),
        (fit = `${ON} ${IDt}`),
        (dit = `${wm}-${NDt}`),
        (MDt = "cluster"),
        (pit = `${wm}-${MDt}`),
        (ODt = "cluster-alt"),
        (mit = `${wm}-${ODt}`),
        (PN = "parent"),
        (BN = "note"),
        (git = "state"),
        (q_ = "----"),
        (yit = `${q_}${BN}`),
        (FN = `${q_}${PN}`));
    });
  function $N(e = "", t = 0, r = "", n = q_) {
    let i = r !== null && r.length > 0 ? `${n}${r}` : "";
    return `${git}-${e}${i}-${t}`;
  }
  function Y_(e, t, r) {
    if (!t.id || t.id === "</join></fork>" || t.id === "</choice>") return;
    t.cssClasses &&
      (Array.isArray(t.cssCompiledStyles) || (t.cssCompiledStyles = []),
      t.cssClasses.split(" ").forEach((i) => {
        let s = r.get(i);
        s &&
          (t.cssCompiledStyles = [...(t.cssCompiledStyles ?? []), ...s.styles]);
      }));
    let n = e.find((i) => i.id === t.id);
    n ? Object.assign(n, t) : e.push(t);
  }
  function BDt(e) {
    return e?.classes?.join(" ") ?? "";
  }
  function FDt(e) {
    return e?.styles ?? [];
  }
  var X_,
    su,
    PDt,
    xit,
    vm,
    bit,
    kit = x(() => {
      "use strict";
      pe();
      Vt();
      Be();
      H_();
      ((X_ = new Map()), (su = 0));
      a($N, "stateDomId");
      ((PDt = a((e, t, r, n, i, s, o, l) => {
        (P.trace("items", t),
          t.forEach((u) => {
            switch (u.stmt) {
              case iu:
                vm(e, u, r, n, i, s, o, l);
                break;
              case tf:
                vm(e, u, r, n, i, s, o, l);
                break;
              case Uy:
                {
                  (vm(e, u.state1, r, n, i, s, o, l),
                    vm(e, u.state2, r, n, i, s, o, l));
                  let h = {
                    id: "edge" + su,
                    start: u.state1.id,
                    end: u.state2.id,
                    arrowhead: "normal",
                    arrowTypeEnd: "arrow_barb",
                    style: AN,
                    labelStyle: "",
                    label: Rt.sanitizeText(u.description ?? "", K()),
                    arrowheadStyle: LN,
                    labelpos: RN,
                    labelType: DN,
                    thickness: NN,
                    classes: ON,
                    look: o,
                  };
                  (i.push(h), su++);
                }
                break;
            }
          }));
      }, "setupDoc")),
        (xit = a((e, t = z_) => {
          let r = t;
          if (e.doc) for (let n of e.doc) n.stmt === "dir" && (r = n.value);
          return r;
        }, "getDir")));
      a(Y_, "insertOrUpdateNode");
      a(BDt, "getClassesFromDbInfo");
      a(FDt, "getStylesFromDbInfo");
      ((vm = a((e, t, r, n, i, s, o, l) => {
        let u = t.id,
          h = r.get(u),
          f = BDt(h),
          d = FDt(h),
          p = K();
        if ((P.info("dataFetcher parsedItem", t, h, d), u !== "root")) {
          let m = U_;
          (t.start === !0 ? (m = oit) : t.start === !1 && (m = lit),
            t.type !== tf && (m = t.type),
            X_.get(u) ||
              X_.set(u, {
                id: u,
                shape: m,
                description: Rt.sanitizeText(u, p),
                cssClasses: `${f} ${hit}`,
                cssStyles: d,
              }));
          let g = X_.get(u);
          (t.description &&
            (Array.isArray(g.description)
              ? ((g.shape = j_), g.description.push(t.description))
              : g.description?.length && g.description.length > 0
                ? ((g.shape = j_),
                  g.description === u
                    ? (g.description = [t.description])
                    : (g.description = [g.description, t.description]))
                : ((g.shape = U_), (g.description = t.description)),
            (g.description = Rt.sanitizeTextOrArray(g.description, p))),
            g.description?.length === 1 &&
              g.shape === j_ &&
              (g.type === "group" ? (g.shape = MN) : (g.shape = U_)),
            !g.type &&
              t.doc &&
              (P.info("Setting cluster for XCX", u, xit(t)),
              (g.type = "group"),
              (g.isGroup = !0),
              (g.dir = xit(t)),
              (g.shape = t.type === W_ ? IN : MN),
              (g.cssClasses = `${g.cssClasses} ${pit} ${s ? mit : ""}`)));
          let y = {
            labelStyle: "",
            shape: g.shape,
            label: g.description,
            cssClasses: g.cssClasses,
            cssCompiledStyles: [],
            cssStyles: g.cssStyles,
            id: u,
            dir: g.dir,
            domId: $N(u, su),
            type: g.type,
            isGroup: g.type === "group",
            padding: 8,
            rx: 10,
            ry: 10,
            look: o,
          };
          if (
            (y.shape === IN && (y.label = ""),
            e &&
              e.id !== "root" &&
              (P.trace("Setting node ", u, " to be child of its parent ", e.id),
              (y.parentId = e.id)),
            (y.centerLabel = !0),
            t.note)
          ) {
            let b = {
                labelStyle: "",
                shape: cit,
                label: t.note.text,
                cssClasses: dit,
                cssStyles: [],
                cssCompiledStyles: [],
                id: u + yit + "-" + su,
                domId: $N(u, su, BN),
                type: g.type,
                isGroup: g.type === "group",
                padding: p.flowchart?.padding,
                look: o,
                position: t.note.position,
              },
              k = u + FN,
              T = {
                labelStyle: "",
                shape: uit,
                label: t.note.text,
                cssClasses: g.cssClasses,
                cssStyles: [],
                id: u + FN,
                domId: $N(u, su, PN),
                type: "group",
                isGroup: !0,
                padding: 16,
                look: o,
                position: t.note.position,
              };
            (su++,
              (T.id = k),
              (b.parentId = k),
              Y_(n, T, l),
              Y_(n, b, l),
              Y_(n, y, l));
            let C = u,
              L = b.id;
            (t.note.position === "left of" && ((C = b.id), (L = u)),
              i.push({
                id: C + "-" + L,
                start: C,
                end: L,
                arrowhead: "none",
                arrowTypeEnd: "",
                style: AN,
                labelStyle: "",
                classes: fit,
                arrowheadStyle: LN,
                labelpos: RN,
                labelType: DN,
                thickness: NN,
                look: o,
              }));
          } else Y_(n, y, l);
        }
        t.doc &&
          (P.trace("Adding nodes children "), PDt(t, t.doc, r, n, i, !s, o, l));
      }, "dataFetcher")),
        (bit = a(() => {
          (X_.clear(), (su = 0));
        }, "reset")));
    });
  var GN,
    $Dt,
    GDt,
    Tit,
    VN = x(() => {
      "use strict";
      pe();
      Vt();
      hd();
      ph();
      mh();
      _e();
      H_();
      ((GN = a((e, t = z_) => {
        if (!e.doc) return t;
        let r = t;
        for (let n of e.doc) n.stmt === "dir" && (r = n.value);
        return r;
      }, "getDir")),
        ($Dt = a(function (e, t) {
          return t.db.getClasses();
        }, "getClasses")),
        (GDt = a(async function (e, t, r, n) {
          (P.info("REF0:"), P.info("Drawing state diagram (v2)", t));
          let { securityLevel: i, state: s, layout: o } = K();
          n.db.extract(n.db.getRootDocV2());
          let l = n.db.getData(),
            u = _o(t, i);
          ((l.type = n.type),
            (l.layoutAlgorithm = o),
            (l.nodeSpacing = s?.nodeSpacing || 50),
            (l.rankSpacing = s?.rankSpacing || 50),
            (l.markers = ["barb"]),
            (l.diagramId = t),
            await No(l, u));
          let h = 8;
          try {
            (typeof n.db.getLinks == "function"
              ? n.db.getLinks()
              : new Map()
            ).forEach((d, p) => {
              let m =
                typeof p == "string" ? p : typeof p?.id == "string" ? p.id : "";
              if (!m) {
                P.warn(
                  "\u26A0\uFE0F Invalid or missing stateId from key:",
                  JSON.stringify(p),
                );
                return;
              }
              let g = u.node()?.querySelectorAll("g"),
                y;
              if (
                (g?.forEach((C) => {
                  C.textContent?.trim() === m && (y = C);
                }),
                !y)
              ) {
                P.warn("\u26A0\uFE0F Could not find node matching text:", m);
                return;
              }
              let b = y.parentNode;
              if (!b) {
                P.warn("\u26A0\uFE0F Node has no parent, cannot wrap:", m);
                return;
              }
              let k = document.createElementNS(
                  "http://www.w3.org/2000/svg",
                  "a",
                ),
                T = d.url.replace(/^"+|"+$/g, "");
              if (
                (k.setAttributeNS(
                  "http://www.w3.org/1999/xlink",
                  "xlink:href",
                  T,
                ),
                k.setAttribute("target", "_blank"),
                d.tooltip)
              ) {
                let C = d.tooltip.replace(/^"+|"+$/g, "");
                k.setAttribute("title", C);
              }
              (b.replaceChild(k, y),
                k.appendChild(y),
                P.info("\u{1F517} Wrapped node in <a> tag for:", m, d.url));
            });
          } catch (f) {
            P.error("\u274C Error injecting clickable links:", f);
          }
          (le.insertTitle(
            u,
            "statediagramTitleText",
            s?.titleTopMargin ?? 25,
            n.db.getDiagramTitle(),
          ),
            la(u, h, wm, s?.useMaxWidth ?? !0));
        }, "draw")),
        (Tit = { getClasses: $Dt, draw: GDt, getDir: GN }));
    });
  var Qi,
    Sit,
    _it,
    K_,
    ma,
    Q_ = x(() => {
      "use strict";
      pe();
      Vt();
      _e();
      Be();
      yn();
      kit();
      VN();
      H_();
      ((Qi = {
        START_NODE: "[*]",
        START_TYPE: "start",
        END_NODE: "[*]",
        END_TYPE: "end",
        COLOR_KEYWORD: "color",
        FILL_KEYWORD: "fill",
        BG_FILL: "bgFill",
        STYLECLASS_SEP: ",",
      }),
        (Sit = a(() => new Map(), "newClassesList")),
        (_it = a(
          () => ({ relations: [], states: new Map(), documents: {} }),
          "newDoc",
        )),
        (K_ = a((e) => JSON.parse(JSON.stringify(e)), "clone")),
        (ma = class {
          constructor(t) {
            this.version = t;
            this.nodes = [];
            this.edges = [];
            this.rootDoc = [];
            this.classes = Sit();
            this.documents = { root: _it() };
            this.currentDocument = this.documents.root;
            this.startEndCount = 0;
            this.dividerCnt = 0;
            this.links = new Map();
            this.getAccTitle = tr;
            this.setAccTitle = Xe;
            this.getAccDescription = rr;
            this.setAccDescription = er;
            this.setDiagramTitle = lr;
            this.getDiagramTitle = nr;
            (this.clear(),
              (this.setRootDoc = this.setRootDoc.bind(this)),
              (this.getDividerId = this.getDividerId.bind(this)),
              (this.setDirection = this.setDirection.bind(this)),
              (this.trimColon = this.trimColon.bind(this)));
          }
          static {
            a(this, "StateDB");
          }
          static {
            this.relationType = {
              AGGREGATION: 0,
              EXTENSION: 1,
              COMPOSITION: 2,
              DEPENDENCY: 3,
            };
          }
          extract(t) {
            this.clear(!0);
            for (let i of Array.isArray(t) ? t : t.doc)
              switch (i.stmt) {
                case iu:
                  this.addState(
                    i.id.trim(),
                    i.type,
                    i.doc,
                    i.description,
                    i.note,
                  );
                  break;
                case Uy:
                  this.addRelation(i.state1, i.state2, i.description);
                  break;
                case iit:
                  this.addStyleClass(i.id.trim(), i.classes);
                  break;
                case sit:
                  this.handleStyleDef(i);
                  break;
                case ait:
                  this.setCssClass(i.id.trim(), i.styleClass);
                  break;
                case "click":
                  this.addLink(i.id, i.url, i.tooltip);
                  break;
              }
            let r = this.getStates(),
              n = K();
            (bit(),
              vm(
                void 0,
                this.getRootDocV2(),
                r,
                this.nodes,
                this.edges,
                !0,
                n.look,
                this.classes,
              ));
            for (let i of this.nodes)
              if (Array.isArray(i.label)) {
                if (
                  ((i.description = i.label.slice(1)),
                  i.isGroup && i.description.length > 0)
                )
                  throw new Error(
                    `Group nodes can only have label. Remove the additional description for node [${i.id}]`,
                  );
                i.label = i.label[0];
              }
          }
          handleStyleDef(t) {
            let r = t.id.trim().split(","),
              n = t.styleClass.split(",");
            for (let i of r) {
              let s = this.getState(i);
              if (!s) {
                let o = i.trim();
                (this.addState(o), (s = this.getState(o)));
              }
              s && (s.styles = n.map((o) => o.replace(/;/g, "")?.trim()));
            }
          }
          setRootDoc(t) {
            (P.info("Setting root doc", t),
              (this.rootDoc = t),
              this.version === 1
                ? this.extract(t)
                : this.extract(this.getRootDocV2()));
          }
          docTranslator(t, r, n) {
            if (r.stmt === Uy) {
              (this.docTranslator(t, r.state1, !0),
                this.docTranslator(t, r.state2, !1));
              return;
            }
            if (
              (r.stmt === iu &&
                (r.id === Qi.START_NODE
                  ? ((r.id = t.id + (n ? "_start" : "_end")), (r.start = n))
                  : (r.id = r.id.trim())),
              (r.stmt !== Jh && r.stmt !== iu) || !r.doc)
            )
              return;
            let i = [],
              s = [];
            for (let o of r.doc)
              if (o.type === W_) {
                let l = K_(o);
                ((l.doc = K_(s)), i.push(l), (s = []));
              } else s.push(o);
            if (i.length > 0 && s.length > 0) {
              let o = { stmt: iu, id: A4(), type: "divider", doc: K_(s) };
              (i.push(K_(o)), (r.doc = i));
            }
            r.doc.forEach((o) => this.docTranslator(r, o, !0));
          }
          getRootDocV2() {
            return (
              this.docTranslator(
                { id: Jh, stmt: Jh },
                { id: Jh, stmt: Jh, doc: this.rootDoc },
                !0,
              ),
              { id: Jh, doc: this.rootDoc }
            );
          }
          addState(
            t,
            r = tf,
            n = void 0,
            i = void 0,
            s = void 0,
            o = void 0,
            l = void 0,
            u = void 0,
          ) {
            let h = t?.trim();
            if (!this.currentDocument.states.has(h))
              (P.info("Adding state ", h, i),
                this.currentDocument.states.set(h, {
                  stmt: iu,
                  id: h,
                  descriptions: [],
                  type: r,
                  doc: n,
                  note: s,
                  classes: [],
                  styles: [],
                  textStyles: [],
                }));
            else {
              let f = this.currentDocument.states.get(h);
              if (!f) throw new Error(`State not found: ${h}`);
              (f.doc || (f.doc = n), f.type || (f.type = r));
            }
            if (
              (i &&
                (P.info("Setting state description", h, i),
                (Array.isArray(i) ? i : [i]).forEach((d) =>
                  this.addDescription(h, d.trim()),
                )),
              s)
            ) {
              let f = this.currentDocument.states.get(h);
              if (!f) throw new Error(`State not found: ${h}`);
              ((f.note = s), (f.note.text = Rt.sanitizeText(f.note.text, K())));
            }
            (o &&
              (P.info("Setting state classes", h, o),
              (Array.isArray(o) ? o : [o]).forEach((d) =>
                this.setCssClass(h, d.trim()),
              )),
              l &&
                (P.info("Setting state styles", h, l),
                (Array.isArray(l) ? l : [l]).forEach((d) =>
                  this.setStyle(h, d.trim()),
                )),
              u &&
                (P.info("Setting state styles", h, l),
                (Array.isArray(u) ? u : [u]).forEach((d) =>
                  this.setTextStyle(h, d.trim()),
                )));
          }
          clear(t) {
            ((this.nodes = []),
              (this.edges = []),
              (this.documents = { root: _it() }),
              (this.currentDocument = this.documents.root),
              (this.startEndCount = 0),
              (this.classes = Sit()),
              t || ((this.links = new Map()), Ye()));
          }
          getState(t) {
            return this.currentDocument.states.get(t);
          }
          getStates() {
            return this.currentDocument.states;
          }
          logDocuments() {
            P.info("Documents = ", this.documents);
          }
          getRelations() {
            return this.currentDocument.relations;
          }
          addLink(t, r, n) {
            (this.links.set(t, { url: r, tooltip: n }),
              P.warn("Adding link", t, r, n));
          }
          getLinks() {
            return this.links;
          }
          startIdIfNeeded(t = "") {
            return t === Qi.START_NODE
              ? (this.startEndCount++, `${Qi.START_TYPE}${this.startEndCount}`)
              : t;
          }
          startTypeIfNeeded(t = "", r = tf) {
            return t === Qi.START_NODE ? Qi.START_TYPE : r;
          }
          endIdIfNeeded(t = "") {
            return t === Qi.END_NODE
              ? (this.startEndCount++, `${Qi.END_TYPE}${this.startEndCount}`)
              : t;
          }
          endTypeIfNeeded(t = "", r = tf) {
            return t === Qi.END_NODE ? Qi.END_TYPE : r;
          }
          addRelationObjs(t, r, n = "") {
            let i = this.startIdIfNeeded(t.id.trim()),
              s = this.startTypeIfNeeded(t.id.trim(), t.type),
              o = this.startIdIfNeeded(r.id.trim()),
              l = this.startTypeIfNeeded(r.id.trim(), r.type);
            (this.addState(
              i,
              s,
              t.doc,
              t.description,
              t.note,
              t.classes,
              t.styles,
              t.textStyles,
            ),
              this.addState(
                o,
                l,
                r.doc,
                r.description,
                r.note,
                r.classes,
                r.styles,
                r.textStyles,
              ),
              this.currentDocument.relations.push({
                id1: i,
                id2: o,
                relationTitle: Rt.sanitizeText(n, K()),
              }));
          }
          addRelation(t, r, n) {
            if (typeof t == "object" && typeof r == "object")
              this.addRelationObjs(t, r, n);
            else if (typeof t == "string" && typeof r == "string") {
              let i = this.startIdIfNeeded(t.trim()),
                s = this.startTypeIfNeeded(t),
                o = this.endIdIfNeeded(r.trim()),
                l = this.endTypeIfNeeded(r);
              (this.addState(i, s),
                this.addState(o, l),
                this.currentDocument.relations.push({
                  id1: i,
                  id2: o,
                  relationTitle: n ? Rt.sanitizeText(n, K()) : void 0,
                }));
            }
          }
          addDescription(t, r) {
            let n = this.currentDocument.states.get(t),
              i = r.startsWith(":") ? r.replace(":", "").trim() : r;
            n?.descriptions?.push(Rt.sanitizeText(i, K()));
          }
          cleanupLabel(t) {
            return t.startsWith(":") ? t.slice(2).trim() : t.trim();
          }
          getDividerId() {
            return (this.dividerCnt++, `divider-id-${this.dividerCnt}`);
          }
          addStyleClass(t, r = "") {
            this.classes.has(t) ||
              this.classes.set(t, { id: t, styles: [], textStyles: [] });
            let n = this.classes.get(t);
            r &&
              n &&
              r.split(Qi.STYLECLASS_SEP).forEach((i) => {
                let s = i.replace(/([^;]*);/, "$1").trim();
                if (RegExp(Qi.COLOR_KEYWORD).exec(i)) {
                  let l = s
                    .replace(Qi.FILL_KEYWORD, Qi.BG_FILL)
                    .replace(Qi.COLOR_KEYWORD, Qi.FILL_KEYWORD);
                  n.textStyles.push(l);
                }
                n.styles.push(s);
              });
          }
          getClasses() {
            return this.classes;
          }
          setCssClass(t, r) {
            t.split(",").forEach((n) => {
              let i = this.getState(n);
              if (!i) {
                let s = n.trim();
                (this.addState(s), (i = this.getState(s)));
              }
              i?.classes?.push(r);
            });
          }
          setStyle(t, r) {
            this.getState(t)?.styles?.push(r);
          }
          setTextStyle(t, r) {
            this.getState(t)?.textStyles?.push(r);
          }
          getDirectionStatement() {
            return this.rootDoc.find((t) => t.stmt === EN);
          }
          getDirection() {
            return this.getDirectionStatement()?.value ?? nit;
          }
          setDirection(t) {
            let r = this.getDirectionStatement();
            r ? (r.value = t) : this.rootDoc.unshift({ stmt: EN, value: t });
          }
          trimColon(t) {
            return t.startsWith(":") ? t.slice(1).trim() : t.trim();
          }
          getData() {
            let t = K();
            return {
              nodes: this.nodes,
              edges: this.edges,
              other: {},
              config: t,
              direction: GN(this.getRootDocV2()),
            };
          }
          getConfig() {
            return K().state;
          }
        }));
    });
  var VDt,
    Z_,
    zN = x(() => {
      "use strict";
      ((VDt = a(
        (e) => `
defs #statediagram-barbEnd {
    fill: ${e.transitionColor};
    stroke: ${e.transitionColor};
  }
g.stateGroup text {
  fill: ${e.nodeBorder};
  stroke: none;
  font-size: 10px;
}
g.stateGroup text {
  fill: ${e.textColor};
  stroke: none;
  font-size: 10px;

}
g.stateGroup .state-title {
  font-weight: bolder;
  fill: ${e.stateLabelColor};
}

g.stateGroup rect {
  fill: ${e.mainBkg};
  stroke: ${e.nodeBorder};
}

g.stateGroup line {
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.transition {
  stroke: ${e.transitionColor};
  stroke-width: 1;
  fill: none;
}

.stateGroup .composit {
  fill: ${e.background};
  border-bottom: 1px
}

.stateGroup .alt-composit {
  fill: #e0e0e0;
  border-bottom: 1px
}

.state-note {
  stroke: ${e.noteBorderColor};
  fill: ${e.noteBkgColor};

  text {
    fill: ${e.noteTextColor};
    stroke: none;
    font-size: 10px;
  }
}

.stateLabel .box {
  stroke: none;
  stroke-width: 0;
  fill: ${e.mainBkg};
  opacity: 0.5;
}

.edgeLabel .label rect {
  fill: ${e.labelBackgroundColor};
  opacity: 0.5;
}
.edgeLabel {
  background-color: ${e.edgeLabelBackground};
  p {
    background-color: ${e.edgeLabelBackground};
  }
  rect {
    opacity: 0.5;
    background-color: ${e.edgeLabelBackground};
    fill: ${e.edgeLabelBackground};
  }
  text-align: center;
}
.edgeLabel .label text {
  fill: ${e.transitionLabelColor || e.tertiaryTextColor};
}
.label div .edgeLabel {
  color: ${e.transitionLabelColor || e.tertiaryTextColor};
}

.stateLabel text {
  fill: ${e.stateLabelColor};
  font-size: 10px;
  font-weight: bold;
}

.node circle.state-start {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node .fork-join {
  fill: ${e.specialStateColor};
  stroke: ${e.specialStateColor};
}

.node circle.state-end {
  fill: ${e.innerEndBackground};
  stroke: ${e.background};
  stroke-width: 1.5
}
.end-state-inner {
  fill: ${e.compositeBackground || e.background};
  // stroke: ${e.background};
  stroke-width: 1.5
}

.node rect {
  fill: ${e.stateBkg || e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}
.node polygon {
  fill: ${e.mainBkg};
  stroke: ${e.stateBorder || e.nodeBorder};;
  stroke-width: 1px;
}
#statediagram-barbEnd {
  fill: ${e.lineColor};
}

.statediagram-cluster rect {
  fill: ${e.compositeTitleBackground};
  stroke: ${e.stateBorder || e.nodeBorder};
  stroke-width: 1px;
}

.cluster-label, .nodeLabel {
  color: ${e.stateLabelColor};
  // line-height: 1;
}

.statediagram-cluster rect.outer {
  rx: 5px;
  ry: 5px;
}
.statediagram-state .divider {
  stroke: ${e.stateBorder || e.nodeBorder};
}

.statediagram-state .title-state {
  rx: 5px;
  ry: 5px;
}
.statediagram-cluster.statediagram-cluster .inner {
  fill: ${e.compositeBackground || e.background};
}
.statediagram-cluster.statediagram-cluster-alt .inner {
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.statediagram-cluster .inner {
  rx:0;
  ry:0;
}

.statediagram-state rect.basic {
  rx: 5px;
  ry: 5px;
}
.statediagram-state rect.divider {
  stroke-dasharray: 10,10;
  fill: ${e.altBackground ? e.altBackground : "#efefef"};
}

.note-edge {
  stroke-dasharray: 5;
}

.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}
.statediagram-note rect {
  fill: ${e.noteBkgColor};
  stroke: ${e.noteBorderColor};
  stroke-width: 1px;
  rx: 0;
  ry: 0;
}

.statediagram-note text {
  fill: ${e.noteTextColor};
}

.statediagram-note .nodeLabel {
  color: ${e.noteTextColor};
}
.statediagram .edgeLabel {
  color: red; // ${e.noteTextColor};
}

#dependencyStart, #dependencyEnd {
  fill: ${e.lineColor};
  stroke: ${e.lineColor};
  stroke-width: 1;
}

.statediagramTitleText {
  text-anchor: middle;
  font-size: 18px;
  fill: ${e.textColor};
}
`,
        "getStyles",
      )),
        (Z_ = VDt));
    });
  var zDt,
    WDt,
    UDt,
    jDt,
    wit,
    qDt,
    HDt,
    YDt,
    XDt,
    WN,
    Cit,
    vit,
    Eit = x(() => {
      "use strict";
      Ge();
      Q_();
      _e();
      Be();
      pe();
      Vt();
      ((zDt = a(
        (e) =>
          e
            .append("circle")
            .attr("class", "start-state")
            .attr("r", K().state.sizeUnit)
            .attr("cx", K().state.padding + K().state.sizeUnit)
            .attr("cy", K().state.padding + K().state.sizeUnit),
        "drawStartState",
      )),
        (WDt = a(
          (e) =>
            e
              .append("line")
              .style("stroke", "grey")
              .style("stroke-dasharray", "3")
              .attr("x1", K().state.textHeight)
              .attr("class", "divider")
              .attr("x2", K().state.textHeight * 2)
              .attr("y1", 0)
              .attr("y2", 0),
          "drawDivider",
        )),
        (UDt = a((e, t) => {
          let r = e
              .append("text")
              .attr("x", 2 * K().state.padding)
              .attr("y", K().state.textHeight + 2 * K().state.padding)
              .attr("font-size", K().state.fontSize)
              .attr("class", "state-title")
              .text(t.id),
            n = r.node().getBBox();
          return (
            e
              .insert("rect", ":first-child")
              .attr("x", K().state.padding)
              .attr("y", K().state.padding)
              .attr("width", n.width + 2 * K().state.padding)
              .attr("height", n.height + 2 * K().state.padding)
              .attr("rx", K().state.radius),
            r
          );
        }, "drawSimpleState")),
        (jDt = a((e, t) => {
          let r = a(function (p, m, g) {
              let y = p
                .append("tspan")
                .attr("x", 2 * K().state.padding)
                .text(m);
              g || y.attr("dy", K().state.textHeight);
            }, "addTspan"),
            i = e
              .append("text")
              .attr("x", 2 * K().state.padding)
              .attr("y", K().state.textHeight + 1.3 * K().state.padding)
              .attr("font-size", K().state.fontSize)
              .attr("class", "state-title")
              .text(t.descriptions[0])
              .node()
              .getBBox(),
            s = i.height,
            o = e
              .append("text")
              .attr("x", K().state.padding)
              .attr(
                "y",
                s +
                  K().state.padding * 0.4 +
                  K().state.dividerMargin +
                  K().state.textHeight,
              )
              .attr("class", "state-description"),
            l = !0,
            u = !0;
          t.descriptions.forEach(function (p) {
            (l || (r(o, p, u), (u = !1)), (l = !1));
          });
          let h = e
              .append("line")
              .attr("x1", K().state.padding)
              .attr("y1", K().state.padding + s + K().state.dividerMargin / 2)
              .attr("y2", K().state.padding + s + K().state.dividerMargin / 2)
              .attr("class", "descr-divider"),
            f = o.node().getBBox(),
            d = Math.max(f.width, i.width);
          return (
            h.attr("x2", d + 3 * K().state.padding),
            e
              .insert("rect", ":first-child")
              .attr("x", K().state.padding)
              .attr("y", K().state.padding)
              .attr("width", d + 2 * K().state.padding)
              .attr("height", f.height + s + 2 * K().state.padding)
              .attr("rx", K().state.radius),
            e
          );
        }, "drawDescrState")),
        (wit = a((e, t, r) => {
          let n = K().state.padding,
            i = 2 * K().state.padding,
            s = e.node().getBBox(),
            o = s.width,
            l = s.x,
            u = e
              .append("text")
              .attr("x", 0)
              .attr("y", K().state.titleShift)
              .attr("font-size", K().state.fontSize)
              .attr("class", "state-title")
              .text(t.id),
            f = u.node().getBBox().width + i,
            d = Math.max(f, o);
          d === o && (d = d + i);
          let p,
            m = e.node().getBBox();
          (t.doc,
            (p = l - n),
            f > o && (p = (o - d) / 2 + n),
            Math.abs(l - m.x) < n && f > o && (p = l - (f - o) / 2));
          let g = 1 - K().state.textHeight;
          return (
            e
              .insert("rect", ":first-child")
              .attr("x", p)
              .attr("y", g)
              .attr("class", r ? "alt-composit" : "composit")
              .attr("width", d)
              .attr(
                "height",
                m.height + K().state.textHeight + K().state.titleShift + 1,
              )
              .attr("rx", "0"),
            u.attr("x", p + n),
            f <= o && u.attr("x", l + (d - i) / 2 - f / 2 + n),
            e
              .insert("rect", ":first-child")
              .attr("x", p)
              .attr(
                "y",
                K().state.titleShift - K().state.textHeight - K().state.padding,
              )
              .attr("width", d)
              .attr("height", K().state.textHeight * 3)
              .attr("rx", K().state.radius),
            e
              .insert("rect", ":first-child")
              .attr("x", p)
              .attr(
                "y",
                K().state.titleShift - K().state.textHeight - K().state.padding,
              )
              .attr("width", d)
              .attr("height", m.height + 3 + 2 * K().state.textHeight)
              .attr("rx", K().state.radius),
            e
          );
        }, "addTitleAndBox")),
        (qDt = a(
          (e) => (
            e
              .append("circle")
              .attr("class", "end-state-outer")
              .attr("r", K().state.sizeUnit + K().state.miniPadding)
              .attr(
                "cx",
                K().state.padding + K().state.sizeUnit + K().state.miniPadding,
              )
              .attr(
                "cy",
                K().state.padding + K().state.sizeUnit + K().state.miniPadding,
              ),
            e
              .append("circle")
              .attr("class", "end-state-inner")
              .attr("r", K().state.sizeUnit)
              .attr("cx", K().state.padding + K().state.sizeUnit + 2)
              .attr("cy", K().state.padding + K().state.sizeUnit + 2)
          ),
          "drawEndState",
        )),
        (HDt = a((e, t) => {
          let r = K().state.forkWidth,
            n = K().state.forkHeight;
          if (t.parentId) {
            let i = r;
            ((r = n), (n = i));
          }
          return e
            .append("rect")
            .style("stroke", "black")
            .style("fill", "black")
            .attr("width", r)
            .attr("height", n)
            .attr("x", K().state.padding)
            .attr("y", K().state.padding);
        }, "drawForkJoinState")),
        (YDt = a((e, t, r, n) => {
          let i = 0,
            s = n.append("text");
          (s.style("text-anchor", "start"), s.attr("class", "noteText"));
          let o = e.replace(/\r\n/g, "<br/>");
          o = o.replace(/\n/g, "<br/>");
          let l = o.split(Rt.lineBreakRegex),
            u = 1.25 * K().state.noteMargin;
          for (let h of l) {
            let f = h.trim();
            if (f.length > 0) {
              let d = s.append("tspan");
              if ((d.text(f), u === 0)) {
                let p = d.node().getBBox();
                u += p.height;
              }
              ((i += u),
                d.attr("x", t + K().state.noteMargin),
                d.attr("y", r + i + 1.25 * K().state.noteMargin));
            }
          }
          return { textWidth: s.node().getBBox().width, textHeight: i };
        }, "_drawLongText")),
        (XDt = a((e, t) => {
          t.attr("class", "state-note");
          let r = t.append("rect").attr("x", 0).attr("y", K().state.padding),
            n = t.append("g"),
            { textWidth: i, textHeight: s } = YDt(e, 0, 0, n);
          return (
            r.attr("height", s + 2 * K().state.noteMargin),
            r.attr("width", i + K().state.noteMargin * 2),
            r
          );
        }, "drawNote")),
        (WN = a(function (e, t) {
          let r = t.id,
            n = { id: r, label: t.id, width: 0, height: 0 },
            i = e.append("g").attr("id", r).attr("class", "stateGroup");
          (t.type === "start" && zDt(i),
            t.type === "end" && qDt(i),
            (t.type === "fork" || t.type === "join") && HDt(i, t),
            t.type === "note" && XDt(t.note.text, i),
            t.type === "divider" && WDt(i),
            t.type === "default" && t.descriptions.length === 0 && UDt(i, t),
            t.type === "default" && t.descriptions.length > 0 && jDt(i, t));
          let s = i.node().getBBox();
          return (
            (n.width = s.width + 2 * K().state.padding),
            (n.height = s.height + 2 * K().state.padding),
            n
          );
        }, "drawState")),
        (Cit = 0),
        (vit = a(function (e, t, r) {
          let n = a(function (u) {
            switch (u) {
              case ma.relationType.AGGREGATION:
                return "aggregation";
              case ma.relationType.EXTENSION:
                return "extension";
              case ma.relationType.COMPOSITION:
                return "composition";
              case ma.relationType.DEPENDENCY:
                return "dependency";
            }
          }, "getRelationType");
          t.points = t.points.filter((u) => !Number.isNaN(u.y));
          let i = t.points,
            s = Oa()
              .x(function (u) {
                return u.x;
              })
              .y(function (u) {
                return u.y;
              })
              .curve(Ys),
            o = e
              .append("path")
              .attr("d", s(i))
              .attr("id", "edge" + Cit)
              .attr("class", "transition"),
            l = "";
          if (
            (K().state.arrowMarkerAbsolute && (l = tl(!0)),
            o.attr(
              "marker-end",
              "url(" + l + "#" + n(ma.relationType.DEPENDENCY) + "End)",
            ),
            r.title !== void 0)
          ) {
            let u = e.append("g").attr("class", "stateLabel"),
              { x: h, y: f } = le.calcLabelPosition(t.points),
              d = Rt.getRows(r.title),
              p = 0,
              m = [],
              g = 0,
              y = 0;
            for (let T = 0; T <= d.length; T++) {
              let C = u
                  .append("text")
                  .attr("text-anchor", "middle")
                  .text(d[T])
                  .attr("x", h)
                  .attr("y", f + p),
                L = C.node().getBBox();
              ((g = Math.max(g, L.width)),
                (y = Math.min(y, L.x)),
                P.info(L.x, h, f + p),
                p === 0 &&
                  ((p = C.node().getBBox().height),
                  P.info("Title height", p, f)),
                m.push(C));
            }
            let b = p * d.length;
            if (d.length > 1) {
              let T = (d.length - 1) * p * 0.5;
              (m.forEach((C, L) => C.attr("y", f + L * p - T)),
                (b = p * d.length));
            }
            let k = u.node().getBBox();
            (u
              .insert("rect", ":first-child")
              .attr("class", "box")
              .attr("x", h - g / 2 - K().state.padding / 2)
              .attr("y", f - b / 2 - K().state.padding / 2 - 3.5)
              .attr("width", g + K().state.padding)
              .attr("height", b + K().state.padding),
              P.info(k));
          }
          Cit++;
        }, "drawEdge")));
    });
  var $s,
    UN,
    KDt,
    QDt,
    ZDt,
    JDt,
    Ait,
    Lit,
    Rit = x(() => {
      "use strict";
      Ge();
      Q5();
      aa();
      Vt();
      Be();
      Eit();
      pe();
      On();
      ((UN = {}),
        (KDt = a(function () {}, "setConf")),
        (QDt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "dependencyEnd")
            .attr("refX", 19)
            .attr("refY", 7)
            .attr("markerWidth", 20)
            .attr("markerHeight", 28)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
        }, "insertMarkers")),
        (ZDt = a(function (e, t, r, n) {
          $s = K().state;
          let i = K().securityLevel,
            s;
          i === "sandbox" && (s = xt("#i" + t));
          let o =
              i === "sandbox"
                ? xt(s.nodes()[0].contentDocument.body)
                : xt("body"),
            l = i === "sandbox" ? s.nodes()[0].contentDocument : document;
          P.debug("Rendering diagram " + e);
          let u = o.select(`[id='${t}']`);
          QDt(u);
          let h = n.db.getRootDoc();
          Ait(h, u, void 0, !1, o, l, n);
          let f = $s.padding,
            d = u.node().getBBox(),
            p = d.width + f * 2,
            m = d.height + f * 2,
            g = p * 1.75;
          (Ar(u, m, g, $s.useMaxWidth),
            u.attr(
              "viewBox",
              `${d.x - $s.padding}  ${d.y - $s.padding} ` + p + " " + m,
            ));
        }, "draw")),
        (JDt = a(
          (e) => (e ? e.length * $s.fontSizeFactor : 1),
          "getLabelWidth",
        )),
        (Ait = a((e, t, r, n, i, s, o) => {
          let l = new _r({ compound: !0, multigraph: !0 }),
            u,
            h = !0;
          for (u = 0; u < e.length; u++)
            if (e[u].stmt === "relation") {
              h = !1;
              break;
            }
          (r
            ? l.setGraph({
                rankdir: "LR",
                multigraph: !0,
                compound: !0,
                ranker: "tight-tree",
                ranksep: h ? 1 : $s.edgeLengthFactor,
                nodeSep: h ? 1 : 50,
                isMultiGraph: !0,
              })
            : l.setGraph({
                rankdir: "TB",
                multigraph: !0,
                compound: !0,
                ranksep: h ? 1 : $s.edgeLengthFactor,
                nodeSep: h ? 1 : 50,
                ranker: "tight-tree",
                isMultiGraph: !0,
              }),
            l.setDefaultEdgeLabel(function () {
              return {};
            }));
          let f = o.db.getStates(),
            d = o.db.getRelations(),
            p = Object.keys(f),
            m = !0;
          for (let T of p) {
            let C = f[T];
            r && (C.parentId = r);
            let L;
            if (C.doc) {
              let w = t
                .append("g")
                .attr("id", C.id)
                .attr("class", "stateGroup");
              if (((L = Ait(C.doc, w, C.id, !n, i, s, o)), m)) {
                w = wit(w, C, n);
                let D = w.node().getBBox();
                ((L.width = D.width),
                  (L.height = D.height + $s.padding / 2),
                  (UN[C.id] = { y: $s.compositTitleSize }));
              } else {
                let D = w.node().getBBox();
                ((L.width = D.width), (L.height = D.height));
              }
            } else L = WN(t, C, l);
            if (C.note) {
              let w = {
                  descriptions: [],
                  id: C.id + "-note",
                  note: C.note,
                  type: "note",
                },
                D = WN(t, w, l);
              (C.note.position === "left of"
                ? (l.setNode(L.id + "-note", D), l.setNode(L.id, L))
                : (l.setNode(L.id, L), l.setNode(L.id + "-note", D)),
                l.setParent(L.id, L.id + "-group"),
                l.setParent(L.id + "-note", L.id + "-group"));
            } else l.setNode(L.id, L);
          }
          P.debug("Count=", l.nodeCount(), l);
          let g = 0;
          (d.forEach(function (T) {
            (g++,
              P.debug("Setting edge", T),
              l.setEdge(
                T.id1,
                T.id2,
                {
                  relation: T,
                  width: JDt(T.title),
                  height: $s.labelHeight * Rt.getRows(T.title).length,
                  labelpos: "c",
                },
                "id" + g,
              ));
          }),
            Y0(l),
            P.debug("Graph after layout", l.nodes()));
          let y = t.node();
          l.nodes().forEach(function (T) {
            T !== void 0 && l.node(T) !== void 0
              ? (P.warn("Node " + T + ": " + JSON.stringify(l.node(T))),
                i
                  .select("#" + y.id + " #" + T)
                  .attr(
                    "transform",
                    "translate(" +
                      (l.node(T).x - l.node(T).width / 2) +
                      "," +
                      (l.node(T).y +
                        (UN[T] ? UN[T].y : 0) -
                        l.node(T).height / 2) +
                      " )",
                  ),
                i
                  .select("#" + y.id + " #" + T)
                  .attr("data-x-shift", l.node(T).x - l.node(T).width / 2),
                s
                  .querySelectorAll("#" + y.id + " #" + T + " .divider")
                  .forEach((L) => {
                    let w = L.parentElement,
                      D = 0,
                      G = 0;
                    (w &&
                      (w.parentElement && (D = w.parentElement.getBBox().width),
                      (G = parseInt(w.getAttribute("data-x-shift"), 10)),
                      Number.isNaN(G) && (G = 0)),
                      L.setAttribute("x1", 0 - G + 8),
                      L.setAttribute("x2", D - G - 8));
                  }))
              : P.debug("No Node " + T + ": " + JSON.stringify(l.node(T)));
          });
          let b = y.getBBox();
          (l.edges().forEach(function (T) {
            T !== void 0 &&
              l.edge(T) !== void 0 &&
              (P.debug(
                "Edge " + T.v + " -> " + T.w + ": " + JSON.stringify(l.edge(T)),
              ),
              vit(t, l.edge(T), l.edge(T).relation));
          }),
            (b = y.getBBox()));
          let k = { id: r || "root", label: r || "root", width: 0, height: 0 };
          return (
            (k.width = b.width + 2 * $s.padding),
            (k.height = b.height + 2 * $s.padding),
            P.debug("Doc rendered", k, l),
            k
          );
        }, "renderDoc")),
        (Lit = { setConf: KDt, draw: ZDt }));
    });
  var Dit = {};
  Oe(Dit, { diagram: () => tNt });
  var tNt,
    Nit = x(() => {
      "use strict";
      vN();
      Q_();
      zN();
      Rit();
      tNt = {
        parser: V_,
        get db() {
          return new ma(1);
        },
        renderer: Lit,
        styles: Z_,
        init: a((e) => {
          (e.state || (e.state = {}),
            (e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute));
        }, "init"),
      };
    });
  var Oit = {};
  Oe(Oit, { diagram: () => iNt });
  var iNt,
    Pit = x(() => {
      "use strict";
      vN();
      Q_();
      zN();
      VN();
      iNt = {
        parser: V_,
        get db() {
          return new ma(2);
        },
        renderer: Tit,
        styles: Z_,
        init: a((e) => {
          (e.state || (e.state = {}),
            (e.state.arrowMarkerAbsolute = e.arrowMarkerAbsolute));
        }, "init"),
      };
    });
  var jN,
    $it,
    Git = x(() => {
      "use strict";
      jN = (function () {
        var e = a(function (d, p, m, g) {
            for (m = m || {}, g = d.length; g--; m[d[g]] = p);
            return m;
          }, "o"),
          t = [6, 8, 10, 11, 12, 14, 16, 17, 18],
          r = [1, 9],
          n = [1, 10],
          i = [1, 11],
          s = [1, 12],
          o = [1, 13],
          l = [1, 14],
          u = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              journey: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NEWLINE: 10,
              title: 11,
              acc_title: 12,
              acc_title_value: 13,
              acc_descr: 14,
              acc_descr_value: 15,
              acc_descr_multiline_value: 16,
              section: 17,
              taskName: 18,
              taskData: 19,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "journey",
              6: "EOF",
              8: "SPACE",
              10: "NEWLINE",
              11: "title",
              12: "acc_title",
              13: "acc_title_value",
              14: "acc_descr",
              15: "acc_descr_value",
              16: "acc_descr_multiline_value",
              17: "section",
              18: "taskName",
              19: "taskData",
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 2],
            ],
            performAction: a(function (p, m, g, y, b, k, T) {
              var C = k.length - 1;
              switch (b) {
                case 1:
                  return k[C - 1];
                case 2:
                  this.$ = [];
                  break;
                case 3:
                  (k[C - 1].push(k[C]), (this.$ = k[C - 1]));
                  break;
                case 4:
                case 5:
                  this.$ = k[C];
                  break;
                case 6:
                case 7:
                  this.$ = [];
                  break;
                case 8:
                  (y.setDiagramTitle(k[C].substr(6)),
                    (this.$ = k[C].substr(6)));
                  break;
                case 9:
                  ((this.$ = k[C].trim()), y.setAccTitle(this.$));
                  break;
                case 10:
                case 11:
                  ((this.$ = k[C].trim()), y.setAccDescription(this.$));
                  break;
                case 12:
                  (y.addSection(k[C].substr(8)), (this.$ = k[C].substr(8)));
                  break;
                case 13:
                  (y.addTask(k[C - 1], k[C]), (this.$ = "task"));
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              {
                6: [1, 4],
                7: 5,
                8: [1, 6],
                9: 7,
                10: [1, 8],
                11: r,
                12: n,
                14: i,
                16: s,
                17: o,
                18: l,
              },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              { 9: 15, 11: r, 12: n, 14: i, 16: s, 17: o, 18: l },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 8]),
              { 13: [1, 16] },
              { 15: [1, 17] },
              e(t, [2, 11]),
              e(t, [2, 12]),
              { 19: [1, 18] },
              e(t, [2, 4]),
              e(t, [2, 9]),
              e(t, [2, 10]),
              e(t, [2, 13]),
            ],
            defaultActions: {},
            parseError: a(function (p, m) {
              if (m.recoverable) this.trace(p);
              else {
                var g = new Error(p);
                throw ((g.hash = m), g);
              }
            }, "parseError"),
            parse: a(function (p) {
              var m = this,
                g = [0],
                y = [],
                b = [null],
                k = [],
                T = this.table,
                C = "",
                L = 0,
                w = 0,
                D = 0,
                G = 2,
                E = 1,
                R = k.slice.call(arguments, 1),
                F = Object.create(this.lexer),
                S = { yy: {} };
              for (var O in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, O) &&
                  (S.yy[O] = this.yy[O]);
              (F.setInput(p, S.yy),
                (S.yy.lexer = F),
                (S.yy.parser = this),
                typeof F.yylloc > "u" && (F.yylloc = {}));
              var v = F.yylloc;
              k.push(v);
              var _ = F.options && F.options.ranges;
              typeof S.yy.parseError == "function"
                ? (this.parseError = S.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function A(ot) {
                ((g.length = g.length - 2 * ot),
                  (b.length = b.length - ot),
                  (k.length = k.length - ot));
              }
              a(A, "popStack");
              function N() {
                var ot;
                return (
                  (ot = y.pop() || F.lex() || E),
                  typeof ot != "number" &&
                    (ot instanceof Array && ((y = ot), (ot = y.pop())),
                    (ot = m.symbols_[ot] || ot)),
                  ot
                );
              }
              a(N, "lex");
              for (var B, M, I, V, $, q, tt = {}, ht, H, kt, ft; ; ) {
                if (
                  ((I = g[g.length - 1]),
                  this.defaultActions[I]
                    ? (V = this.defaultActions[I])
                    : ((B === null || typeof B > "u") && (B = N()),
                      (V = T[I] && T[I][B])),
                  typeof V > "u" || !V.length || !V[0])
                ) {
                  var yt = "";
                  ft = [];
                  for (ht in T[I])
                    this.terminals_[ht] &&
                      ht > G &&
                      ft.push("'" + this.terminals_[ht] + "'");
                  (F.showPosition
                    ? (yt =
                        "Parse error on line " +
                        (L + 1) +
                        `:
` +
                        F.showPosition() +
                        `
Expecting ` +
                        ft.join(", ") +
                        ", got '" +
                        (this.terminals_[B] || B) +
                        "'")
                    : (yt =
                        "Parse error on line " +
                        (L + 1) +
                        ": Unexpected " +
                        (B == E
                          ? "end of input"
                          : "'" + (this.terminals_[B] || B) + "'")),
                    this.parseError(yt, {
                      text: F.match,
                      token: this.terminals_[B] || B,
                      line: F.yylineno,
                      loc: v,
                      expected: ft,
                    }));
                }
                if (V[0] instanceof Array && V.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      I +
                      ", token: " +
                      B,
                  );
                switch (V[0]) {
                  case 1:
                    (g.push(B),
                      b.push(F.yytext),
                      k.push(F.yylloc),
                      g.push(V[1]),
                      (B = null),
                      M
                        ? ((B = M), (M = null))
                        : ((w = F.yyleng),
                          (C = F.yytext),
                          (L = F.yylineno),
                          (v = F.yylloc),
                          D > 0 && D--));
                    break;
                  case 2:
                    if (
                      ((H = this.productions_[V[1]][1]),
                      (tt.$ = b[b.length - H]),
                      (tt._$ = {
                        first_line: k[k.length - (H || 1)].first_line,
                        last_line: k[k.length - 1].last_line,
                        first_column: k[k.length - (H || 1)].first_column,
                        last_column: k[k.length - 1].last_column,
                      }),
                      _ &&
                        (tt._$.range = [
                          k[k.length - (H || 1)].range[0],
                          k[k.length - 1].range[1],
                        ]),
                      (q = this.performAction.apply(
                        tt,
                        [C, w, L, S.yy, V[1], b, k].concat(R),
                      )),
                      typeof q < "u")
                    )
                      return q;
                    (H &&
                      ((g = g.slice(0, -1 * H * 2)),
                      (b = b.slice(0, -1 * H)),
                      (k = k.slice(0, -1 * H))),
                      g.push(this.productions_[V[1]][0]),
                      b.push(tt.$),
                      k.push(tt._$),
                      (kt = T[g[g.length - 2]][g[g.length - 1]]),
                      g.push(kt));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          h = (function () {
            var d = {
              EOF: 1,
              parseError: a(function (m, g) {
                if (this.yy.parser) this.yy.parser.parseError(m, g);
                else throw new Error(m);
              }, "parseError"),
              setInput: a(function (p, m) {
                return (
                  (this.yy = m || this.yy || {}),
                  (this._input = p),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var p = this._input[0];
                ((this.yytext += p),
                  this.yyleng++,
                  this.offset++,
                  (this.match += p),
                  (this.matched += p));
                var m = p.match(/(?:\r\n?|\n).*/g);
                return (
                  m
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  p
                );
              }, "input"),
              unput: a(function (p) {
                var m = p.length,
                  g = p.split(/(?:\r\n?|\n)/g);
                ((this._input = p + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - m)),
                  (this.offset -= m));
                var y = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  g.length - 1 && (this.yylineno -= g.length - 1));
                var b = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: g
                      ? (g.length === y.length ? this.yylloc.first_column : 0) +
                        y[y.length - g.length].length -
                        g[0].length
                      : this.yylloc.first_column - m,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [b[0], b[0] + this.yyleng - m]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (p) {
                this.unput(this.match.slice(p));
              }, "less"),
              pastInput: a(function () {
                var p = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (p.length > 20 ? "..." : "") +
                  p.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var p = this.match;
                return (
                  p.length < 20 && (p += this._input.substr(0, 20 - p.length)),
                  (p.substr(0, 20) + (p.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var p = this.pastInput(),
                  m = new Array(p.length + 1).join("-");
                return (
                  p +
                  this.upcomingInput() +
                  `
` +
                  m +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (p, m) {
                var g, y, b;
                if (
                  (this.options.backtrack_lexer &&
                    ((b = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (b.yylloc.range = this.yylloc.range.slice(0))),
                  (y = p[0].match(/(?:\r\n?|\n).*/g)),
                  y && (this.yylineno += y.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: y
                      ? y[y.length - 1].length -
                        y[y.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + p[0].length,
                  }),
                  (this.yytext += p[0]),
                  (this.match += p[0]),
                  (this.matches = p),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(p[0].length)),
                  (this.matched += p[0]),
                  (g = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    m,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  g)
                )
                  return g;
                if (this._backtrack) {
                  for (var k in b) this[k] = b[k];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var p, m, g, y;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var b = this._currentRules(), k = 0; k < b.length; k++)
                  if (
                    ((g = this._input.match(this.rules[b[k]])),
                    g && (!m || g[0].length > m[0].length))
                  ) {
                    if (((m = g), (y = k), this.options.backtrack_lexer)) {
                      if (((p = this.test_match(g, b[k])), p !== !1)) return p;
                      if (this._backtrack) {
                        m = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return m
                  ? ((p = this.test_match(m, b[y])), p !== !1 ? p : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var m = this.next();
                return m || this.lex();
              }, "lex"),
              begin: a(function (m) {
                this.conditionStack.push(m);
              }, "begin"),
              popState: a(function () {
                var m = this.conditionStack.length - 1;
                return m > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (m) {
                return (
                  (m = this.conditionStack.length - 1 - Math.abs(m || 0)),
                  m >= 0 ? this.conditionStack[m] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (m) {
                this.begin(m);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (m, g, y, b) {
                var k = b;
                switch (y) {
                  case 0:
                    break;
                  case 1:
                    break;
                  case 2:
                    return 10;
                  case 3:
                    break;
                  case 4:
                    break;
                  case 5:
                    return 4;
                  case 6:
                    return 11;
                  case 7:
                    return (this.begin("acc_title"), 12);
                    break;
                  case 8:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 9:
                    return (this.begin("acc_descr"), 14);
                    break;
                  case 10:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 11:
                    this.begin("acc_descr_multiline");
                    break;
                  case 12:
                    this.popState();
                    break;
                  case 13:
                    return "acc_descr_multiline_value";
                  case 14:
                    return 17;
                  case 15:
                    return 18;
                  case 16:
                    return 19;
                  case 17:
                    return ":";
                  case 18:
                    return 6;
                  case 19:
                    return "INVALID";
                }
              }, "anonymous"),
              rules: [
                /^(?:%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:journey\b)/i,
                /^(?:title\s[^#\n;]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:section\s[^#:\n;]+)/i,
                /^(?:[^#:\n;]+)/i,
                /^(?::[^#\n;]+)/i,
                /^(?::)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [12, 13], inclusive: !1 },
                acc_descr: { rules: [10], inclusive: !1 },
                acc_title: { rules: [8], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18, 19,
                  ],
                  inclusive: !0,
                },
              },
            };
            return d;
          })();
        u.lexer = h;
        function f() {
          this.yy = {};
        }
        return (a(f, "Parser"), (f.prototype = u), (u.Parser = f), new f());
      })();
      jN.parser = jN;
      $it = jN;
    });
  var Em,
    qN,
    jy,
    qy,
    lNt,
    cNt,
    uNt,
    hNt,
    fNt,
    dNt,
    pNt,
    Vit,
    mNt,
    HN,
    zit = x(() => {
      "use strict";
      pe();
      yn();
      ((Em = ""),
        (qN = []),
        (jy = []),
        (qy = []),
        (lNt = a(function () {
          ((qN.length = 0), (jy.length = 0), (Em = ""), (qy.length = 0), Ye());
        }, "clear")),
        (cNt = a(function (e) {
          ((Em = e), qN.push(e));
        }, "addSection")),
        (uNt = a(function () {
          return qN;
        }, "getSections")),
        (hNt = a(function () {
          let e = Vit(),
            t = 100,
            r = 0;
          for (; !e && r < t; ) ((e = Vit()), r++);
          return (jy.push(...qy), jy);
        }, "getTasks")),
        (fNt = a(function () {
          let e = [];
          return (
            jy.forEach((r) => {
              r.people && e.push(...r.people);
            }),
            [...new Set(e)].sort()
          );
        }, "updateActors")),
        (dNt = a(function (e, t) {
          let r = t.substr(1).split(":"),
            n = 0,
            i = [];
          r.length === 1
            ? ((n = Number(r[0])), (i = []))
            : ((n = Number(r[0])), (i = r[1].split(",")));
          let s = i.map((l) => l.trim()),
            o = { section: Em, type: Em, people: s, task: e, score: n };
          qy.push(o);
        }, "addTask")),
        (pNt = a(function (e) {
          let t = {
            section: Em,
            type: Em,
            description: e,
            task: e,
            classes: [],
          };
          jy.push(t);
        }, "addTaskOrg")),
        (Vit = a(function () {
          let e = a(function (r) {
              return qy[r].processed;
            }, "compileTask"),
            t = !0;
          for (let [r, n] of qy.entries()) (e(r), (t = t && n.processed));
          return t;
        }, "compileTasks")),
        (mNt = a(function () {
          return fNt();
        }, "getActors")),
        (HN = {
          getConfig: a(() => K().journey, "getConfig"),
          clear: lNt,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          setAccTitle: Xe,
          getAccTitle: tr,
          setAccDescription: er,
          getAccDescription: rr,
          addSection: cNt,
          getSections: uNt,
          getTasks: hNt,
          addTask: dNt,
          addTaskOrg: pNt,
          getActors: mNt,
        }));
    });
  var gNt,
    Wit,
    Uit = x(() => {
      "use strict";
      Md();
      ((gNt = a(
        (e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.textColor};
  }
  .mouth {
    stroke: #666;
  }

  line {
    stroke: ${e.textColor}
  }

  .legend {
    fill: ${e.textColor};
    font-family: ${e.fontFamily};
  }

  .label text {
    fill: #333;
  }
  .label {
    color: ${e.textColor}
  }

  .face {
    ${e.faceColor ? `fill: ${e.faceColor}` : "fill: #FFF8DC"};
    stroke: #999;
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 1.5px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
    }
    text-align: center;
  }

  .cluster rect {
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .task-type-0, .section-type-0  {
    ${e.fillType0 ? `fill: ${e.fillType0}` : ""};
  }
  .task-type-1, .section-type-1  {
    ${e.fillType0 ? `fill: ${e.fillType1}` : ""};
  }
  .task-type-2, .section-type-2  {
    ${e.fillType0 ? `fill: ${e.fillType2}` : ""};
  }
  .task-type-3, .section-type-3  {
    ${e.fillType0 ? `fill: ${e.fillType3}` : ""};
  }
  .task-type-4, .section-type-4  {
    ${e.fillType0 ? `fill: ${e.fillType4}` : ""};
  }
  .task-type-5, .section-type-5  {
    ${e.fillType0 ? `fill: ${e.fillType5}` : ""};
  }
  .task-type-6, .section-type-6  {
    ${e.fillType0 ? `fill: ${e.fillType6}` : ""};
  }
  .task-type-7, .section-type-7  {
    ${e.fillType0 ? `fill: ${e.fillType7}` : ""};
  }

  .actor-0 {
    ${e.actor0 ? `fill: ${e.actor0}` : ""};
  }
  .actor-1 {
    ${e.actor1 ? `fill: ${e.actor1}` : ""};
  }
  .actor-2 {
    ${e.actor2 ? `fill: ${e.actor2}` : ""};
  }
  .actor-3 {
    ${e.actor3 ? `fill: ${e.actor3}` : ""};
  }
  .actor-4 {
    ${e.actor4 ? `fill: ${e.actor4}` : ""};
  }
  .actor-5 {
    ${e.actor5 ? `fill: ${e.actor5}` : ""};
  }
  ${Io()}
`,
        "getStyles",
      )),
        (Wit = gNt));
    });
  var YN,
    yNt,
    qit,
    Hit,
    xNt,
    bNt,
    jit,
    kNt,
    TNt,
    Yit,
    SNt,
    Am,
    Xit = x(() => {
      "use strict";
      Ge();
      a0();
      ((YN = a(function (e, t) {
        return Vu(e, t);
      }, "drawRect")),
        (yNt = a(function (e, t) {
          let n = e
              .append("circle")
              .attr("cx", t.cx)
              .attr("cy", t.cy)
              .attr("class", "face")
              .attr("r", 15)
              .attr("stroke-width", 2)
              .attr("overflow", "visible"),
            i = e.append("g");
          (i
            .append("circle")
            .attr("cx", t.cx - 15 / 3)
            .attr("cy", t.cy - 15 / 3)
            .attr("r", 1.5)
            .attr("stroke-width", 2)
            .attr("fill", "#666")
            .attr("stroke", "#666"),
            i
              .append("circle")
              .attr("cx", t.cx + 15 / 3)
              .attr("cy", t.cy - 15 / 3)
              .attr("r", 1.5)
              .attr("stroke-width", 2)
              .attr("fill", "#666")
              .attr("stroke", "#666"));
          function s(u) {
            let h = Ma()
              .startAngle(Math.PI / 2)
              .endAngle(3 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175);
            u.append("path")
              .attr("class", "mouth")
              .attr("d", h)
              .attr("transform", "translate(" + t.cx + "," + (t.cy + 2) + ")");
          }
          a(s, "smile");
          function o(u) {
            let h = Ma()
              .startAngle((3 * Math.PI) / 2)
              .endAngle(5 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175);
            u.append("path")
              .attr("class", "mouth")
              .attr("d", h)
              .attr("transform", "translate(" + t.cx + "," + (t.cy + 7) + ")");
          }
          a(o, "sad");
          function l(u) {
            u.append("line")
              .attr("class", "mouth")
              .attr("stroke", 2)
              .attr("x1", t.cx - 5)
              .attr("y1", t.cy + 7)
              .attr("x2", t.cx + 5)
              .attr("y2", t.cy + 7)
              .attr("class", "mouth")
              .attr("stroke-width", "1px")
              .attr("stroke", "#666");
          }
          return (
            a(l, "ambivalent"),
            t.score > 3 ? s(i) : t.score < 3 ? o(i) : l(i),
            n
          );
        }, "drawFace")),
        (qit = a(function (e, t) {
          let r = e.append("circle");
          return (
            r.attr("cx", t.cx),
            r.attr("cy", t.cy),
            r.attr("class", "actor-" + t.pos),
            r.attr("fill", t.fill),
            r.attr("stroke", t.stroke),
            r.attr("r", t.r),
            r.class !== void 0 && r.attr("class", r.class),
            t.title !== void 0 && r.append("title").text(t.title),
            r
          );
        }, "drawCircle")),
        (Hit = a(function (e, t) {
          return WB(e, t);
        }, "drawText")),
        (xNt = a(function (e, t) {
          function r(i, s, o, l, u) {
            return (
              i +
              "," +
              s +
              " " +
              (i + o) +
              "," +
              s +
              " " +
              (i + o) +
              "," +
              (s + l - u) +
              " " +
              (i + o - u * 1.2) +
              "," +
              (s + l) +
              " " +
              i +
              "," +
              (s + l)
            );
          }
          a(r, "genPoints");
          let n = e.append("polygon");
          (n.attr("points", r(t.x, t.y, 50, 20, 7)),
            n.attr("class", "labelBox"),
            (t.y = t.y + t.labelMargin),
            (t.x = t.x + 0.5 * t.labelMargin),
            Hit(e, t));
        }, "drawLabel")),
        (bNt = a(function (e, t, r) {
          let n = e.append("g"),
            i = ri();
          ((i.x = t.x),
            (i.y = t.y),
            (i.fill = t.fill),
            (i.width =
              r.width * t.taskCount + r.diagramMarginX * (t.taskCount - 1)),
            (i.height = r.height),
            (i.class = "journey-section section-type-" + t.num),
            (i.rx = 3),
            (i.ry = 3),
            YN(n, i),
            Yit(r)(
              t.text,
              n,
              i.x,
              i.y,
              i.width,
              i.height,
              { class: "journey-section section-type-" + t.num },
              r,
              t.colour,
            ));
        }, "drawSection")),
        (jit = -1),
        (kNt = a(function (e, t, r) {
          let n = t.x + r.width / 2,
            i = e.append("g");
          jit++;
          let s = 300 + 5 * 30;
          (i
            .append("line")
            .attr("id", "task" + jit)
            .attr("x1", n)
            .attr("y1", t.y)
            .attr("x2", n)
            .attr("y2", s)
            .attr("class", "task-line")
            .attr("stroke-width", "1px")
            .attr("stroke-dasharray", "4 2")
            .attr("stroke", "#666"),
            yNt(i, { cx: n, cy: 300 + (5 - t.score) * 30, score: t.score }));
          let o = ri();
          ((o.x = t.x),
            (o.y = t.y),
            (o.fill = t.fill),
            (o.width = r.width),
            (o.height = r.height),
            (o.class = "task task-type-" + t.num),
            (o.rx = 3),
            (o.ry = 3),
            YN(i, o));
          let l = t.x + 14;
          (t.people.forEach((u) => {
            let h = t.actors[u].color,
              f = {
                cx: l,
                cy: t.y,
                r: 7,
                fill: h,
                stroke: "#000",
                title: u,
                pos: t.actors[u].position,
              };
            (qit(i, f), (l += 10));
          }),
            Yit(r)(
              t.task,
              i,
              o.x,
              o.y,
              o.width,
              o.height,
              { class: "task" },
              r,
              t.colour,
            ));
        }, "drawTask")),
        (TNt = a(function (e, t) {
          U2(e, t);
        }, "drawBackgroundRect")),
        (Yit = (function () {
          function e(i, s, o, l, u, h, f, d) {
            let p = s
              .append("text")
              .attr("x", o + u / 2)
              .attr("y", l + h / 2 + 5)
              .style("font-color", d)
              .style("text-anchor", "middle")
              .text(i);
            n(p, f);
          }
          a(e, "byText");
          function t(i, s, o, l, u, h, f, d, p) {
            let { taskFontSize: m, taskFontFamily: g } = d,
              y = i.split(/<br\s*\/?>/gi);
            for (let b = 0; b < y.length; b++) {
              let k = b * m - (m * (y.length - 1)) / 2,
                T = s
                  .append("text")
                  .attr("x", o + u / 2)
                  .attr("y", l)
                  .attr("fill", p)
                  .style("text-anchor", "middle")
                  .style("font-size", m)
                  .style("font-family", g);
              (T.append("tspan")
                .attr("x", o + u / 2)
                .attr("dy", k)
                .text(y[b]),
                T.attr("y", l + h / 2)
                  .attr("dominant-baseline", "central")
                  .attr("alignment-baseline", "central"),
                n(T, f));
            }
          }
          a(t, "byTspan");
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append("switch"),
              g = p
                .append("foreignObject")
                .attr("x", o)
                .attr("y", l)
                .attr("width", u)
                .attr("height", h)
                .attr("position", "fixed")
                .append("xhtml:div")
                .style("display", "table")
                .style("height", "100%")
                .style("width", "100%");
            (g
              .append("div")
              .attr("class", "label")
              .style("display", "table-cell")
              .style("text-align", "center")
              .style("vertical-align", "middle")
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f));
          }
          a(r, "byFo");
          function n(i, s) {
            for (let o in s) o in s && i.attr(o, s[o]);
          }
          return (
            a(n, "_setTextAttrs"),
            function (i) {
              return i.textPlacement === "fo"
                ? r
                : i.textPlacement === "old"
                  ? e
                  : t;
            }
          );
        })()),
        (SNt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 5)
            .attr("refY", 2)
            .attr("markerWidth", 6)
            .attr("markerHeight", 4)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0,0 V 4 L6,2 Z");
        }, "initGraphics")),
        (Am = {
          drawRect: YN,
          drawCircle: qit,
          drawSection: bNt,
          drawText: Hit,
          drawLabel: xNt,
          drawTask: kNt,
          drawBackgroundRect: TNt,
          initGraphics: SNt,
        }));
    });
  function CNt(e) {
    let t = K().journey,
      r = t.maxLabelWidth;
    J_ = 0;
    let n = 60;
    Object.keys(Vl).forEach((i) => {
      let s = Vl[i].color,
        o = {
          cx: 20,
          cy: n,
          r: 7,
          fill: s,
          stroke: "#000",
          pos: Vl[i].position,
        };
      Am.drawCircle(e, o);
      let l = e.append("text").attr("visibility", "hidden").text(i),
        u = l.node().getBoundingClientRect().width;
      l.remove();
      let h = [];
      if (u <= r) h = [i];
      else {
        let f = i.split(" "),
          d = "";
        ((l = e.append("text").attr("visibility", "hidden")),
          f.forEach((p) => {
            let m = d ? `${d} ${p}` : p;
            if ((l.text(m), l.node().getBoundingClientRect().width > r)) {
              if (
                (d && h.push(d),
                (d = p),
                l.text(p),
                l.node().getBoundingClientRect().width > r)
              ) {
                let y = "";
                for (let b of p)
                  ((y += b),
                    l.text(y + "-"),
                    l.node().getBoundingClientRect().width > r &&
                      (h.push(y.slice(0, -1) + "-"), (y = b)));
                d = y;
              }
            } else d = m;
          }),
          d && h.push(d),
          l.remove());
      }
      (h.forEach((f, d) => {
        let p = {
            x: 40,
            y: n + 7 + d * 20,
            fill: "#666",
            text: f,
            textMargin: t.boxTextMargin ?? 5,
          },
          g = Am.drawText(e, p).node().getBoundingClientRect().width;
        g > J_ && g > t.leftMargin - g && (J_ = g);
      }),
        (n += Math.max(20, h.length * 20)));
    });
  }
  var _Nt,
    Vl,
    J_,
    Qa,
    au,
    wNt,
    ga,
    XN,
    Kit,
    vNt,
    KN,
    Qit = x(() => {
      "use strict";
      Ge();
      Xit();
      pe();
      On();
      ((_Nt = a(function (e) {
        Object.keys(e).forEach(function (r) {
          Qa[r] = e[r];
        });
      }, "setConf")),
        (Vl = {}),
        (J_ = 0));
      a(CNt, "drawActorLegend");
      ((Qa = K().journey),
        (au = 0),
        (wNt = a(function (e, t, r, n) {
          let i = K(),
            s = i.journey.titleColor,
            o = i.journey.titleFontSize,
            l = i.journey.titleFontFamily,
            u = i.securityLevel,
            h;
          u === "sandbox" && (h = xt("#i" + t));
          let f =
            u === "sandbox"
              ? xt(h.nodes()[0].contentDocument.body)
              : xt("body");
          ga.init();
          let d = f.select("#" + t);
          Am.initGraphics(d);
          let p = n.db.getTasks(),
            m = n.db.getDiagramTitle(),
            g = n.db.getActors();
          for (let L in Vl) delete Vl[L];
          let y = 0;
          (g.forEach((L) => {
            ((Vl[L] = {
              color: Qa.actorColours[y % Qa.actorColours.length],
              position: y,
            }),
              y++);
          }),
            CNt(d),
            (au = Qa.leftMargin + J_),
            ga.insert(0, 0, au, Object.keys(Vl).length * 50),
            vNt(d, p, 0));
          let b = ga.getBounds();
          m &&
            d
              .append("text")
              .text(m)
              .attr("x", au)
              .attr("font-size", o)
              .attr("font-weight", "bold")
              .attr("y", 25)
              .attr("fill", s)
              .attr("font-family", l);
          let k = b.stopy - b.starty + 2 * Qa.diagramMarginY,
            T = au + b.stopx + 2 * Qa.diagramMarginX;
          (Ar(d, k, T, Qa.useMaxWidth),
            d
              .append("line")
              .attr("x1", au)
              .attr("y1", Qa.height * 4)
              .attr("x2", T - au - 4)
              .attr("y2", Qa.height * 4)
              .attr("stroke-width", 4)
              .attr("stroke", "black")
              .attr("marker-end", "url(#arrowhead)"));
          let C = m ? 70 : 0;
          (d.attr("viewBox", `${b.startx} -25 ${T} ${k + C}`),
            d.attr("preserveAspectRatio", "xMinYMin meet"),
            d.attr("height", k + C + 25));
        }, "draw")),
        (ga = {
          data: {
            startx: void 0,
            stopx: void 0,
            starty: void 0,
            stopy: void 0,
          },
          verticalPos: 0,
          sequenceItems: [],
          init: a(function () {
            ((this.sequenceItems = []),
              (this.data = {
                startx: void 0,
                stopx: void 0,
                starty: void 0,
                stopy: void 0,
              }),
              (this.verticalPos = 0));
          }, "init"),
          updateVal: a(function (e, t, r, n) {
            e[t] === void 0 ? (e[t] = r) : (e[t] = n(r, e[t]));
          }, "updateVal"),
          updateBounds: a(function (e, t, r, n) {
            let i = K().journey,
              s = this,
              o = 0;
            function l(u) {
              return a(function (f) {
                o++;
                let d = s.sequenceItems.length - o + 1;
                (s.updateVal(f, "starty", t - d * i.boxMargin, Math.min),
                  s.updateVal(f, "stopy", n + d * i.boxMargin, Math.max),
                  s.updateVal(ga.data, "startx", e - d * i.boxMargin, Math.min),
                  s.updateVal(ga.data, "stopx", r + d * i.boxMargin, Math.max),
                  u !== "activation" &&
                    (s.updateVal(f, "startx", e - d * i.boxMargin, Math.min),
                    s.updateVal(f, "stopx", r + d * i.boxMargin, Math.max),
                    s.updateVal(
                      ga.data,
                      "starty",
                      t - d * i.boxMargin,
                      Math.min,
                    ),
                    s.updateVal(
                      ga.data,
                      "stopy",
                      n + d * i.boxMargin,
                      Math.max,
                    )));
              }, "updateItemBounds");
            }
            (a(l, "updateFn"), this.sequenceItems.forEach(l()));
          }, "updateBounds"),
          insert: a(function (e, t, r, n) {
            let i = Math.min(e, r),
              s = Math.max(e, r),
              o = Math.min(t, n),
              l = Math.max(t, n);
            (this.updateVal(ga.data, "startx", i, Math.min),
              this.updateVal(ga.data, "starty", o, Math.min),
              this.updateVal(ga.data, "stopx", s, Math.max),
              this.updateVal(ga.data, "stopy", l, Math.max),
              this.updateBounds(i, o, s, l));
          }, "insert"),
          bumpVerticalPos: a(function (e) {
            ((this.verticalPos = this.verticalPos + e),
              (this.data.stopy = this.verticalPos));
          }, "bumpVerticalPos"),
          getVerticalPos: a(function () {
            return this.verticalPos;
          }, "getVerticalPos"),
          getBounds: a(function () {
            return this.data;
          }, "getBounds"),
        }),
        (XN = Qa.sectionFills),
        (Kit = Qa.sectionColours),
        (vNt = a(function (e, t, r) {
          let n = K().journey,
            i = "",
            s = n.height * 2 + n.diagramMarginY,
            o = r + s,
            l = 0,
            u = "#CCC",
            h = "black",
            f = 0;
          for (let [d, p] of t.entries()) {
            if (i !== p.section) {
              ((u = XN[l % XN.length]),
                (f = l % XN.length),
                (h = Kit[l % Kit.length]));
              let g = 0,
                y = p.section;
              for (let k = d; k < t.length && t[k].section == y; k++) g = g + 1;
              let b = {
                x: d * n.taskMargin + d * n.width + au,
                y: 50,
                text: p.section,
                fill: u,
                num: f,
                colour: h,
                taskCount: g,
              };
              (Am.drawSection(e, b, n), (i = p.section), l++);
            }
            let m = p.people.reduce((g, y) => (Vl[y] && (g[y] = Vl[y]), g), {});
            ((p.x = d * n.taskMargin + d * n.width + au),
              (p.y = o),
              (p.width = n.diagramMarginX),
              (p.height = n.diagramMarginY),
              (p.colour = h),
              (p.fill = u),
              (p.num = f),
              (p.actors = m),
              Am.drawTask(e, p, n),
              ga.insert(p.x, p.y, p.x + p.width + n.taskMargin, 300 + 5 * 30));
          }
        }, "drawTasks")),
        (KN = { setConf: _Nt, draw: wNt }));
    });
  var Zit = {};
  Oe(Zit, { diagram: () => ENt });
  var ENt,
    Jit = x(() => {
      "use strict";
      Git();
      zit();
      Uit();
      Qit();
      ENt = {
        parser: $it,
        db: HN,
        renderer: KN,
        styles: Wit,
        init: a((e) => {
          (KN.setConf(e.journey), HN.clear());
        }, "init"),
      };
    });
  var ZN,
    ist,
    sst = x(() => {
      "use strict";
      ZN = (function () {
        var e = a(function (p, m, g, y) {
            for (g = g || {}, y = p.length; y--; g[p[y]] = m);
            return g;
          }, "o"),
          t = [6, 8, 10, 11, 12, 14, 16, 17, 20, 21],
          r = [1, 9],
          n = [1, 10],
          i = [1, 11],
          s = [1, 12],
          o = [1, 13],
          l = [1, 16],
          u = [1, 17],
          h = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              timeline: 4,
              document: 5,
              EOF: 6,
              line: 7,
              SPACE: 8,
              statement: 9,
              NEWLINE: 10,
              title: 11,
              acc_title: 12,
              acc_title_value: 13,
              acc_descr: 14,
              acc_descr_value: 15,
              acc_descr_multiline_value: 16,
              section: 17,
              period_statement: 18,
              event_statement: 19,
              period: 20,
              event: 21,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "timeline",
              6: "EOF",
              8: "SPACE",
              10: "NEWLINE",
              11: "title",
              12: "acc_title",
              13: "acc_title_value",
              14: "acc_descr",
              15: "acc_descr_value",
              16: "acc_descr_multiline_value",
              17: "section",
              20: "period",
              21: "event",
            },
            productions_: [
              0,
              [3, 3],
              [5, 0],
              [5, 2],
              [7, 2],
              [7, 1],
              [7, 1],
              [7, 1],
              [9, 1],
              [9, 2],
              [9, 2],
              [9, 1],
              [9, 1],
              [9, 1],
              [9, 1],
              [18, 1],
              [19, 1],
            ],
            performAction: a(function (m, g, y, b, k, T, C) {
              var L = T.length - 1;
              switch (k) {
                case 1:
                  return T[L - 1];
                case 2:
                  this.$ = [];
                  break;
                case 3:
                  (T[L - 1].push(T[L]), (this.$ = T[L - 1]));
                  break;
                case 4:
                case 5:
                  this.$ = T[L];
                  break;
                case 6:
                case 7:
                  this.$ = [];
                  break;
                case 8:
                  (b.getCommonDb().setDiagramTitle(T[L].substr(6)),
                    (this.$ = T[L].substr(6)));
                  break;
                case 9:
                  ((this.$ = T[L].trim()), b.getCommonDb().setAccTitle(this.$));
                  break;
                case 10:
                case 11:
                  ((this.$ = T[L].trim()),
                    b.getCommonDb().setAccDescription(this.$));
                  break;
                case 12:
                  (b.addSection(T[L].substr(8)), (this.$ = T[L].substr(8)));
                  break;
                case 15:
                  (b.addTask(T[L], 0, ""), (this.$ = T[L]));
                  break;
                case 16:
                  (b.addEvent(T[L].substr(2)), (this.$ = T[L]));
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              e(t, [2, 2], { 5: 3 }),
              {
                6: [1, 4],
                7: 5,
                8: [1, 6],
                9: 7,
                10: [1, 8],
                11: r,
                12: n,
                14: i,
                16: s,
                17: o,
                18: 14,
                19: 15,
                20: l,
                21: u,
              },
              e(t, [2, 7], { 1: [2, 1] }),
              e(t, [2, 3]),
              {
                9: 18,
                11: r,
                12: n,
                14: i,
                16: s,
                17: o,
                18: 14,
                19: 15,
                20: l,
                21: u,
              },
              e(t, [2, 5]),
              e(t, [2, 6]),
              e(t, [2, 8]),
              { 13: [1, 19] },
              { 15: [1, 20] },
              e(t, [2, 11]),
              e(t, [2, 12]),
              e(t, [2, 13]),
              e(t, [2, 14]),
              e(t, [2, 15]),
              e(t, [2, 16]),
              e(t, [2, 4]),
              e(t, [2, 9]),
              e(t, [2, 10]),
            ],
            defaultActions: {},
            parseError: a(function (m, g) {
              if (g.recoverable) this.trace(m);
              else {
                var y = new Error(m);
                throw ((y.hash = g), y);
              }
            }, "parseError"),
            parse: a(function (m) {
              var g = this,
                y = [0],
                b = [],
                k = [null],
                T = [],
                C = this.table,
                L = "",
                w = 0,
                D = 0,
                G = 0,
                E = 2,
                R = 1,
                F = T.slice.call(arguments, 1),
                S = Object.create(this.lexer),
                O = { yy: {} };
              for (var v in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, v) &&
                  (O.yy[v] = this.yy[v]);
              (S.setInput(m, O.yy),
                (O.yy.lexer = S),
                (O.yy.parser = this),
                typeof S.yylloc > "u" && (S.yylloc = {}));
              var _ = S.yylloc;
              T.push(_);
              var A = S.options && S.options.ranges;
              typeof O.yy.parseError == "function"
                ? (this.parseError = O.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function N(dt) {
                ((y.length = y.length - 2 * dt),
                  (k.length = k.length - dt),
                  (T.length = T.length - dt));
              }
              a(N, "popStack");
              function B() {
                var dt;
                return (
                  (dt = b.pop() || S.lex() || R),
                  typeof dt != "number" &&
                    (dt instanceof Array && ((b = dt), (dt = b.pop())),
                    (dt = g.symbols_[dt] || dt)),
                  dt
                );
              }
              a(B, "lex");
              for (var M, I, V, $, q, tt, ht = {}, H, kt, ft, yt; ; ) {
                if (
                  ((V = y[y.length - 1]),
                  this.defaultActions[V]
                    ? ($ = this.defaultActions[V])
                    : ((M === null || typeof M > "u") && (M = B()),
                      ($ = C[V] && C[V][M])),
                  typeof $ > "u" || !$.length || !$[0])
                ) {
                  var ot = "";
                  yt = [];
                  for (H in C[V])
                    this.terminals_[H] &&
                      H > E &&
                      yt.push("'" + this.terminals_[H] + "'");
                  (S.showPosition
                    ? (ot =
                        "Parse error on line " +
                        (w + 1) +
                        `:
` +
                        S.showPosition() +
                        `
Expecting ` +
                        yt.join(", ") +
                        ", got '" +
                        (this.terminals_[M] || M) +
                        "'")
                    : (ot =
                        "Parse error on line " +
                        (w + 1) +
                        ": Unexpected " +
                        (M == R
                          ? "end of input"
                          : "'" + (this.terminals_[M] || M) + "'")),
                    this.parseError(ot, {
                      text: S.match,
                      token: this.terminals_[M] || M,
                      line: S.yylineno,
                      loc: _,
                      expected: yt,
                    }));
                }
                if ($[0] instanceof Array && $.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      V +
                      ", token: " +
                      M,
                  );
                switch ($[0]) {
                  case 1:
                    (y.push(M),
                      k.push(S.yytext),
                      T.push(S.yylloc),
                      y.push($[1]),
                      (M = null),
                      I
                        ? ((M = I), (I = null))
                        : ((D = S.yyleng),
                          (L = S.yytext),
                          (w = S.yylineno),
                          (_ = S.yylloc),
                          G > 0 && G--));
                    break;
                  case 2:
                    if (
                      ((kt = this.productions_[$[1]][1]),
                      (ht.$ = k[k.length - kt]),
                      (ht._$ = {
                        first_line: T[T.length - (kt || 1)].first_line,
                        last_line: T[T.length - 1].last_line,
                        first_column: T[T.length - (kt || 1)].first_column,
                        last_column: T[T.length - 1].last_column,
                      }),
                      A &&
                        (ht._$.range = [
                          T[T.length - (kt || 1)].range[0],
                          T[T.length - 1].range[1],
                        ]),
                      (tt = this.performAction.apply(
                        ht,
                        [L, D, w, O.yy, $[1], k, T].concat(F),
                      )),
                      typeof tt < "u")
                    )
                      return tt;
                    (kt &&
                      ((y = y.slice(0, -1 * kt * 2)),
                      (k = k.slice(0, -1 * kt)),
                      (T = T.slice(0, -1 * kt))),
                      y.push(this.productions_[$[1]][0]),
                      k.push(ht.$),
                      T.push(ht._$),
                      (ft = C[y[y.length - 2]][y[y.length - 1]]),
                      y.push(ft));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          f = (function () {
            var p = {
              EOF: 1,
              parseError: a(function (g, y) {
                if (this.yy.parser) this.yy.parser.parseError(g, y);
                else throw new Error(g);
              }, "parseError"),
              setInput: a(function (m, g) {
                return (
                  (this.yy = g || this.yy || {}),
                  (this._input = m),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var m = this._input[0];
                ((this.yytext += m),
                  this.yyleng++,
                  this.offset++,
                  (this.match += m),
                  (this.matched += m));
                var g = m.match(/(?:\r\n?|\n).*/g);
                return (
                  g
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  m
                );
              }, "input"),
              unput: a(function (m) {
                var g = m.length,
                  y = m.split(/(?:\r\n?|\n)/g);
                ((this._input = m + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - g)),
                  (this.offset -= g));
                var b = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  y.length - 1 && (this.yylineno -= y.length - 1));
                var k = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: y
                      ? (y.length === b.length ? this.yylloc.first_column : 0) +
                        b[b.length - y.length].length -
                        y[0].length
                      : this.yylloc.first_column - g,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [k[0], k[0] + this.yyleng - g]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (m) {
                this.unput(this.match.slice(m));
              }, "less"),
              pastInput: a(function () {
                var m = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (m.length > 20 ? "..." : "") +
                  m.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var m = this.match;
                return (
                  m.length < 20 && (m += this._input.substr(0, 20 - m.length)),
                  (m.substr(0, 20) + (m.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var m = this.pastInput(),
                  g = new Array(m.length + 1).join("-");
                return (
                  m +
                  this.upcomingInput() +
                  `
` +
                  g +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (m, g) {
                var y, b, k;
                if (
                  (this.options.backtrack_lexer &&
                    ((k = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (k.yylloc.range = this.yylloc.range.slice(0))),
                  (b = m[0].match(/(?:\r\n?|\n).*/g)),
                  b && (this.yylineno += b.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: b
                      ? b[b.length - 1].length -
                        b[b.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + m[0].length,
                  }),
                  (this.yytext += m[0]),
                  (this.match += m[0]),
                  (this.matches = m),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(m[0].length)),
                  (this.matched += m[0]),
                  (y = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    g,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  y)
                )
                  return y;
                if (this._backtrack) {
                  for (var T in k) this[T] = k[T];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var m, g, y, b;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var k = this._currentRules(), T = 0; T < k.length; T++)
                  if (
                    ((y = this._input.match(this.rules[k[T]])),
                    y && (!g || y[0].length > g[0].length))
                  ) {
                    if (((g = y), (b = T), this.options.backtrack_lexer)) {
                      if (((m = this.test_match(y, k[T])), m !== !1)) return m;
                      if (this._backtrack) {
                        g = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return g
                  ? ((m = this.test_match(g, k[b])), m !== !1 ? m : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var g = this.next();
                return g || this.lex();
              }, "lex"),
              begin: a(function (g) {
                this.conditionStack.push(g);
              }, "begin"),
              popState: a(function () {
                var g = this.conditionStack.length - 1;
                return g > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (g) {
                return (
                  (g = this.conditionStack.length - 1 - Math.abs(g || 0)),
                  g >= 0 ? this.conditionStack[g] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (g) {
                this.begin(g);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (g, y, b, k) {
                var T = k;
                switch (b) {
                  case 0:
                    break;
                  case 1:
                    break;
                  case 2:
                    return 10;
                  case 3:
                    break;
                  case 4:
                    break;
                  case 5:
                    return 4;
                  case 6:
                    return 11;
                  case 7:
                    return (this.begin("acc_title"), 12);
                    break;
                  case 8:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 9:
                    return (this.begin("acc_descr"), 14);
                    break;
                  case 10:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 11:
                    this.begin("acc_descr_multiline");
                    break;
                  case 12:
                    this.popState();
                    break;
                  case 13:
                    return "acc_descr_multiline_value";
                  case 14:
                    return 17;
                  case 15:
                    return 21;
                  case 16:
                    return 20;
                  case 17:
                    return 6;
                  case 18:
                    return "INVALID";
                }
              }, "anonymous"),
              rules: [
                /^(?:%(?!\{)[^\n]*)/i,
                /^(?:[^\}]%%[^\n]*)/i,
                /^(?:[\n]+)/i,
                /^(?:\s+)/i,
                /^(?:#[^\n]*)/i,
                /^(?:timeline\b)/i,
                /^(?:title\s[^\n]+)/i,
                /^(?:accTitle\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*:\s*)/i,
                /^(?:(?!\n||)*[^\n]*)/i,
                /^(?:accDescr\s*\{\s*)/i,
                /^(?:[\}])/i,
                /^(?:[^\}]*)/i,
                /^(?:section\s[^:\n]+)/i,
                /^(?::\s(?:[^:\n]|:(?!\s))+)/i,
                /^(?:[^#:\n]+)/i,
                /^(?:$)/i,
                /^(?:.)/i,
              ],
              conditions: {
                acc_descr_multiline: { rules: [12, 13], inclusive: !1 },
                acc_descr: { rules: [10], inclusive: !1 },
                acc_title: { rules: [8], inclusive: !1 },
                INITIAL: {
                  rules: [0, 1, 2, 3, 4, 5, 6, 7, 9, 11, 14, 15, 16, 17, 18],
                  inclusive: !0,
                },
              },
            };
            return p;
          })();
        h.lexer = f;
        function d() {
          this.yy = {};
        }
        return (a(d, "Parser"), (d.prototype = h), (h.Parser = d), new d());
      })();
      ZN.parser = ZN;
      ist = ZN;
    });
  var t8 = {};
  Oe(t8, {
    addEvent: () => pst,
    addSection: () => ust,
    addTask: () => dst,
    addTaskOrg: () => mst,
    clear: () => cst,
    default: () => INt,
    getCommonDb: () => lst,
    getSections: () => hst,
    getTasks: () => fst,
  });
  var Lm,
    ost,
    JN,
    tC,
    Rm,
    lst,
    cst,
    ust,
    hst,
    fst,
    dst,
    pst,
    mst,
    ast,
    INt,
    gst = x(() => {
      "use strict";
      yn();
      ((Lm = ""),
        (ost = 0),
        (JN = []),
        (tC = []),
        (Rm = []),
        (lst = a(() => ag, "getCommonDb")),
        (cst = a(function () {
          ((JN.length = 0), (tC.length = 0), (Lm = ""), (Rm.length = 0), Ye());
        }, "clear")),
        (ust = a(function (e) {
          ((Lm = e), JN.push(e));
        }, "addSection")),
        (hst = a(function () {
          return JN;
        }, "getSections")),
        (fst = a(function () {
          let e = ast(),
            t = 100,
            r = 0;
          for (; !e && r < t; ) ((e = ast()), r++);
          return (tC.push(...Rm), tC);
        }, "getTasks")),
        (dst = a(function (e, t, r) {
          let n = {
            id: ost++,
            section: Lm,
            type: Lm,
            task: e,
            score: t || 0,
            events: r ? [r] : [],
          };
          Rm.push(n);
        }, "addTask")),
        (pst = a(function (e) {
          Rm.find((r) => r.id === ost - 1).events.push(e);
        }, "addEvent")),
        (mst = a(function (e) {
          let t = {
            section: Lm,
            type: Lm,
            description: e,
            task: e,
            classes: [],
          };
          tC.push(t);
        }, "addTaskOrg")),
        (ast = a(function () {
          let e = a(function (r) {
              return Rm[r].processed;
            }, "compileTask"),
            t = !0;
          for (let [r, n] of Rm.entries()) (e(r), (t = t && n.processed));
          return t;
        }, "compileTasks")),
        (INt = {
          clear: cst,
          getCommonDb: lst,
          addSection: ust,
          getSections: hst,
          getTasks: fst,
          addTask: dst,
          addTaskOrg: mst,
          addEvent: pst,
        }));
    });
  function kst(e, t) {
    e.each(function () {
      var r = xt(this),
        n = r
          .text()
          .split(/(\s+|<br>)/)
          .reverse(),
        i,
        s = [],
        o = 1.1,
        l = r.attr("y"),
        u = parseFloat(r.attr("dy")),
        h = r
          .text(null)
          .append("tspan")
          .attr("x", 0)
          .attr("y", l)
          .attr("dy", u + "em");
      for (let f = 0; f < n.length; f++)
        ((i = n[n.length - 1 - f]),
          s.push(i),
          h.text(s.join(" ").trim()),
          (h.node().getComputedTextLength() > t || i === "<br>") &&
            (s.pop(),
            h.text(s.join(" ").trim()),
            i === "<br>" ? (s = [""]) : (s = [i]),
            (h = r
              .append("tspan")
              .attr("x", 0)
              .attr("y", l)
              .attr("dy", o + "em")
              .text(i))));
    });
  }
  var MNt,
    eC,
    ONt,
    PNt,
    xst,
    BNt,
    FNt,
    yst,
    $Nt,
    GNt,
    VNt,
    e8,
    bst,
    zNt,
    WNt,
    UNt,
    jNt,
    ou,
    Tst = x(() => {
      "use strict";
      Ge();
      ((MNt = 12),
        (eC = a(function (e, t) {
          let r = e.append("rect");
          return (
            r.attr("x", t.x),
            r.attr("y", t.y),
            r.attr("fill", t.fill),
            r.attr("stroke", t.stroke),
            r.attr("width", t.width),
            r.attr("height", t.height),
            r.attr("rx", t.rx),
            r.attr("ry", t.ry),
            t.class !== void 0 && r.attr("class", t.class),
            r
          );
        }, "drawRect")),
        (ONt = a(function (e, t) {
          let n = e
              .append("circle")
              .attr("cx", t.cx)
              .attr("cy", t.cy)
              .attr("class", "face")
              .attr("r", 15)
              .attr("stroke-width", 2)
              .attr("overflow", "visible"),
            i = e.append("g");
          (i
            .append("circle")
            .attr("cx", t.cx - 15 / 3)
            .attr("cy", t.cy - 15 / 3)
            .attr("r", 1.5)
            .attr("stroke-width", 2)
            .attr("fill", "#666")
            .attr("stroke", "#666"),
            i
              .append("circle")
              .attr("cx", t.cx + 15 / 3)
              .attr("cy", t.cy - 15 / 3)
              .attr("r", 1.5)
              .attr("stroke-width", 2)
              .attr("fill", "#666")
              .attr("stroke", "#666"));
          function s(u) {
            let h = Ma()
              .startAngle(Math.PI / 2)
              .endAngle(3 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175);
            u.append("path")
              .attr("class", "mouth")
              .attr("d", h)
              .attr("transform", "translate(" + t.cx + "," + (t.cy + 2) + ")");
          }
          a(s, "smile");
          function o(u) {
            let h = Ma()
              .startAngle((3 * Math.PI) / 2)
              .endAngle(5 * (Math.PI / 2))
              .innerRadius(7.5)
              .outerRadius(6.8181818181818175);
            u.append("path")
              .attr("class", "mouth")
              .attr("d", h)
              .attr("transform", "translate(" + t.cx + "," + (t.cy + 7) + ")");
          }
          a(o, "sad");
          function l(u) {
            u.append("line")
              .attr("class", "mouth")
              .attr("stroke", 2)
              .attr("x1", t.cx - 5)
              .attr("y1", t.cy + 7)
              .attr("x2", t.cx + 5)
              .attr("y2", t.cy + 7)
              .attr("class", "mouth")
              .attr("stroke-width", "1px")
              .attr("stroke", "#666");
          }
          return (
            a(l, "ambivalent"),
            t.score > 3 ? s(i) : t.score < 3 ? o(i) : l(i),
            n
          );
        }, "drawFace")),
        (PNt = a(function (e, t) {
          let r = e.append("circle");
          return (
            r.attr("cx", t.cx),
            r.attr("cy", t.cy),
            r.attr("class", "actor-" + t.pos),
            r.attr("fill", t.fill),
            r.attr("stroke", t.stroke),
            r.attr("r", t.r),
            r.class !== void 0 && r.attr("class", r.class),
            t.title !== void 0 && r.append("title").text(t.title),
            r
          );
        }, "drawCircle")),
        (xst = a(function (e, t) {
          let r = t.text.replace(/<br\s*\/?>/gi, " "),
            n = e.append("text");
          (n.attr("x", t.x),
            n.attr("y", t.y),
            n.attr("class", "legend"),
            n.style("text-anchor", t.anchor),
            t.class !== void 0 && n.attr("class", t.class));
          let i = n.append("tspan");
          return (i.attr("x", t.x + t.textMargin * 2), i.text(r), n);
        }, "drawText")),
        (BNt = a(function (e, t) {
          function r(i, s, o, l, u) {
            return (
              i +
              "," +
              s +
              " " +
              (i + o) +
              "," +
              s +
              " " +
              (i + o) +
              "," +
              (s + l - u) +
              " " +
              (i + o - u * 1.2) +
              "," +
              (s + l) +
              " " +
              i +
              "," +
              (s + l)
            );
          }
          a(r, "genPoints");
          let n = e.append("polygon");
          (n.attr("points", r(t.x, t.y, 50, 20, 7)),
            n.attr("class", "labelBox"),
            (t.y = t.y + t.labelMargin),
            (t.x = t.x + 0.5 * t.labelMargin),
            xst(e, t));
        }, "drawLabel")),
        (FNt = a(function (e, t, r) {
          let n = e.append("g"),
            i = e8();
          ((i.x = t.x),
            (i.y = t.y),
            (i.fill = t.fill),
            (i.width = r.width),
            (i.height = r.height),
            (i.class = "journey-section section-type-" + t.num),
            (i.rx = 3),
            (i.ry = 3),
            eC(n, i),
            bst(r)(
              t.text,
              n,
              i.x,
              i.y,
              i.width,
              i.height,
              { class: "journey-section section-type-" + t.num },
              r,
              t.colour,
            ));
        }, "drawSection")),
        (yst = -1),
        ($Nt = a(function (e, t, r) {
          let n = t.x + r.width / 2,
            i = e.append("g");
          yst++;
          let s = 300 + 5 * 30;
          (i
            .append("line")
            .attr("id", "task" + yst)
            .attr("x1", n)
            .attr("y1", t.y)
            .attr("x2", n)
            .attr("y2", s)
            .attr("class", "task-line")
            .attr("stroke-width", "1px")
            .attr("stroke-dasharray", "4 2")
            .attr("stroke", "#666"),
            ONt(i, { cx: n, cy: 300 + (5 - t.score) * 30, score: t.score }));
          let o = e8();
          ((o.x = t.x),
            (o.y = t.y),
            (o.fill = t.fill),
            (o.width = r.width),
            (o.height = r.height),
            (o.class = "task task-type-" + t.num),
            (o.rx = 3),
            (o.ry = 3),
            eC(i, o),
            bst(r)(
              t.task,
              i,
              o.x,
              o.y,
              o.width,
              o.height,
              { class: "task" },
              r,
              t.colour,
            ));
        }, "drawTask")),
        (GNt = a(function (e, t) {
          eC(e, {
            x: t.startx,
            y: t.starty,
            width: t.stopx - t.startx,
            height: t.stopy - t.starty,
            fill: t.fill,
            class: "rect",
          }).lower();
        }, "drawBackgroundRect")),
        (VNt = a(function () {
          return {
            x: 0,
            y: 0,
            fill: void 0,
            "text-anchor": "start",
            width: 100,
            height: 100,
            textMargin: 0,
            rx: 0,
            ry: 0,
          };
        }, "getTextObj")),
        (e8 = a(function () {
          return {
            x: 0,
            y: 0,
            width: 100,
            anchor: "start",
            height: 100,
            rx: 0,
            ry: 0,
          };
        }, "getNoteRect")),
        (bst = (function () {
          function e(i, s, o, l, u, h, f, d) {
            let p = s
              .append("text")
              .attr("x", o + u / 2)
              .attr("y", l + h / 2 + 5)
              .style("font-color", d)
              .style("text-anchor", "middle")
              .text(i);
            n(p, f);
          }
          a(e, "byText");
          function t(i, s, o, l, u, h, f, d, p) {
            let { taskFontSize: m, taskFontFamily: g } = d,
              y = i.split(/<br\s*\/?>/gi);
            for (let b = 0; b < y.length; b++) {
              let k = b * m - (m * (y.length - 1)) / 2,
                T = s
                  .append("text")
                  .attr("x", o + u / 2)
                  .attr("y", l)
                  .attr("fill", p)
                  .style("text-anchor", "middle")
                  .style("font-size", m)
                  .style("font-family", g);
              (T.append("tspan")
                .attr("x", o + u / 2)
                .attr("dy", k)
                .text(y[b]),
                T.attr("y", l + h / 2)
                  .attr("dominant-baseline", "central")
                  .attr("alignment-baseline", "central"),
                n(T, f));
            }
          }
          a(t, "byTspan");
          function r(i, s, o, l, u, h, f, d) {
            let p = s.append("switch"),
              g = p
                .append("foreignObject")
                .attr("x", o)
                .attr("y", l)
                .attr("width", u)
                .attr("height", h)
                .attr("position", "fixed")
                .append("xhtml:div")
                .style("display", "table")
                .style("height", "100%")
                .style("width", "100%");
            (g
              .append("div")
              .attr("class", "label")
              .style("display", "table-cell")
              .style("text-align", "center")
              .style("vertical-align", "middle")
              .text(i),
              t(i, p, o, l, u, h, f, d),
              n(g, f));
          }
          a(r, "byFo");
          function n(i, s) {
            for (let o in s) o in s && i.attr(o, s[o]);
          }
          return (
            a(n, "_setTextAttrs"),
            function (i) {
              return i.textPlacement === "fo"
                ? r
                : i.textPlacement === "old"
                  ? e
                  : t;
            }
          );
        })()),
        (zNt = a(function (e) {
          e.append("defs")
            .append("marker")
            .attr("id", "arrowhead")
            .attr("refX", 5)
            .attr("refY", 2)
            .attr("markerWidth", 6)
            .attr("markerHeight", 4)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0,0 V 4 L6,2 Z");
        }, "initGraphics")));
      a(kst, "wrap");
      ((WNt = a(function (e, t, r, n) {
        let i = (r % MNt) - 1,
          s = e.append("g");
        ((t.section = i),
          s.attr(
            "class",
            (t.class ? t.class + " " : "") +
              "timeline-node " +
              ("section-" + i),
          ));
        let o = s.append("g"),
          l = s.append("g"),
          h = l
            .append("text")
            .text(t.descr)
            .attr("dy", "1em")
            .attr("alignment-baseline", "middle")
            .attr("dominant-baseline", "middle")
            .attr("text-anchor", "middle")
            .call(kst, t.width)
            .node()
            .getBBox(),
          f = n.fontSize?.replace ? n.fontSize.replace("px", "") : n.fontSize;
        return (
          (t.height = h.height + f * 1.1 * 0.5 + t.padding),
          (t.height = Math.max(t.height, t.maxHeight)),
          (t.width = t.width + 2 * t.padding),
          l.attr(
            "transform",
            "translate(" + t.width / 2 + ", " + t.padding / 2 + ")",
          ),
          jNt(o, t, i, n),
          t
        );
      }, "drawNode")),
        (UNt = a(function (e, t, r) {
          let n = e.append("g"),
            s = n
              .append("text")
              .text(t.descr)
              .attr("dy", "1em")
              .attr("alignment-baseline", "middle")
              .attr("dominant-baseline", "middle")
              .attr("text-anchor", "middle")
              .call(kst, t.width)
              .node()
              .getBBox(),
            o = r.fontSize?.replace ? r.fontSize.replace("px", "") : r.fontSize;
          return (n.remove(), s.height + o * 1.1 * 0.5 + t.padding);
        }, "getVirtualNodeHeight")),
        (jNt = a(function (e, t, r) {
          (e
            .append("path")
            .attr("id", "node-" + t.id)
            .attr("class", "node-bkg node-" + t.type)
            .attr(
              "d",
              `M0 ${t.height - 5} v${-t.height + 2 * 5} q0,-5 5,-5 h${t.width - 2 * 5} q5,0 5,5 v${t.height - 5} H0 Z`,
            ),
            e
              .append("line")
              .attr("class", "node-line-" + r)
              .attr("x1", 0)
              .attr("y1", t.height)
              .attr("x2", t.width)
              .attr("y2", t.height));
        }, "defaultBkg")),
        (ou = {
          drawRect: eC,
          drawCircle: PNt,
          drawSection: FNt,
          drawText: xst,
          drawLabel: BNt,
          drawTask: $Nt,
          drawBackgroundRect: GNt,
          getTextObj: VNt,
          getNoteRect: e8,
          initGraphics: zNt,
          drawNode: WNt,
          getVirtualNodeHeight: UNt,
        }));
    });
  var qNt,
    Sst,
    HNt,
    _st,
    Cst = x(() => {
      "use strict";
      Ge();
      Tst();
      Vt();
      pe();
      On();
      ((qNt = a(function (e, t, r, n) {
        let i = K(),
          s = i.timeline?.leftMargin ?? 50;
        P.debug("timeline", n.db);
        let o = i.securityLevel,
          l;
        o === "sandbox" && (l = xt("#i" + t));
        let h = (
          o === "sandbox" ? xt(l.nodes()[0].contentDocument.body) : xt("body")
        ).select("#" + t);
        h.append("g");
        let f = n.db.getTasks(),
          d = n.db.getCommonDb().getDiagramTitle();
        (P.debug("task", f), ou.initGraphics(h));
        let p = n.db.getSections();
        P.debug("sections", p);
        let m = 0,
          g = 0,
          y = 0,
          b = 0,
          k = 50 + s,
          T = 50;
        b = 50;
        let C = 0,
          L = !0;
        p.forEach(function (R) {
          let F = {
              number: C,
              descr: R,
              section: C,
              width: 150,
              padding: 20,
              maxHeight: m,
            },
            S = ou.getVirtualNodeHeight(h, F, i);
          (P.debug("sectionHeight before draw", S), (m = Math.max(m, S + 20)));
        });
        let w = 0,
          D = 0;
        P.debug("tasks.length", f.length);
        for (let [R, F] of f.entries()) {
          let S = {
              number: R,
              descr: F,
              section: F.section,
              width: 150,
              padding: 20,
              maxHeight: g,
            },
            O = ou.getVirtualNodeHeight(h, S, i);
          (P.debug("taskHeight before draw", O),
            (g = Math.max(g, O + 20)),
            (w = Math.max(w, F.events.length)));
          let v = 0;
          for (let _ of F.events) {
            let A = {
              descr: _,
              section: F.section,
              number: F.section,
              width: 150,
              padding: 20,
              maxHeight: 50,
            };
            v += ou.getVirtualNodeHeight(h, A, i);
          }
          (F.events.length > 0 && (v += (F.events.length - 1) * 10),
            (D = Math.max(D, v)));
        }
        (P.debug("maxSectionHeight before draw", m),
          P.debug("maxTaskHeight before draw", g),
          p && p.length > 0
            ? p.forEach((R) => {
                let F = f.filter((_) => _.section === R),
                  S = {
                    number: C,
                    descr: R,
                    section: C,
                    width: 200 * Math.max(F.length, 1) - 50,
                    padding: 20,
                    maxHeight: m,
                  };
                P.debug("sectionNode", S);
                let O = h.append("g"),
                  v = ou.drawNode(O, S, C, i);
                (P.debug("sectionNode output", v),
                  O.attr("transform", `translate(${k}, ${b})`),
                  (T += m + 50),
                  F.length > 0 && Sst(h, F, C, k, T, g, i, w, D, m, !1),
                  (k += 200 * Math.max(F.length, 1)),
                  (T = b),
                  C++);
              })
            : ((L = !1), Sst(h, f, C, k, T, g, i, w, D, m, !0)));
        let G = h.node().getBBox();
        (P.debug("bounds", G),
          d &&
            h
              .append("text")
              .text(d)
              .attr("x", G.width / 2 - s)
              .attr("font-size", "4ex")
              .attr("font-weight", "bold")
              .attr("y", 20),
          (y = L ? m + g + 150 : g + 100),
          h
            .append("g")
            .attr("class", "lineWrapper")
            .append("line")
            .attr("x1", s)
            .attr("y1", y)
            .attr("x2", G.width + 3 * s)
            .attr("y2", y)
            .attr("stroke-width", 4)
            .attr("stroke", "black")
            .attr("marker-end", "url(#arrowhead)"),
          Ql(
            void 0,
            h,
            i.timeline?.padding ?? 50,
            i.timeline?.useMaxWidth ?? !1,
          ));
      }, "draw")),
        (Sst = a(function (e, t, r, n, i, s, o, l, u, h, f) {
          for (let d of t) {
            let p = {
              descr: d.task,
              section: r,
              number: r,
              width: 150,
              padding: 20,
              maxHeight: s,
            };
            P.debug("taskNode", p);
            let m = e.append("g").attr("class", "taskWrapper"),
              y = ou.drawNode(m, p, r, o).height;
            if (
              (P.debug("taskHeight after draw", y),
              m.attr("transform", `translate(${n}, ${i})`),
              (s = Math.max(s, y)),
              d.events)
            ) {
              let b = e.append("g").attr("class", "lineWrapper"),
                k = s;
              ((i += 100),
                (k = k + HNt(e, d.events, r, n, i, o)),
                (i -= 100),
                b
                  .append("line")
                  .attr("x1", n + 190 / 2)
                  .attr("y1", i + s)
                  .attr("x2", n + 190 / 2)
                  .attr("y2", i + s + 100 + u + 100)
                  .attr("stroke-width", 2)
                  .attr("stroke", "black")
                  .attr("marker-end", "url(#arrowhead)")
                  .attr("stroke-dasharray", "5,5"));
            }
            ((n = n + 200), f && !o.timeline?.disableMulticolor && r++);
          }
          i = i - 10;
        }, "drawTasks")),
        (HNt = a(function (e, t, r, n, i, s) {
          let o = 0,
            l = i;
          i = i + 100;
          for (let u of t) {
            let h = {
              descr: u,
              section: r,
              number: r,
              width: 150,
              padding: 20,
              maxHeight: 50,
            };
            P.debug("eventNode", h);
            let f = e.append("g").attr("class", "eventWrapper"),
              p = ou.drawNode(f, h, r, s).height;
            ((o = o + p),
              f.attr("transform", `translate(${n}, ${i})`),
              (i = i + 10 + p));
          }
          return ((i = l), o);
        }, "drawEvents")),
        (_st = { setConf: a(() => {}, "setConf"), draw: qNt }));
    });
  var YNt,
    XNt,
    wst,
    vst = x(() => {
      "use strict";
      Us();
      ((YNt = a((e) => {
        let t = "";
        for (let r = 0; r < e.THEME_COLOR_LIMIT; r++)
          ((e["lineColor" + r] = e["lineColor" + r] || e["cScaleInv" + r]),
            Ni(e["lineColor" + r])
              ? (e["lineColor" + r] = Yt(e["lineColor" + r], 20))
              : (e["lineColor" + r] = ee(e["lineColor" + r], 20)));
        for (let r = 0; r < e.THEME_COLOR_LIMIT; r++) {
          let n = "" + (17 - 3 * r);
          t += `
    .section-${r - 1} rect, .section-${r - 1} path, .section-${r - 1} circle, .section-${r - 1} path  {
      fill: ${e["cScale" + r]};
    }
    .section-${r - 1} text {
     fill: ${e["cScaleLabel" + r]};
    }
    .node-icon-${r - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + r]};
    }
    .section-edge-${r - 1}{
      stroke: ${e["cScale" + r]};
    }
    .edge-depth-${r - 1}{
      stroke-width: ${n};
    }
    .section-${r - 1} line {
      stroke: ${e["cScaleInv" + r]} ;
      stroke-width: 3;
    }

    .lineWrapper line{
      stroke: ${e["cScaleLabel" + r]} ;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }
    `;
        }
        return t;
      }, "genSections")),
        (XNt = a(
          (e) => `
  .edge {
    stroke-width: 3;
  }
  ${YNt(e)}
  .section-root rect, .section-root path, .section-root circle  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .eventWrapper  {
   filter: brightness(120%);
  }
`,
          "getStyles",
        )),
        (wst = XNt));
    });
  var Est = {};
  Oe(Est, { diagram: () => KNt });
  var KNt,
    Ast = x(() => {
      "use strict";
      sst();
      gst();
      Cst();
      vst();
      KNt = { db: t8, renderer: _st, parser: ist, styles: wst };
    });
  var r8,
    Dst,
    Nst = x(() => {
      "use strict";
      r8 = (function () {
        var e = a(function (G, E, R, F) {
            for (R = R || {}, F = G.length; F--; R[G[F]] = E);
            return R;
          }, "o"),
          t = [1, 4],
          r = [1, 13],
          n = [1, 12],
          i = [1, 15],
          s = [1, 16],
          o = [1, 20],
          l = [1, 19],
          u = [6, 7, 8],
          h = [1, 26],
          f = [1, 24],
          d = [1, 25],
          p = [6, 7, 11],
          m = [1, 31],
          g = [6, 7, 11, 24],
          y = [1, 6, 13, 16, 17, 20, 23],
          b = [1, 35],
          k = [1, 36],
          T = [1, 6, 7, 11, 13, 16, 17, 20, 23],
          C = [1, 38],
          L = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              mindMap: 4,
              spaceLines: 5,
              SPACELINE: 6,
              NL: 7,
              KANBAN: 8,
              document: 9,
              stop: 10,
              EOF: 11,
              statement: 12,
              SPACELIST: 13,
              node: 14,
              shapeData: 15,
              ICON: 16,
              CLASS: 17,
              nodeWithId: 18,
              nodeWithoutId: 19,
              NODE_DSTART: 20,
              NODE_DESCR: 21,
              NODE_DEND: 22,
              NODE_ID: 23,
              SHAPE_DATA: 24,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              6: "SPACELINE",
              7: "NL",
              8: "KANBAN",
              11: "EOF",
              13: "SPACELIST",
              16: "ICON",
              17: "CLASS",
              20: "NODE_DSTART",
              21: "NODE_DESCR",
              22: "NODE_DEND",
              23: "NODE_ID",
              24: "SHAPE_DATA",
            },
            productions_: [
              0,
              [3, 1],
              [3, 2],
              [5, 1],
              [5, 2],
              [5, 2],
              [4, 2],
              [4, 3],
              [10, 1],
              [10, 1],
              [10, 1],
              [10, 2],
              [10, 2],
              [9, 3],
              [9, 2],
              [12, 3],
              [12, 2],
              [12, 2],
              [12, 2],
              [12, 1],
              [12, 2],
              [12, 1],
              [12, 1],
              [12, 1],
              [12, 1],
              [14, 1],
              [14, 1],
              [19, 3],
              [18, 1],
              [18, 4],
              [15, 2],
              [15, 1],
            ],
            performAction: a(function (E, R, F, S, O, v, _) {
              var A = v.length - 1;
              switch (O) {
                case 6:
                case 7:
                  return S;
                case 8:
                  S.getLogger().trace("Stop NL ");
                  break;
                case 9:
                  S.getLogger().trace("Stop EOF ");
                  break;
                case 11:
                  S.getLogger().trace("Stop NL2 ");
                  break;
                case 12:
                  S.getLogger().trace("Stop EOF2 ");
                  break;
                case 15:
                  (S.getLogger().info("Node: ", v[A - 1].id),
                    S.addNode(
                      v[A - 2].length,
                      v[A - 1].id,
                      v[A - 1].descr,
                      v[A - 1].type,
                      v[A],
                    ));
                  break;
                case 16:
                  (S.getLogger().info("Node: ", v[A].id),
                    S.addNode(v[A - 1].length, v[A].id, v[A].descr, v[A].type));
                  break;
                case 17:
                  (S.getLogger().trace("Icon: ", v[A]),
                    S.decorateNode({ icon: v[A] }));
                  break;
                case 18:
                case 23:
                  S.decorateNode({ class: v[A] });
                  break;
                case 19:
                  S.getLogger().trace("SPACELIST");
                  break;
                case 20:
                  (S.getLogger().trace("Node: ", v[A - 1].id),
                    S.addNode(
                      0,
                      v[A - 1].id,
                      v[A - 1].descr,
                      v[A - 1].type,
                      v[A],
                    ));
                  break;
                case 21:
                  (S.getLogger().trace("Node: ", v[A].id),
                    S.addNode(0, v[A].id, v[A].descr, v[A].type));
                  break;
                case 22:
                  S.decorateNode({ icon: v[A] });
                  break;
                case 27:
                  (S.getLogger().trace("node found ..", v[A - 2]),
                    (this.$ = {
                      id: v[A - 1],
                      descr: v[A - 1],
                      type: S.getType(v[A - 2], v[A]),
                    }));
                  break;
                case 28:
                  this.$ = { id: v[A], descr: v[A], type: 0 };
                  break;
                case 29:
                  (S.getLogger().trace("node found ..", v[A - 3]),
                    (this.$ = {
                      id: v[A - 3],
                      descr: v[A - 1],
                      type: S.getType(v[A - 2], v[A]),
                    }));
                  break;
                case 30:
                  this.$ = v[A - 1] + v[A];
                  break;
                case 31:
                  this.$ = v[A];
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: 2, 5: 3, 6: [1, 5], 8: t },
              { 1: [3] },
              { 1: [2, 1] },
              { 4: 6, 6: [1, 7], 7: [1, 8], 8: t },
              {
                6: r,
                7: [1, 10],
                9: 9,
                12: 11,
                13: n,
                14: 14,
                16: i,
                17: s,
                18: 17,
                19: 18,
                20: o,
                23: l,
              },
              e(u, [2, 3]),
              { 1: [2, 2] },
              e(u, [2, 4]),
              e(u, [2, 5]),
              {
                1: [2, 6],
                6: r,
                12: 21,
                13: n,
                14: 14,
                16: i,
                17: s,
                18: 17,
                19: 18,
                20: o,
                23: l,
              },
              {
                6: r,
                9: 22,
                12: 11,
                13: n,
                14: 14,
                16: i,
                17: s,
                18: 17,
                19: 18,
                20: o,
                23: l,
              },
              { 6: h, 7: f, 10: 23, 11: d },
              e(p, [2, 24], {
                18: 17,
                19: 18,
                14: 27,
                16: [1, 28],
                17: [1, 29],
                20: o,
                23: l,
              }),
              e(p, [2, 19]),
              e(p, [2, 21], { 15: 30, 24: m }),
              e(p, [2, 22]),
              e(p, [2, 23]),
              e(g, [2, 25]),
              e(g, [2, 26]),
              e(g, [2, 28], { 20: [1, 32] }),
              { 21: [1, 33] },
              { 6: h, 7: f, 10: 34, 11: d },
              {
                1: [2, 7],
                6: r,
                12: 21,
                13: n,
                14: 14,
                16: i,
                17: s,
                18: 17,
                19: 18,
                20: o,
                23: l,
              },
              e(y, [2, 14], { 7: b, 11: k }),
              e(T, [2, 8]),
              e(T, [2, 9]),
              e(T, [2, 10]),
              e(p, [2, 16], { 15: 37, 24: m }),
              e(p, [2, 17]),
              e(p, [2, 18]),
              e(p, [2, 20], { 24: C }),
              e(g, [2, 31]),
              { 21: [1, 39] },
              { 22: [1, 40] },
              e(y, [2, 13], { 7: b, 11: k }),
              e(T, [2, 11]),
              e(T, [2, 12]),
              e(p, [2, 15], { 24: C }),
              e(g, [2, 30]),
              { 22: [1, 41] },
              e(g, [2, 27]),
              e(g, [2, 29]),
            ],
            defaultActions: { 2: [2, 1], 6: [2, 2] },
            parseError: a(function (E, R) {
              if (R.recoverable) this.trace(E);
              else {
                var F = new Error(E);
                throw ((F.hash = R), F);
              }
            }, "parseError"),
            parse: a(function (E) {
              var R = this,
                F = [0],
                S = [],
                O = [null],
                v = [],
                _ = this.table,
                A = "",
                N = 0,
                B = 0,
                M = 0,
                I = 2,
                V = 1,
                $ = v.slice.call(arguments, 1),
                q = Object.create(this.lexer),
                tt = { yy: {} };
              for (var ht in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, ht) &&
                  (tt.yy[ht] = this.yy[ht]);
              (q.setInput(E, tt.yy),
                (tt.yy.lexer = q),
                (tt.yy.parser = this),
                typeof q.yylloc > "u" && (q.yylloc = {}));
              var H = q.yylloc;
              v.push(H);
              var kt = q.options && q.options.ranges;
              typeof tt.yy.parseError == "function"
                ? (this.parseError = tt.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function ft(jt) {
                ((F.length = F.length - 2 * jt),
                  (O.length = O.length - jt),
                  (v.length = v.length - jt));
              }
              a(ft, "popStack");
              function yt() {
                var jt;
                return (
                  (jt = S.pop() || q.lex() || V),
                  typeof jt != "number" &&
                    (jt instanceof Array && ((S = jt), (jt = S.pop())),
                    (jt = R.symbols_[jt] || jt)),
                  jt
                );
              }
              a(yt, "lex");
              for (var ot, dt, nt, Q, et, X, st = {}, U, gt, z, ge; ; ) {
                if (
                  ((nt = F[F.length - 1]),
                  this.defaultActions[nt]
                    ? (Q = this.defaultActions[nt])
                    : ((ot === null || typeof ot > "u") && (ot = yt()),
                      (Q = _[nt] && _[nt][ot])),
                  typeof Q > "u" || !Q.length || !Q[0])
                ) {
                  var lt = "";
                  ge = [];
                  for (U in _[nt])
                    this.terminals_[U] &&
                      U > I &&
                      ge.push("'" + this.terminals_[U] + "'");
                  (q.showPosition
                    ? (lt =
                        "Parse error on line " +
                        (N + 1) +
                        `:
` +
                        q.showPosition() +
                        `
Expecting ` +
                        ge.join(", ") +
                        ", got '" +
                        (this.terminals_[ot] || ot) +
                        "'")
                    : (lt =
                        "Parse error on line " +
                        (N + 1) +
                        ": Unexpected " +
                        (ot == V
                          ? "end of input"
                          : "'" + (this.terminals_[ot] || ot) + "'")),
                    this.parseError(lt, {
                      text: q.match,
                      token: this.terminals_[ot] || ot,
                      line: q.yylineno,
                      loc: H,
                      expected: ge,
                    }));
                }
                if (Q[0] instanceof Array && Q.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      nt +
                      ", token: " +
                      ot,
                  );
                switch (Q[0]) {
                  case 1:
                    (F.push(ot),
                      O.push(q.yytext),
                      v.push(q.yylloc),
                      F.push(Q[1]),
                      (ot = null),
                      dt
                        ? ((ot = dt), (dt = null))
                        : ((B = q.yyleng),
                          (A = q.yytext),
                          (N = q.yylineno),
                          (H = q.yylloc),
                          M > 0 && M--));
                    break;
                  case 2:
                    if (
                      ((gt = this.productions_[Q[1]][1]),
                      (st.$ = O[O.length - gt]),
                      (st._$ = {
                        first_line: v[v.length - (gt || 1)].first_line,
                        last_line: v[v.length - 1].last_line,
                        first_column: v[v.length - (gt || 1)].first_column,
                        last_column: v[v.length - 1].last_column,
                      }),
                      kt &&
                        (st._$.range = [
                          v[v.length - (gt || 1)].range[0],
                          v[v.length - 1].range[1],
                        ]),
                      (X = this.performAction.apply(
                        st,
                        [A, B, N, tt.yy, Q[1], O, v].concat($),
                      )),
                      typeof X < "u")
                    )
                      return X;
                    (gt &&
                      ((F = F.slice(0, -1 * gt * 2)),
                      (O = O.slice(0, -1 * gt)),
                      (v = v.slice(0, -1 * gt))),
                      F.push(this.productions_[Q[1]][0]),
                      O.push(st.$),
                      v.push(st._$),
                      (z = _[F[F.length - 2]][F[F.length - 1]]),
                      F.push(z));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          w = (function () {
            var G = {
              EOF: 1,
              parseError: a(function (R, F) {
                if (this.yy.parser) this.yy.parser.parseError(R, F);
                else throw new Error(R);
              }, "parseError"),
              setInput: a(function (E, R) {
                return (
                  (this.yy = R || this.yy || {}),
                  (this._input = E),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var E = this._input[0];
                ((this.yytext += E),
                  this.yyleng++,
                  this.offset++,
                  (this.match += E),
                  (this.matched += E));
                var R = E.match(/(?:\r\n?|\n).*/g);
                return (
                  R
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  E
                );
              }, "input"),
              unput: a(function (E) {
                var R = E.length,
                  F = E.split(/(?:\r\n?|\n)/g);
                ((this._input = E + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - R)),
                  (this.offset -= R));
                var S = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  F.length - 1 && (this.yylineno -= F.length - 1));
                var O = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: F
                      ? (F.length === S.length ? this.yylloc.first_column : 0) +
                        S[S.length - F.length].length -
                        F[0].length
                      : this.yylloc.first_column - R,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [O[0], O[0] + this.yyleng - R]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (E) {
                this.unput(this.match.slice(E));
              }, "less"),
              pastInput: a(function () {
                var E = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (E.length > 20 ? "..." : "") +
                  E.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var E = this.match;
                return (
                  E.length < 20 && (E += this._input.substr(0, 20 - E.length)),
                  (E.substr(0, 20) + (E.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var E = this.pastInput(),
                  R = new Array(E.length + 1).join("-");
                return (
                  E +
                  this.upcomingInput() +
                  `
` +
                  R +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (E, R) {
                var F, S, O;
                if (
                  (this.options.backtrack_lexer &&
                    ((O = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (O.yylloc.range = this.yylloc.range.slice(0))),
                  (S = E[0].match(/(?:\r\n?|\n).*/g)),
                  S && (this.yylineno += S.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: S
                      ? S[S.length - 1].length -
                        S[S.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + E[0].length,
                  }),
                  (this.yytext += E[0]),
                  (this.match += E[0]),
                  (this.matches = E),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(E[0].length)),
                  (this.matched += E[0]),
                  (F = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    R,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  F)
                )
                  return F;
                if (this._backtrack) {
                  for (var v in O) this[v] = O[v];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var E, R, F, S;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var O = this._currentRules(), v = 0; v < O.length; v++)
                  if (
                    ((F = this._input.match(this.rules[O[v]])),
                    F && (!R || F[0].length > R[0].length))
                  ) {
                    if (((R = F), (S = v), this.options.backtrack_lexer)) {
                      if (((E = this.test_match(F, O[v])), E !== !1)) return E;
                      if (this._backtrack) {
                        R = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return R
                  ? ((E = this.test_match(R, O[S])), E !== !1 ? E : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var R = this.next();
                return R || this.lex();
              }, "lex"),
              begin: a(function (R) {
                this.conditionStack.push(R);
              }, "begin"),
              popState: a(function () {
                var R = this.conditionStack.length - 1;
                return R > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (R) {
                return (
                  (R = this.conditionStack.length - 1 - Math.abs(R || 0)),
                  R >= 0 ? this.conditionStack[R] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (R) {
                this.begin(R);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (R, F, S, O) {
                var v = O;
                switch (S) {
                  case 0:
                    return (this.pushState("shapeData"), (F.yytext = ""), 24);
                    break;
                  case 1:
                    return (this.pushState("shapeDataStr"), 24);
                    break;
                  case 2:
                    return (this.popState(), 24);
                    break;
                  case 3:
                    let _ = /\n\s*/g;
                    return ((F.yytext = F.yytext.replace(_, "<br/>")), 24);
                    break;
                  case 4:
                    return 24;
                  case 5:
                    this.popState();
                    break;
                  case 6:
                    return (R.getLogger().trace("Found comment", F.yytext), 6);
                    break;
                  case 7:
                    return 8;
                  case 8:
                    this.begin("CLASS");
                    break;
                  case 9:
                    return (this.popState(), 17);
                    break;
                  case 10:
                    this.popState();
                    break;
                  case 11:
                    (R.getLogger().trace("Begin icon"), this.begin("ICON"));
                    break;
                  case 12:
                    return (R.getLogger().trace("SPACELINE"), 6);
                    break;
                  case 13:
                    return 7;
                  case 14:
                    return 16;
                  case 15:
                    (R.getLogger().trace("end icon"), this.popState());
                    break;
                  case 16:
                    return (
                      R.getLogger().trace("Exploding node"),
                      this.begin("NODE"),
                      20
                    );
                    break;
                  case 17:
                    return (
                      R.getLogger().trace("Cloud"),
                      this.begin("NODE"),
                      20
                    );
                    break;
                  case 18:
                    return (
                      R.getLogger().trace("Explosion Bang"),
                      this.begin("NODE"),
                      20
                    );
                    break;
                  case 19:
                    return (
                      R.getLogger().trace("Cloud Bang"),
                      this.begin("NODE"),
                      20
                    );
                    break;
                  case 20:
                    return (this.begin("NODE"), 20);
                    break;
                  case 21:
                    return (this.begin("NODE"), 20);
                    break;
                  case 22:
                    return (this.begin("NODE"), 20);
                    break;
                  case 23:
                    return (this.begin("NODE"), 20);
                    break;
                  case 24:
                    return 13;
                  case 25:
                    return 23;
                  case 26:
                    return 11;
                  case 27:
                    this.begin("NSTR2");
                    break;
                  case 28:
                    return "NODE_DESCR";
                  case 29:
                    this.popState();
                    break;
                  case 30:
                    (R.getLogger().trace("Starting NSTR"), this.begin("NSTR"));
                    break;
                  case 31:
                    return (
                      R.getLogger().trace("description:", F.yytext),
                      "NODE_DESCR"
                    );
                    break;
                  case 32:
                    this.popState();
                    break;
                  case 33:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end ))"),
                      "NODE_DEND"
                    );
                    break;
                  case 34:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end )"),
                      "NODE_DEND"
                    );
                    break;
                  case 35:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end ...", F.yytext),
                      "NODE_DEND"
                    );
                    break;
                  case 36:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end (("),
                      "NODE_DEND"
                    );
                    break;
                  case 37:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end (-"),
                      "NODE_DEND"
                    );
                    break;
                  case 38:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end (-"),
                      "NODE_DEND"
                    );
                    break;
                  case 39:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end (("),
                      "NODE_DEND"
                    );
                    break;
                  case 40:
                    return (
                      this.popState(),
                      R.getLogger().trace("node end (("),
                      "NODE_DEND"
                    );
                    break;
                  case 41:
                    return (
                      R.getLogger().trace("Long description:", F.yytext),
                      21
                    );
                    break;
                  case 42:
                    return (
                      R.getLogger().trace("Long description:", F.yytext),
                      21
                    );
                    break;
                }
              }, "anonymous"),
              rules: [
                /^(?:@\{)/i,
                /^(?:["])/i,
                /^(?:["])/i,
                /^(?:[^\"]+)/i,
                /^(?:[^}^"]+)/i,
                /^(?:\})/i,
                /^(?:\s*%%.*)/i,
                /^(?:kanban\b)/i,
                /^(?::::)/i,
                /^(?:.+)/i,
                /^(?:\n)/i,
                /^(?:::icon\()/i,
                /^(?:[\s]+[\n])/i,
                /^(?:[\n]+)/i,
                /^(?:[^\)]+)/i,
                /^(?:\))/i,
                /^(?:-\))/i,
                /^(?:\(-)/i,
                /^(?:\)\))/i,
                /^(?:\))/i,
                /^(?:\(\()/i,
                /^(?:\{\{)/i,
                /^(?:\()/i,
                /^(?:\[)/i,
                /^(?:[\s]+)/i,
                /^(?:[^\(\[\n\)\{\}@]+)/i,
                /^(?:$)/i,
                /^(?:["][`])/i,
                /^(?:[^`"]+)/i,
                /^(?:[`]["])/i,
                /^(?:["])/i,
                /^(?:[^"]+)/i,
                /^(?:["])/i,
                /^(?:[\)]\))/i,
                /^(?:[\)])/i,
                /^(?:[\]])/i,
                /^(?:\}\})/i,
                /^(?:\(-)/i,
                /^(?:-\))/i,
                /^(?:\(\()/i,
                /^(?:\()/i,
                /^(?:[^\)\]\(\}]+)/i,
                /^(?:.+(?!\(\())/i,
              ],
              conditions: {
                shapeDataEndBracket: { rules: [], inclusive: !1 },
                shapeDataStr: { rules: [2, 3], inclusive: !1 },
                shapeData: { rules: [1, 4, 5], inclusive: !1 },
                CLASS: { rules: [9, 10], inclusive: !1 },
                ICON: { rules: [14, 15], inclusive: !1 },
                NSTR2: { rules: [28, 29], inclusive: !1 },
                NSTR: { rules: [31, 32], inclusive: !1 },
                NODE: {
                  rules: [27, 30, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42],
                  inclusive: !1,
                },
                INITIAL: {
                  rules: [
                    0, 6, 7, 8, 11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24,
                    25, 26,
                  ],
                  inclusive: !0,
                },
              },
            };
            return G;
          })();
        L.lexer = w;
        function D() {
          this.yy = {};
        }
        return (a(D, "Parser"), (D.prototype = L), (L.Parser = D), new D());
      })();
      r8.parser = r8;
      Dst = r8;
    });
  var ya,
    i8,
    n8,
    s8,
    t8t,
    e8t,
    Ist,
    r8t,
    n8t,
    Gn,
    i8t,
    s8t,
    a8t,
    o8t,
    l8t,
    c8t,
    u8t,
    Mst,
    Ost = x(() => {
      "use strict";
      pe();
      Be();
      Vt();
      Ss();
      v0();
      ((ya = []),
        (i8 = []),
        (n8 = 0),
        (s8 = {}),
        (t8t = a(() => {
          ((ya = []), (i8 = []), (n8 = 0), (s8 = {}));
        }, "clear")),
        (e8t = a((e) => {
          if (ya.length === 0) return null;
          let t = ya[0].level,
            r = null;
          for (let n = ya.length - 1; n >= 0; n--)
            if ((ya[n].level === t && !r && (r = ya[n]), ya[n].level < t))
              throw new Error(
                'Items without section detected, found section ("' +
                  ya[n].label +
                  '")',
              );
          return e === r?.level ? null : r;
        }, "getSection")),
        (Ist = a(function () {
          return i8;
        }, "getSections")),
        (r8t = a(function () {
          let e = [],
            t = [],
            r = Ist(),
            n = K();
          for (let i of r) {
            let s = {
              id: i.id,
              label: Ie(i.label ?? "", n),
              isGroup: !0,
              ticket: i.ticket,
              shape: "kanbanSection",
              level: i.level,
              look: n.look,
            };
            t.push(s);
            let o = ya.filter((l) => l.parentId === i.id);
            for (let l of o) {
              let u = {
                id: l.id,
                parentId: i.id,
                label: Ie(l.label ?? "", n),
                isGroup: !1,
                ticket: l?.ticket,
                priority: l?.priority,
                assigned: l?.assigned,
                icon: l?.icon,
                shape: "kanbanItem",
                level: l.level,
                rx: 5,
                ry: 5,
                cssStyles: ["text-align: left"],
              };
              t.push(u);
            }
          }
          return { nodes: t, edges: e, other: {}, config: K() };
        }, "getData")),
        (n8t = a((e, t, r, n, i) => {
          let s = K(),
            o = s.mindmap?.padding ?? ze.mindmap.padding;
          switch (n) {
            case Gn.ROUNDED_RECT:
            case Gn.RECT:
            case Gn.HEXAGON:
              o *= 2;
          }
          let l = {
            id: Ie(t, s) || "kbn" + n8++,
            level: e,
            label: Ie(r, s),
            width: s.mindmap?.maxNodeWidth ?? ze.mindmap.maxNodeWidth,
            padding: o,
            isGroup: !1,
          };
          if (i !== void 0) {
            let h;
            i.includes(`
`)
              ? (h =
                  i +
                  `
`)
              : (h =
                  `{
` +
                  i +
                  `
}`);
            let f = wc(h, { schema: Cc });
            if (
              f.shape &&
              (f.shape !== f.shape.toLowerCase() || f.shape.includes("_"))
            )
              throw new Error(
                `No such shape: ${f.shape}. Shape names should be lowercase.`,
              );
            (f?.shape && f.shape === "kanbanItem" && (l.shape = f?.shape),
              f?.label && (l.label = f?.label),
              f?.icon && (l.icon = f?.icon.toString()),
              f?.assigned && (l.assigned = f?.assigned.toString()),
              f?.ticket && (l.ticket = f?.ticket.toString()),
              f?.priority && (l.priority = f?.priority));
          }
          let u = e8t(e);
          (u ? (l.parentId = u.id || "kbn" + n8++) : i8.push(l), ya.push(l));
        }, "addNode")),
        (Gn = {
          DEFAULT: 0,
          NO_BORDER: 0,
          ROUNDED_RECT: 1,
          RECT: 2,
          CIRCLE: 3,
          CLOUD: 4,
          BANG: 5,
          HEXAGON: 6,
        }),
        (i8t = a((e, t) => {
          switch ((P.debug("In get type", e, t), e)) {
            case "[":
              return Gn.RECT;
            case "(":
              return t === ")" ? Gn.ROUNDED_RECT : Gn.CLOUD;
            case "((":
              return Gn.CIRCLE;
            case ")":
              return Gn.CLOUD;
            case "))":
              return Gn.BANG;
            case "{{":
              return Gn.HEXAGON;
            default:
              return Gn.DEFAULT;
          }
        }, "getType")),
        (s8t = a((e, t) => {
          s8[e] = t;
        }, "setElementForId")),
        (a8t = a((e) => {
          if (!e) return;
          let t = K(),
            r = ya[ya.length - 1];
          (e.icon && (r.icon = Ie(e.icon, t)),
            e.class && (r.cssClasses = Ie(e.class, t)));
        }, "decorateNode")),
        (o8t = a((e) => {
          switch (e) {
            case Gn.DEFAULT:
              return "no-border";
            case Gn.RECT:
              return "rect";
            case Gn.ROUNDED_RECT:
              return "rounded-rect";
            case Gn.CIRCLE:
              return "circle";
            case Gn.CLOUD:
              return "cloud";
            case Gn.BANG:
              return "bang";
            case Gn.HEXAGON:
              return "hexgon";
            default:
              return "no-border";
          }
        }, "type2Str")),
        (l8t = a(() => P, "getLogger")),
        (c8t = a((e) => s8[e], "getElementById")),
        (u8t = {
          clear: t8t,
          addNode: n8t,
          getSections: Ist,
          getData: r8t,
          nodeType: Gn,
          getType: i8t,
          setElementForId: s8t,
          decorateNode: a8t,
          type2Str: o8t,
          getLogger: l8t,
          getElementById: c8t,
        }),
        (Mst = u8t));
    });
  var h8t,
    Pst,
    Bst = x(() => {
      "use strict";
      pe();
      Vt();
      Fl();
      On();
      Ss();
      Yb();
      ik();
      ((h8t = a(async (e, t, r, n) => {
        P.debug(
          `Rendering kanban diagram
` + e,
        );
        let s = n.db.getData(),
          o = K();
        o.htmlLabels = !1;
        let l = Ei(t),
          u = l.append("g");
        u.attr("class", "sections");
        let h = l.append("g");
        h.attr("class", "items");
        let f = s.nodes.filter((b) => b.isGroup),
          d = 0,
          p = 10,
          m = [],
          g = 25;
        for (let b of f) {
          let k = o?.kanban?.sectionWidth || 200;
          ((d = d + 1),
            (b.x = k * d + ((d - 1) * p) / 2),
            (b.width = k),
            (b.y = 0),
            (b.height = k * 3),
            (b.rx = 5),
            (b.ry = 5),
            (b.cssClasses = b.cssClasses + " section-" + d));
          let T = await fd(u, b);
          ((g = Math.max(g, T?.labelBBox?.height)), m.push(T));
        }
        let y = 0;
        for (let b of f) {
          let k = m[y];
          y = y + 1;
          let T = o?.kanban?.sectionWidth || 200,
            C = (-T * 3) / 2 + g,
            L = C,
            w = s.nodes.filter((E) => E.parentId === b.id);
          for (let E of w) {
            if (E.isGroup)
              throw new Error(
                "Groups within groups are not allowed in Kanban diagrams",
              );
            ((E.x = b.x), (E.width = T - 1.5 * p));
            let F = (await dd(h, E, { config: o })).node().getBBox();
            ((E.y = L + F.height / 2),
              await G0(E),
              (L = E.y + F.height / 2 + p / 2));
          }
          let D = k.cluster.select("rect"),
            G = Math.max(L - C + 3 * p, 50) + (g - 25);
          D.attr("height", G);
        }
        Ql(
          void 0,
          l,
          o.mindmap?.padding ?? ze.kanban.padding,
          o.mindmap?.useMaxWidth ?? ze.kanban.useMaxWidth,
        );
      }, "draw")),
        (Pst = { draw: h8t }));
    });
  var f8t,
    d8t,
    Fst,
    $st = x(() => {
      "use strict";
      Us();
      Md();
      ((f8t = a((e) => {
        let t = "";
        for (let n = 0; n < e.THEME_COLOR_LIMIT; n++)
          ((e["lineColor" + n] = e["lineColor" + n] || e["cScaleInv" + n]),
            Ni(e["lineColor" + n])
              ? (e["lineColor" + n] = Yt(e["lineColor" + n], 20))
              : (e["lineColor" + n] = ee(e["lineColor" + n], 20)));
        let r = a((n, i) => (e.darkMode ? ee(n, i) : Yt(n, i)), "adjuster");
        for (let n = 0; n < e.THEME_COLOR_LIMIT; n++) {
          let i = "" + (17 - 3 * n);
          t += `
    .section-${n - 1} rect, .section-${n - 1} path, .section-${n - 1} circle, .section-${n - 1} polygon, .section-${n - 1} path  {
      fill: ${r(e["cScale" + n], 10)};
      stroke: ${r(e["cScale" + n], 10)};

    }
    .section-${n - 1} text {
     fill: ${e["cScaleLabel" + n]};
    }
    .node-icon-${n - 1} {
      font-size: 40px;
      color: ${e["cScaleLabel" + n]};
    }
    .section-edge-${n - 1}{
      stroke: ${e["cScale" + n]};
    }
    .edge-depth-${n - 1}{
      stroke-width: ${i};
    }
    .section-${n - 1} line {
      stroke: ${e["cScaleInv" + n]} ;
      stroke-width: 3;
    }

    .disabled, .disabled circle, .disabled text {
      fill: lightgray;
    }
    .disabled text {
      fill: #efefef;
    }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }

  .kanban-ticket-link {
    fill: ${e.background};
    stroke: ${e.nodeBorder};
    text-decoration: underline;
  }
    `;
        }
        return t;
      }, "genSections")),
        (d8t = a(
          (e) => `
  .edge {
    stroke-width: 3;
  }
  ${f8t(e)}
  .section-root rect, .section-root path, .section-root circle, .section-root polygon  {
    fill: ${e.git0};
  }
  .section-root text {
    fill: ${e.gitBranchLabel0};
  }
  .icon-container {
    height:100%;
    display: flex;
    justify-content: center;
    align-items: center;
  }
  .edge {
    fill: none;
  }
  .cluster-label, .label {
    color: ${e.textColor};
    fill: ${e.textColor};
    }
  .kanban-label {
    dy: 1em;
    alignment-baseline: middle;
    text-anchor: middle;
    dominant-baseline: middle;
    text-align: center;
  }
    ${Io()}
`,
          "getStyles",
        )),
        (Fst = d8t));
    });
  var Gst = {};
  Oe(Gst, { diagram: () => p8t });
  var p8t,
    Vst = x(() => {
      "use strict";
      Nst();
      Ost();
      Bst();
      $st();
      p8t = { db: Mst, renderer: Pst, parser: Dst, styles: Fst };
    });
  var a8,
    Hy,
    Ust = x(() => {
      "use strict";
      a8 = (function () {
        var e = a(function (l, u, h, f) {
            for (h = h || {}, f = l.length; f--; h[l[f]] = u);
            return h;
          }, "o"),
          t = [1, 9],
          r = [1, 10],
          n = [1, 5, 10, 12],
          i = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              start: 3,
              SANKEY: 4,
              NEWLINE: 5,
              csv: 6,
              opt_eof: 7,
              record: 8,
              csv_tail: 9,
              EOF: 10,
              "field[source]": 11,
              COMMA: 12,
              "field[target]": 13,
              "field[value]": 14,
              field: 15,
              escaped: 16,
              non_escaped: 17,
              DQUOTE: 18,
              ESCAPED_TEXT: 19,
              NON_ESCAPED_TEXT: 20,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "SANKEY",
              5: "NEWLINE",
              10: "EOF",
              11: "field[source]",
              12: "COMMA",
              13: "field[target]",
              14: "field[value]",
              18: "DQUOTE",
              19: "ESCAPED_TEXT",
              20: "NON_ESCAPED_TEXT",
            },
            productions_: [
              0,
              [3, 4],
              [6, 2],
              [9, 2],
              [9, 0],
              [7, 1],
              [7, 0],
              [8, 5],
              [15, 1],
              [15, 1],
              [16, 3],
              [17, 1],
            ],
            performAction: a(function (u, h, f, d, p, m, g) {
              var y = m.length - 1;
              switch (p) {
                case 7:
                  let b = d.findOrCreateNode(
                      m[y - 4].trim().replaceAll('""', '"'),
                    ),
                    k = d.findOrCreateNode(
                      m[y - 2].trim().replaceAll('""', '"'),
                    ),
                    T = parseFloat(m[y].trim());
                  d.addLink(b, k, T);
                  break;
                case 8:
                case 9:
                case 11:
                  this.$ = m[y];
                  break;
                case 10:
                  this.$ = m[y - 1];
                  break;
              }
            }, "anonymous"),
            table: [
              { 3: 1, 4: [1, 2] },
              { 1: [3] },
              { 5: [1, 3] },
              { 6: 4, 8: 5, 15: 6, 16: 7, 17: 8, 18: t, 20: r },
              { 1: [2, 6], 7: 11, 10: [1, 12] },
              e(r, [2, 4], { 9: 13, 5: [1, 14] }),
              { 12: [1, 15] },
              e(n, [2, 8]),
              e(n, [2, 9]),
              { 19: [1, 16] },
              e(n, [2, 11]),
              { 1: [2, 1] },
              { 1: [2, 5] },
              e(r, [2, 2]),
              { 6: 17, 8: 5, 15: 6, 16: 7, 17: 8, 18: t, 20: r },
              { 15: 18, 16: 7, 17: 8, 18: t, 20: r },
              { 18: [1, 19] },
              e(r, [2, 3]),
              { 12: [1, 20] },
              e(n, [2, 10]),
              { 15: 21, 16: 7, 17: 8, 18: t, 20: r },
              e([1, 5, 10], [2, 7]),
            ],
            defaultActions: { 11: [2, 1], 12: [2, 5] },
            parseError: a(function (u, h) {
              if (h.recoverable) this.trace(u);
              else {
                var f = new Error(u);
                throw ((f.hash = h), f);
              }
            }, "parseError"),
            parse: a(function (u) {
              var h = this,
                f = [0],
                d = [],
                p = [null],
                m = [],
                g = this.table,
                y = "",
                b = 0,
                k = 0,
                T = 0,
                C = 2,
                L = 1,
                w = m.slice.call(arguments, 1),
                D = Object.create(this.lexer),
                G = { yy: {} };
              for (var E in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, E) &&
                  (G.yy[E] = this.yy[E]);
              (D.setInput(u, G.yy),
                (G.yy.lexer = D),
                (G.yy.parser = this),
                typeof D.yylloc > "u" && (D.yylloc = {}));
              var R = D.yylloc;
              m.push(R);
              var F = D.options && D.options.ranges;
              typeof G.yy.parseError == "function"
                ? (this.parseError = G.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function S(H) {
                ((f.length = f.length - 2 * H),
                  (p.length = p.length - H),
                  (m.length = m.length - H));
              }
              a(S, "popStack");
              function O() {
                var H;
                return (
                  (H = d.pop() || D.lex() || L),
                  typeof H != "number" &&
                    (H instanceof Array && ((d = H), (H = d.pop())),
                    (H = h.symbols_[H] || H)),
                  H
                );
              }
              a(O, "lex");
              for (var v, _, A, N, B, M, I = {}, V, $, q, tt; ; ) {
                if (
                  ((A = f[f.length - 1]),
                  this.defaultActions[A]
                    ? (N = this.defaultActions[A])
                    : ((v === null || typeof v > "u") && (v = O()),
                      (N = g[A] && g[A][v])),
                  typeof N > "u" || !N.length || !N[0])
                ) {
                  var ht = "";
                  tt = [];
                  for (V in g[A])
                    this.terminals_[V] &&
                      V > C &&
                      tt.push("'" + this.terminals_[V] + "'");
                  (D.showPosition
                    ? (ht =
                        "Parse error on line " +
                        (b + 1) +
                        `:
` +
                        D.showPosition() +
                        `
Expecting ` +
                        tt.join(", ") +
                        ", got '" +
                        (this.terminals_[v] || v) +
                        "'")
                    : (ht =
                        "Parse error on line " +
                        (b + 1) +
                        ": Unexpected " +
                        (v == L
                          ? "end of input"
                          : "'" + (this.terminals_[v] || v) + "'")),
                    this.parseError(ht, {
                      text: D.match,
                      token: this.terminals_[v] || v,
                      line: D.yylineno,
                      loc: R,
                      expected: tt,
                    }));
                }
                if (N[0] instanceof Array && N.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      A +
                      ", token: " +
                      v,
                  );
                switch (N[0]) {
                  case 1:
                    (f.push(v),
                      p.push(D.yytext),
                      m.push(D.yylloc),
                      f.push(N[1]),
                      (v = null),
                      _
                        ? ((v = _), (_ = null))
                        : ((k = D.yyleng),
                          (y = D.yytext),
                          (b = D.yylineno),
                          (R = D.yylloc),
                          T > 0 && T--));
                    break;
                  case 2:
                    if (
                      (($ = this.productions_[N[1]][1]),
                      (I.$ = p[p.length - $]),
                      (I._$ = {
                        first_line: m[m.length - ($ || 1)].first_line,
                        last_line: m[m.length - 1].last_line,
                        first_column: m[m.length - ($ || 1)].first_column,
                        last_column: m[m.length - 1].last_column,
                      }),
                      F &&
                        (I._$.range = [
                          m[m.length - ($ || 1)].range[0],
                          m[m.length - 1].range[1],
                        ]),
                      (M = this.performAction.apply(
                        I,
                        [y, k, b, G.yy, N[1], p, m].concat(w),
                      )),
                      typeof M < "u")
                    )
                      return M;
                    ($ &&
                      ((f = f.slice(0, -1 * $ * 2)),
                      (p = p.slice(0, -1 * $)),
                      (m = m.slice(0, -1 * $))),
                      f.push(this.productions_[N[1]][0]),
                      p.push(I.$),
                      m.push(I._$),
                      (q = g[f[f.length - 2]][f[f.length - 1]]),
                      f.push(q));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          s = (function () {
            var l = {
              EOF: 1,
              parseError: a(function (h, f) {
                if (this.yy.parser) this.yy.parser.parseError(h, f);
                else throw new Error(h);
              }, "parseError"),
              setInput: a(function (u, h) {
                return (
                  (this.yy = h || this.yy || {}),
                  (this._input = u),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var u = this._input[0];
                ((this.yytext += u),
                  this.yyleng++,
                  this.offset++,
                  (this.match += u),
                  (this.matched += u));
                var h = u.match(/(?:\r\n?|\n).*/g);
                return (
                  h
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  u
                );
              }, "input"),
              unput: a(function (u) {
                var h = u.length,
                  f = u.split(/(?:\r\n?|\n)/g);
                ((this._input = u + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - h)),
                  (this.offset -= h));
                var d = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  f.length - 1 && (this.yylineno -= f.length - 1));
                var p = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: f
                      ? (f.length === d.length ? this.yylloc.first_column : 0) +
                        d[d.length - f.length].length -
                        f[0].length
                      : this.yylloc.first_column - h,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [p[0], p[0] + this.yyleng - h]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (u) {
                this.unput(this.match.slice(u));
              }, "less"),
              pastInput: a(function () {
                var u = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (u.length > 20 ? "..." : "") +
                  u.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var u = this.match;
                return (
                  u.length < 20 && (u += this._input.substr(0, 20 - u.length)),
                  (u.substr(0, 20) + (u.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var u = this.pastInput(),
                  h = new Array(u.length + 1).join("-");
                return (
                  u +
                  this.upcomingInput() +
                  `
` +
                  h +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (u, h) {
                var f, d, p;
                if (
                  (this.options.backtrack_lexer &&
                    ((p = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (p.yylloc.range = this.yylloc.range.slice(0))),
                  (d = u[0].match(/(?:\r\n?|\n).*/g)),
                  d && (this.yylineno += d.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: d
                      ? d[d.length - 1].length -
                        d[d.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + u[0].length,
                  }),
                  (this.yytext += u[0]),
                  (this.match += u[0]),
                  (this.matches = u),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(u[0].length)),
                  (this.matched += u[0]),
                  (f = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    h,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  f)
                )
                  return f;
                if (this._backtrack) {
                  for (var m in p) this[m] = p[m];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var u, h, f, d;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var p = this._currentRules(), m = 0; m < p.length; m++)
                  if (
                    ((f = this._input.match(this.rules[p[m]])),
                    f && (!h || f[0].length > h[0].length))
                  ) {
                    if (((h = f), (d = m), this.options.backtrack_lexer)) {
                      if (((u = this.test_match(f, p[m])), u !== !1)) return u;
                      if (this._backtrack) {
                        h = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return h
                  ? ((u = this.test_match(h, p[d])), u !== !1 ? u : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var h = this.next();
                return h || this.lex();
              }, "lex"),
              begin: a(function (h) {
                this.conditionStack.push(h);
              }, "begin"),
              popState: a(function () {
                var h = this.conditionStack.length - 1;
                return h > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (h) {
                return (
                  (h = this.conditionStack.length - 1 - Math.abs(h || 0)),
                  h >= 0 ? this.conditionStack[h] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (h) {
                this.begin(h);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: { "case-insensitive": !0 },
              performAction: a(function (h, f, d, p) {
                var m = p;
                switch (d) {
                  case 0:
                    return (this.pushState("csv"), 4);
                    break;
                  case 1:
                    return (this.pushState("csv"), 4);
                    break;
                  case 2:
                    return 10;
                  case 3:
                    return 5;
                  case 4:
                    return 12;
                  case 5:
                    return (this.pushState("escaped_text"), 18);
                    break;
                  case 6:
                    return 20;
                  case 7:
                    return (this.popState("escaped_text"), 18);
                    break;
                  case 8:
                    return 19;
                }
              }, "anonymous"),
              rules: [
                /^(?:sankey-beta\b)/i,
                /^(?:sankey\b)/i,
                /^(?:$)/i,
                /^(?:((\u000D\u000A)|(\u000A)))/i,
                /^(?:(\u002C))/i,
                /^(?:(\u0022))/i,
                /^(?:([\u0020-\u0021\u0023-\u002B\u002D-\u007E])*)/i,
                /^(?:(\u0022)(?!(\u0022)))/i,
                /^(?:(([\u0020-\u0021\u0023-\u002B\u002D-\u007E])|(\u002C)|(\u000D)|(\u000A)|(\u0022)(\u0022))*)/i,
              ],
              conditions: {
                csv: { rules: [2, 3, 4, 5, 6, 7, 8], inclusive: !1 },
                escaped_text: { rules: [7, 8], inclusive: !1 },
                INITIAL: { rules: [0, 1, 2, 3, 4, 5, 6, 7, 8], inclusive: !0 },
              },
            };
            return l;
          })();
        i.lexer = s;
        function o() {
          this.yy = {};
        }
        return (a(o, "Parser"), (o.prototype = i), (i.Parser = o), new o());
      })();
      a8.parser = a8;
      Hy = a8;
    });
  var nC,
    iC,
    rC,
    x8t,
    o8,
    b8t,
    l8,
    k8t,
    T8t,
    S8t,
    _8t,
    jst,
    qst = x(() => {
      "use strict";
      pe();
      Be();
      yn();
      ((nC = []),
        (iC = []),
        (rC = new Map()),
        (x8t = a(() => {
          ((nC = []), (iC = []), (rC = new Map()), Ye());
        }, "clear")),
        (o8 = class {
          constructor(t, r, n = 0) {
            this.source = t;
            this.target = r;
            this.value = n;
          }
          static {
            a(this, "SankeyLink");
          }
        }),
        (b8t = a((e, t, r) => {
          nC.push(new o8(e, t, r));
        }, "addLink")),
        (l8 = class {
          constructor(t) {
            this.ID = t;
          }
          static {
            a(this, "SankeyNode");
          }
        }),
        (k8t = a((e) => {
          e = Rt.sanitizeText(e, K());
          let t = rC.get(e);
          return (
            t === void 0 && ((t = new l8(e)), rC.set(e, t), iC.push(t)),
            t
          );
        }, "findOrCreateNode")),
        (T8t = a(() => iC, "getNodes")),
        (S8t = a(() => nC, "getLinks")),
        (_8t = a(
          () => ({
            nodes: iC.map((e) => ({ id: e.ID })),
            links: nC.map((e) => ({
              source: e.source.ID,
              target: e.target.ID,
              value: e.value,
            })),
          }),
          "getGraph",
        )),
        (jst = {
          nodesMap: rC,
          getConfig: a(() => K().sankey, "getConfig"),
          getNodes: T8t,
          getLinks: S8t,
          getGraph: _8t,
          addLink: b8t,
          findOrCreateNode: k8t,
          getAccTitle: tr,
          setAccTitle: Xe,
          getAccDescription: rr,
          setAccDescription: er,
          getDiagramTitle: nr,
          setDiagramTitle: lr,
          clear: x8t,
        }));
    });
  function Yy(e, t) {
    let r;
    if (t === void 0)
      for (let n of e)
        n != null && (r < n || (r === void 0 && n >= n)) && (r = n);
    else {
      let n = -1;
      for (let i of e)
        (i = t(i, ++n, e)) != null &&
          (r < i || (r === void 0 && i >= i)) &&
          (r = i);
    }
    return r;
  }
  var Hst = x(() => {
    "use strict";
    a(Yy, "max");
  });
  function Dm(e, t) {
    let r;
    if (t === void 0)
      for (let n of e)
        n != null && (r > n || (r === void 0 && n >= n)) && (r = n);
    else {
      let n = -1;
      for (let i of e)
        (i = t(i, ++n, e)) != null &&
          (r > i || (r === void 0 && i >= i)) &&
          (r = i);
    }
    return r;
  }
  var Yst = x(() => {
    "use strict";
    a(Dm, "min");
  });
  function Nm(e, t) {
    let r = 0;
    if (t === void 0) for (let n of e) (n = +n) && (r += n);
    else {
      let n = -1;
      for (let i of e) (i = +t(i, ++n, e)) && (r += i);
    }
    return r;
  }
  var Xst = x(() => {
    "use strict";
    a(Nm, "sum");
  });
  var c8 = x(() => {
    "use strict";
    Hst();
    Yst();
    Xst();
  });
  function C8t(e) {
    return e.target.depth;
  }
  function u8(e) {
    return e.depth;
  }
  function h8(e, t) {
    return t - 1 - e.height;
  }
  function Xy(e, t) {
    return e.sourceLinks.length ? e.depth : t - 1;
  }
  function f8(e) {
    return e.targetLinks.length
      ? e.depth
      : e.sourceLinks.length
        ? Dm(e.sourceLinks, C8t) - 1
        : 0;
  }
  var d8 = x(() => {
    "use strict";
    c8();
    a(C8t, "targetDepth");
    a(u8, "left");
    a(h8, "right");
    a(Xy, "justify");
    a(f8, "center");
  });
  function Im(e) {
    return function () {
      return e;
    };
  }
  var Kst = x(() => {
    "use strict";
    a(Im, "constant");
  });
  function Qst(e, t) {
    return sC(e.source, t.source) || e.index - t.index;
  }
  function Zst(e, t) {
    return sC(e.target, t.target) || e.index - t.index;
  }
  function sC(e, t) {
    return e.y0 - t.y0;
  }
  function p8(e) {
    return e.value;
  }
  function w8t(e) {
    return e.index;
  }
  function v8t(e) {
    return e.nodes;
  }
  function E8t(e) {
    return e.links;
  }
  function Jst(e, t) {
    let r = e.get(t);
    if (!r) throw new Error("missing: " + t);
    return r;
  }
  function tat({ nodes: e }) {
    for (let t of e) {
      let r = t.y0,
        n = r;
      for (let i of t.sourceLinks) ((i.y0 = r + i.width / 2), (r += i.width));
      for (let i of t.targetLinks) ((i.y1 = n + i.width / 2), (n += i.width));
    }
  }
  function aC() {
    let e = 0,
      t = 0,
      r = 1,
      n = 1,
      i = 24,
      s = 8,
      o,
      l = w8t,
      u = Xy,
      h,
      f,
      d = v8t,
      p = E8t,
      m = 6;
    function g() {
      let A = {
        nodes: d.apply(null, arguments),
        links: p.apply(null, arguments),
      };
      return (y(A), b(A), k(A), T(A), w(A), tat(A), A);
    }
    (a(g, "sankey"),
      (g.update = function (A) {
        return (tat(A), A);
      }),
      (g.nodeId = function (A) {
        return arguments.length
          ? ((l = typeof A == "function" ? A : Im(A)), g)
          : l;
      }),
      (g.nodeAlign = function (A) {
        return arguments.length
          ? ((u = typeof A == "function" ? A : Im(A)), g)
          : u;
      }),
      (g.nodeSort = function (A) {
        return arguments.length ? ((h = A), g) : h;
      }),
      (g.nodeWidth = function (A) {
        return arguments.length ? ((i = +A), g) : i;
      }),
      (g.nodePadding = function (A) {
        return arguments.length ? ((s = o = +A), g) : s;
      }),
      (g.nodes = function (A) {
        return arguments.length
          ? ((d = typeof A == "function" ? A : Im(A)), g)
          : d;
      }),
      (g.links = function (A) {
        return arguments.length
          ? ((p = typeof A == "function" ? A : Im(A)), g)
          : p;
      }),
      (g.linkSort = function (A) {
        return arguments.length ? ((f = A), g) : f;
      }),
      (g.size = function (A) {
        return arguments.length
          ? ((e = t = 0), (r = +A[0]), (n = +A[1]), g)
          : [r - e, n - t];
      }),
      (g.extent = function (A) {
        return arguments.length
          ? ((e = +A[0][0]), (r = +A[1][0]), (t = +A[0][1]), (n = +A[1][1]), g)
          : [
              [e, t],
              [r, n],
            ];
      }),
      (g.iterations = function (A) {
        return arguments.length ? ((m = +A), g) : m;
      }));
    function y({ nodes: A, links: N }) {
      for (let [M, I] of A.entries())
        ((I.index = M), (I.sourceLinks = []), (I.targetLinks = []));
      let B = new Map(A.map((M, I) => [l(M, I, A), M]));
      for (let [M, I] of N.entries()) {
        I.index = M;
        let { source: V, target: $ } = I;
        (typeof V != "object" && (V = I.source = Jst(B, V)),
          typeof $ != "object" && ($ = I.target = Jst(B, $)),
          V.sourceLinks.push(I),
          $.targetLinks.push(I));
      }
      if (f != null)
        for (let { sourceLinks: M, targetLinks: I } of A)
          (M.sort(f), I.sort(f));
    }
    a(y, "computeNodeLinks");
    function b({ nodes: A }) {
      for (let N of A)
        N.value =
          N.fixedValue === void 0
            ? Math.max(Nm(N.sourceLinks, p8), Nm(N.targetLinks, p8))
            : N.fixedValue;
    }
    a(b, "computeNodeValues");
    function k({ nodes: A }) {
      let N = A.length,
        B = new Set(A),
        M = new Set(),
        I = 0;
      for (; B.size; ) {
        for (let V of B) {
          V.depth = I;
          for (let { target: $ } of V.sourceLinks) M.add($);
        }
        if (++I > N) throw new Error("circular link");
        ((B = M), (M = new Set()));
      }
    }
    a(k, "computeNodeDepths");
    function T({ nodes: A }) {
      let N = A.length,
        B = new Set(A),
        M = new Set(),
        I = 0;
      for (; B.size; ) {
        for (let V of B) {
          V.height = I;
          for (let { source: $ } of V.targetLinks) M.add($);
        }
        if (++I > N) throw new Error("circular link");
        ((B = M), (M = new Set()));
      }
    }
    a(T, "computeNodeHeights");
    function C({ nodes: A }) {
      let N = Yy(A, (I) => I.depth) + 1,
        B = (r - e - i) / (N - 1),
        M = new Array(N);
      for (let I of A) {
        let V = Math.max(0, Math.min(N - 1, Math.floor(u.call(null, I, N))));
        ((I.layer = V),
          (I.x0 = e + V * B),
          (I.x1 = I.x0 + i),
          M[V] ? M[V].push(I) : (M[V] = [I]));
      }
      if (h) for (let I of M) I.sort(h);
      return M;
    }
    a(C, "computeNodeLayers");
    function L(A) {
      let N = Dm(A, (B) => (n - t - (B.length - 1) * o) / Nm(B, p8));
      for (let B of A) {
        let M = t;
        for (let I of B) {
          ((I.y0 = M), (I.y1 = M + I.value * N), (M = I.y1 + o));
          for (let V of I.sourceLinks) V.width = V.value * N;
        }
        M = (n - M + o) / (B.length + 1);
        for (let I = 0; I < B.length; ++I) {
          let V = B[I];
          ((V.y0 += M * (I + 1)), (V.y1 += M * (I + 1)));
        }
        O(B);
      }
    }
    a(L, "initializeNodeBreadths");
    function w(A) {
      let N = C(A);
      ((o = Math.min(s, (n - t) / (Yy(N, (B) => B.length) - 1))), L(N));
      for (let B = 0; B < m; ++B) {
        let M = Math.pow(0.99, B),
          I = Math.max(1 - M, (B + 1) / m);
        (G(N, M, I), D(N, M, I));
      }
    }
    a(w, "computeNodeBreadths");
    function D(A, N, B) {
      for (let M = 1, I = A.length; M < I; ++M) {
        let V = A[M];
        for (let $ of V) {
          let q = 0,
            tt = 0;
          for (let { source: H, value: kt } of $.targetLinks) {
            let ft = kt * ($.layer - H.layer);
            ((q += v(H, $) * ft), (tt += ft));
          }
          if (!(tt > 0)) continue;
          let ht = (q / tt - $.y0) * N;
          (($.y0 += ht), ($.y1 += ht), S($));
        }
        (h === void 0 && V.sort(sC), E(V, B));
      }
    }
    a(D, "relaxLeftToRight");
    function G(A, N, B) {
      for (let M = A.length, I = M - 2; I >= 0; --I) {
        let V = A[I];
        for (let $ of V) {
          let q = 0,
            tt = 0;
          for (let { target: H, value: kt } of $.sourceLinks) {
            let ft = kt * (H.layer - $.layer);
            ((q += _($, H) * ft), (tt += ft));
          }
          if (!(tt > 0)) continue;
          let ht = (q / tt - $.y0) * N;
          (($.y0 += ht), ($.y1 += ht), S($));
        }
        (h === void 0 && V.sort(sC), E(V, B));
      }
    }
    a(G, "relaxRightToLeft");
    function E(A, N) {
      let B = A.length >> 1,
        M = A[B];
      (F(A, M.y0 - o, B - 1, N),
        R(A, M.y1 + o, B + 1, N),
        F(A, n, A.length - 1, N),
        R(A, t, 0, N));
    }
    a(E, "resolveCollisions");
    function R(A, N, B, M) {
      for (; B < A.length; ++B) {
        let I = A[B],
          V = (N - I.y0) * M;
        (V > 1e-6 && ((I.y0 += V), (I.y1 += V)), (N = I.y1 + o));
      }
    }
    a(R, "resolveCollisionsTopToBottom");
    function F(A, N, B, M) {
      for (; B >= 0; --B) {
        let I = A[B],
          V = (I.y1 - N) * M;
        (V > 1e-6 && ((I.y0 -= V), (I.y1 -= V)), (N = I.y0 - o));
      }
    }
    a(F, "resolveCollisionsBottomToTop");
    function S({ sourceLinks: A, targetLinks: N }) {
      if (f === void 0) {
        for (let {
          source: { sourceLinks: B },
        } of N)
          B.sort(Zst);
        for (let {
          target: { targetLinks: B },
        } of A)
          B.sort(Qst);
      }
    }
    a(S, "reorderNodeLinks");
    function O(A) {
      if (f === void 0)
        for (let { sourceLinks: N, targetLinks: B } of A)
          (N.sort(Zst), B.sort(Qst));
    }
    a(O, "reorderLinks");
    function v(A, N) {
      let B = A.y0 - ((A.sourceLinks.length - 1) * o) / 2;
      for (let { target: M, width: I } of A.sourceLinks) {
        if (M === N) break;
        B += I + o;
      }
      for (let { source: M, width: I } of N.targetLinks) {
        if (M === A) break;
        B -= I;
      }
      return B;
    }
    a(v, "targetTop");
    function _(A, N) {
      let B = N.y0 - ((N.targetLinks.length - 1) * o) / 2;
      for (let { source: M, width: I } of N.targetLinks) {
        if (M === A) break;
        B += I + o;
      }
      for (let { target: M, width: I } of A.sourceLinks) {
        if (M === N) break;
        B -= I;
      }
      return B;
    }
    return (a(_, "sourceTop"), g);
  }
  var eat = x(() => {
    "use strict";
    c8();
    d8();
    Kst();
    a(Qst, "ascendingSourceBreadth");
    a(Zst, "ascendingTargetBreadth");
    a(sC, "ascendingBreadth");
    a(p8, "value");
    a(w8t, "defaultId");
    a(v8t, "defaultNodes");
    a(E8t, "defaultLinks");
    a(Jst, "find");
    a(tat, "computeLinkBreadths");
    a(aC, "Sankey");
  });
  function y8() {
    ((this._x0 = this._y0 = this._x1 = this._y1 = null), (this._ = ""));
  }
  function rat() {
    return new y8();
  }
  var m8,
    g8,
    ef,
    A8t,
    x8,
    nat = x(() => {
      "use strict";
      ((m8 = Math.PI), (g8 = 2 * m8), (ef = 1e-6), (A8t = g8 - ef));
      a(y8, "Path");
      a(rat, "path");
      y8.prototype = rat.prototype = {
        constructor: y8,
        moveTo: a(function (e, t) {
          this._ +=
            "M" + (this._x0 = this._x1 = +e) + "," + (this._y0 = this._y1 = +t);
        }, "moveTo"),
        closePath: a(function () {
          this._x1 !== null &&
            ((this._x1 = this._x0), (this._y1 = this._y0), (this._ += "Z"));
        }, "closePath"),
        lineTo: a(function (e, t) {
          this._ += "L" + (this._x1 = +e) + "," + (this._y1 = +t);
        }, "lineTo"),
        quadraticCurveTo: a(function (e, t, r, n) {
          this._ +=
            "Q" + +e + "," + +t + "," + (this._x1 = +r) + "," + (this._y1 = +n);
        }, "quadraticCurveTo"),
        bezierCurveTo: a(function (e, t, r, n, i, s) {
          this._ +=
            "C" +
            +e +
            "," +
            +t +
            "," +
            +r +
            "," +
            +n +
            "," +
            (this._x1 = +i) +
            "," +
            (this._y1 = +s);
        }, "bezierCurveTo"),
        arcTo: a(function (e, t, r, n, i) {
          ((e = +e), (t = +t), (r = +r), (n = +n), (i = +i));
          var s = this._x1,
            o = this._y1,
            l = r - e,
            u = n - t,
            h = s - e,
            f = o - t,
            d = h * h + f * f;
          if (i < 0) throw new Error("negative radius: " + i);
          if (this._x1 === null)
            this._ += "M" + (this._x1 = e) + "," + (this._y1 = t);
          else if (d > ef)
            if (!(Math.abs(f * l - u * h) > ef) || !i)
              this._ += "L" + (this._x1 = e) + "," + (this._y1 = t);
            else {
              var p = r - s,
                m = n - o,
                g = l * l + u * u,
                y = p * p + m * m,
                b = Math.sqrt(g),
                k = Math.sqrt(d),
                T =
                  i * Math.tan((m8 - Math.acos((g + d - y) / (2 * b * k))) / 2),
                C = T / k,
                L = T / b;
              (Math.abs(C - 1) > ef &&
                (this._ += "L" + (e + C * h) + "," + (t + C * f)),
                (this._ +=
                  "A" +
                  i +
                  "," +
                  i +
                  ",0,0," +
                  +(f * p > h * m) +
                  "," +
                  (this._x1 = e + L * l) +
                  "," +
                  (this._y1 = t + L * u)));
            }
        }, "arcTo"),
        arc: a(function (e, t, r, n, i, s) {
          ((e = +e), (t = +t), (r = +r), (s = !!s));
          var o = r * Math.cos(n),
            l = r * Math.sin(n),
            u = e + o,
            h = t + l,
            f = 1 ^ s,
            d = s ? n - i : i - n;
          if (r < 0) throw new Error("negative radius: " + r);
          (this._x1 === null
            ? (this._ += "M" + u + "," + h)
            : (Math.abs(this._x1 - u) > ef || Math.abs(this._y1 - h) > ef) &&
              (this._ += "L" + u + "," + h),
            r &&
              (d < 0 && (d = (d % g8) + g8),
              d > A8t
                ? (this._ +=
                    "A" +
                    r +
                    "," +
                    r +
                    ",0,1," +
                    f +
                    "," +
                    (e - o) +
                    "," +
                    (t - l) +
                    "A" +
                    r +
                    "," +
                    r +
                    ",0,1," +
                    f +
                    "," +
                    (this._x1 = u) +
                    "," +
                    (this._y1 = h))
                : d > ef &&
                  (this._ +=
                    "A" +
                    r +
                    "," +
                    r +
                    ",0," +
                    +(d >= m8) +
                    "," +
                    f +
                    "," +
                    (this._x1 = e + r * Math.cos(i)) +
                    "," +
                    (this._y1 = t + r * Math.sin(i)))));
        }, "arc"),
        rect: a(function (e, t, r, n) {
          this._ +=
            "M" +
            (this._x0 = this._x1 = +e) +
            "," +
            (this._y0 = this._y1 = +t) +
            "h" +
            +r +
            "v" +
            +n +
            "h" +
            -r +
            "Z";
        }, "rect"),
        toString: a(function () {
          return this._;
        }, "toString"),
      };
      x8 = rat;
    });
  var iat = x(() => {
    "use strict";
    nat();
  });
  function oC(e) {
    return a(function () {
      return e;
    }, "constant");
  }
  var sat = x(() => {
    "use strict";
    a(oC, "default");
  });
  function aat(e) {
    return e[0];
  }
  function oat(e) {
    return e[1];
  }
  var lat = x(() => {
    "use strict";
    a(aat, "x");
    a(oat, "y");
  });
  var cat,
    uat = x(() => {
      "use strict";
      cat = Array.prototype.slice;
    });
  function L8t(e) {
    return e.source;
  }
  function R8t(e) {
    return e.target;
  }
  function D8t(e) {
    var t = L8t,
      r = R8t,
      n = aat,
      i = oat,
      s = null;
    function o() {
      var l,
        u = cat.call(arguments),
        h = t.apply(this, u),
        f = r.apply(this, u);
      if (
        (s || (s = l = x8()),
        e(
          s,
          +n.apply(this, ((u[0] = h), u)),
          +i.apply(this, u),
          +n.apply(this, ((u[0] = f), u)),
          +i.apply(this, u),
        ),
        l)
      )
        return ((s = null), l + "" || null);
    }
    return (
      a(o, "link"),
      (o.source = function (l) {
        return arguments.length ? ((t = l), o) : t;
      }),
      (o.target = function (l) {
        return arguments.length ? ((r = l), o) : r;
      }),
      (o.x = function (l) {
        return arguments.length
          ? ((n = typeof l == "function" ? l : oC(+l)), o)
          : n;
      }),
      (o.y = function (l) {
        return arguments.length
          ? ((i = typeof l == "function" ? l : oC(+l)), o)
          : i;
      }),
      (o.context = function (l) {
        return arguments.length ? ((s = l ?? null), o) : s;
      }),
      o
    );
  }
  function N8t(e, t, r, n, i) {
    (e.moveTo(t, r), e.bezierCurveTo((t = (t + n) / 2), r, t, i, n, i));
  }
  function b8() {
    return D8t(N8t);
  }
  var hat = x(() => {
    "use strict";
    iat();
    uat();
    sat();
    lat();
    a(L8t, "linkSource");
    a(R8t, "linkTarget");
    a(D8t, "link");
    a(N8t, "curveHorizontal");
    a(b8, "linkHorizontal");
  });
  var fat = x(() => {
    "use strict";
    hat();
  });
  function I8t(e) {
    return [e.source.x1, e.y0];
  }
  function M8t(e) {
    return [e.target.x0, e.y1];
  }
  function lC() {
    return b8().source(I8t).target(M8t);
  }
  var dat = x(() => {
    "use strict";
    fat();
    a(I8t, "horizontalSource");
    a(M8t, "horizontalTarget");
    a(lC, "default");
  });
  var pat = x(() => {
    "use strict";
    eat();
    d8();
    dat();
  });
  var Ky,
    mat = x(() => {
      "use strict";
      Ky = class e {
        static {
          a(this, "Uid");
        }
        static {
          this.count = 0;
        }
        static next(t) {
          return new e(t + ++e.count);
        }
        constructor(t) {
          ((this.id = t), (this.href = `#${t}`));
        }
        toString() {
          return "url(" + this.href + ")";
        }
      };
    });
  var O8t,
    P8t,
    gat,
    yat = x(() => {
      "use strict";
      pe();
      Ge();
      pat();
      On();
      mat();
      ((O8t = { left: u8, right: h8, center: f8, justify: Xy }),
        (P8t = a(function (e, t, r, n) {
          let { securityLevel: i, sankey: s } = K(),
            o = wx.sankey,
            l;
          i === "sandbox" && (l = xt("#i" + t));
          let u =
              i === "sandbox"
                ? xt(l.nodes()[0].contentDocument.body)
                : xt("body"),
            h = i === "sandbox" ? u.select(`[id="${t}"]`) : xt(`[id="${t}"]`),
            f = s?.width ?? o.width,
            d = s?.height ?? o.width,
            p = s?.useMaxWidth ?? o.useMaxWidth,
            m = s?.nodeAlignment ?? o.nodeAlignment,
            g = s?.prefix ?? o.prefix,
            y = s?.suffix ?? o.suffix,
            b = s?.showValues ?? o.showValues,
            k = n.db.getGraph(),
            T = O8t[m];
          aC()
            .nodeId((F) => F.id)
            .nodeWidth(10)
            .nodePadding(10 + (b ? 15 : 0))
            .nodeAlign(T)
            .extent([
              [0, 0],
              [f, d],
            ])(k);
          let w = _s(M3);
          h.append("g")
            .attr("class", "nodes")
            .selectAll(".node")
            .data(k.nodes)
            .join("g")
            .attr("class", "node")
            .attr("id", (F) => (F.uid = Ky.next("node-")).id)
            .attr("transform", function (F) {
              return "translate(" + F.x0 + "," + F.y0 + ")";
            })
            .attr("x", (F) => F.x0)
            .attr("y", (F) => F.y0)
            .append("rect")
            .attr("height", (F) => F.y1 - F.y0)
            .attr("width", (F) => F.x1 - F.x0)
            .attr("fill", (F) => w(F.id));
          let D = a(
            ({ id: F, value: S }) =>
              b
                ? `${F}
${g}${Math.round(S * 100) / 100}${y}`
                : F,
            "getText",
          );
          h.append("g")
            .attr("class", "node-labels")
            .attr("font-size", 14)
            .selectAll("text")
            .data(k.nodes)
            .join("text")
            .attr("x", (F) => (F.x0 < f / 2 ? F.x1 + 6 : F.x0 - 6))
            .attr("y", (F) => (F.y1 + F.y0) / 2)
            .attr("dy", `${b ? "0" : "0.35"}em`)
            .attr("text-anchor", (F) => (F.x0 < f / 2 ? "start" : "end"))
            .text(D);
          let G = h
              .append("g")
              .attr("class", "links")
              .attr("fill", "none")
              .attr("stroke-opacity", 0.5)
              .selectAll(".link")
              .data(k.links)
              .join("g")
              .attr("class", "link")
              .style("mix-blend-mode", "multiply"),
            E = s?.linkColor ?? "gradient";
          if (E === "gradient") {
            let F = G.append("linearGradient")
              .attr("id", (S) => (S.uid = Ky.next("linearGradient-")).id)
              .attr("gradientUnits", "userSpaceOnUse")
              .attr("x1", (S) => S.source.x1)
              .attr("x2", (S) => S.target.x0);
            (F.append("stop")
              .attr("offset", "0%")
              .attr("stop-color", (S) => w(S.source.id)),
              F.append("stop")
                .attr("offset", "100%")
                .attr("stop-color", (S) => w(S.target.id)));
          }
          let R;
          switch (E) {
            case "gradient":
              R = a((F) => F.uid, "coloring");
              break;
            case "source":
              R = a((F) => w(F.source.id), "coloring");
              break;
            case "target":
              R = a((F) => w(F.target.id), "coloring");
              break;
            default:
              R = E;
          }
          (G.append("path")
            .attr("d", lC())
            .attr("stroke", R)
            .attr("stroke-width", (F) => Math.max(1, F.width)),
            Ql(void 0, h, 0, p));
        }, "draw")),
        (gat = { draw: P8t }));
    });
  var xat,
    bat = x(() => {
      "use strict";
      xat = a(
        (e) =>
          e
            .replaceAll(/^[^\S\n\r]+|[^\S\n\r]+$/g, "")
            .replaceAll(
              /([\n\r])+/g,
              `
`,
            )
            .trim(),
        "prepareTextForParsing",
      );
    });
  var B8t,
    kat,
    Tat = x(() => {
      "use strict";
      ((B8t = a(
        (e) => `.label {
      font-family: ${e.fontFamily};
    }`,
        "getStyles",
      )),
        (kat = B8t));
    });
  var Sat = {};
  Oe(Sat, { diagram: () => $8t });
  var F8t,
    $8t,
    _at = x(() => {
      "use strict";
      Ust();
      qst();
      yat();
      bat();
      Tat();
      F8t = Hy.parse.bind(Hy);
      Hy.parse = (e) => F8t(xat(e));
      $8t = { styles: kat, parser: Hy, db: jst, renderer: gat };
    });
  var W8t,
    Mm,
    k8 = x(() => {
      "use strict";
      un();
      Ss();
      _e();
      yn();
      ((W8t = ze.packet),
        (Mm = class {
          constructor() {
            this.packet = [];
            this.setAccTitle = Xe;
            this.getAccTitle = tr;
            this.setDiagramTitle = lr;
            this.getDiagramTitle = nr;
            this.getAccDescription = rr;
            this.setAccDescription = er;
          }
          static {
            a(this, "PacketDB");
          }
          getConfig() {
            let t = on({ ...W8t, ...ke().packet });
            return (t.showBits && (t.paddingY += 10), t);
          }
          getPacket() {
            return this.packet;
          }
          pushWord(t) {
            t.length > 0 && this.packet.push(t);
          }
          clear() {
            (Ye(), (this.packet = []));
          }
        }));
    });
  var U8t,
    j8t,
    q8t,
    T8,
    vat = x(() => {
      "use strict";
      jh();
      Vt();
      gm();
      k8();
      ((U8t = 1e4),
        (j8t = a((e, t) => {
          qo(e, t);
          let r = -1,
            n = [],
            i = 1,
            { bitsPerRow: s } = t.getConfig();
          for (let { start: o, end: l, bits: u, label: h } of e.blocks) {
            if (o !== void 0 && l !== void 0 && l < o)
              throw new Error(
                `Packet block ${o} - ${l} is invalid. End must be greater than start.`,
              );
            if (((o ??= r + 1), o !== r + 1))
              throw new Error(
                `Packet block ${o} - ${l ?? o} is not contiguous. It should start from ${r + 1}.`,
              );
            if (u === 0)
              throw new Error(
                `Packet block ${o} is invalid. Cannot have a zero bit field.`,
              );
            for (
              l ??= o + (u ?? 1) - 1,
                u ??= l - o + 1,
                r = l,
                P.debug(`Packet block ${o} - ${r} with label ${h}`);
              n.length <= s + 1 && t.getPacket().length < U8t;

            ) {
              let [f, d] = q8t({ start: o, end: l, bits: u, label: h }, i, s);
              if (
                (n.push(f),
                f.end + 1 === i * s && (t.pushWord(n), (n = []), i++),
                !d)
              )
                break;
              ({ start: o, end: l, bits: u, label: h } = d);
            }
          }
          t.pushWord(n);
        }, "populate")),
        (q8t = a((e, t, r) => {
          if (e.start === void 0)
            throw new Error("start should have been set during first phase");
          if (e.end === void 0)
            throw new Error("end should have been set during first phase");
          if (e.start > e.end)
            throw new Error(
              `Block start ${e.start} is greater than block end ${e.end}.`,
            );
          if (e.end + 1 <= t * r) return [e, void 0];
          let n = t * r - 1,
            i = t * r;
          return [
            { start: e.start, end: n, label: e.label, bits: n - e.start },
            { start: i, end: e.end, label: e.label, bits: e.end - i },
          ];
        }, "getNextFittingBlock")),
        (T8 = {
          parser: { yy: void 0 },
          parse: a(async (e) => {
            let t = await Bs("packet", e),
              r = T8.parser?.yy;
            if (!(r instanceof Mm))
              throw new Error(
                "parser.parser?.yy was not a PacketDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.",
              );
            (P.debug(t), j8t(t, r));
          }, "parse"),
        }));
    });
  var H8t,
    Y8t,
    Eat,
    Aat = x(() => {
      "use strict";
      Fl();
      On();
      ((H8t = a((e, t, r, n) => {
        let i = n.db,
          s = i.getConfig(),
          { rowHeight: o, paddingY: l, bitWidth: u, bitsPerRow: h } = s,
          f = i.getPacket(),
          d = i.getDiagramTitle(),
          p = o + l,
          m = p * (f.length + 1) - (d ? 0 : o),
          g = u * h + 2,
          y = Ei(t);
        (y.attr("viewbox", `0 0 ${g} ${m}`), Ar(y, m, g, s.useMaxWidth));
        for (let [b, k] of f.entries()) Y8t(y, k, b, s);
        y.append("text")
          .text(d)
          .attr("x", g / 2)
          .attr("y", m - p / 2)
          .attr("dominant-baseline", "middle")
          .attr("text-anchor", "middle")
          .attr("class", "packetTitle");
      }, "draw")),
        (Y8t = a(
          (
            e,
            t,
            r,
            {
              rowHeight: n,
              paddingX: i,
              paddingY: s,
              bitWidth: o,
              bitsPerRow: l,
              showBits: u,
            },
          ) => {
            let h = e.append("g"),
              f = r * (n + s) + s;
            for (let d of t) {
              let p = (d.start % l) * o + 1,
                m = (d.end - d.start + 1) * o - i;
              if (
                (h
                  .append("rect")
                  .attr("x", p)
                  .attr("y", f)
                  .attr("width", m)
                  .attr("height", n)
                  .attr("class", "packetBlock"),
                h
                  .append("text")
                  .attr("x", p + m / 2)
                  .attr("y", f + n / 2)
                  .attr("class", "packetLabel")
                  .attr("dominant-baseline", "middle")
                  .attr("text-anchor", "middle")
                  .text(d.label),
                !u)
              )
                continue;
              let g = d.end === d.start,
                y = f - 2;
              (h
                .append("text")
                .attr("x", p + (g ? m / 2 : 0))
                .attr("y", y)
                .attr("class", "packetByte start")
                .attr("dominant-baseline", "auto")
                .attr("text-anchor", g ? "middle" : "start")
                .text(d.start),
                g ||
                  h
                    .append("text")
                    .attr("x", p + m)
                    .attr("y", y)
                    .attr("class", "packetByte end")
                    .attr("dominant-baseline", "auto")
                    .attr("text-anchor", "end")
                    .text(d.end));
            }
          },
          "drawWord",
        )),
        (Eat = { draw: H8t }));
    });
  var X8t,
    Lat,
    Rat = x(() => {
      "use strict";
      _e();
      ((X8t = {
        byteFontSize: "10px",
        startByteColor: "black",
        endByteColor: "black",
        labelColor: "black",
        labelFontSize: "12px",
        titleColor: "black",
        titleFontSize: "14px",
        blockStrokeColor: "black",
        blockStrokeWidth: "1",
        blockFillColor: "#efefef",
      }),
        (Lat = a(({ packet: e } = {}) => {
          let t = on(X8t, e);
          return `
	.packetByte {
		font-size: ${t.byteFontSize};
	}
	.packetByte.start {
		fill: ${t.startByteColor};
	}
	.packetByte.end {
		fill: ${t.endByteColor};
	}
	.packetLabel {
		fill: ${t.labelColor};
		font-size: ${t.labelFontSize};
	}
	.packetTitle {
		fill: ${t.titleColor};
		font-size: ${t.titleFontSize};
	}
	.packetBlock {
		stroke: ${t.blockStrokeColor};
		stroke-width: ${t.blockStrokeWidth};
		fill: ${t.blockFillColor};
	}
	`;
        }, "styles")));
    });
  var Dat = {};
  Oe(Dat, { diagram: () => K8t });
  var K8t,
    Nat = x(() => {
      "use strict";
      k8();
      vat();
      Aat();
      Rat();
      K8t = {
        parser: T8,
        get db() {
          return new Mm();
        },
        renderer: Eat,
        styles: Lat,
      };
    });
  var Om,
    Oat,
    rf,
    J8t,
    tIt,
    Pat,
    eIt,
    rIt,
    nIt,
    iIt,
    sIt,
    aIt,
    oIt,
    nf,
    S8 = x(() => {
      "use strict";
      un();
      Ss();
      _e();
      yn();
      ((Om = {
        showLegend: !0,
        ticks: 5,
        max: null,
        min: 0,
        graticule: "circle",
      }),
        (Oat = { axes: [], curves: [], options: Om }),
        (rf = structuredClone(Oat)),
        (J8t = ze.radar),
        (tIt = a(() => on({ ...J8t, ...ke().radar }), "getConfig")),
        (Pat = a(() => rf.axes, "getAxes")),
        (eIt = a(() => rf.curves, "getCurves")),
        (rIt = a(() => rf.options, "getOptions")),
        (nIt = a((e) => {
          rf.axes = e.map((t) => ({ name: t.name, label: t.label ?? t.name }));
        }, "setAxes")),
        (iIt = a((e) => {
          rf.curves = e.map((t) => ({
            name: t.name,
            label: t.label ?? t.name,
            entries: sIt(t.entries),
          }));
        }, "setCurves")),
        (sIt = a((e) => {
          if (e[0].axis == null) return e.map((r) => r.value);
          let t = Pat();
          if (t.length === 0)
            throw new Error(
              "Axes must be populated before curves for reference entries",
            );
          return t.map((r) => {
            let n = e.find((i) => i.axis?.$refText === r.name);
            if (n === void 0)
              throw new Error("Missing entry for axis " + r.label);
            return n.value;
          });
        }, "computeCurveEntries")),
        (aIt = a((e) => {
          let t = e.reduce((r, n) => ((r[n.name] = n), r), {});
          rf.options = {
            showLegend: t.showLegend?.value ?? Om.showLegend,
            ticks: t.ticks?.value ?? Om.ticks,
            max: t.max?.value ?? Om.max,
            min: t.min?.value ?? Om.min,
            graticule: t.graticule?.value ?? Om.graticule,
          };
        }, "setOptions")),
        (oIt = a(() => {
          (Ye(), (rf = structuredClone(Oat)));
        }, "clear")),
        (nf = {
          getAxes: Pat,
          getCurves: eIt,
          getOptions: rIt,
          setAxes: nIt,
          setCurves: iIt,
          setOptions: aIt,
          getConfig: tIt,
          clear: oIt,
          setAccTitle: Xe,
          getAccTitle: tr,
          setDiagramTitle: lr,
          getDiagramTitle: nr,
          getAccDescription: rr,
          setAccDescription: er,
        }));
    });
  var lIt,
    Bat,
    Fat = x(() => {
      "use strict";
      jh();
      Vt();
      gm();
      S8();
      ((lIt = a((e) => {
        qo(e, nf);
        let { axes: t, curves: r, options: n } = e;
        (nf.setAxes(t), nf.setCurves(r), nf.setOptions(n));
      }, "populate")),
        (Bat = {
          parse: a(async (e) => {
            let t = await Bs("radar", e);
            (P.debug(t), lIt(t));
          }, "parse"),
        }));
    });
  function dIt(e, t, r, n, i, s, o) {
    let l = t.length,
      u = Math.min(o.width, o.height) / 2;
    r.forEach((h, f) => {
      if (h.entries.length !== l) return;
      let d = h.entries.map((p, m) => {
        let g = (2 * Math.PI * m) / l - Math.PI / 2,
          y = pIt(p, n, i, u),
          b = y * Math.cos(g),
          k = y * Math.sin(g);
        return { x: b, y: k };
      });
      s === "circle"
        ? e
            .append("path")
            .attr("d", mIt(d, o.curveTension))
            .attr("class", `radarCurve-${f}`)
        : s === "polygon" &&
          e
            .append("polygon")
            .attr("points", d.map((p) => `${p.x},${p.y}`).join(" "))
            .attr("class", `radarCurve-${f}`);
    });
  }
  function pIt(e, t, r, n) {
    let i = Math.min(Math.max(e, t), r);
    return (n * (i - t)) / (r - t);
  }
  function mIt(e, t) {
    let r = e.length,
      n = `M${e[0].x},${e[0].y}`;
    for (let i = 0; i < r; i++) {
      let s = e[(i - 1 + r) % r],
        o = e[i],
        l = e[(i + 1) % r],
        u = e[(i + 2) % r],
        h = { x: o.x + (l.x - s.x) * t, y: o.y + (l.y - s.y) * t },
        f = { x: l.x - (u.x - o.x) * t, y: l.y - (u.y - o.y) * t };
      n += ` C${h.x},${h.y} ${f.x},${f.y} ${l.x},${l.y}`;
    }
    return `${n} Z`;
  }
  function gIt(e, t, r, n) {
    if (!r) return;
    let i = ((n.width / 2 + n.marginRight) * 3) / 4,
      s = (-(n.height / 2 + n.marginTop) * 3) / 4,
      o = 20;
    t.forEach((l, u) => {
      let h = e.append("g").attr("transform", `translate(${i}, ${s + u * o})`);
      (h
        .append("rect")
        .attr("width", 12)
        .attr("height", 12)
        .attr("class", `radarLegendBox-${u}`),
        h
          .append("text")
          .attr("x", 16)
          .attr("y", 0)
          .attr("class", "radarLegendText")
          .text(l.label));
    });
  }
  var cIt,
    uIt,
    hIt,
    fIt,
    $at,
    Gat = x(() => {
      "use strict";
      Fl();
      ((cIt = a((e, t, r, n) => {
        let i = n.db,
          s = i.getAxes(),
          o = i.getCurves(),
          l = i.getOptions(),
          u = i.getConfig(),
          h = i.getDiagramTitle(),
          f = Ei(t),
          d = uIt(f, u),
          p = l.max ?? Math.max(...o.map((y) => Math.max(...y.entries))),
          m = l.min,
          g = Math.min(u.width, u.height) / 2;
        (hIt(d, s, g, l.ticks, l.graticule),
          fIt(d, s, g, u),
          dIt(d, s, o, m, p, l.graticule, u),
          gIt(d, o, l.showLegend, u),
          d
            .append("text")
            .attr("class", "radarTitle")
            .text(h)
            .attr("x", 0)
            .attr("y", -u.height / 2 - u.marginTop));
      }, "draw")),
        (uIt = a((e, t) => {
          let r = t.width + t.marginLeft + t.marginRight,
            n = t.height + t.marginTop + t.marginBottom,
            i = {
              x: t.marginLeft + t.width / 2,
              y: t.marginTop + t.height / 2,
            };
          return (
            e
              .attr("viewbox", `0 0 ${r} ${n}`)
              .attr("width", r)
              .attr("height", n),
            e.append("g").attr("transform", `translate(${i.x}, ${i.y})`)
          );
        }, "drawFrame")),
        (hIt = a((e, t, r, n, i) => {
          if (i === "circle")
            for (let s = 0; s < n; s++) {
              let o = (r * (s + 1)) / n;
              e.append("circle").attr("r", o).attr("class", "radarGraticule");
            }
          else if (i === "polygon") {
            let s = t.length;
            for (let o = 0; o < n; o++) {
              let l = (r * (o + 1)) / n,
                u = t
                  .map((h, f) => {
                    let d = (2 * f * Math.PI) / s - Math.PI / 2,
                      p = l * Math.cos(d),
                      m = l * Math.sin(d);
                    return `${p},${m}`;
                  })
                  .join(" ");
              e.append("polygon")
                .attr("points", u)
                .attr("class", "radarGraticule");
            }
          }
        }, "drawGraticule")),
        (fIt = a((e, t, r, n) => {
          let i = t.length;
          for (let s = 0; s < i; s++) {
            let o = t[s].label,
              l = (2 * s * Math.PI) / i - Math.PI / 2;
            (e
              .append("line")
              .attr("x1", 0)
              .attr("y1", 0)
              .attr("x2", r * n.axisScaleFactor * Math.cos(l))
              .attr("y2", r * n.axisScaleFactor * Math.sin(l))
              .attr("class", "radarAxisLine"),
              e
                .append("text")
                .text(o)
                .attr("x", r * n.axisLabelFactor * Math.cos(l))
                .attr("y", r * n.axisLabelFactor * Math.sin(l))
                .attr("class", "radarAxisLabel"));
          }
        }, "drawAxes")));
      a(dIt, "drawCurves");
      a(pIt, "relativeRadius");
      a(mIt, "closedRoundCurve");
      a(gIt, "drawLegend");
      $at = { draw: cIt };
    });
  var yIt,
    xIt,
    Vat,
    zat = x(() => {
      "use strict";
      _e();
      Qm();
      un();
      ((yIt = a((e, t) => {
        let r = "";
        for (let n = 0; n < e.THEME_COLOR_LIMIT; n++) {
          let i = e[`cScale${n}`];
          r += `
		.radarCurve-${n} {
			color: ${i};
			fill: ${i};
			fill-opacity: ${t.curveOpacity};
			stroke: ${i};
			stroke-width: ${t.curveStrokeWidth};
		}
		.radarLegendBox-${n} {
			fill: ${i};
			fill-opacity: ${t.curveOpacity};
			stroke: ${i};
		}
		`;
        }
        return r;
      }, "genIndexStyles")),
        (xIt = a((e) => {
          let t = Hl(),
            r = ke(),
            n = on(t, r.themeVariables),
            i = on(n.radar, e);
          return { themeVariables: n, radarOptions: i };
        }, "buildRadarStyleOptions")),
        (Vat = a(({ radar: e } = {}) => {
          let { themeVariables: t, radarOptions: r } = xIt(e);
          return `
	.radarTitle {
		font-size: ${t.fontSize};
		color: ${t.titleColor};
		dominant-baseline: hanging;
		text-anchor: middle;
	}
	.radarAxisLine {
		stroke: ${r.axisColor};
		stroke-width: ${r.axisStrokeWidth};
	}
	.radarAxisLabel {
		dominant-baseline: middle;
		text-anchor: middle;
		font-size: ${r.axisLabelFontSize}px;
		color: ${r.axisColor};
	}
	.radarGraticule {
		fill: ${r.graticuleColor};
		fill-opacity: ${r.graticuleOpacity};
		stroke: ${r.graticuleColor};
		stroke-width: ${r.graticuleStrokeWidth};
	}
	.radarLegendText {
		text-anchor: start;
		font-size: ${r.legendFontSize}px;
		dominant-baseline: hanging;
	}
	${yIt(t, r)}
	`;
        }, "styles")));
    });
  var Wat = {};
  Oe(Wat, { diagram: () => bIt });
  var bIt,
    Uat = x(() => {
      "use strict";
      S8();
      Fat();
      Gat();
      zat();
      bIt = { parser: Bat, db: nf, renderer: $at, styles: Vat };
    });
  var _8,
    Hat,
    Yat = x(() => {
      "use strict";
      _8 = (function () {
        var e = a(function (C, L, w, D) {
            for (w = w || {}, D = C.length; D--; w[C[D]] = L);
            return w;
          }, "o"),
          t = [1, 15],
          r = [1, 7],
          n = [1, 13],
          i = [1, 14],
          s = [1, 19],
          o = [1, 16],
          l = [1, 17],
          u = [1, 18],
          h = [8, 30],
          f = [8, 10, 21, 28, 29, 30, 31, 39, 43, 46],
          d = [1, 23],
          p = [1, 24],
          m = [8, 10, 15, 16, 21, 28, 29, 30, 31, 39, 43, 46],
          g = [8, 10, 15, 16, 21, 27, 28, 29, 30, 31, 39, 43, 46],
          y = [1, 49],
          b = {
            trace: a(function () {}, "trace"),
            yy: {},
            symbols_: {
              error: 2,
              spaceLines: 3,
              SPACELINE: 4,
              NL: 5,
              separator: 6,
              SPACE: 7,
              EOF: 8,
              start: 9,
              BLOCK_DIAGRAM_KEY: 10,
              document: 11,
              stop: 12,
              statement: 13,
              link: 14,
              LINK: 15,
              START_LINK: 16,
              LINK_LABEL: 17,
              STR: 18,
              nodeStatement: 19,
              columnsStatement: 20,
              SPACE_BLOCK: 21,
              blockStatement: 22,
              classDefStatement: 23,
              cssClassStatement: 24,
              styleStatement: 25,
              node: 26,
              SIZE: 27,
              COLUMNS: 28,
              "id-block": 29,
              end: 30,
              NODE_ID: 31,
              nodeShapeNLabel: 32,
              dirList: 33,
              DIR: 34,
              NODE_DSTART: 35,
              NODE_DEND: 36,
              BLOCK_ARROW_START: 37,
              BLOCK_ARROW_END: 38,
              classDef: 39,
              CLASSDEF_ID: 40,
              CLASSDEF_STYLEOPTS: 41,
              DEFAULT: 42,
              class: 43,
              CLASSENTITY_IDS: 44,
              STYLECLASS: 45,
              style: 46,
              STYLE_ENTITY_IDS: 47,
              STYLE_DEFINITION_DATA: 48,
              $accept: 0,
              $end: 1,
            },
            terminals_: {
              2: "error",
              4: "SPACELINE",
              5: "NL",
              7: "SPACE",
              8: "EOF",
              10: "BLOCK_DIAGRAM_KEY",
              15: "LINK",
              16: "START_LINK",
              17: "LINK_LABEL",
              18: "STR",
              21: "SPACE_BLOCK",
              27: "SIZE",
              28: "COLUMNS",
              29: "id-block",
              30: "end",
              31: "NODE_ID",
              34: "DIR",
              35: "NODE_DSTART",
              36: "NODE_DEND",
              37: "BLOCK_ARROW_START",
              38: "BLOCK_ARROW_END",
              39: "classDef",
              40: "CLASSDEF_ID",
              41: "CLASSDEF_STYLEOPTS",
              42: "DEFAULT",
              43: "class",
              44: "CLASSENTITY_IDS",
              45: "STYLECLASS",
              46: "style",
              47: "STYLE_ENTITY_IDS",
              48: "STYLE_DEFINITION_DATA",
            },
            productions_: [
              0,
              [3, 1],
              [3, 2],
              [3, 2],
              [6, 1],
              [6, 1],
              [6, 1],
              [9, 3],
              [12, 1],
              [12, 1],
              [12, 2],
              [12, 2],
              [11, 1],
              [11, 2],
              [14, 1],
              [14, 4],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [13, 1],
              [19, 3],
              [19, 2],
              [19, 1],
              [20, 1],
              [22, 4],
              [22, 3],
              [26, 1],
              [26, 2],
              [33, 1],
              [33, 2],
              [32, 3],
              [32, 4],
              [23, 3],
              [23, 3],
              [24, 3],
              [25, 3],
            ],
            performAction: a(function (L, w, D, G, E, R, F) {
              var S = R.length - 1;
              switch (E) {
                case 4:
                  G.getLogger().debug("Rule: separator (NL) ");
                  break;
                case 5:
                  G.getLogger().debug("Rule: separator (Space) ");
                  break;
                case 6:
                  G.getLogger().debug("Rule: separator (EOF) ");
                  break;
                case 7:
                  (G.getLogger().debug("Rule: hierarchy: ", R[S - 1]),
                    G.setHierarchy(R[S - 1]));
                  break;
                case 8:
                  G.getLogger().debug("Stop NL ");
                  break;
                case 9:
                  G.getLogger().debug("Stop EOF ");
                  break;
                case 10:
                  G.getLogger().debug("Stop NL2 ");
                  break;
                case 11:
                  G.getLogger().debug("Stop EOF2 ");
                  break;
                case 12:
                  (G.getLogger().debug("Rule: statement: ", R[S]),
                    typeof R[S].length == "number"
                      ? (this.$ = R[S])
                      : (this.$ = [R[S]]));
                  break;
                case 13:
                  (G.getLogger().debug("Rule: statement #2: ", R[S - 1]),
                    (this.$ = [R[S - 1]].concat(R[S])));
                  break;
                case 14:
                  (G.getLogger().debug("Rule: link: ", R[S], L),
                    (this.$ = { edgeTypeStr: R[S], label: "" }));
                  break;
                case 15:
                  (G.getLogger().debug(
                    "Rule: LABEL link: ",
                    R[S - 3],
                    R[S - 1],
                    R[S],
                  ),
                    (this.$ = { edgeTypeStr: R[S], label: R[S - 1] }));
                  break;
                case 18:
                  let O = parseInt(R[S]),
                    v = G.generateId();
                  this.$ = {
                    id: v,
                    type: "space",
                    label: "",
                    width: O,
                    children: [],
                  };
                  break;
                case 23:
                  G.getLogger().debug(
                    "Rule: (nodeStatement link node) ",
                    R[S - 2],
                    R[S - 1],
                    R[S],
                    " typestr: ",
                    R[S - 1].edgeTypeStr,
                  );
                  let _ = G.edgeStrToEdgeData(R[S - 1].edgeTypeStr);
                  this.$ = [
                    {
                      id: R[S - 2].id,
                      label: R[S - 2].label,
                      type: R[S - 2].type,
                      directions: R[S - 2].directions,
                    },
                    {
                      id: R[S - 2].id + "-" + R[S].id,
                      start: R[S - 2].id,
                      end: R[S].id,
                      label: R[S - 1].label,
                      type: "edge",
                      directions: R[S].directions,
                      arrowTypeEnd: _,
                      arrowTypeStart: "arrow_open",
                    },
                    {
                      id: R[S].id,
                      label: R[S].label,
                      type: G.typeStr2Type(R[S].typeStr),
                      directions: R[S].directions,
                    },
                  ];
                  break;
                case 24:
                  (G.getLogger().debug(
                    "Rule: nodeStatement (abc88 node size) ",
                    R[S - 1],
                    R[S],
                  ),
                    (this.$ = {
                      id: R[S - 1].id,
                      label: R[S - 1].label,
                      type: G.typeStr2Type(R[S - 1].typeStr),
                      directions: R[S - 1].directions,
                      widthInColumns: parseInt(R[S], 10),
                    }));
                  break;
                case 25:
                  (G.getLogger().debug("Rule: nodeStatement (node) ", R[S]),
                    (this.$ = {
                      id: R[S].id,
                      label: R[S].label,
                      type: G.typeStr2Type(R[S].typeStr),
                      directions: R[S].directions,
                      widthInColumns: 1,
                    }));
                  break;
                case 26:
                  (G.getLogger().debug("APA123", this ? this : "na"),
                    G.getLogger().debug("COLUMNS: ", R[S]),
                    (this.$ = {
                      type: "column-setting",
                      columns: R[S] === "auto" ? -1 : parseInt(R[S]),
                    }));
                  break;
                case 27:
                  G.getLogger().debug(
                    "Rule: id-block statement : ",
                    R[S - 2],
                    R[S - 1],
                  );
                  let A = G.generateId();
                  this.$ = {
                    ...R[S - 2],
                    type: "composite",
                    children: R[S - 1],
                  };
                  break;
                case 28:
                  G.getLogger().debug(
                    "Rule: blockStatement : ",
                    R[S - 2],
                    R[S - 1],
                    R[S],
                  );
                  let N = G.generateId();
                  this.$ = {
                    id: N,
                    type: "composite",
                    label: "",
                    children: R[S - 1],
                  };
                  break;
                case 29:
                  (G.getLogger().debug(
                    "Rule: node (NODE_ID separator): ",
                    R[S],
                  ),
                    (this.$ = { id: R[S] }));
                  break;
                case 30:
                  (G.getLogger().debug(
                    "Rule: node (NODE_ID nodeShapeNLabel separator): ",
                    R[S - 1],
                    R[S],
                  ),
                    (this.$ = {
                      id: R[S - 1],
                      label: R[S].label,
                      typeStr: R[S].typeStr,
                      directions: R[S].directions,
                    }));
                  break;
                case 31:
                  (G.getLogger().debug("Rule: dirList: ", R[S]),
                    (this.$ = [R[S]]));
                  break;
                case 32:
                  (G.getLogger().debug("Rule: dirList: ", R[S - 1], R[S]),
                    (this.$ = [R[S - 1]].concat(R[S])));
                  break;
                case 33:
                  (G.getLogger().debug(
                    "Rule: nodeShapeNLabel: ",
                    R[S - 2],
                    R[S - 1],
                    R[S],
                  ),
                    (this.$ = { typeStr: R[S - 2] + R[S], label: R[S - 1] }));
                  break;
                case 34:
                  (G.getLogger().debug(
                    "Rule: BLOCK_ARROW nodeShapeNLabel: ",
                    R[S - 3],
                    R[S - 2],
                    " #3:",
                    R[S - 1],
                    R[S],
                  ),
                    (this.$ = {
                      typeStr: R[S - 3] + R[S],
                      label: R[S - 2],
                      directions: R[S - 1],
                    }));
                  break;
                case 35:
                case 36:
                  this.$ = {
                    type: "classDef",
                    id: R[S - 1].trim(),
                    css: R[S].trim(),
                  };
                  break;
                case 37:
                  this.$ = {
                    type: "applyClass",
                    id: R[S - 1].trim(),
                    styleClass: R[S].trim(),
                  };
                  break;
                case 38:
                  this.$ = {
                    type: "applyStyles",
                    id: R[S - 1].trim(),
                    stylesStr: R[S].trim(),
                  };
                  break;
              }
            }, "anonymous"),
            table: [
              { 9: 1, 10: [1, 2] },
              { 1: [3] },
              {
                10: t,
                11: 3,
                13: 4,
                19: 5,
                20: 6,
                21: r,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              },
              { 8: [1, 20] },
              e(h, [2, 12], {
                13: 4,
                19: 5,
                20: 6,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                11: 21,
                10: t,
                21: r,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              }),
              e(f, [2, 16], { 14: 22, 15: d, 16: p }),
              e(f, [2, 17]),
              e(f, [2, 18]),
              e(f, [2, 19]),
              e(f, [2, 20]),
              e(f, [2, 21]),
              e(f, [2, 22]),
              e(m, [2, 25], { 27: [1, 25] }),
              e(f, [2, 26]),
              { 19: 26, 26: 12, 31: s },
              {
                10: t,
                11: 27,
                13: 4,
                19: 5,
                20: 6,
                21: r,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              },
              { 40: [1, 28], 42: [1, 29] },
              { 44: [1, 30] },
              { 47: [1, 31] },
              e(g, [2, 29], { 32: 32, 35: [1, 33], 37: [1, 34] }),
              { 1: [2, 7] },
              e(h, [2, 13]),
              { 26: 35, 31: s },
              { 31: [2, 14] },
              { 17: [1, 36] },
              e(m, [2, 24]),
              {
                10: t,
                11: 37,
                13: 4,
                14: 22,
                15: d,
                16: p,
                19: 5,
                20: 6,
                21: r,
                22: 8,
                23: 9,
                24: 10,
                25: 11,
                26: 12,
                28: n,
                29: i,
                31: s,
                39: o,
                43: l,
                46: u,
              },
              { 30: [1, 38] },
              { 41: [1, 39] },
              { 41: [1, 40] },
              { 45: [1, 41] },
              { 48: [1, 42] },
              e(g, [2, 30]),
              { 18: [1, 43] },
              { 18: [1, 44] },
              e(m, [2, 23]),
              { 18: [1, 45] },
              { 30: [1, 46] },
              e(f, [2, 28]),
              e(f, [2, 35]),
              e(f, [2, 36]),
              e(f, [2, 37]),
              e(f, [2, 38]),
              { 36: [1, 47] },
              { 33: 48, 34: y },
              { 15: [1, 50] },
              e(f, [2, 27]),
              e(g, [2, 33]),
              { 38: [1, 51] },
              { 33: 52, 34: y, 38: [2, 31] },
              { 31: [2, 15] },
              e(g, [2, 34]),
              { 38: [2, 32] },
            ],
            defaultActions: {
              20: [2, 7],
              23: [2, 14],
              50: [2, 15],
              52: [2, 32],
            },
            parseError: a(function (L, w) {
              if (w.recoverable) this.trace(L);
              else {
                var D = new Error(L);
                throw ((D.hash = w), D);
              }
            }, "parseError"),
            parse: a(function (L) {
              var w = this,
                D = [0],
                G = [],
                E = [null],
                R = [],
                F = this.table,
                S = "",
                O = 0,
                v = 0,
                _ = 0,
                A = 2,
                N = 1,
                B = R.slice.call(arguments, 1),
                M = Object.create(this.lexer),
                I = { yy: {} };
              for (var V in this.yy)
                Object.prototype.hasOwnProperty.call(this.yy, V) &&
                  (I.yy[V] = this.yy[V]);
              (M.setInput(L, I.yy),
                (I.yy.lexer = M),
                (I.yy.parser = this),
                typeof M.yylloc > "u" && (M.yylloc = {}));
              var $ = M.yylloc;
              R.push($);
              var q = M.options && M.options.ranges;
              typeof I.yy.parseError == "function"
                ? (this.parseError = I.yy.parseError)
                : (this.parseError = Object.getPrototypeOf(this).parseError);
              function tt(gt) {
                ((D.length = D.length - 2 * gt),
                  (E.length = E.length - gt),
                  (R.length = R.length - gt));
              }
              a(tt, "popStack");
              function ht() {
                var gt;
                return (
                  (gt = G.pop() || M.lex() || N),
                  typeof gt != "number" &&
                    (gt instanceof Array && ((G = gt), (gt = G.pop())),
                    (gt = w.symbols_[gt] || gt)),
                  gt
                );
              }
              a(ht, "lex");
              for (var H, kt, ft, yt, ot, dt, nt = {}, Q, et, X, st; ; ) {
                if (
                  ((ft = D[D.length - 1]),
                  this.defaultActions[ft]
                    ? (yt = this.defaultActions[ft])
                    : ((H === null || typeof H > "u") && (H = ht()),
                      (yt = F[ft] && F[ft][H])),
                  typeof yt > "u" || !yt.length || !yt[0])
                ) {
                  var U = "";
                  st = [];
                  for (Q in F[ft])
                    this.terminals_[Q] &&
                      Q > A &&
                      st.push("'" + this.terminals_[Q] + "'");
                  (M.showPosition
                    ? (U =
                        "Parse error on line " +
                        (O + 1) +
                        `:
` +
                        M.showPosition() +
                        `
Expecting ` +
                        st.join(", ") +
                        ", got '" +
                        (this.terminals_[H] || H) +
                        "'")
                    : (U =
                        "Parse error on line " +
                        (O + 1) +
                        ": Unexpected " +
                        (H == N
                          ? "end of input"
                          : "'" + (this.terminals_[H] || H) + "'")),
                    this.parseError(U, {
                      text: M.match,
                      token: this.terminals_[H] || H,
                      line: M.yylineno,
                      loc: $,
                      expected: st,
                    }));
                }
                if (yt[0] instanceof Array && yt.length > 1)
                  throw new Error(
                    "Parse Error: multiple actions possible at state: " +
                      ft +
                      ", token: " +
                      H,
                  );
                switch (yt[0]) {
                  case 1:
                    (D.push(H),
                      E.push(M.yytext),
                      R.push(M.yylloc),
                      D.push(yt[1]),
                      (H = null),
                      kt
                        ? ((H = kt), (kt = null))
                        : ((v = M.yyleng),
                          (S = M.yytext),
                          (O = M.yylineno),
                          ($ = M.yylloc),
                          _ > 0 && _--));
                    break;
                  case 2:
                    if (
                      ((et = this.productions_[yt[1]][1]),
                      (nt.$ = E[E.length - et]),
                      (nt._$ = {
                        first_line: R[R.length - (et || 1)].first_line,
                        last_line: R[R.length - 1].last_line,
                        first_column: R[R.length - (et || 1)].first_column,
                        last_column: R[R.length - 1].last_column,
                      }),
                      q &&
                        (nt._$.range = [
                          R[R.length - (et || 1)].range[0],
                          R[R.length - 1].range[1],
                        ]),
                      (dt = this.performAction.apply(
                        nt,
                        [S, v, O, I.yy, yt[1], E, R].concat(B),
                      )),
                      typeof dt < "u")
                    )
                      return dt;
                    (et &&
                      ((D = D.slice(0, -1 * et * 2)),
                      (E = E.slice(0, -1 * et)),
                      (R = R.slice(0, -1 * et))),
                      D.push(this.productions_[yt[1]][0]),
                      E.push(nt.$),
                      R.push(nt._$),
                      (X = F[D[D.length - 2]][D[D.length - 1]]),
                      D.push(X));
                    break;
                  case 3:
                    return !0;
                }
              }
              return !0;
            }, "parse"),
          },
          k = (function () {
            var C = {
              EOF: 1,
              parseError: a(function (w, D) {
                if (this.yy.parser) this.yy.parser.parseError(w, D);
                else throw new Error(w);
              }, "parseError"),
              setInput: a(function (L, w) {
                return (
                  (this.yy = w || this.yy || {}),
                  (this._input = L),
                  (this._more = this._backtrack = this.done = !1),
                  (this.yylineno = this.yyleng = 0),
                  (this.yytext = this.matched = this.match = ""),
                  (this.conditionStack = ["INITIAL"]),
                  (this.yylloc = {
                    first_line: 1,
                    first_column: 0,
                    last_line: 1,
                    last_column: 0,
                  }),
                  this.options.ranges && (this.yylloc.range = [0, 0]),
                  (this.offset = 0),
                  this
                );
              }, "setInput"),
              input: a(function () {
                var L = this._input[0];
                ((this.yytext += L),
                  this.yyleng++,
                  this.offset++,
                  (this.match += L),
                  (this.matched += L));
                var w = L.match(/(?:\r\n?|\n).*/g);
                return (
                  w
                    ? (this.yylineno++, this.yylloc.last_line++)
                    : this.yylloc.last_column++,
                  this.options.ranges && this.yylloc.range[1]++,
                  (this._input = this._input.slice(1)),
                  L
                );
              }, "input"),
              unput: a(function (L) {
                var w = L.length,
                  D = L.split(/(?:\r\n?|\n)/g);
                ((this._input = L + this._input),
                  (this.yytext = this.yytext.substr(0, this.yytext.length - w)),
                  (this.offset -= w));
                var G = this.match.split(/(?:\r\n?|\n)/g);
                ((this.match = this.match.substr(0, this.match.length - 1)),
                  (this.matched = this.matched.substr(
                    0,
                    this.matched.length - 1,
                  )),
                  D.length - 1 && (this.yylineno -= D.length - 1));
                var E = this.yylloc.range;
                return (
                  (this.yylloc = {
                    first_line: this.yylloc.first_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.first_column,
                    last_column: D
                      ? (D.length === G.length ? this.yylloc.first_column : 0) +
                        G[G.length - D.length].length -
                        D[0].length
                      : this.yylloc.first_column - w,
                  }),
                  this.options.ranges &&
                    (this.yylloc.range = [E[0], E[0] + this.yyleng - w]),
                  (this.yyleng = this.yytext.length),
                  this
                );
              }, "unput"),
              more: a(function () {
                return ((this._more = !0), this);
              }, "more"),
              reject: a(function () {
                if (this.options.backtrack_lexer) this._backtrack = !0;
                else
                  return this.parseError(
                    "Lexical error on line " +
                      (this.yylineno + 1) +
                      `. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).
` +
                      this.showPosition(),
                    { text: "", token: null, line: this.yylineno },
                  );
                return this;
              }, "reject"),
              less: a(function (L) {
                this.unput(this.match.slice(L));
              }, "less"),
              pastInput: a(function () {
                var L = this.matched.substr(
                  0,
                  this.matched.length - this.match.length,
                );
                return (
                  (L.length > 20 ? "..." : "") +
                  L.substr(-20).replace(/\n/g, "")
                );
              }, "pastInput"),
              upcomingInput: a(function () {
                var L = this.match;
                return (
                  L.length < 20 && (L += this._input.substr(0, 20 - L.length)),
                  (L.substr(0, 20) + (L.length > 20 ? "..." : "")).replace(
                    /\n/g,
                    "",
                  )
                );
              }, "upcomingInput"),
              showPosition: a(function () {
                var L = this.pastInput(),
                  w = new Array(L.length + 1).join("-");
                return (
                  L +
                  this.upcomingInput() +
                  `
` +
                  w +
                  "^"
                );
              }, "showPosition"),
              test_match: a(function (L, w) {
                var D, G, E;
                if (
                  (this.options.backtrack_lexer &&
                    ((E = {
                      yylineno: this.yylineno,
                      yylloc: {
                        first_line: this.yylloc.first_line,
                        last_line: this.last_line,
                        first_column: this.yylloc.first_column,
                        last_column: this.yylloc.last_column,
                      },
                      yytext: this.yytext,
                      match: this.match,
                      matches: this.matches,
                      matched: this.matched,
                      yyleng: this.yyleng,
                      offset: this.offset,
                      _more: this._more,
                      _input: this._input,
                      yy: this.yy,
                      conditionStack: this.conditionStack.slice(0),
                      done: this.done,
                    }),
                    this.options.ranges &&
                      (E.yylloc.range = this.yylloc.range.slice(0))),
                  (G = L[0].match(/(?:\r\n?|\n).*/g)),
                  G && (this.yylineno += G.length),
                  (this.yylloc = {
                    first_line: this.yylloc.last_line,
                    last_line: this.yylineno + 1,
                    first_column: this.yylloc.last_column,
                    last_column: G
                      ? G[G.length - 1].length -
                        G[G.length - 1].match(/\r?\n?/)[0].length
                      : this.yylloc.last_column + L[0].length,
                  }),
                  (this.yytext += L[0]),
                  (this.match += L[0]),
                  (this.matches = L),
                  (this.yyleng = this.yytext.length),
                  this.options.ranges &&
                    (this.yylloc.range = [
                      this.offset,
                      (this.offset += this.yyleng),
                    ]),
                  (this._more = !1),
                  (this._backtrack = !1),
                  (this._input = this._input.slice(L[0].length)),
                  (this.matched += L[0]),
                  (D = this.performAction.call(
                    this,
                    this.yy,
                    this,
                    w,
                    this.conditionStack[this.conditionStack.length - 1],
                  )),
                  this.done && this._input && (this.done = !1),
                  D)
                )
                  return D;
                if (this._backtrack) {
                  for (var R in E) this[R] = E[R];
                  return !1;
                }
                return !1;
              }, "test_match"),
              next: a(function () {
                if (this.done) return this.EOF;
                this._input || (this.done = !0);
                var L, w, D, G;
                this._more || ((this.yytext = ""), (this.match = ""));
                for (var E = this._currentRules(), R = 0; R < E.length; R++)
                  if (
                    ((D = this._input.match(this.rules[E[R]])),
                    D && (!w || D[0].length > w[0].length))
                  ) {
                    if (((w = D), (G = R), this.options.backtrack_lexer)) {
                      if (((L = this.test_match(D, E[R])), L !== !1)) return L;
                      if (this._backtrack) {
                        w = !1;
                        continue;
                      } else return !1;
                    } else if (!this.options.flex) break;
                  }
                return w
                  ? ((L = this.test_match(w, E[G])), L !== !1 ? L : !1)
                  : this._input === ""
                    ? this.EOF
                    : this.parseError(
                        "Lexical error on line " +
                          (this.yylineno + 1) +
                          `. Unrecognized text.
` +
                          this.showPosition(),
                        { text: "", token: null, line: this.yylineno },
                      );
              }, "next"),
              lex: a(function () {
                var w = this.next();
                return w || this.lex();
              }, "lex"),
              begin: a(function (w) {
                this.conditionStack.push(w);
              }, "begin"),
              popState: a(function () {
                var w = this.conditionStack.length - 1;
                return w > 0
                  ? this.conditionStack.pop()
                  : this.conditionStack[0];
              }, "popState"),
              _currentRules: a(function () {
                return this.conditionStack.length &&
                  this.conditionStack[this.conditionStack.length - 1]
                  ? this.conditions[
                      this.conditionStack[this.conditionStack.length - 1]
                    ].rules
                  : this.conditions.INITIAL.rules;
              }, "_currentRules"),
              topState: a(function (w) {
                return (
                  (w = this.conditionStack.length - 1 - Math.abs(w || 0)),
                  w >= 0 ? this.conditionStack[w] : "INITIAL"
                );
              }, "topState"),
              pushState: a(function (w) {
                this.begin(w);
              }, "pushState"),
              stateStackSize: a(function () {
                return this.conditionStack.length;
              }, "stateStackSize"),
              options: {},
              performAction: a(function (w, D, G, E) {
                var R = E;
                switch (G) {
                  case 0:
                    return (w.getLogger().debug("Found block-beta"), 10);
                    break;
                  case 1:
                    return (w.getLogger().debug("Found id-block"), 29);
                    break;
                  case 2:
                    return (w.getLogger().debug("Found block"), 10);
                    break;
                  case 3:
                    w.getLogger().debug(".", D.yytext);
                    break;
                  case 4:
                    w.getLogger().debug("_", D.yytext);
                    break;
                  case 5:
                    return 5;
                  case 6:
                    return ((D.yytext = -1), 28);
                    break;
                  case 7:
                    return (
                      (D.yytext = D.yytext.replace(/columns\s+/, "")),
                      w.getLogger().debug("COLUMNS (LEX)", D.yytext),
                      28
                    );
                    break;
                  case 8:
                    this.pushState("md_string");
                    break;
                  case 9:
                    return "MD_STR";
                  case 10:
                    this.popState();
                    break;
                  case 11:
                    this.pushState("string");
                    break;
                  case 12:
                    (w.getLogger().debug("LEX: POPPING STR:", D.yytext),
                      this.popState());
                    break;
                  case 13:
                    return (
                      w.getLogger().debug("LEX: STR end:", D.yytext),
                      "STR"
                    );
                    break;
                  case 14:
                    return (
                      (D.yytext = D.yytext.replace(/space\:/, "")),
                      w.getLogger().debug("SPACE NUM (LEX)", D.yytext),
                      21
                    );
                    break;
                  case 15:
                    return (
                      (D.yytext = "1"),
                      w.getLogger().debug("COLUMNS (LEX)", D.yytext),
                      21
                    );
                    break;
                  case 16:
                    return 42;
                  case 17:
                    return "LINKSTYLE";
                  case 18:
                    return "INTERPOLATE";
                  case 19:
                    return (this.pushState("CLASSDEF"), 39);
                    break;
                  case 20:
                    return (
                      this.popState(),
                      this.pushState("CLASSDEFID"),
                      "DEFAULT_CLASSDEF_ID"
                    );
                    break;
                  case 21:
                    return (this.popState(), this.pushState("CLASSDEFID"), 40);
                    break;
                  case 22:
                    return (this.popState(), 41);
                    break;
                  case 23:
                    return (this.pushState("CLASS"), 43);
                    break;
                  case 24:
                    return (this.popState(), this.pushState("CLASS_STYLE"), 44);
                    break;
                  case 25:
                    return (this.popState(), 45);
                    break;
                  case 26:
                    return (this.pushState("STYLE_STMNT"), 46);
                    break;
                  case 27:
                    return (
                      this.popState(),
                      this.pushState("STYLE_DEFINITION"),
                      47
                    );
                    break;
                  case 28:
                    return (this.popState(), 48);
                    break;
                  case 29:
                    return (this.pushState("acc_title"), "acc_title");
                    break;
                  case 30:
                    return (this.popState(), "acc_title_value");
                    break;
                  case 31:
                    return (this.pushState("acc_descr"), "acc_descr");
                    break;
                  case 32:
                    return (this.popState(), "acc_descr_value");
                    break;
                  case 33:
                    this.pushState("acc_descr_multiline");
                    break;
                  case 34:
                    this.popState();
                    break;
                  case 35:
                    return "acc_descr_multiline_value";
                  case 36:
                    return 30;
                  case 37:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: (("),
                      "NODE_DEND"
                    );
                    break;
                  case 38:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: (("),
                      "NODE_DEND"
                    );
                    break;
                  case 39:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: ))"),
                      "NODE_DEND"
                    );
                    break;
                  case 40:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: (("),
                      "NODE_DEND"
                    );
                    break;
                  case 41:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: (("),
                      "NODE_DEND"
                    );
                    break;
                  case 42:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: (-"),
                      "NODE_DEND"
                    );
                    break;
                  case 43:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: -)"),
                      "NODE_DEND"
                    );
                    break;
                  case 44:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: (("),
                      "NODE_DEND"
                    );
                    break;
                  case 45:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: ]]"),
                      "NODE_DEND"
                    );
                    break;
                  case 46:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: ("),
                      "NODE_DEND"
                    );
                    break;
                  case 47:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: ])"),
                      "NODE_DEND"
                    );
                    break;
                  case 48:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: /]"),
                      "NODE_DEND"
                    );
                    break;
                  case 49:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: /]"),
                      "NODE_DEND"
                    );
                    break;
                  case 50:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: )]"),
                      "NODE_DEND"
                    );
                    break;
                  case 51:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: )"),
                      "NODE_DEND"
                    );
                    break;
                  case 52:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: ]>"),
                      "NODE_DEND"
                    );
                    break;
                  case 53:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: ]"),
                      "NODE_DEND"
                    );
                    break;
                  case 54:
                    return (
                      w.getLogger().debug("Lexa: -)"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 55:
                    return (
                      w.getLogger().debug("Lexa: (-"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 56:
                    return (
                      w.getLogger().debug("Lexa: ))"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 57:
                    return (
                      w.getLogger().debug("Lexa: )"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 58:
                    return (
                      w.getLogger().debug("Lex: ((("),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 59:
                    return (
                      w.getLogger().debug("Lexa: )"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 60:
                    return (
                      w.getLogger().debug("Lexa: )"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 61:
                    return (
                      w.getLogger().debug("Lexa: )"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 62:
                    return (
                      w.getLogger().debug("Lexc: >"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 63:
                    return (
                      w.getLogger().debug("Lexa: (["),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 64:
                    return (
                      w.getLogger().debug("Lexa: )"),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 65:
                    return (this.pushState("NODE"), 35);
                    break;
                  case 66:
                    return (this.pushState("NODE"), 35);
                    break;
                  case 67:
                    return (this.pushState("NODE"), 35);
                    break;
                  case 68:
                    return (this.pushState("NODE"), 35);
                    break;
                  case 69:
                    return (this.pushState("NODE"), 35);
                    break;
                  case 70:
                    return (this.pushState("NODE"), 35);
                    break;
                  case 71:
                    return (this.pushState("NODE"), 35);
                    break;
                  case 72:
                    return (
                      w.getLogger().debug("Lexa: ["),
                      this.pushState("NODE"),
                      35
                    );
                    break;
                  case 73:
                    return (
                      this.pushState("BLOCK_ARROW"),
                      w.getLogger().debug("LEX ARR START"),
                      37
                    );
                    break;
                  case 74:
                    return (w.getLogger().debug("Lex: NODE_ID", D.yytext), 31);
                    break;
                  case 75:
                    return (w.getLogger().debug("Lex: EOF", D.yytext), 8);
                    break;
                  case 76:
                    this.pushState("md_string");
                    break;
                  case 77:
                    this.pushState("md_string");
                    break;
                  case 78:
                    return "NODE_DESCR";
                  case 79:
                    this.popState();
                    break;
                  case 80:
                    (w.getLogger().debug("Lex: Starting string"),
                      this.pushState("string"));
                    break;
                  case 81:
                    (w.getLogger().debug("LEX ARR: Starting string"),
                      this.pushState("string"));
                    break;
                  case 82:
                    return (
                      w.getLogger().debug("LEX: NODE_DESCR:", D.yytext),
                      "NODE_DESCR"
                    );
                    break;
                  case 83:
                    (w.getLogger().debug("LEX POPPING"), this.popState());
                    break;
                  case 84:
                    (w.getLogger().debug("Lex: =>BAE"),
                      this.pushState("ARROW_DIR"));
                    break;
                  case 85:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, "")),
                      w.getLogger().debug("Lex (right): dir:", D.yytext),
                      "DIR"
                    );
                    break;
                  case 86:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, "")),
                      w.getLogger().debug("Lex (left):", D.yytext),
                      "DIR"
                    );
                    break;
                  case 87:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, "")),
                      w.getLogger().debug("Lex (x):", D.yytext),
                      "DIR"
                    );
                    break;
                  case 88:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, "")),
                      w.getLogger().debug("Lex (y):", D.yytext),
                      "DIR"
                    );
                    break;
                  case 89:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, "")),
                      w.getLogger().debug("Lex (up):", D.yytext),
                      "DIR"
                    );
                    break;
                  case 90:
                    return (
                      (D.yytext = D.yytext.replace(/^,\s*/, "")),
                      w.getLogger().debug("Lex (down):", D.yytext),
                      "DIR"
                    );
                    break;
                  case 91:
                    return (
                      (D.yytext = "]>"),
                      w.getLogger().debug("Lex (ARROW_DIR end):", D.yytext),
                      this.popState(),
                      this.popState(),
                      "BLOCK_ARROW_END"
                    );
                    break;
                  case 92:
                    return (
                      w.getLogger().debug("Lex: LINK", "#" + D.yytext + "#"),
                      15
                    );
                    break;
                  case 93:
                    return (w.getLogger().debug("Lex: LINK", D.yytext), 15);
                    break;
                  case 94:
                    return (w.getLogger().debug("Lex: LINK", D.yytext), 15);
                    break;
                  case 95:
                    return (w.getLogger().debug("Lex: LINK", D.yytext), 15);
                    break;
                  case 96:
                    return (
                      w.getLogger().debug("Lex: START_LINK", D.yytext),
                      this.pushState("LLABEL"),
                      16
                    );
                    break;
                  case 97:
                    return (
                      w.getLogger().debug("Lex: START_LINK", D.yytext),
                      this.pushState("LLABEL"),
                      16
                    );
                    break;
                  case 98:
                    return (
                      w.getLogger().debug("Lex: START_LINK", D.yytext),
                      this.pushState("LLABEL"),
                      16
                    );
                    break;
                  case 99:
                    this.pushState("md_string");
                    break;
                  case 100:
                    return (
                      w.getLogger().debug("Lex: Starting string"),
                      this.pushState("string"),
                      "LINK_LABEL"
                    );
                    break;
                  case 101:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: LINK", "#" + D.yytext + "#"),
                      15
                    );
                    break;
                  case 102:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: LINK", D.yytext),
                      15
                    );
                    break;
                  case 103:
                    return (
                      this.popState(),
                      w.getLogger().debug("Lex: LINK", D.yytext),
                      15
                    );
                    break;
                  case 104:
                    return (
                      w.getLogger().debug("Lex: COLON", D.yytext),
                      (D.yytext = D.yytext.slice(1)),
                      27
                    );
                    break;
                }
              }, "anonymous"),
              rules: [
                /^(?:block-beta\b)/,
                /^(?:block:)/,
                /^(?:block\b)/,
                /^(?:[\s]+)/,
                /^(?:[\n]+)/,
                /^(?:((\u000D\u000A)|(\u000A)))/,
                /^(?:columns\s+auto\b)/,
                /^(?:columns\s+[\d]+)/,
                /^(?:["][`])/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^"]*)/,
                /^(?:space[:]\d+)/,
                /^(?:space\b)/,
                /^(?:default\b)/,
                /^(?:linkStyle\b)/,
                /^(?:interpolate\b)/,
                /^(?:classDef\s+)/,
                /^(?:DEFAULT\s+)/,
                /^(?:\w+\s+)/,
                /^(?:[^\n]*)/,
                /^(?:class\s+)/,
                /^(?:(\w+)+((,\s*\w+)*))/,
                /^(?:[^\n]*)/,
                /^(?:style\s+)/,
                /^(?:(\w+)+((,\s*\w+)*))/,
                /^(?:[^\n]*)/,
                /^(?:accTitle\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*:\s*)/,
                /^(?:(?!\n||)*[^\n]*)/,
                /^(?:accDescr\s*\{\s*)/,
                /^(?:[\}])/,
                /^(?:[^\}]*)/,
                /^(?:end\b\s*)/,
                /^(?:\(\(\()/,
                /^(?:\)\)\))/,
                /^(?:[\)]\))/,
                /^(?:\}\})/,
                /^(?:\})/,
                /^(?:\(-)/,
                /^(?:-\))/,
                /^(?:\(\()/,
                /^(?:\]\])/,
                /^(?:\()/,
                /^(?:\]\))/,
                /^(?:\\\])/,
                /^(?:\/\])/,
                /^(?:\)\])/,
                /^(?:[\)])/,
                /^(?:\]>)/,
                /^(?:[\]])/,
                /^(?:-\))/,
                /^(?:\(-)/,
                /^(?:\)\))/,
                /^(?:\))/,
                /^(?:\(\(\()/,
                /^(?:\(\()/,
                /^(?:\{\{)/,
                /^(?:\{)/,
                /^(?:>)/,
                /^(?:\(\[)/,
                /^(?:\()/,
                /^(?:\[\[)/,
                /^(?:\[\|)/,
                /^(?:\[\()/,
                /^(?:\)\)\))/,
                /^(?:\[\\)/,
                /^(?:\[\/)/,
                /^(?:\[\\)/,
                /^(?:\[)/,
                /^(?:<\[)/,
                /^(?:[^\(\[\n\-\)\{\}\s\<\>:]+)/,
                /^(?:$)/,
                /^(?:["][`])/,
                /^(?:["][`])/,
                /^(?:[^`"]+)/,
                /^(?:[`]["])/,
                /^(?:["])/,
                /^(?:["])/,
                /^(?:[^"]+)/,
                /^(?:["])/,
                /^(?:\]>\s*\()/,
                /^(?:,?\s*right\s*)/,
                /^(?:,?\s*left\s*)/,
                /^(?:,?\s*x\s*)/,
                /^(?:,?\s*y\s*)/,
                /^(?:,?\s*up\s*)/,
                /^(?:,?\s*down\s*)/,
                /^(?:\)\s*)/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?:\s*~~[\~]+\s*)/,
                /^(?:\s*[xo<]?--\s*)/,
                /^(?:\s*[xo<]?==\s*)/,
                /^(?:\s*[xo<]?-\.\s*)/,
                /^(?:["][`])/,
                /^(?:["])/,
                /^(?:\s*[xo<]?--+[-xo>]\s*)/,
                /^(?:\s*[xo<]?==+[=xo>]\s*)/,
                /^(?:\s*[xo<]?-?\.+-[xo>]?\s*)/,
                /^(?::\d+)/,
              ],
              conditions: {
                STYLE_DEFINITION: { rules: [28], inclusive: !1 },
                STYLE_STMNT: { rules: [27], inclusive: !1 },
                CLASSDEFID: { rules: [22], inclusive: !1 },
                CLASSDEF: { rules: [20, 21], inclusive: !1 },
                CLASS_STYLE: { rules: [25], inclusive: !1 },
                CLASS: { rules: [24], inclusive: !1 },
                LLABEL: { rules: [99, 100, 101, 102, 103], inclusive: !1 },
                ARROW_DIR: {
                  rules: [85, 86, 87, 88, 89, 90, 91],
                  inclusive: !1,
                },
                BLOCK_ARROW: { rules: [76, 81, 84], inclusive: !1 },
                NODE: {
                  rules: [
                    37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51,
                    52, 53, 77, 80,
                  ],
                  inclusive: !1,
                },
                md_string: { rules: [9, 10, 78, 79], inclusive: !1 },
                space: { rules: [], inclusive: !1 },
                string: { rules: [12, 13, 82, 83], inclusive: !1 },
                acc_descr_multiline: { rules: [34, 35], inclusive: !1 },
                acc_descr: { rules: [32], inclusive: !1 },
                acc_title: { rules: [30], inclusive: !1 },
                INITIAL: {
                  rules: [
                    0, 1, 2, 3, 4, 5, 6, 7, 8, 11, 14, 15, 16, 17, 18, 19, 23,
                    26, 29, 31, 33, 36, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63,
                    64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 92, 93, 94,
                    95, 96, 97, 98, 104,
                  ],
                  inclusive: !0,
                },
              },
            };
            return C;
          })();
        b.lexer = k;
        function T() {
          this.yy = {};
        }
        return (a(T, "Parser"), (T.prototype = b), (b.Parser = T), new T());
      })();
      _8.parser = _8;
      Hat = _8;
    });
  function LIt(e) {
    switch ((P.debug("typeStr2Type", e), e)) {
      case "[]":
        return "square";
      case "()":
        return (P.debug("we have a round"), "round");
      case "(())":
        return "circle";
      case ">]":
        return "rect_left_inv_arrow";
      case "{}":
        return "diamond";
      case "{{}}":
        return "hexagon";
      case "([])":
        return "stadium";
      case "[[]]":
        return "subroutine";
      case "[()]":
        return "cylinder";
      case "((()))":
        return "doublecircle";
      case "[//]":
        return "lean_right";
      case "[\\\\]":
        return "lean_left";
      case "[/\\]":
        return "trapezoid";
      case "[\\/]":
        return "inv_trapezoid";
      case "<[]>":
        return "block_arrow";
      default:
        return "na";
    }
  }
  function RIt(e) {
    switch ((P.debug("typeStr2Type", e), e)) {
      case "==":
        return "thick";
      default:
        return "normal";
    }
  }
  function DIt(e) {
    switch (e.replace(/^[\s-]+|[\s-]+$/g, "")) {
      case "x":
        return "arrow_cross";
      case "o":
        return "arrow_circle";
      case ">":
        return "arrow_point";
      default:
        return "";
    }
  }
  var Za,
    w8,
    C8,
    Xat,
    Kat,
    SIt,
    Zat,
    _It,
    cC,
    CIt,
    wIt,
    vIt,
    EIt,
    Jat,
    v8,
    Qy,
    AIt,
    Qat,
    NIt,
    IIt,
    MIt,
    OIt,
    PIt,
    BIt,
    FIt,
    $It,
    GIt,
    VIt,
    zIt,
    tot,
    eot = x(() => {
      "use strict";
      QA();
      un();
      pe();
      Vt();
      Be();
      yn();
      ((Za = new Map()),
        (w8 = []),
        (C8 = new Map()),
        (Xat = "color"),
        (Kat = "fill"),
        (SIt = "bgFill"),
        (Zat = ","),
        (_It = K()),
        (cC = new Map()),
        (CIt = a((e) => Rt.sanitizeText(e, _It), "sanitizeText")),
        (wIt = a(function (e, t = "") {
          let r = cC.get(e);
          (r || ((r = { id: e, styles: [], textStyles: [] }), cC.set(e, r)),
            t?.split(Zat).forEach((n) => {
              let i = n.replace(/([^;]*);/, "$1").trim();
              if (RegExp(Xat).exec(n)) {
                let o = i.replace(Kat, SIt).replace(Xat, Kat);
                r.textStyles.push(o);
              }
              r.styles.push(i);
            }));
        }, "addStyleClass")),
        (vIt = a(function (e, t = "") {
          let r = Za.get(e);
          t != null && (r.styles = t.split(Zat));
        }, "addStyle2Node")),
        (EIt = a(function (e, t) {
          e.split(",").forEach(function (r) {
            let n = Za.get(r);
            if (n === void 0) {
              let i = r.trim();
              ((n = { id: i, type: "na", children: [] }), Za.set(i, n));
            }
            (n.classes || (n.classes = []), n.classes.push(t));
          });
        }, "setCssClass")),
        (Jat = a((e, t) => {
          let r = e.flat(),
            n = [],
            s = r.find((o) => o?.type === "column-setting")?.columns ?? -1;
          for (let o of r) {
            if (
              (typeof s == "number" &&
                s > 0 &&
                o.type !== "column-setting" &&
                typeof o.widthInColumns == "number" &&
                o.widthInColumns > s &&
                P.warn(
                  `Block ${o.id} width ${o.widthInColumns} exceeds configured column width ${s}`,
                ),
              o.label && (o.label = CIt(o.label)),
              o.type === "classDef")
            ) {
              wIt(o.id, o.css);
              continue;
            }
            if (o.type === "applyClass") {
              EIt(o.id, o?.styleClass ?? "");
              continue;
            }
            if (o.type === "applyStyles") {
              o?.stylesStr && vIt(o.id, o?.stylesStr);
              continue;
            }
            if (o.type === "column-setting") t.columns = o.columns ?? -1;
            else if (o.type === "edge") {
              let l = (C8.get(o.id) ?? 0) + 1;
              (C8.set(o.id, l), (o.id = l + "-" + o.id), w8.push(o));
            } else {
              o.label ||
                (o.type === "composite" ? (o.label = "") : (o.label = o.id));
              let l = Za.get(o.id);
              if (
                (l === void 0
                  ? Za.set(o.id, o)
                  : (o.type !== "na" && (l.type = o.type),
                    o.label !== o.id && (l.label = o.label)),
                o.children && Jat(o.children, o),
                o.type === "space")
              ) {
                let u = o.width ?? 1;
                for (let h = 0; h < u; h++) {
                  let f = Sr(o);
                  ((f.id = f.id + "-" + h), Za.set(f.id, f), n.push(f));
                }
              } else l === void 0 && n.push(o);
            }
          }
          t.children = n;
        }, "populateBlockDatabase")),
        (v8 = []),
        (Qy = { id: "root", type: "composite", children: [], columns: -1 }),
        (AIt = a(() => {
          (P.debug("Clear called"),
            Ye(),
            (Qy = { id: "root", type: "composite", children: [], columns: -1 }),
            (Za = new Map([["root", Qy]])),
            (v8 = []),
            (cC = new Map()),
            (w8 = []),
            (C8 = new Map()));
        }, "clear")));
      a(LIt, "typeStr2Type");
      a(RIt, "edgeTypeStr2Type");
      a(DIt, "edgeStrToEdgeData");
      ((Qat = 0),
        (NIt = a(
          () => (
            Qat++,
            "id-" + Math.random().toString(36).substr(2, 12) + "-" + Qat
          ),
          "generateId",
        )),
        (IIt = a((e) => {
          ((Qy.children = e), Jat(e, Qy), (v8 = Qy.children));
        }, "setHierarchy")),
        (MIt = a((e) => {
          let t = Za.get(e);
          return t
            ? t.columns
              ? t.columns
              : t.children
                ? t.children.length
                : -1
            : -1;
        }, "getColumns")),
        (OIt = a(() => [...Za.values()], "getBlocksFlat")),
        (PIt = a(() => v8 || [], "getBlocks")),
        (BIt = a(() => w8, "getEdges")),
        (FIt = a((e) => Za.get(e), "getBlock")),
        ($It = a((e) => {
          Za.set(e.id, e);
        }, "setBlock")),
        (GIt = a(() => P, "getLogger")),
        (VIt = a(function () {
          return cC;
        }, "getClasses")),
        (zIt = {
          getConfig: a(() => ke().block, "getConfig"),
          typeStr2Type: LIt,
          edgeTypeStr2Type: RIt,
          edgeStrToEdgeData: DIt,
          getLogger: GIt,
          getBlocksFlat: OIt,
          getBlocks: PIt,
          getEdges: BIt,
          setHierarchy: IIt,
          getBlock: FIt,
          setBlock: $It,
          getColumns: MIt,
          getClasses: VIt,
          clear: AIt,
          generateId: NIt,
        }),
        (tot = zIt));
    });
  var uC,
    WIt,
    rot,
    not = x(() => {
      "use strict";
      Us();
      Md();
      ((uC = a((e, t) => {
        let r = gu,
          n = r(e, "r"),
          i = r(e, "g"),
          s = r(e, "b");
        return Di(n, i, s, t);
      }, "fade")),
        (WIt = a(
          (e) => `.label {
    font-family: ${e.fontFamily};
    color: ${e.nodeTextColor || e.textColor};
  }
  .cluster-label text {
    fill: ${e.titleColor};
  }
  .cluster-label span,p {
    color: ${e.titleColor};
  }



  .label text,span,p {
    fill: ${e.nodeTextColor || e.textColor};
    color: ${e.nodeTextColor || e.textColor};
  }

  .node rect,
  .node circle,
  .node ellipse,
  .node polygon,
  .node path {
    fill: ${e.mainBkg};
    stroke: ${e.nodeBorder};
    stroke-width: 1px;
  }
  .flowchart-label text {
    text-anchor: middle;
  }
  // .flowchart-label .text-outer-tspan {
  //   text-anchor: middle;
  // }
  // .flowchart-label .text-inner-tspan {
  //   text-anchor: start;
  // }

  .node .label {
    text-align: center;
  }
  .node.clickable {
    cursor: pointer;
  }

  .arrowheadPath {
    fill: ${e.arrowheadColor};
  }

  .edgePath .path {
    stroke: ${e.lineColor};
    stroke-width: 2.0px;
  }

  .flowchart-link {
    stroke: ${e.lineColor};
    fill: none;
  }

  .edgeLabel {
    background-color: ${e.edgeLabelBackground};
    rect {
      opacity: 0.5;
      background-color: ${e.edgeLabelBackground};
      fill: ${e.edgeLabelBackground};
    }
    text-align: center;
  }

  /* For html labels only */
  .labelBkg {
    background-color: ${uC(e.edgeLabelBackground, 0.5)};
    // background-color:
  }

  .node .cluster {
    // fill: ${uC(e.mainBkg, 0.5)};
    fill: ${uC(e.clusterBkg, 0.5)};
    stroke: ${uC(e.clusterBorder, 0.2)};
    box-shadow: rgba(50, 50, 93, 0.25) 0px 13px 27px -5px, rgba(0, 0, 0, 0.3) 0px 8px 16px -8px;
    stroke-width: 1px;
  }

  .cluster text {
    fill: ${e.titleColor};
  }

  .cluster span,p {
    color: ${e.titleColor};
  }
  /* .cluster div {
    color: ${e.titleColor};
  } */

  div.mermaidTooltip {
    position: absolute;
    text-align: center;
    max-width: 200px;
    padding: 2px;
    font-family: ${e.fontFamily};
    font-size: 12px;
    background: ${e.tertiaryColor};
    border: 1px solid ${e.border2};
    border-radius: 2px;
    pointer-events: none;
    z-index: 100;
  }

  .flowchartTitleText {
    text-anchor: middle;
    font-size: 18px;
    fill: ${e.textColor};
  }
  ${Io()}
`,
          "getStyles",
        )),
        (rot = WIt));
    });
  var UIt,
    jIt,
    qIt,
    HIt,
    YIt,
    XIt,
    KIt,
    QIt,
    ZIt,
    JIt,
    t7t,
    iot,
    sot = x(() => {
      "use strict";
      Vt();
      ((UIt = a((e, t, r, n) => {
        t.forEach((i) => {
          t7t[i](e, r, n);
        });
      }, "insertMarkers")),
        (jIt = a((e, t, r) => {
          (P.trace("Making markers for ", r),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-extensionStart")
              .attr("class", "marker extension " + t)
              .attr("refX", 18)
              .attr("refY", 7)
              .attr("markerWidth", 190)
              .attr("markerHeight", 240)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 1,7 L18,13 V 1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-extensionEnd")
              .attr("class", "marker extension " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 1,1 V 13 L18,7 Z"));
        }, "extension")),
        (qIt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-compositionStart")
            .attr("class", "marker composition " + t)
            .attr("refX", 18)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-compositionEnd")
              .attr("class", "marker composition " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"));
        }, "composition")),
        (HIt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-aggregationStart")
            .attr("class", "marker aggregation " + t)
            .attr("refX", 18)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-aggregationEnd")
              .attr("class", "marker aggregation " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 18,7 L9,13 L1,7 L9,1 Z"));
        }, "aggregation")),
        (YIt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-dependencyStart")
            .attr("class", "marker dependency " + t)
            .attr("refX", 6)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 5,7 L9,13 L1,7 L9,1 Z"),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-dependencyEnd")
              .attr("class", "marker dependency " + t)
              .attr("refX", 13)
              .attr("refY", 7)
              .attr("markerWidth", 20)
              .attr("markerHeight", 28)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 18,7 L9,13 L14,7 L9,1 Z"));
        }, "dependency")),
        (XIt = a((e, t, r) => {
          (e
            .append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-lollipopStart")
            .attr("class", "marker lollipop " + t)
            .attr("refX", 13)
            .attr("refY", 7)
            .attr("markerWidth", 190)
            .attr("markerHeight", 240)
            .attr("orient", "auto")
            .append("circle")
            .attr("stroke", "black")
            .attr("fill", "transparent")
            .attr("cx", 7)
            .attr("cy", 7)
            .attr("r", 6),
            e
              .append("defs")
              .append("marker")
              .attr("id", r + "_" + t + "-lollipopEnd")
              .attr("class", "marker lollipop " + t)
              .attr("refX", 1)
              .attr("refY", 7)
              .attr("markerWidth", 190)
              .attr("markerHeight", 240)
              .attr("orient", "auto")
              .append("circle")
              .attr("stroke", "black")
              .attr("fill", "transparent")
              .attr("cx", 7)
              .attr("cy", 7)
              .attr("r", 6));
        }, "lollipop")),
        (KIt = a((e, t, r) => {
          (e
            .append("marker")
            .attr("id", r + "_" + t + "-pointEnd")
            .attr("class", "marker " + t)
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 6)
            .attr("refY", 5)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 12)
            .attr("markerHeight", 12)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 0 0 L 10 5 L 0 10 z")
            .attr("class", "arrowMarkerPath")
            .style("stroke-width", 1)
            .style("stroke-dasharray", "1,0"),
            e
              .append("marker")
              .attr("id", r + "_" + t + "-pointStart")
              .attr("class", "marker " + t)
              .attr("viewBox", "0 0 10 10")
              .attr("refX", 4.5)
              .attr("refY", 5)
              .attr("markerUnits", "userSpaceOnUse")
              .attr("markerWidth", 12)
              .attr("markerHeight", 12)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 0 5 L 10 10 L 10 0 z")
              .attr("class", "arrowMarkerPath")
              .style("stroke-width", 1)
              .style("stroke-dasharray", "1,0"));
        }, "point")),
        (QIt = a((e, t, r) => {
          (e
            .append("marker")
            .attr("id", r + "_" + t + "-circleEnd")
            .attr("class", "marker " + t)
            .attr("viewBox", "0 0 10 10")
            .attr("refX", 11)
            .attr("refY", 5)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 11)
            .attr("markerHeight", 11)
            .attr("orient", "auto")
            .append("circle")
            .attr("cx", "5")
            .attr("cy", "5")
            .attr("r", "5")
            .attr("class", "arrowMarkerPath")
            .style("stroke-width", 1)
            .style("stroke-dasharray", "1,0"),
            e
              .append("marker")
              .attr("id", r + "_" + t + "-circleStart")
              .attr("class", "marker " + t)
              .attr("viewBox", "0 0 10 10")
              .attr("refX", -1)
              .attr("refY", 5)
              .attr("markerUnits", "userSpaceOnUse")
              .attr("markerWidth", 11)
              .attr("markerHeight", 11)
              .attr("orient", "auto")
              .append("circle")
              .attr("cx", "5")
              .attr("cy", "5")
              .attr("r", "5")
              .attr("class", "arrowMarkerPath")
              .style("stroke-width", 1)
              .style("stroke-dasharray", "1,0"));
        }, "circle")),
        (ZIt = a((e, t, r) => {
          (e
            .append("marker")
            .attr("id", r + "_" + t + "-crossEnd")
            .attr("class", "marker cross " + t)
            .attr("viewBox", "0 0 11 11")
            .attr("refX", 12)
            .attr("refY", 5.2)
            .attr("markerUnits", "userSpaceOnUse")
            .attr("markerWidth", 11)
            .attr("markerHeight", 11)
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 1,1 l 9,9 M 10,1 l -9,9")
            .attr("class", "arrowMarkerPath")
            .style("stroke-width", 2)
            .style("stroke-dasharray", "1,0"),
            e
              .append("marker")
              .attr("id", r + "_" + t + "-crossStart")
              .attr("class", "marker cross " + t)
              .attr("viewBox", "0 0 11 11")
              .attr("refX", -1)
              .attr("refY", 5.2)
              .attr("markerUnits", "userSpaceOnUse")
              .attr("markerWidth", 11)
              .attr("markerHeight", 11)
              .attr("orient", "auto")
              .append("path")
              .attr("d", "M 1,1 l 9,9 M 10,1 l -9,9")
              .attr("class", "arrowMarkerPath")
              .style("stroke-width", 2)
              .style("stroke-dasharray", "1,0"));
        }, "cross")),
        (JIt = a((e, t, r) => {
          e.append("defs")
            .append("marker")
            .attr("id", r + "_" + t + "-barbEnd")
            .attr("refX", 19)
            .attr("refY", 7)
            .attr("markerWidth", 20)
            .attr("markerHeight", 14)
            .attr("markerUnits", "strokeWidth")
            .attr("orient", "auto")
            .append("path")
            .attr("d", "M 19,7 L9,13 L14,7 L9,1 Z");
        }, "barb")),
        (t7t = {
          extension: jIt,
          composition: qIt,
          aggregation: HIt,
          dependency: YIt,
          lollipop: XIt,
          point: KIt,
          circle: QIt,
          cross: ZIt,
          barb: JIt,
        }),
        (iot = UIt));
    });
  function e7t(e, t) {
    if (e === 0 || !Number.isInteger(e))
      throw new Error("Columns must be an integer !== 0.");
    if (t < 0 || !Number.isInteger(t))
      throw new Error("Position must be a non-negative integer." + t);
    if (e < 0) return { px: t, py: 0 };
    if (e === 1) return { px: 0, py: t };
    let r = t % e,
      n = Math.floor(t / e);
    return { px: r, py: n };
  }
  function E8(e, t, r = 0, n = 0) {
    (P.debug(
      "setBlockSizes abc95 (start)",
      e.id,
      e?.size?.x,
      "block width =",
      e?.size,
      "siblingWidth",
      r,
    ),
      e?.size?.width || (e.size = { width: r, height: n, x: 0, y: 0 }));
    let i = 0,
      s = 0;
    if (e.children?.length > 0) {
      for (let m of e.children) E8(m, t);
      let o = r7t(e);
      ((i = o.width),
        (s = o.height),
        P.debug(
          "setBlockSizes abc95 maxWidth of",
          e.id,
          ":s children is ",
          i,
          s,
        ));
      for (let m of e.children)
        m.size &&
          (P.debug(
            `abc95 Setting size of children of ${e.id} id=${m.id} ${i} ${s} ${JSON.stringify(m.size)}`,
          ),
          (m.size.width =
            i * (m.widthInColumns ?? 1) + Tn * ((m.widthInColumns ?? 1) - 1)),
          (m.size.height = s),
          (m.size.x = 0),
          (m.size.y = 0),
          P.debug(
            `abc95 updating size of ${e.id} children child:${m.id} maxWidth:${i} maxHeight:${s}`,
          ));
      for (let m of e.children) E8(m, t, i, s);
      let l = e.columns ?? -1,
        u = 0;
      for (let m of e.children) u += m.widthInColumns ?? 1;
      let h = e.children.length;
      l > 0 && l < u && (h = l);
      let f = Math.ceil(u / h),
        d = h * (i + Tn) + Tn,
        p = f * (s + Tn) + Tn;
      if (d < r) {
        (P.debug(
          `Detected to small sibling: abc95 ${e.id} siblingWidth ${r} siblingHeight ${n} width ${d}`,
        ),
          (d = r),
          (p = n));
        let m = (r - h * Tn - Tn) / h,
          g = (n - f * Tn - Tn) / f;
        (P.debug("Size indata abc88", e.id, "childWidth", m, "maxWidth", i),
          P.debug("Size indata abc88", e.id, "childHeight", g, "maxHeight", s),
          P.debug("Size indata abc88 xSize", h, "padding", Tn));
        for (let y of e.children)
          y.size &&
            ((y.size.width = m),
            (y.size.height = g),
            (y.size.x = 0),
            (y.size.y = 0));
      }
      if (
        (P.debug(
          `abc95 (finale calc) ${e.id} xSize ${h} ySize ${f} columns ${l}${e.children.length} width=${Math.max(d, e.size?.width || 0)}`,
        ),
        d < (e?.size?.width || 0))
      ) {
        d = e?.size?.width || 0;
        let m = l > 0 ? Math.min(e.children.length, l) : e.children.length;
        if (m > 0) {
          let g = (d - m * Tn - Tn) / m;
          P.debug("abc95 (growing to fit) width", e.id, d, e.size?.width, g);
          for (let y of e.children) y.size && (y.size.width = g);
        }
      }
      e.size = { width: d, height: p, x: 0, y: 0 };
    }
    P.debug(
      "setBlockSizes abc94 (done)",
      e.id,
      e?.size?.x,
      e?.size?.width,
      e?.size?.y,
      e?.size?.height,
    );
  }
  function aot(e, t) {
    P.debug(
      `abc85 layout blocks (=>layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`,
    );
    let r = e.columns ?? -1;
    if (
      (P.debug("layoutBlocks columns abc95", e.id, "=>", r, e),
      e.children && e.children.length > 0)
    ) {
      let n = e?.children[0]?.size?.width ?? 0,
        i = e.children.length * n + (e.children.length - 1) * Tn;
      P.debug("widthOfChildren 88", i, "posX");
      let s = 0;
      P.debug("abc91 block?.size?.x", e.id, e?.size?.x);
      let o = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -Tn,
        l = 0;
      for (let u of e.children) {
        let h = e;
        if (!u.size) continue;
        let { width: f, height: d } = u.size,
          { px: p, py: m } = e7t(r, s);
        if (
          (m != l &&
            ((l = m),
            (o = e?.size?.x ? e?.size?.x + (-e?.size?.width / 2 || 0) : -Tn),
            P.debug(
              "New row in layout for block",
              e.id,
              " and child ",
              u.id,
              l,
            )),
          P.debug(
            `abc89 layout blocks (child) id: ${u.id} Pos: ${s} (px, py) ${p},${m} (${h?.size?.x},${h?.size?.y}) parent: ${h.id} width: ${f}${Tn}`,
          ),
          h.size)
        ) {
          let y = f / 2;
          ((u.size.x = o + Tn + y),
            P.debug(
              `abc91 layout blocks (calc) px, pyid:${u.id} startingPos=X${o} new startingPosX${u.size.x} ${y} padding=${Tn} width=${f} halfWidth=${y} => x:${u.size.x} y:${u.size.y} ${u.widthInColumns} (width * (child?.w || 1)) / 2 ${(f * (u?.widthInColumns ?? 1)) / 2}`,
            ),
            (o = u.size.x + y),
            (u.size.y =
              h.size.y - h.size.height / 2 + m * (d + Tn) + d / 2 + Tn),
            P.debug(
              `abc88 layout blocks (calc) px, pyid:${u.id}startingPosX${o}${Tn}${y}=>x:${u.size.x}y:${u.size.y}${u.widthInColumns}(width * (child?.w || 1)) / 2${(f * (u?.widthInColumns ?? 1)) / 2}`,
            ));
        }
        u.children && aot(u, t);
        let g = u?.widthInColumns ?? 1;
        (r > 0 && (g = Math.min(g, r - (s % r))),
          (s += g),
          P.debug("abc88 columnsPos", u, s));
      }
    }
    P.debug(
      `layout blocks (<==layoutBlocks) ${e.id} x: ${e?.size?.x} y: ${e?.size?.y} width: ${e?.size?.width}`,
    );
  }
  function oot(
    e,
    { minX: t, minY: r, maxX: n, maxY: i } = {
      minX: 0,
      minY: 0,
      maxX: 0,
      maxY: 0,
    },
  ) {
    if (e.size && e.id !== "root") {
      let { x: s, y: o, width: l, height: u } = e.size;
      (s - l / 2 < t && (t = s - l / 2),
        o - u / 2 < r && (r = o - u / 2),
        s + l / 2 > n && (n = s + l / 2),
        o + u / 2 > i && (i = o + u / 2));
    }
    if (e.children)
      for (let s of e.children)
        ({
          minX: t,
          minY: r,
          maxX: n,
          maxY: i,
        } = oot(s, { minX: t, minY: r, maxX: n, maxY: i }));
    return { minX: t, minY: r, maxX: n, maxY: i };
  }
  function lot(e) {
    let t = e.getBlock("root");
    if (!t) return;
    (E8(t, e, 0, 0),
      aot(t, e),
      P.debug("getBlocks", JSON.stringify(t, null, 2)));
    let { minX: r, minY: n, maxX: i, maxY: s } = oot(t),
      o = s - n,
      l = i - r;
    return { x: r, y: n, width: l, height: o };
  }
  var Tn,
    r7t,
    cot = x(() => {
      "use strict";
      Vt();
      pe();
      Tn = K()?.block?.padding ?? 8;
      a(e7t, "calculateBlockPosition");
      r7t = a((e) => {
        let t = 0,
          r = 0;
        for (let n of e.children) {
          let {
            width: i,
            height: s,
            x: o,
            y: l,
          } = n.size ?? { width: 0, height: 0, x: 0, y: 0 };
          (P.debug(
            "getMaxChildSize abc95 child:",
            n.id,
            "width:",
            i,
            "height:",
            s,
            "x:",
            o,
            "y:",
            l,
            n.type,
          ),
            n.type !== "space" &&
              (i > t && (t = i / (e.widthInColumns ?? 1)), s > r && (r = s)));
        }
        return { width: t, height: r };
      }, "getMaxChildSize");
      a(E8, "setBlockSizes");
      a(aot, "layoutBlocks");
      a(oot, "findBounds");
      a(lot, "layout");
    });
  function uot(e, t) {
    t && e.attr("style", t);
  }
  function n7t(e, t) {
    let r = xt(
        document.createElementNS("http://www.w3.org/2000/svg", "foreignObject"),
      ),
      n = r.append("xhtml:div"),
      i = e.label,
      s = e.isNode ? "nodeLabel" : "edgeLabel",
      o = n.append("span");
    return (
      o.html(Ie(i, t)),
      uot(o, e.labelStyle),
      o.attr("class", s),
      uot(n, e.labelStyle),
      n.style("display", "inline-block"),
      n.style("white-space", "nowrap"),
      n.attr("xmlns", "http://www.w3.org/1999/xhtml"),
      r.node()
    );
  }
  var i7t,
    Zi,
    hC = x(() => {
      "use strict";
      Ge();
      pe();
      Be();
      Vt();
      Ga();
      _e();
      a(uot, "applyStyle");
      a(n7t, "addHtmlLabel");
      ((i7t = a(async (e, t, r, n) => {
        let i = e || "";
        typeof i == "object" && (i = i[0]);
        let s = K();
        if (Pe(s.flowchart.htmlLabels)) {
          ((i = i.replace(/\\n|\n/g, "<br />")), P.debug("vertexText" + i));
          let o = await uA(Xn(i)),
            l = {
              isNode: n,
              label: o,
              labelStyle: t.replace("fill:", "color:"),
            };
          return n7t(l, s);
        } else {
          let o = document.createElementNS(
            "http://www.w3.org/2000/svg",
            "text",
          );
          o.setAttribute("style", t.replace("color:", "fill:"));
          let l = [];
          typeof i == "string"
            ? (l = i.split(/\\n|\n|<br\s*\/?>/gi))
            : Array.isArray(i)
              ? (l = i)
              : (l = []);
          for (let u of l) {
            let h = document.createElementNS(
              "http://www.w3.org/2000/svg",
              "tspan",
            );
            (h.setAttributeNS(
              "http://www.w3.org/XML/1998/namespace",
              "xml:space",
              "preserve",
            ),
              h.setAttribute("dy", "1em"),
              h.setAttribute("x", "0"),
              r
                ? h.setAttribute("class", "title-row")
                : h.setAttribute("class", "row"),
              (h.textContent = u.trim()),
              o.appendChild(h));
          }
          return o;
        }
      }, "createLabel")),
        (Zi = i7t));
    });
  var fot,
    s7t,
    hot,
    dot = x(() => {
      "use strict";
      Vt();
      ((fot = a((e, t, r, n, i) => {
        (t.arrowTypeStart && hot(e, "start", t.arrowTypeStart, r, n, i),
          t.arrowTypeEnd && hot(e, "end", t.arrowTypeEnd, r, n, i));
      }, "addEdgeMarkers")),
        (s7t = {
          arrow_cross: "cross",
          arrow_point: "point",
          arrow_barb: "barb",
          arrow_circle: "circle",
          aggregation: "aggregation",
          extension: "extension",
          composition: "composition",
          dependency: "dependency",
          lollipop: "lollipop",
        }),
        (hot = a((e, t, r, n, i, s) => {
          let o = s7t[r];
          if (!o) {
            P.warn(`Unknown arrow type: ${r}`);
            return;
          }
          let l = t === "start" ? "Start" : "End";
          e.attr(`marker-${t}`, `url(${n}#${i}_${s}-${o}${l})`);
        }, "addEdgeMarker")));
    });
  function fC(e, t) {
    K().flowchart.htmlLabels &&
      e &&
      ((e.style.width = t.length * 9 + "px"), (e.style.height = "12px"));
  }
  var A8,
    Ai,
    mot,
    got,
    a7t,
    o7t,
    pot,
    yot,
    xot = x(() => {
      "use strict";
      Vt();
      hC();
      Ga();
      Ge();
      pe();
      _e();
      Be();
      MA();
      F0();
      dot();
      ((A8 = {}),
        (Ai = {}),
        (mot = a(async (e, t) => {
          let r = K(),
            n = Pe(r.flowchart.htmlLabels),
            i =
              t.labelType === "markdown"
                ? Kn(
                    e,
                    t.label,
                    {
                      style: t.labelStyle,
                      useHtmlLabels: n,
                      addSvgBackground: !0,
                    },
                    r,
                  )
                : await Zi(t.label, t.labelStyle),
            s = e.insert("g").attr("class", "edgeLabel"),
            o = s.insert("g").attr("class", "label");
          o.node().appendChild(i);
          let l = i.getBBox();
          if (n) {
            let h = i.children[0],
              f = xt(i);
            ((l = h.getBoundingClientRect()),
              f.attr("width", l.width),
              f.attr("height", l.height));
          }
          (o.attr(
            "transform",
            "translate(" + -l.width / 2 + ", " + -l.height / 2 + ")",
          ),
            (A8[t.id] = s),
            (t.width = l.width),
            (t.height = l.height));
          let u;
          if (t.startLabelLeft) {
            let h = await Zi(t.startLabelLeft, t.labelStyle),
              f = e.insert("g").attr("class", "edgeTerminals"),
              d = f.insert("g").attr("class", "inner");
            u = d.node().appendChild(h);
            let p = h.getBBox();
            (d.attr(
              "transform",
              "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")",
            ),
              Ai[t.id] || (Ai[t.id] = {}),
              (Ai[t.id].startLeft = f),
              fC(u, t.startLabelLeft));
          }
          if (t.startLabelRight) {
            let h = await Zi(t.startLabelRight, t.labelStyle),
              f = e.insert("g").attr("class", "edgeTerminals"),
              d = f.insert("g").attr("class", "inner");
            ((u = f.node().appendChild(h)), d.node().appendChild(h));
            let p = h.getBBox();
            (d.attr(
              "transform",
              "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")",
            ),
              Ai[t.id] || (Ai[t.id] = {}),
              (Ai[t.id].startRight = f),
              fC(u, t.startLabelRight));
          }
          if (t.endLabelLeft) {
            let h = await Zi(t.endLabelLeft, t.labelStyle),
              f = e.insert("g").attr("class", "edgeTerminals"),
              d = f.insert("g").attr("class", "inner");
            u = d.node().appendChild(h);
            let p = h.getBBox();
            (d.attr(
              "transform",
              "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")",
            ),
              f.node().appendChild(h),
              Ai[t.id] || (Ai[t.id] = {}),
              (Ai[t.id].endLeft = f),
              fC(u, t.endLabelLeft));
          }
          if (t.endLabelRight) {
            let h = await Zi(t.endLabelRight, t.labelStyle),
              f = e.insert("g").attr("class", "edgeTerminals"),
              d = f.insert("g").attr("class", "inner");
            u = d.node().appendChild(h);
            let p = h.getBBox();
            (d.attr(
              "transform",
              "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")",
            ),
              f.node().appendChild(h),
              Ai[t.id] || (Ai[t.id] = {}),
              (Ai[t.id].endRight = f),
              fC(u, t.endLabelRight));
          }
          return i;
        }, "insertEdgeLabel")));
      a(fC, "setTerminalWidth");
      ((got = a((e, t) => {
        P.debug("Moving label abc88 ", e.id, e.label, A8[e.id], t);
        let r = t.updatedPath ? t.updatedPath : t.originalPath,
          n = K(),
          { subGraphTitleTotalMargin: i } = Tl(n);
        if (e.label) {
          let s = A8[e.id],
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcLabelPosition(r);
            (P.debug(
              "Moving label " + e.label + " from (",
              o,
              ",",
              l,
              ") to (",
              u.x,
              ",",
              u.y,
              ") abc88",
            ),
              t.updatedPath && ((o = u.x), (l = u.y)));
          }
          s.attr("transform", `translate(${o}, ${l + i / 2})`);
        }
        if (e.startLabelLeft) {
          let s = Ai[e.id].startLeft,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeStart ? 10 : 0,
              "start_left",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
        if (e.startLabelRight) {
          let s = Ai[e.id].startRight,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeStart ? 10 : 0,
              "start_right",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
        if (e.endLabelLeft) {
          let s = Ai[e.id].endLeft,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeEnd ? 10 : 0,
              "end_left",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
        if (e.endLabelRight) {
          let s = Ai[e.id].endRight,
            o = e.x,
            l = e.y;
          if (r) {
            let u = le.calcTerminalLabelPosition(
              e.arrowTypeEnd ? 10 : 0,
              "end_right",
              r,
            );
            ((o = u.x), (l = u.y));
          }
          s.attr("transform", `translate(${o}, ${l})`);
        }
      }, "positionEdgeLabel")),
        (a7t = a((e, t) => {
          let r = e.x,
            n = e.y,
            i = Math.abs(t.x - r),
            s = Math.abs(t.y - n),
            o = e.width / 2,
            l = e.height / 2;
          return i >= o || s >= l;
        }, "outsideNode")),
        (o7t = a((e, t, r) => {
          P.debug(`intersection calc abc89:
  outsidePoint: ${JSON.stringify(t)}
  insidePoint : ${JSON.stringify(r)}
  node        : x:${e.x} y:${e.y} w:${e.width} h:${e.height}`);
          let n = e.x,
            i = e.y,
            s = Math.abs(n - r.x),
            o = e.width / 2,
            l = r.x < t.x ? o - s : o + s,
            u = e.height / 2,
            h = Math.abs(t.y - r.y),
            f = Math.abs(t.x - r.x);
          if (Math.abs(i - t.y) * o > Math.abs(n - t.x) * u) {
            let d = r.y < t.y ? t.y - u - i : i - u - t.y;
            l = (f * d) / h;
            let p = {
              x: r.x < t.x ? r.x + l : r.x - f + l,
              y: r.y < t.y ? r.y + h - d : r.y - h + d,
            };
            return (
              l === 0 && ((p.x = t.x), (p.y = t.y)),
              f === 0 && (p.x = t.x),
              h === 0 && (p.y = t.y),
              P.debug(
                `abc89 topp/bott calc, Q ${h}, q ${d}, R ${f}, r ${l}`,
                p,
              ),
              p
            );
          } else {
            r.x < t.x ? (l = t.x - o - n) : (l = n - o - t.x);
            let d = (h * l) / f,
              p = r.x < t.x ? r.x + f - l : r.x - f + l,
              m = r.y < t.y ? r.y + d : r.y - d;
            return (
              P.debug(`sides calc abc89, Q ${h}, q ${d}, R ${f}, r ${l}`, {
                _x: p,
                _y: m,
              }),
              l === 0 && ((p = t.x), (m = t.y)),
              f === 0 && (p = t.x),
              h === 0 && (m = t.y),
              { x: p, y: m }
            );
          }
        }, "intersection")),
        (pot = a((e, t) => {
          P.debug("abc88 cutPathAtIntersect", e, t);
          let r = [],
            n = e[0],
            i = !1;
          return (
            e.forEach((s) => {
              if (!a7t(t, s) && !i) {
                let o = o7t(t, n, s),
                  l = !1;
                (r.forEach((u) => {
                  l = l || (u.x === o.x && u.y === o.y);
                }),
                  r.some((u) => u.x === o.x && u.y === o.y) || r.push(o),
                  (i = !0));
              } else ((n = s), i || r.push(s));
            }),
            r
          );
        }, "cutPathAtIntersect")),
        (yot = a(function (e, t, r, n, i, s, o) {
          let l = r.points;
          P.debug("abc88 InsertEdge: edge=", r, "e=", t);
          let u = !1,
            h = s.node(t.v);
          var f = s.node(t.w);
          (f?.intersect &&
            h?.intersect &&
            ((l = l.slice(1, r.points.length - 1)),
            l.unshift(h.intersect(l[0])),
            l.push(f.intersect(l[l.length - 1]))),
            r.toCluster &&
              (P.debug("to cluster abc88", n[r.toCluster]),
              (l = pot(r.points, n[r.toCluster].node)),
              (u = !0)),
            r.fromCluster &&
              (P.debug("from cluster abc88", n[r.fromCluster]),
              (l = pot(l.reverse(), n[r.fromCluster].node).reverse()),
              (u = !0)));
          let d = l.filter((L) => !Number.isNaN(L.y)),
            p = Ys;
          r.curve && (i === "graph" || i === "flowchart") && (p = r.curve);
          let { x: m, y: g } = Kb(r),
            y = Oa().x(m).y(g).curve(p),
            b;
          switch (r.thickness) {
            case "normal":
              b = "edge-thickness-normal";
              break;
            case "thick":
              b = "edge-thickness-thick";
              break;
            case "invisible":
              b = "edge-thickness-thick";
              break;
            default:
              b = "";
          }
          switch (r.pattern) {
            case "solid":
              b += " edge-pattern-solid";
              break;
            case "dotted":
              b += " edge-pattern-dotted";
              break;
            case "dashed":
              b += " edge-pattern-dashed";
              break;
          }
          let k = e
              .append("path")
              .attr("d", y(d))
              .attr("id", r.id)
              .attr("class", " " + b + (r.classes ? " " + r.classes : ""))
              .attr("style", r.style),
            T = "";
          ((K().flowchart.arrowMarkerAbsolute ||
            K().state.arrowMarkerAbsolute) &&
            (T = tl(!0)),
            fot(k, r, T, o, i));
          let C = {};
          return (u && (C.updatedPath = l), (C.originalPath = r.points), C);
        }, "insertEdge")));
    });
  var l7t,
    bot,
    kot = x(() => {
      "use strict";
      ((l7t = a((e) => {
        let t = new Set();
        for (let r of e)
          switch (r) {
            case "x":
              (t.add("right"), t.add("left"));
              break;
            case "y":
              (t.add("up"), t.add("down"));
              break;
            default:
              t.add(r);
              break;
          }
        return t;
      }, "expandAndDeduplicateDirections")),
        (bot = a((e, t, r) => {
          let n = l7t(e),
            i = 2,
            s = t.height + 2 * r.padding,
            o = s / i,
            l = t.width + 2 * o + r.padding,
            u = r.padding / 2;
          return n.has("right") && n.has("left") && n.has("up") && n.has("down")
            ? [
                { x: 0, y: 0 },
                { x: o, y: 0 },
                { x: l / 2, y: 2 * u },
                { x: l - o, y: 0 },
                { x: l, y: 0 },
                { x: l, y: -s / 3 },
                { x: l + 2 * u, y: -s / 2 },
                { x: l, y: (-2 * s) / 3 },
                { x: l, y: -s },
                { x: l - o, y: -s },
                { x: l / 2, y: -s - 2 * u },
                { x: o, y: -s },
                { x: 0, y: -s },
                { x: 0, y: (-2 * s) / 3 },
                { x: -2 * u, y: -s / 2 },
                { x: 0, y: -s / 3 },
              ]
            : n.has("right") && n.has("left") && n.has("up")
              ? [
                  { x: o, y: 0 },
                  { x: l - o, y: 0 },
                  { x: l, y: -s / 2 },
                  { x: l - o, y: -s },
                  { x: o, y: -s },
                  { x: 0, y: -s / 2 },
                ]
              : n.has("right") && n.has("left") && n.has("down")
                ? [
                    { x: 0, y: 0 },
                    { x: o, y: -s },
                    { x: l - o, y: -s },
                    { x: l, y: 0 },
                  ]
                : n.has("right") && n.has("up") && n.has("down")
                  ? [
                      { x: 0, y: 0 },
                      { x: l, y: -o },
                      { x: l, y: -s + o },
                      { x: 0, y: -s },
                    ]
                  : n.has("left") && n.has("up") && n.has("down")
                    ? [
                        { x: l, y: 0 },
                        { x: 0, y: -o },
                        { x: 0, y: -s + o },
                        { x: l, y: -s },
                      ]
                    : n.has("right") && n.has("left")
                      ? [
                          { x: o, y: 0 },
                          { x: o, y: -u },
                          { x: l - o, y: -u },
                          { x: l - o, y: 0 },
                          { x: l, y: -s / 2 },
                          { x: l - o, y: -s },
                          { x: l - o, y: -s + u },
                          { x: o, y: -s + u },
                          { x: o, y: -s },
                          { x: 0, y: -s / 2 },
                        ]
                      : n.has("up") && n.has("down")
                        ? [
                            { x: l / 2, y: 0 },
                            { x: 0, y: -u },
                            { x: o, y: -u },
                            { x: o, y: -s + u },
                            { x: 0, y: -s + u },
                            { x: l / 2, y: -s },
                            { x: l, y: -s + u },
                            { x: l - o, y: -s + u },
                            { x: l - o, y: -u },
                            { x: l, y: -u },
                          ]
                        : n.has("right") && n.has("up")
                          ? [
                              { x: 0, y: 0 },
                              { x: l, y: -o },
                              { x: 0, y: -s },
                            ]
                          : n.has("right") && n.has("down")
                            ? [
                                { x: 0, y: 0 },
                                { x: l, y: 0 },
                                { x: 0, y: -s },
                              ]
                            : n.has("left") && n.has("up")
                              ? [
                                  { x: l, y: 0 },
                                  { x: 0, y: -o },
                                  { x: l, y: -s },
                                ]
                              : n.has("left") && n.has("down")
                                ? [
                                    { x: l, y: 0 },
                                    { x: 0, y: 0 },
                                    { x: l, y: -s },
                                  ]
                                : n.has("right")
                                  ? [
                                      { x: o, y: -u },
                                      { x: o, y: -u },
                                      { x: l - o, y: -u },
                                      { x: l - o, y: 0 },
                                      { x: l, y: -s / 2 },
                                      { x: l - o, y: -s },
                                      { x: l - o, y: -s + u },
                                      { x: o, y: -s + u },
                                      { x: o, y: -s + u },
                                    ]
                                  : n.has("left")
                                    ? [
                                        { x: o, y: 0 },
                                        { x: o, y: -u },
                                        { x: l - o, y: -u },
                                        { x: l - o, y: -s + u },
                                        { x: o, y: -s + u },
                                        { x: o, y: -s },
                                        { x: 0, y: -s / 2 },
                                      ]
                                    : n.has("up")
                                      ? [
                                          { x: o, y: -u },
                                          { x: o, y: -s + u },
                                          { x: 0, y: -s + u },
                                          { x: l / 2, y: -s },
                                          { x: l, y: -s + u },
                                          { x: l - o, y: -s + u },
                                          { x: l - o, y: -u },
                                        ]
                                      : n.has("down")
                                        ? [
                                            { x: l / 2, y: 0 },
                                            { x: 0, y: -u },
                                            { x: o, y: -u },
                                            { x: o, y: -s + u },
                                            { x: l - o, y: -s + u },
                                            { x: l - o, y: -u },
                                            { x: l, y: -u },
                                          ]
                                        : [{ x: 0, y: 0 }];
        }, "getArrowPoints")));
    });
  function c7t(e, t) {
    return e.intersect(t);
  }
  var Tot,
    Sot = x(() => {
      "use strict";
      a(c7t, "intersectNode");
      Tot = c7t;
    });
  function u7t(e, t, r, n) {
    var i = e.x,
      s = e.y,
      o = i - n.x,
      l = s - n.y,
      u = Math.sqrt(t * t * l * l + r * r * o * o),
      h = Math.abs((t * r * o) / u);
    n.x < i && (h = -h);
    var f = Math.abs((t * r * l) / u);
    return (n.y < s && (f = -f), { x: i + h, y: s + f });
  }
  var dC,
    L8 = x(() => {
      "use strict";
      a(u7t, "intersectEllipse");
      dC = u7t;
    });
  function h7t(e, t, r) {
    return dC(e, t, t, r);
  }
  var _ot,
    Cot = x(() => {
      "use strict";
      L8();
      a(h7t, "intersectCircle");
      _ot = h7t;
    });
  function f7t(e, t, r, n) {
    var i, s, o, l, u, h, f, d, p, m, g, y, b, k, T;
    if (
      ((i = t.y - e.y),
      (o = e.x - t.x),
      (u = t.x * e.y - e.x * t.y),
      (p = i * r.x + o * r.y + u),
      (m = i * n.x + o * n.y + u),
      !(p !== 0 && m !== 0 && wot(p, m)) &&
        ((s = n.y - r.y),
        (l = r.x - n.x),
        (h = n.x * r.y - r.x * n.y),
        (f = s * e.x + l * e.y + h),
        (d = s * t.x + l * t.y + h),
        !(f !== 0 && d !== 0 && wot(f, d)) && ((g = i * l - s * o), g !== 0)))
    )
      return (
        (y = Math.abs(g / 2)),
        (b = o * h - l * u),
        (k = b < 0 ? (b - y) / g : (b + y) / g),
        (b = s * u - i * h),
        (T = b < 0 ? (b - y) / g : (b + y) / g),
        { x: k, y: T }
      );
  }
  function wot(e, t) {
    return e * t > 0;
  }
  var vot,
    Eot = x(() => {
      "use strict";
      a(f7t, "intersectLine");
      a(wot, "sameSign");
      vot = f7t;
    });
  function d7t(e, t, r) {
    var n = e.x,
      i = e.y,
      s = [],
      o = Number.POSITIVE_INFINITY,
      l = Number.POSITIVE_INFINITY;
    typeof t.forEach == "function"
      ? t.forEach(function (g) {
          ((o = Math.min(o, g.x)), (l = Math.min(l, g.y)));
        })
      : ((o = Math.min(o, t.x)), (l = Math.min(l, t.y)));
    for (
      var u = n - e.width / 2 - o, h = i - e.height / 2 - l, f = 0;
      f < t.length;
      f++
    ) {
      var d = t[f],
        p = t[f < t.length - 1 ? f + 1 : 0],
        m = vot(e, r, { x: u + d.x, y: h + d.y }, { x: u + p.x, y: h + p.y });
      m && s.push(m);
    }
    return s.length
      ? (s.length > 1 &&
          s.sort(function (g, y) {
            var b = g.x - r.x,
              k = g.y - r.y,
              T = Math.sqrt(b * b + k * k),
              C = y.x - r.x,
              L = y.y - r.y,
              w = Math.sqrt(C * C + L * L);
            return T < w ? -1 : T === w ? 0 : 1;
          }),
        s[0])
      : e;
  }
  var Aot,
    Lot = x(() => {
      "use strict";
      Eot();
      Aot = d7t;
      a(d7t, "intersectPolygon");
    });
  var p7t,
    Rot,
    Dot = x(() => {
      "use strict";
      ((p7t = a((e, t) => {
        var r = e.x,
          n = e.y,
          i = t.x - r,
          s = t.y - n,
          o = e.width / 2,
          l = e.height / 2,
          u,
          h;
        return (
          Math.abs(s) * o > Math.abs(i) * l
            ? (s < 0 && (l = -l), (u = s === 0 ? 0 : (l * i) / s), (h = l))
            : (i < 0 && (o = -o), (u = o), (h = i === 0 ? 0 : (o * s) / i)),
          { x: r + u, y: n + h }
        );
      }, "intersectRect")),
        (Rot = p7t));
    });
  var Ur,
    R8 = x(() => {
      "use strict";
      Sot();
      Cot();
      L8();
      Lot();
      Dot();
      Ur = { node: Tot, circle: _ot, ellipse: dC, polygon: Aot, rect: Rot };
    });
  function Ja(e, t, r, n) {
    return e
      .insert("polygon", ":first-child")
      .attr(
        "points",
        n
          .map(function (i) {
            return i.x + "," + i.y;
          })
          .join(" "),
      )
      .attr("class", "label-container")
      .attr("transform", "translate(" + -t / 2 + "," + r / 2 + ")");
  }
  var Ln,
    nn,
    D8 = x(() => {
      "use strict";
      hC();
      Ga();
      pe();
      Ge();
      Be();
      _e();
      ((Ln = a(async (e, t, r, n) => {
        let i = K(),
          s,
          o = t.useHtmlLabels || Pe(i.flowchart.htmlLabels);
        r ? (s = r) : (s = "node default");
        let l = e
            .insert("g")
            .attr("class", s)
            .attr("id", t.domId || t.id),
          u = l.insert("g").attr("class", "label").attr("style", t.labelStyle),
          h;
        t.labelText === void 0
          ? (h = "")
          : (h = typeof t.labelText == "string" ? t.labelText : t.labelText[0]);
        let f = u.node(),
          d;
        t.labelType === "markdown"
          ? (d = Kn(
              u,
              Ie(Xn(h), i),
              {
                useHtmlLabels: o,
                width: t.width || i.flowchart.wrappingWidth,
                classes: "markdown-node-label",
              },
              i,
            ))
          : (d = f.appendChild(await Zi(Ie(Xn(h), i), t.labelStyle, !1, n)));
        let p = d.getBBox(),
          m = t.padding / 2;
        if (Pe(i.flowchart.htmlLabels)) {
          let g = d.children[0],
            y = xt(d),
            b = g.getElementsByTagName("img");
          if (b) {
            let k = h.replace(/<img[^>]*>/g, "").trim() === "";
            await Promise.all(
              [...b].map(
                (T) =>
                  new Promise((C) => {
                    function L() {
                      if (
                        ((T.style.display = "flex"),
                        (T.style.flexDirection = "column"),
                        k)
                      ) {
                        let w = i.fontSize
                            ? i.fontSize
                            : window.getComputedStyle(document.body).fontSize,
                          G = parseInt(w, 10) * 5 + "px";
                        ((T.style.minWidth = G), (T.style.maxWidth = G));
                      } else T.style.width = "100%";
                      C(T);
                    }
                    (a(L, "setupImage"),
                      setTimeout(() => {
                        T.complete && L();
                      }),
                      T.addEventListener("error", L),
                      T.addEventListener("load", L));
                  }),
              ),
            );
          }
          ((p = g.getBoundingClientRect()),
            y.attr("width", p.width),
            y.attr("height", p.height));
        }
        return (
          o
            ? u.attr(
                "transform",
                "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")",
              )
            : u.attr("transform", "translate(0, " + -p.height / 2 + ")"),
          t.centerLabel &&
            u.attr(
              "transform",
              "translate(" + -p.width / 2 + ", " + -p.height / 2 + ")",
            ),
          u.insert("rect", ":first-child"),
          { shapeSvg: l, bbox: p, halfPadding: m, label: u }
        );
      }, "labelHelper")),
        (nn = a((e, t) => {
          let r = t.node().getBBox();
          ((e.width = r.width), (e.height = r.height));
        }, "updateNodeBounds")));
      a(Ja, "insertPolygonShape");
    });
  var m7t,
    Not,
    Iot = x(() => {
      "use strict";
      D8();
      Vt();
      pe();
      R8();
      ((m7t = a(async (e, t) => {
        t.useHtmlLabels || K().flowchart.htmlLabels || (t.centerLabel = !0);
        let {
          shapeSvg: n,
          bbox: i,
          halfPadding: s,
        } = await Ln(e, t, "node " + t.classes, !0);
        P.info("Classes = ", t.classes);
        let o = n.insert("rect", ":first-child");
        return (
          o
            .attr("rx", t.rx)
            .attr("ry", t.ry)
            .attr("x", -i.width / 2 - s)
            .attr("y", -i.height / 2 - s)
            .attr("width", i.width + t.padding)
            .attr("height", i.height + t.padding),
          nn(t, o),
          (t.intersect = function (l) {
            return Ur.rect(t, l);
          }),
          n
        );
      }, "note")),
        (Not = m7t));
    });
  function N8(e, t, r, n) {
    let i = [],
      s = a((l) => {
        i.push(l, 0);
      }, "addBorder"),
      o = a((l) => {
        i.push(0, l);
      }, "skipBorder");
    (t.includes("t") ? (P.debug("add top border"), s(r)) : o(r),
      t.includes("r") ? (P.debug("add right border"), s(n)) : o(n),
      t.includes("b") ? (P.debug("add bottom border"), s(r)) : o(r),
      t.includes("l") ? (P.debug("add left border"), s(n)) : o(n),
      e.attr("stroke-dasharray", i.join(" ")));
  }
  var Mot,
    Gs,
    Oot,
    g7t,
    y7t,
    x7t,
    b7t,
    k7t,
    T7t,
    S7t,
    _7t,
    C7t,
    w7t,
    v7t,
    E7t,
    A7t,
    L7t,
    R7t,
    D7t,
    N7t,
    I7t,
    M7t,
    Pot,
    O7t,
    P7t,
    Bot,
    pC,
    I8,
    Fot,
    $ot = x(() => {
      "use strict";
      Ge();
      pe();
      Be();
      Vt();
      kot();
      hC();
      R8();
      Iot();
      D8();
      ((Mot = a((e) => (e ? " " + e : ""), "formatClass")),
        (Gs = a(
          (e, t) => `${t || "node default"}${Mot(e.classes)} ${Mot(e.class)}`,
          "getClassesFromNode",
        )),
        (Oot = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = i + s,
            l = [
              { x: o / 2, y: 0 },
              { x: o, y: -o / 2 },
              { x: o / 2, y: -o },
              { x: 0, y: -o / 2 },
            ];
          P.info("Question main (Circle)");
          let u = Ja(r, o, o, l);
          return (
            u.attr("style", t.style),
            nn(t, u),
            (t.intersect = function (h) {
              return (P.warn("Intersect called"), Ur.polygon(t, l, h));
            }),
            r
          );
        }, "question")),
        (g7t = a((e, t) => {
          let r = e
              .insert("g")
              .attr("class", "node default")
              .attr("id", t.domId || t.id),
            n = 28,
            i = [
              { x: 0, y: n / 2 },
              { x: n / 2, y: 0 },
              { x: 0, y: -n / 2 },
              { x: -n / 2, y: 0 },
            ];
          return (
            r
              .insert("polygon", ":first-child")
              .attr(
                "points",
                i
                  .map(function (o) {
                    return o.x + "," + o.y;
                  })
                  .join(" "),
              )
              .attr("class", "state-start")
              .attr("r", 7)
              .attr("width", 28)
              .attr("height", 28),
            (t.width = 28),
            (t.height = 28),
            (t.intersect = function (o) {
              return Ur.circle(t, 14, o);
            }),
            r
          );
        }, "choice")),
        (y7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = 4,
            s = n.height + t.padding,
            o = s / i,
            l = n.width + 2 * o + t.padding,
            u = [
              { x: o, y: 0 },
              { x: l - o, y: 0 },
              { x: l, y: -s / 2 },
              { x: l - o, y: -s },
              { x: o, y: -s },
              { x: 0, y: -s / 2 },
            ],
            h = Ja(r, l, s, u);
          return (
            h.attr("style", t.style),
            nn(t, h),
            (t.intersect = function (f) {
              return Ur.polygon(t, u, f);
            }),
            r
          );
        }, "hexagon")),
        (x7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, void 0, !0),
            i = 2,
            s = n.height + 2 * t.padding,
            o = s / i,
            l = n.width + 2 * o + t.padding,
            u = bot(t.directions, n, t),
            h = Ja(r, l, s, u);
          return (
            h.attr("style", t.style),
            nn(t, h),
            (t.intersect = function (f) {
              return Ur.polygon(t, u, f);
            }),
            r
          );
        }, "block_arrow")),
        (b7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: -s / 2, y: 0 },
              { x: i, y: 0 },
              { x: i, y: -s },
              { x: -s / 2, y: -s },
              { x: 0, y: -s / 2 },
            ];
          return (
            Ja(r, i, s, o).attr("style", t.style),
            (t.width = i + s),
            (t.height = s),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u);
            }),
            r
          );
        }, "rect_left_inv_arrow")),
        (k7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: (-2 * s) / 6, y: 0 },
              { x: i - s / 6, y: 0 },
              { x: i + (2 * s) / 6, y: -s },
              { x: s / 6, y: -s },
            ],
            l = Ja(r, i, s, o);
          return (
            l.attr("style", t.style),
            nn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u);
            }),
            r
          );
        }, "lean_right")),
        (T7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: (2 * s) / 6, y: 0 },
              { x: i + s / 6, y: 0 },
              { x: i - (2 * s) / 6, y: -s },
              { x: -s / 6, y: -s },
            ],
            l = Ja(r, i, s, o);
          return (
            l.attr("style", t.style),
            nn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u);
            }),
            r
          );
        }, "lean_left")),
        (S7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: (-2 * s) / 6, y: 0 },
              { x: i + (2 * s) / 6, y: 0 },
              { x: i - s / 6, y: -s },
              { x: s / 6, y: -s },
            ],
            l = Ja(r, i, s, o);
          return (
            l.attr("style", t.style),
            nn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u);
            }),
            r
          );
        }, "trapezoid")),
        (_7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: s / 6, y: 0 },
              { x: i - s / 6, y: 0 },
              { x: i + (2 * s) / 6, y: -s },
              { x: (-2 * s) / 6, y: -s },
            ],
            l = Ja(r, i, s, o);
          return (
            l.attr("style", t.style),
            nn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u);
            }),
            r
          );
        }, "inv_trapezoid")),
        (C7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: 0, y: 0 },
              { x: i + s / 2, y: 0 },
              { x: i, y: -s / 2 },
              { x: i + s / 2, y: -s },
              { x: 0, y: -s },
            ],
            l = Ja(r, i, s, o);
          return (
            l.attr("style", t.style),
            nn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u);
            }),
            r
          );
        }, "rect_right_inv_arrow")),
        (w7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = i / 2,
            o = s / (2.5 + i / 50),
            l = n.height + o + t.padding,
            u =
              "M 0," +
              o +
              " a " +
              s +
              "," +
              o +
              " 0,0,0 " +
              i +
              " 0 a " +
              s +
              "," +
              o +
              " 0,0,0 " +
              -i +
              " 0 l 0," +
              l +
              " a " +
              s +
              "," +
              o +
              " 0,0,0 " +
              i +
              " 0 l 0," +
              -l,
            h = r
              .attr("label-offset-y", o)
              .insert("path", ":first-child")
              .attr("style", t.style)
              .attr("d", u)
              .attr(
                "transform",
                "translate(" + -i / 2 + "," + -(l / 2 + o) + ")",
              );
          return (
            nn(t, h),
            (t.intersect = function (f) {
              let d = Ur.rect(t, f),
                p = d.x - t.x;
              if (
                s != 0 &&
                (Math.abs(p) < t.width / 2 ||
                  (Math.abs(p) == t.width / 2 &&
                    Math.abs(d.y - t.y) > t.height / 2 - o))
              ) {
                let m = o * o * (1 - (p * p) / (s * s));
                (m != 0 && (m = Math.sqrt(m)),
                  (m = o - m),
                  f.y - t.y > 0 && (m = -m),
                  (d.y += m));
              }
              return d;
            }),
            r
          );
        }, "cylinder")),
        (v7t = a(async (e, t) => {
          let {
              shapeSvg: r,
              bbox: n,
              halfPadding: i,
            } = await Ln(e, t, "node " + t.classes + " " + t.class, !0),
            s = r.insert("rect", ":first-child"),
            o = t.positioned ? t.width : n.width + t.padding,
            l = t.positioned ? t.height : n.height + t.padding,
            u = t.positioned ? -o / 2 : -n.width / 2 - i,
            h = t.positioned ? -l / 2 : -n.height / 2 - i;
          if (
            (s
              .attr("class", "basic label-container")
              .attr("style", t.style)
              .attr("rx", t.rx)
              .attr("ry", t.ry)
              .attr("x", u)
              .attr("y", h)
              .attr("width", o)
              .attr("height", l),
            t.props)
          ) {
            let f = new Set(Object.keys(t.props));
            (t.props.borders &&
              (N8(s, t.props.borders, o, l), f.delete("borders")),
              f.forEach((d) => {
                P.warn(`Unknown node property ${d}`);
              }));
          }
          return (
            nn(t, s),
            (t.intersect = function (f) {
              return Ur.rect(t, f);
            }),
            r
          );
        }, "rect")),
        (E7t = a(async (e, t) => {
          let {
              shapeSvg: r,
              bbox: n,
              halfPadding: i,
            } = await Ln(e, t, "node " + t.classes, !0),
            s = r.insert("rect", ":first-child"),
            o = t.positioned ? t.width : n.width + t.padding,
            l = t.positioned ? t.height : n.height + t.padding,
            u = t.positioned ? -o / 2 : -n.width / 2 - i,
            h = t.positioned ? -l / 2 : -n.height / 2 - i;
          if (
            (s
              .attr("class", "basic cluster composite label-container")
              .attr("style", t.style)
              .attr("rx", t.rx)
              .attr("ry", t.ry)
              .attr("x", u)
              .attr("y", h)
              .attr("width", o)
              .attr("height", l),
            t.props)
          ) {
            let f = new Set(Object.keys(t.props));
            (t.props.borders &&
              (N8(s, t.props.borders, o, l), f.delete("borders")),
              f.forEach((d) => {
                P.warn(`Unknown node property ${d}`);
              }));
          }
          return (
            nn(t, s),
            (t.intersect = function (f) {
              return Ur.rect(t, f);
            }),
            r
          );
        }, "composite")),
        (A7t = a(async (e, t) => {
          let { shapeSvg: r } = await Ln(e, t, "label", !0);
          P.trace("Classes = ", t.class);
          let n = r.insert("rect", ":first-child"),
            i = 0,
            s = 0;
          if (
            (n.attr("width", i).attr("height", s),
            r.attr("class", "label edgeLabel"),
            t.props)
          ) {
            let o = new Set(Object.keys(t.props));
            (t.props.borders &&
              (N8(n, t.props.borders, i, s), o.delete("borders")),
              o.forEach((l) => {
                P.warn(`Unknown node property ${l}`);
              }));
          }
          return (
            nn(t, n),
            (t.intersect = function (o) {
              return Ur.rect(t, o);
            }),
            r
          );
        }, "labelRect")));
      a(N8, "applyNodePropertyBorders");
      ((L7t = a(async (e, t) => {
        let r;
        t.classes ? (r = "node " + t.classes) : (r = "node default");
        let n = e
            .insert("g")
            .attr("class", r)
            .attr("id", t.domId || t.id),
          i = n.insert("rect", ":first-child"),
          s = n.insert("line"),
          o = n.insert("g").attr("class", "label"),
          l = t.labelText.flat ? t.labelText.flat() : t.labelText,
          u = "";
        (typeof l == "object" ? (u = l[0]) : (u = l),
          P.info("Label text abc79", u, l, typeof l == "object"));
        let h = o.node().appendChild(await Zi(u, t.labelStyle, !0, !0)),
          f = { width: 0, height: 0 };
        if (Pe(K().flowchart.htmlLabels)) {
          let y = h.children[0],
            b = xt(h);
          ((f = y.getBoundingClientRect()),
            b.attr("width", f.width),
            b.attr("height", f.height));
        }
        P.info("Text 2", l);
        let d = l.slice(1, l.length),
          p = h.getBBox(),
          m = o
            .node()
            .appendChild(
              await Zi(d.join ? d.join("<br/>") : d, t.labelStyle, !0, !0),
            );
        if (Pe(K().flowchart.htmlLabels)) {
          let y = m.children[0],
            b = xt(m);
          ((f = y.getBoundingClientRect()),
            b.attr("width", f.width),
            b.attr("height", f.height));
        }
        let g = t.padding / 2;
        return (
          xt(m).attr(
            "transform",
            "translate( " +
              (f.width > p.width ? 0 : (p.width - f.width) / 2) +
              ", " +
              (p.height + g + 5) +
              ")",
          ),
          xt(h).attr(
            "transform",
            "translate( " +
              (f.width < p.width ? 0 : -(p.width - f.width) / 2) +
              ", 0)",
          ),
          (f = o.node().getBBox()),
          o.attr(
            "transform",
            "translate(" + -f.width / 2 + ", " + (-f.height / 2 - g + 3) + ")",
          ),
          i
            .attr("class", "outer title-state")
            .attr("x", -f.width / 2 - g)
            .attr("y", -f.height / 2 - g)
            .attr("width", f.width + t.padding)
            .attr("height", f.height + t.padding),
          s
            .attr("class", "divider")
            .attr("x1", -f.width / 2 - g)
            .attr("x2", f.width / 2 + g)
            .attr("y1", -f.height / 2 - g + p.height + g)
            .attr("y2", -f.height / 2 - g + p.height + g),
          nn(t, i),
          (t.intersect = function (y) {
            return Ur.rect(t, y);
          }),
          n
        );
      }, "rectWithTitle")),
        (R7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.height + t.padding,
            s = n.width + i / 4 + t.padding,
            o = r
              .insert("rect", ":first-child")
              .attr("style", t.style)
              .attr("rx", i / 2)
              .attr("ry", i / 2)
              .attr("x", -s / 2)
              .attr("y", -i / 2)
              .attr("width", s)
              .attr("height", i);
          return (
            nn(t, o),
            (t.intersect = function (l) {
              return Ur.rect(t, l);
            }),
            r
          );
        }, "stadium")),
        (D7t = a(async (e, t) => {
          let {
              shapeSvg: r,
              bbox: n,
              halfPadding: i,
            } = await Ln(e, t, Gs(t, void 0), !0),
            s = r.insert("circle", ":first-child");
          return (
            s
              .attr("style", t.style)
              .attr("rx", t.rx)
              .attr("ry", t.ry)
              .attr("r", n.width / 2 + i)
              .attr("width", n.width + t.padding)
              .attr("height", n.height + t.padding),
            P.info("Circle main"),
            nn(t, s),
            (t.intersect = function (o) {
              return (
                P.info("Circle intersect", t, n.width / 2 + i, o),
                Ur.circle(t, n.width / 2 + i, o)
              );
            }),
            r
          );
        }, "circle")),
        (N7t = a(async (e, t) => {
          let {
              shapeSvg: r,
              bbox: n,
              halfPadding: i,
            } = await Ln(e, t, Gs(t, void 0), !0),
            s = 5,
            o = r.insert("g", ":first-child"),
            l = o.insert("circle"),
            u = o.insert("circle");
          return (
            o.attr("class", t.class),
            l
              .attr("style", t.style)
              .attr("rx", t.rx)
              .attr("ry", t.ry)
              .attr("r", n.width / 2 + i + s)
              .attr("width", n.width + t.padding + s * 2)
              .attr("height", n.height + t.padding + s * 2),
            u
              .attr("style", t.style)
              .attr("rx", t.rx)
              .attr("ry", t.ry)
              .attr("r", n.width / 2 + i)
              .attr("width", n.width + t.padding)
              .attr("height", n.height + t.padding),
            P.info("DoubleCircle main"),
            nn(t, l),
            (t.intersect = function (h) {
              return (
                P.info("DoubleCircle intersect", t, n.width / 2 + i + s, h),
                Ur.circle(t, n.width / 2 + i + s, h)
              );
            }),
            r
          );
        }, "doublecircle")),
        (I7t = a(async (e, t) => {
          let { shapeSvg: r, bbox: n } = await Ln(e, t, Gs(t, void 0), !0),
            i = n.width + t.padding,
            s = n.height + t.padding,
            o = [
              { x: 0, y: 0 },
              { x: i, y: 0 },
              { x: i, y: -s },
              { x: 0, y: -s },
              { x: 0, y: 0 },
              { x: -8, y: 0 },
              { x: i + 8, y: 0 },
              { x: i + 8, y: -s },
              { x: -8, y: -s },
              { x: -8, y: 0 },
            ],
            l = Ja(r, i, s, o);
          return (
            l.attr("style", t.style),
            nn(t, l),
            (t.intersect = function (u) {
              return Ur.polygon(t, o, u);
            }),
            r
          );
        }, "subroutine")),
        (M7t = a((e, t) => {
          let r = e
              .insert("g")
              .attr("class", "node default")
              .attr("id", t.domId || t.id),
            n = r.insert("circle", ":first-child");
          return (
            n
              .attr("class", "state-start")
              .attr("r", 7)
              .attr("width", 14)
              .attr("height", 14),
            nn(t, n),
            (t.intersect = function (i) {
              return Ur.circle(t, 7, i);
            }),
            r
          );
        }, "start")),
        (Pot = a((e, t, r) => {
          let n = e
              .insert("g")
              .attr("class", "node default")
              .attr("id", t.domId || t.id),
            i = 70,
            s = 10;
          r === "LR" && ((i = 10), (s = 70));
          let o = n
            .append("rect")
            .attr("x", (-1 * i) / 2)
            .attr("y", (-1 * s) / 2)
            .attr("width", i)
            .attr("height", s)
            .attr("class", "fork-join");
          return (
            nn(t, o),
            (t.height = t.height + t.padding / 2),
            (t.width = t.width + t.padding / 2),
            (t.intersect = function (l) {
              return Ur.rect(t, l);
            }),
            n
          );
        }, "forkJoin")),
        (O7t = a((e, t) => {
          let r = e
              .insert("g")
              .attr("class", "node default")
              .attr("id", t.domId || t.id),
            n = r.insert("circle", ":first-child"),
            i = r.insert("circle", ":first-child");
          return (
            i
              .attr("class", "state-start")
              .attr("r", 7)
              .attr("width", 14)
              .attr("height", 14),
            n
              .attr("class", "state-end")
              .attr("r", 5)
              .attr("width", 10)
              .attr("height", 10),
            nn(t, i),
            (t.intersect = function (s) {
              return Ur.circle(t, 7, s);
            }),
            r
          );
        }, "end")),
        (P7t = a(async (e, t) => {
          let r = t.padding / 2,
            n = 4,
            i = 8,
            s;
          t.classes ? (s = "node " + t.classes) : (s = "node default");
          let o = e
              .insert("g")
              .attr("class", s)
              .attr("id", t.domId || t.id),
            l = o.insert("rect", ":first-child"),
            u = o.insert("line"),
            h = o.insert("line"),
            f = 0,
            d = n,
            p = o.insert("g").attr("class", "label"),
            m = 0,
            g = t.classData.annotations?.[0],
            y = t.classData.annotations[0]
              ? "\xAB" + t.classData.annotations[0] + "\xBB"
              : "",
            b = p.node().appendChild(await Zi(y, t.labelStyle, !0, !0)),
            k = b.getBBox();
          if (Pe(K().flowchart.htmlLabels)) {
            let E = b.children[0],
              R = xt(b);
            ((k = E.getBoundingClientRect()),
              R.attr("width", k.width),
              R.attr("height", k.height));
          }
          t.classData.annotations[0] && ((d += k.height + n), (f += k.width));
          let T = t.classData.label;
          t.classData.type !== void 0 &&
            t.classData.type !== "" &&
            (K().flowchart.htmlLabels
              ? (T += "&lt;" + t.classData.type + "&gt;")
              : (T += "<" + t.classData.type + ">"));
          let C = p.node().appendChild(await Zi(T, t.labelStyle, !0, !0));
          xt(C).attr("class", "classTitle");
          let L = C.getBBox();
          if (Pe(K().flowchart.htmlLabels)) {
            let E = C.children[0],
              R = xt(C);
            ((L = E.getBoundingClientRect()),
              R.attr("width", L.width),
              R.attr("height", L.height));
          }
          ((d += L.height + n), L.width > f && (f = L.width));
          let w = [];
          (t.classData.members.forEach(async (E) => {
            let R = E.getDisplayDetails(),
              F = R.displayText;
            K().flowchart.htmlLabels &&
              (F = F.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
            let S = p
                .node()
                .appendChild(
                  await Zi(F, R.cssStyle ? R.cssStyle : t.labelStyle, !0, !0),
                ),
              O = S.getBBox();
            if (Pe(K().flowchart.htmlLabels)) {
              let v = S.children[0],
                _ = xt(S);
              ((O = v.getBoundingClientRect()),
                _.attr("width", O.width),
                _.attr("height", O.height));
            }
            (O.width > f && (f = O.width), (d += O.height + n), w.push(S));
          }),
            (d += i));
          let D = [];
          if (
            (t.classData.methods.forEach(async (E) => {
              let R = E.getDisplayDetails(),
                F = R.displayText;
              K().flowchart.htmlLabels &&
                (F = F.replace(/</g, "&lt;").replace(/>/g, "&gt;"));
              let S = p
                  .node()
                  .appendChild(
                    await Zi(F, R.cssStyle ? R.cssStyle : t.labelStyle, !0, !0),
                  ),
                O = S.getBBox();
              if (Pe(K().flowchart.htmlLabels)) {
                let v = S.children[0],
                  _ = xt(S);
                ((O = v.getBoundingClientRect()),
                  _.attr("width", O.width),
                  _.attr("height", O.height));
              }
              (O.width > f && (f = O.width), (d += O.height + n), D.push(S));
            }),
            (d += i),
            g)
          ) {
            let E = (f - k.width) / 2;
            (xt(b).attr(
              "transform",
              "translate( " + ((-1 * f) / 2 + E) + ", " + (-1 * d) / 2 + ")",
            ),
              (m = k.height + n));
          }
          let G = (f - L.width) / 2;
          return (
            xt(C).attr(
              "transform",
              "translate( " +
                ((-1 * f) / 2 + G) +
                ", " +
                ((-1 * d) / 2 + m) +
                ")",
            ),
            (m += L.height + n),
            u
              .attr("class", "divider")
              .attr("x1", -f / 2 - r)
              .attr("x2", f / 2 + r)
              .attr("y1", -d / 2 - r + i + m)
              .attr("y2", -d / 2 - r + i + m),
            (m += i),
            w.forEach((E) => {
              xt(E).attr(
                "transform",
                "translate( " +
                  -f / 2 +
                  ", " +
                  ((-1 * d) / 2 + m + i / 2) +
                  ")",
              );
              let R = E?.getBBox();
              m += (R?.height ?? 0) + n;
            }),
            (m += i),
            h
              .attr("class", "divider")
              .attr("x1", -f / 2 - r)
              .attr("x2", f / 2 + r)
              .attr("y1", -d / 2 - r + i + m)
              .attr("y2", -d / 2 - r + i + m),
            (m += i),
            D.forEach((E) => {
              xt(E).attr(
                "transform",
                "translate( " + -f / 2 + ", " + ((-1 * d) / 2 + m) + ")",
              );
              let R = E?.getBBox();
              m += (R?.height ?? 0) + n;
            }),
            l
              .attr("style", t.style)
              .attr("class", "outer title-state")
              .attr("x", -f / 2 - r)
              .attr("y", -(d / 2) - r)
              .attr("width", f + t.padding)
              .attr("height", d + t.padding),
            nn(t, l),
            (t.intersect = function (E) {
              return Ur.rect(t, E);
            }),
            o
          );
        }, "class_box")),
        (Bot = {
          rhombus: Oot,
          composite: E7t,
          question: Oot,
          rect: v7t,
          labelRect: A7t,
          rectWithTitle: L7t,
          choice: g7t,
          circle: D7t,
          doublecircle: N7t,
          stadium: R7t,
          hexagon: y7t,
          block_arrow: x7t,
          rect_left_inv_arrow: b7t,
          lean_right: k7t,
          lean_left: T7t,
          trapezoid: S7t,
          inv_trapezoid: _7t,
          rect_right_inv_arrow: C7t,
          cylinder: w7t,
          start: M7t,
          end: O7t,
          note: Not,
          subroutine: I7t,
          fork: Pot,
          join: Pot,
          class_box: P7t,
        }),
        (pC = {}),
        (I8 = a(async (e, t, r) => {
          let n, i;
          if (t.link) {
            let s;
            (K().securityLevel === "sandbox"
              ? (s = "_top")
              : t.linkTarget && (s = t.linkTarget || "_blank"),
              (n = e
                .insert("svg:a")
                .attr("xlink:href", t.link)
                .attr("target", s)),
              (i = await Bot[t.shape](n, t, r)));
          } else ((i = await Bot[t.shape](e, t, r)), (n = i));
          return (
            t.tooltip && i.attr("title", t.tooltip),
            t.class && i.attr("class", "node default " + t.class),
            (pC[t.id] = n),
            t.haveCallback &&
              pC[t.id].attr("class", pC[t.id].attr("class") + " clickable"),
            n
          );
        }, "insertNode")),
        (Fot = a((e) => {
          let t = pC[e.id];
          P.trace(
            "Transforming node",
            e.diff,
            e,
            "translate(" + (e.x - e.width / 2 - 5) + ", " + e.width / 2 + ")",
          );
          let r = 8,
            n = e.diff || 0;
          return (
            e.clusterNode
              ? t.attr(
                  "transform",
                  "translate(" +
                    (e.x + n - e.width / 2) +
                    ", " +
                    (e.y - e.height / 2 - r) +
                    ")",
                )
              : t.attr("transform", "translate(" + e.x + ", " + e.y + ")"),
            n
          );
        }, "positionNode")));
    });
  function Got(e, t, r = !1) {
    let n = e,
      i = "default";
    ((n?.classes?.length || 0) > 0 && (i = (n?.classes ?? []).join(" ")),
      (i = i + " flowchart-label"));
    let s = 0,
      o = "",
      l;
    switch (n.type) {
      case "round":
        ((s = 5), (o = "rect"));
        break;
      case "composite":
        ((s = 0), (o = "composite"), (l = 0));
        break;
      case "square":
        o = "rect";
        break;
      case "diamond":
        o = "question";
        break;
      case "hexagon":
        o = "hexagon";
        break;
      case "block_arrow":
        o = "block_arrow";
        break;
      case "odd":
        o = "rect_left_inv_arrow";
        break;
      case "lean_right":
        o = "lean_right";
        break;
      case "lean_left":
        o = "lean_left";
        break;
      case "trapezoid":
        o = "trapezoid";
        break;
      case "inv_trapezoid":
        o = "inv_trapezoid";
        break;
      case "rect_left_inv_arrow":
        o = "rect_left_inv_arrow";
        break;
      case "circle":
        o = "circle";
        break;
      case "ellipse":
        o = "ellipse";
        break;
      case "stadium":
        o = "stadium";
        break;
      case "subroutine":
        o = "subroutine";
        break;
      case "cylinder":
        o = "cylinder";
        break;
      case "group":
        o = "rect";
        break;
      case "doublecircle":
        o = "doublecircle";
        break;
      default:
        o = "rect";
    }
    let u = E4(n?.styles ?? []),
      h = n.label,
      f = n.size ?? { width: 0, height: 0, x: 0, y: 0 };
    return {
      labelStyle: u.labelStyle,
      shape: o,
      labelText: h,
      rx: s,
      ry: s,
      class: i,
      style: u.style,
      id: n.id,
      directions: n.directions,
      width: f.width,
      height: f.height,
      x: f.x,
      y: f.y,
      positioned: r,
      intersect: void 0,
      type: n.type,
      padding: l ?? ke()?.block?.padding ?? 0,
    };
  }
  async function B7t(e, t, r) {
    let n = Got(t, r, !1);
    if (n.type === "group") return;
    let i = ke(),
      s = await I8(e, n, { config: i }),
      o = s.node().getBBox(),
      l = r.getBlock(n.id);
    ((l.size = { width: o.width, height: o.height, x: 0, y: 0, node: s }),
      r.setBlock(l),
      s.remove());
  }
  async function F7t(e, t, r) {
    let n = Got(t, r, !0);
    if (r.getBlock(n.id).type !== "space") {
      let s = ke();
      (await I8(e, n, { config: s }), (t.intersect = n?.intersect), Fot(n));
    }
  }
  async function M8(e, t, r, n) {
    for (let i of t)
      (await n(e, i, r), i.children && (await M8(e, i.children, r, n)));
  }
  async function Vot(e, t, r) {
    await M8(e, t, r, B7t);
  }
  async function zot(e, t, r) {
    await M8(e, t, r, F7t);
  }
  async function Wot(e, t, r, n, i) {
    let s = new _r({ multigraph: !0, compound: !0 });
    s.setGraph({
      rankdir: "TB",
      nodesep: 10,
      ranksep: 10,
      marginx: 8,
      marginy: 8,
    });
    for (let o of r)
      o.size &&
        s.setNode(o.id, {
          width: o.size.width,
          height: o.size.height,
          intersect: o.intersect,
        });
    for (let o of t)
      if (o.start && o.end) {
        let l = n.getBlock(o.start),
          u = n.getBlock(o.end);
        if (l?.size && u?.size) {
          let h = l.size,
            f = u.size,
            d = [
              { x: h.x, y: h.y },
              { x: h.x + (f.x - h.x) / 2, y: h.y + (f.y - h.y) / 2 },
              { x: f.x, y: f.y },
            ];
          (yot(
            e,
            { v: o.start, w: o.end, name: o.id },
            {
              ...o,
              arrowTypeEnd: o.arrowTypeEnd,
              arrowTypeStart: o.arrowTypeStart,
              points: d,
              classes:
                "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1",
            },
            void 0,
            "block",
            s,
            i,
          ),
            o.label &&
              (await mot(e, {
                ...o,
                label: o.label,
                labelStyle: "stroke: #333; stroke-width: 1.5px;fill:none;",
                arrowTypeEnd: o.arrowTypeEnd,
                arrowTypeStart: o.arrowTypeStart,
                points: d,
                classes:
                  "edge-thickness-normal edge-pattern-solid flowchart-link LS-a1 LE-b1",
              }),
              got({ ...o, x: d[1].x, y: d[1].y }, { originalPath: d })));
        }
      }
  }
  var Uot = x(() => {
    "use strict";
    aa();
    un();
    xot();
    $ot();
    _e();
    a(Got, "getNodeFromBlock");
    a(B7t, "calculateBlockSize");
    a(F7t, "insertBlockPositioned");
    a(M8, "performOperations");
    a(Vot, "calculateBlockSizes");
    a(zot, "insertBlocks");
    a(Wot, "insertEdges");
  });
  var $7t,
    G7t,
    jot,
    qot = x(() => {
      "use strict";
      Ge();
      un();
      sot();
      Vt();
      On();
      cot();
      Uot();
      (($7t = a(function (e, t) {
        return t.db.getClasses();
      }, "getClasses")),
        (G7t = a(async function (e, t, r, n) {
          let { securityLevel: i, block: s } = ke(),
            o = n.db,
            l;
          i === "sandbox" && (l = xt("#i" + t));
          let u =
              i === "sandbox"
                ? xt(l.nodes()[0].contentDocument.body)
                : xt("body"),
            h = i === "sandbox" ? u.select(`[id="${t}"]`) : xt(`[id="${t}"]`);
          iot(h, ["point", "circle", "cross"], n.type, t);
          let d = o.getBlocks(),
            p = o.getBlocksFlat(),
            m = o.getEdges(),
            g = h.insert("g").attr("class", "block");
          await Vot(g, d, o);
          let y = lot(o);
          if ((await zot(g, d, o), await Wot(g, m, p, o, t), y)) {
            let b = y,
              k = Math.max(1, Math.round(0.125 * (b.width / b.height))),
              T = b.height + k + 10,
              C = b.width + 10,
              { useMaxWidth: L } = s;
            (Ar(h, T, C, !!L),
              P.debug("Here Bounds", y, b),
              h.attr(
                "viewBox",
                `${b.x - 5} ${b.y - 5} ${b.width + 10} ${b.height + 10}`,
              ));
          }
        }, "draw")),
        (jot = { draw: G7t, getClasses: $7t }));
    });
  var Hot = {};
  Oe(Hot, { diagram: () => V7t });
  var V7t,
    Yot = x(() => {
      "use strict";
      Yat();
      eot();
      not();
      qot();
      V7t = { parser: Hat, db: tot, renderer: jot, styles: rot };
    });
  var Pm,
    O8 = x(() => {
      "use strict";
      Ss();
      un();
      _e();
      re();
      yn();
      Pm = class {
        constructor() {
          this.nodes = [];
          this.levels = new Map();
          this.outerNodes = [];
          this.classes = new Map();
          this.setAccTitle = Xe;
          this.getAccTitle = tr;
          this.setDiagramTitle = lr;
          this.getDiagramTitle = nr;
          this.getAccDescription = rr;
          this.setAccDescription = er;
        }
        static {
          a(this, "TreeMapDB");
        }
        getNodes() {
          return this.nodes;
        }
        getConfig() {
          let t = ze,
            r = ke();
          return on({ ...t.treemap, ...(r.treemap ?? {}) });
        }
        addNode(t, r) {
          (this.nodes.push(t),
            this.levels.set(t, r),
            r === 0 && (this.outerNodes.push(t), (this.root ??= t)));
        }
        getRoot() {
          return { name: "", children: this.outerNodes };
        }
        addClass(t, r) {
          let n = this.classes.get(t) ?? { id: t, styles: [], textStyles: [] },
            i = r
              .replace(/\\,/g, "\xA7\xA7\xA7")
              .replace(/,/g, ";")
              .replace(/§§§/g, ",")
              .split(";");
          (i &&
            i.forEach((s) => {
              (D0(s) &&
                (n?.textStyles ? n.textStyles.push(s) : (n.textStyles = [s])),
                n?.styles ? n.styles.push(s) : (n.styles = [s]));
            }),
            this.classes.set(t, n));
        }
        getClasses() {
          return this.classes;
        }
        getStylesForClass(t) {
          return this.classes.get(t)?.styles ?? [];
        }
        clear() {
          (Ye(),
            (this.nodes = []),
            (this.levels = new Map()),
            (this.outerNodes = []),
            (this.classes = new Map()),
            (this.root = void 0));
        }
      };
    });
  function Qot(e) {
    if (!e.length) return [];
    let t = [],
      r = [];
    return (
      e.forEach((n) => {
        let i = { name: n.name, children: n.type === "Leaf" ? void 0 : [] };
        for (
          i.classSelector = n?.classSelector,
            n?.cssCompiledStyles &&
              (i.cssCompiledStyles = [n.cssCompiledStyles]),
            n.type === "Leaf" && n.value !== void 0 && (i.value = n.value);
          r.length > 0 && r[r.length - 1].level >= n.level;

        )
          r.pop();
        if (r.length === 0) t.push(i);
        else {
          let s = r[r.length - 1].node;
          s.children ? s.children.push(i) : (s.children = [i]);
        }
        n.type !== "Leaf" && r.push({ node: i, level: n.level });
      }),
      t
    );
  }
  var Zot = x(() => {
    "use strict";
    a(Qot, "buildHierarchy");
  });
  var j7t,
    q7t,
    P8,
    Jot = x(() => {
      "use strict";
      jh();
      Vt();
      gm();
      Zot();
      O8();
      ((j7t = a((e, t) => {
        qo(e, t);
        let r = [];
        for (let s of e.TreemapRows ?? [])
          s.$type === "ClassDefStatement" &&
            t.addClass(s.className ?? "", s.styleText ?? "");
        for (let s of e.TreemapRows ?? []) {
          let o = s.item;
          if (!o) continue;
          let l = s.indent ? parseInt(s.indent) : 0,
            u = q7t(o),
            h = o.classSelector ? t.getStylesForClass(o.classSelector) : [],
            f = h.length > 0 ? h.join(";") : void 0,
            d = {
              level: l,
              name: u,
              type: o.$type,
              value: o.value,
              classSelector: o.classSelector,
              cssCompiledStyles: f,
            };
          r.push(d);
        }
        let n = Qot(r),
          i = a((s, o) => {
            for (let l of s)
              (t.addNode(l, o),
                l.children && l.children.length > 0 && i(l.children, o + 1));
          }, "addNodesRecursively");
        i(n, 0);
      }, "populate")),
        (q7t = a((e) => (e.name ? String(e.name) : ""), "getItemName")),
        (P8 = {
          parser: { yy: void 0 },
          parse: a(async (e) => {
            try {
              let r = await Bs("treemap", e);
              P.debug("Treemap AST:", r);
              let n = P8.parser?.yy;
              if (!(n instanceof Pm))
                throw new Error(
                  "parser.parser?.yy was not a TreemapDB. This is due to a bug within Mermaid, please report this issue at https://github.com/mermaid-js/mermaid/issues.",
                );
              j7t(r, n);
            } catch (t) {
              throw (P.error("Error parsing treemap:", t), t);
            }
          }, "parse"),
        }));
    });
  var H7t,
    Bm,
    Zy,
    Y7t,
    X7t,
    tlt,
    elt = x(() => {
      "use strict";
      Fl();
      mh();
      On();
      Ge();
      re();
      un();
      Vt();
      ((H7t = 10),
        (Bm = 10),
        (Zy = 25),
        (Y7t = a((e, t, r, n) => {
          let i = n.db,
            s = i.getConfig(),
            o = s.padding ?? H7t,
            l = i.getDiagramTitle(),
            u = i.getRoot(),
            { themeVariables: h } = ke();
          if (!u) return;
          let f = l ? 30 : 0,
            d = Ei(t),
            p = s.nodeWidth ? s.nodeWidth * Bm : 960,
            m = s.nodeHeight ? s.nodeHeight * Bm : 500,
            g = p,
            y = m + f;
          (d.attr("viewBox", `0 0 ${g} ${y}`), Ar(d, y, g, s.useMaxWidth));
          let b;
          try {
            let _ = s.valueFormat || ",";
            if (_ === "$0,0") b = a((A) => "$" + lo(",")(A), "valueFormat");
            else if (_.startsWith("$") && _.includes(",")) {
              let A = /\.\d+/.exec(_),
                N = A ? A[0] : "";
              b = a((B) => "$" + lo("," + N)(B), "valueFormat");
            } else if (_.startsWith("$")) {
              let A = _.substring(1);
              b = a((N) => "$" + lo(A || "")(N), "valueFormat");
            } else b = lo(_);
          } catch (_) {
            (P.error("Error creating format function:", _), (b = lo(",")));
          }
          let k = _s().range([
              "transparent",
              h.cScale0,
              h.cScale1,
              h.cScale2,
              h.cScale3,
              h.cScale4,
              h.cScale5,
              h.cScale6,
              h.cScale7,
              h.cScale8,
              h.cScale9,
              h.cScale10,
              h.cScale11,
            ]),
            T = _s().range([
              "transparent",
              h.cScalePeer0,
              h.cScalePeer1,
              h.cScalePeer2,
              h.cScalePeer3,
              h.cScalePeer4,
              h.cScalePeer5,
              h.cScalePeer6,
              h.cScalePeer7,
              h.cScalePeer8,
              h.cScalePeer9,
              h.cScalePeer10,
              h.cScalePeer11,
            ]),
            C = _s().range([
              h.cScaleLabel0,
              h.cScaleLabel1,
              h.cScaleLabel2,
              h.cScaleLabel3,
              h.cScaleLabel4,
              h.cScaleLabel5,
              h.cScaleLabel6,
              h.cScaleLabel7,
              h.cScaleLabel8,
              h.cScaleLabel9,
              h.cScaleLabel10,
              h.cScaleLabel11,
            ]);
          l &&
            d
              .append("text")
              .attr("x", g / 2)
              .attr("y", f / 2)
              .attr("class", "treemapTitle")
              .attr("text-anchor", "middle")
              .attr("dominant-baseline", "middle")
              .text(l);
          let L = d
              .append("g")
              .attr("transform", `translate(0, ${f})`)
              .attr("class", "treemapContainer"),
            w = Lf(u)
              .sum((_) => _.value ?? 0)
              .sort((_, A) => (A.value ?? 0) - (_.value ?? 0)),
            G = m2()
              .size([p, m])
              .paddingTop((_) =>
                _.children && _.children.length > 0 ? Zy + Bm : 0,
              )
              .paddingInner(o)
              .paddingLeft((_) =>
                _.children && _.children.length > 0 ? Bm : 0,
              )
              .paddingRight((_) =>
                _.children && _.children.length > 0 ? Bm : 0,
              )
              .paddingBottom((_) =>
                _.children && _.children.length > 0 ? Bm : 0,
              )
              .round(!0)(w),
            E = G.descendants().filter(
              (_) => _.children && _.children.length > 0,
            ),
            R = L.selectAll(".treemapSection")
              .data(E)
              .enter()
              .append("g")
              .attr("class", "treemapSection")
              .attr("transform", (_) => `translate(${_.x0},${_.y0})`);
          (R.append("rect")
            .attr("width", (_) => _.x1 - _.x0)
            .attr("height", Zy)
            .attr("class", "treemapSectionHeader")
            .attr("fill", "none")
            .attr("fill-opacity", 0.6)
            .attr("stroke-width", 0.6)
            .attr("style", (_) => (_.depth === 0 ? "display: none;" : "")),
            R.append("clipPath")
              .attr("id", (_, A) => `clip-section-${t}-${A}`)
              .append("rect")
              .attr("width", (_) => Math.max(0, _.x1 - _.x0 - 12))
              .attr("height", Zy),
            R.append("rect")
              .attr("width", (_) => _.x1 - _.x0)
              .attr("height", (_) => _.y1 - _.y0)
              .attr("class", (_, A) => `treemapSection section${A}`)
              .attr("fill", (_) => k(_.data.name))
              .attr("fill-opacity", 0.6)
              .attr("stroke", (_) => T(_.data.name))
              .attr("stroke-width", 2)
              .attr("stroke-opacity", 0.4)
              .attr("style", (_) => {
                if (_.depth === 0) return "display: none;";
                let A = St({ cssCompiledStyles: _.data.cssCompiledStyles });
                return A.nodeStyles + ";" + A.borderStyles.join(";");
              }),
            R.append("text")
              .attr("class", "treemapSectionLabel")
              .attr("x", 6)
              .attr("y", Zy / 2)
              .attr("dominant-baseline", "middle")
              .text((_) => (_.depth === 0 ? "" : _.data.name))
              .attr("font-weight", "bold")
              .attr("style", (_) => {
                if (_.depth === 0) return "display: none;";
                let A =
                    "dominant-baseline: middle; font-size: 12px; fill:" +
                    C(_.data.name) +
                    "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;",
                  N = St({ cssCompiledStyles: _.data.cssCompiledStyles });
                return A + N.labelStyles.replace("color:", "fill:");
              })
              .each(function (_) {
                if (_.depth === 0) return;
                let A = xt(this),
                  N = _.data.name;
                A.text(N);
                let B = _.x1 - _.x0,
                  M = 6,
                  I;
                s.showValues !== !1 && _.value
                  ? (I = B - 10 - 30 - 10 - M)
                  : (I = B - M - 6);
                let $ = Math.max(15, I),
                  q = A.node();
                if (q.getComputedTextLength() > $) {
                  let ht = "...",
                    H = N;
                  for (; H.length > 0; ) {
                    if (((H = N.substring(0, H.length - 1)), H.length === 0)) {
                      (A.text(ht), q.getComputedTextLength() > $ && A.text(""));
                      break;
                    }
                    if ((A.text(H + ht), q.getComputedTextLength() <= $)) break;
                  }
                }
              }),
            s.showValues !== !1 &&
              R.append("text")
                .attr("class", "treemapSectionValue")
                .attr("x", (_) => _.x1 - _.x0 - 10)
                .attr("y", Zy / 2)
                .attr("text-anchor", "end")
                .attr("dominant-baseline", "middle")
                .text((_) => (_.value ? b(_.value) : ""))
                .attr("font-style", "italic")
                .attr("style", (_) => {
                  if (_.depth === 0) return "display: none;";
                  let A =
                      "text-anchor: end; dominant-baseline: middle; font-size: 10px; fill:" +
                      C(_.data.name) +
                      "; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;",
                    N = St({ cssCompiledStyles: _.data.cssCompiledStyles });
                  return A + N.labelStyles.replace("color:", "fill:");
                }));
          let F = G.leaves(),
            S = L.selectAll(".treemapLeafGroup")
              .data(F)
              .enter()
              .append("g")
              .attr(
                "class",
                (_, A) =>
                  `treemapNode treemapLeafGroup leaf${A}${_.data.classSelector ? ` ${_.data.classSelector}` : ""}x`,
              )
              .attr("transform", (_) => `translate(${_.x0},${_.y0})`);
          (S.append("rect")
            .attr("width", (_) => _.x1 - _.x0)
            .attr("height", (_) => _.y1 - _.y0)
            .attr("class", "treemapLeaf")
            .attr("fill", (_) =>
              _.parent ? k(_.parent.data.name) : k(_.data.name),
            )
            .attr(
              "style",
              (_) =>
                St({ cssCompiledStyles: _.data.cssCompiledStyles }).nodeStyles,
            )
            .attr("fill-opacity", 0.3)
            .attr("stroke", (_) =>
              _.parent ? k(_.parent.data.name) : k(_.data.name),
            )
            .attr("stroke-width", 3),
            S.append("clipPath")
              .attr("id", (_, A) => `clip-${t}-${A}`)
              .append("rect")
              .attr("width", (_) => Math.max(0, _.x1 - _.x0 - 4))
              .attr("height", (_) => Math.max(0, _.y1 - _.y0 - 4)),
            S.append("text")
              .attr("class", "treemapLabel")
              .attr("x", (_) => (_.x1 - _.x0) / 2)
              .attr("y", (_) => (_.y1 - _.y0) / 2)
              .attr("style", (_) => {
                let A =
                    "text-anchor: middle; dominant-baseline: middle; font-size: 38px;fill:" +
                    C(_.data.name) +
                    ";",
                  N = St({ cssCompiledStyles: _.data.cssCompiledStyles });
                return A + N.labelStyles.replace("color:", "fill:");
              })
              .attr("clip-path", (_, A) => `url(#clip-${t}-${A})`)
              .text((_) => _.data.name)
              .each(function (_) {
                let A = xt(this),
                  N = _.x1 - _.x0,
                  B = _.y1 - _.y0,
                  M = A.node(),
                  I = 4,
                  V = N - 2 * I,
                  $ = B - 2 * I;
                if (V < 10 || $ < 10) {
                  A.style("display", "none");
                  return;
                }
                let q = parseInt(A.style("font-size"), 10),
                  tt = 8,
                  ht = 28,
                  H = 0.6,
                  kt = 6,
                  ft = 2;
                for (; M.getComputedTextLength() > V && q > tt; )
                  (q--, A.style("font-size", `${q}px`));
                let yt = Math.max(kt, Math.min(ht, Math.round(q * H))),
                  ot = q + ft + yt;
                for (
                  ;
                  ot > $ &&
                  q > tt &&
                  (q--,
                  (yt = Math.max(kt, Math.min(ht, Math.round(q * H)))),
                  !(yt < kt && q === tt));

                )
                  (A.style("font-size", `${q}px`),
                    (ot = q + ft + yt),
                    yt <= kt && ot > $);
                (A.style("font-size", `${q}px`),
                  (M.getComputedTextLength() > V || q < tt || $ < q) &&
                    A.style("display", "none"));
              }),
            s.showValues !== !1 &&
              S.append("text")
                .attr("class", "treemapValue")
                .attr("x", (A) => (A.x1 - A.x0) / 2)
                .attr("y", function (A) {
                  return (A.y1 - A.y0) / 2;
                })
                .attr("style", (A) => {
                  let N =
                      "text-anchor: middle; dominant-baseline: hanging; font-size: 28px;fill:" +
                      C(A.data.name) +
                      ";",
                    B = St({ cssCompiledStyles: A.data.cssCompiledStyles });
                  return N + B.labelStyles.replace("color:", "fill:");
                })
                .attr("clip-path", (A, N) => `url(#clip-${t}-${N})`)
                .text((A) => (A.value ? b(A.value) : ""))
                .each(function (A) {
                  let N = xt(this),
                    B = this.parentNode;
                  if (!B) {
                    N.style("display", "none");
                    return;
                  }
                  let M = xt(B).select(".treemapLabel");
                  if (M.empty() || M.style("display") === "none") {
                    N.style("display", "none");
                    return;
                  }
                  let I = parseFloat(M.style("font-size")),
                    V = 28,
                    $ = 0.6,
                    q = 6,
                    tt = 2,
                    ht = Math.max(q, Math.min(V, Math.round(I * $)));
                  N.style("font-size", `${ht}px`);
                  let kt = (A.y1 - A.y0) / 2 + I / 2 + tt;
                  N.attr("y", kt);
                  let ft = A.x1 - A.x0,
                    dt = A.y1 - A.y0 - 4,
                    nt = ft - 2 * 4;
                  N.node().getComputedTextLength() > nt ||
                  kt + ht > dt ||
                  ht < q
                    ? N.style("display", "none")
                    : N.style("display", null);
                }));
          let v = s.diagramPadding ?? 8;
          la(d, v, "flowchart", s?.useMaxWidth || !1);
        }, "draw")),
        (X7t = a(function (e, t) {
          return t.db.getClasses();
        }, "getClasses")),
        (tlt = { draw: Y7t, getClasses: X7t }));
    });
  var K7t,
    Q7t,
    rlt,
    nlt = x(() => {
      "use strict";
      _e();
      ((K7t = {
        sectionStrokeColor: "black",
        sectionStrokeWidth: "1",
        sectionFillColor: "#efefef",
        leafStrokeColor: "black",
        leafStrokeWidth: "1",
        leafFillColor: "#efefef",
        labelColor: "black",
        labelFontSize: "12px",
        valueFontSize: "10px",
        valueColor: "black",
        titleColor: "black",
        titleFontSize: "14px",
      }),
        (Q7t = a(({ treemap: e } = {}) => {
          let t = on(K7t, e);
          return `
  .treemapNode.section {
    stroke: ${t.sectionStrokeColor};
    stroke-width: ${t.sectionStrokeWidth};
    fill: ${t.sectionFillColor};
  }
  .treemapNode.leaf {
    stroke: ${t.leafStrokeColor};
    stroke-width: ${t.leafStrokeWidth};
    fill: ${t.leafFillColor};
  }
  .treemapLabel {
    fill: ${t.labelColor};
    font-size: ${t.labelFontSize};
  }
  .treemapValue {
    fill: ${t.valueColor};
    font-size: ${t.valueFontSize};
  }
  .treemapTitle {
    fill: ${t.titleColor};
    font-size: ${t.titleFontSize};
  }
  `;
        }, "getStyles")),
        (rlt = Q7t));
    });
  var ilt = {};
  Oe(ilt, { diagram: () => Z7t });
  var Z7t,
    slt = x(() => {
      "use strict";
      O8();
      Jot();
      elt();
      nlt();
      Z7t = {
        parser: P8,
        get db() {
          return new Pm();
        },
        renderer: tlt,
        styles: rlt,
      };
    });
  var FMt = {};
  Oe(FMt, { default: () => BMt });
  bu();
  mw();
  Tu();
  var rG = "c4",
    tyt = a(
      (e) =>
        /^\s*C4Context|C4Container|C4Component|C4Dynamic|C4Deployment/.test(e),
      "detector",
    ),
    eyt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (eG(), tG));
      return { id: rG, diagram: e };
    }, "loader"),
    ryt = { id: rG, detector: tyt, loader: eyt },
    nG = ryt;
  var cK = "flowchart",
    FEt = a(
      (e, t) =>
        t?.flowchart?.defaultRenderer === "dagre-wrapper" ||
        t?.flowchart?.defaultRenderer === "elk"
          ? !1
          : /^\s*graph/.test(e),
      "detector",
    ),
    $Et = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (n6(), r6));
      return { id: cK, diagram: e };
    }, "loader"),
    GEt = { id: cK, detector: FEt, loader: $Et },
    uK = GEt;
  var hK = "flowchart-v2",
    VEt = a(
      (e, t) =>
        t?.flowchart?.defaultRenderer === "dagre-d3"
          ? !1
          : (t?.flowchart?.defaultRenderer === "elk" && (t.layout = "elk"),
            /^\s*graph/.test(e) &&
            t?.flowchart?.defaultRenderer === "dagre-wrapper"
              ? !0
              : /^\s*flowchart/.test(e)),
      "detector",
    ),
    zEt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (n6(), r6));
      return { id: hK, diagram: e };
    }, "loader"),
    WEt = { id: hK, detector: VEt, loader: zEt },
    fK = WEt;
  var TK = "er",
    YEt = a((e) => /^\s*erDiagram/.test(e), "detector"),
    XEt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (kK(), bK));
      return { id: TK, diagram: e };
    }, "loader"),
    KEt = { id: TK, detector: YEt, loader: XEt },
    SK = KEt;
  var Det = "gitGraph",
    v6t = a((e) => /^\s*gitGraph/.test(e), "detector"),
    E6t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Ret(), Let));
      return { id: Det, diagram: e };
    }, "loader"),
    A6t = { id: Det, detector: v6t, loader: E6t },
    Net = A6t;
  var lrt = "gantt",
    mLt = a((e) => /^\s*gantt/.test(e), "detector"),
    gLt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (ort(), art));
      return { id: lrt, diagram: e };
    }, "loader"),
    yLt = { id: lrt, detector: mLt, loader: gLt },
    crt = yLt;
  var xrt = "info",
    _Lt = a((e) => /^\s*info/.test(e), "detector"),
    CLt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (yrt(), grt));
      return { id: xrt, diagram: e };
    }, "loader"),
    brt = { id: xrt, detector: _Lt, loader: CLt };
  var Lrt = "pie",
    BLt = a((e) => /^\s*pie/.test(e), "detector"),
    FLt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Art(), Ert));
      return { id: Lrt, diagram: e };
    }, "loader"),
    Rrt = { id: Lrt, detector: BLt, loader: FLt };
  var Wrt = "quadrantChart",
    rRt = a((e) => /^\s*quadrantChart/.test(e), "detector"),
    nRt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (zrt(), Vrt));
      return { id: Wrt, diagram: e };
    }, "loader"),
    iRt = { id: Wrt, detector: rRt, loader: nRt },
    Urt = iRt;
  var ynt = "xychart",
    TRt = a((e) => /^\s*xychart(-beta)?/.test(e), "detector"),
    SRt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (gnt(), mnt));
      return { id: ynt, diagram: e };
    }, "loader"),
    _Rt = { id: ynt, detector: TRt, loader: SRt },
    xnt = _Rt;
  var Ent = "requirement",
    ERt = a((e) => /^\s*requirement(Diagram)?/.test(e), "detector"),
    ARt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (vnt(), wnt));
      return { id: Ent, diagram: e };
    }, "loader"),
    LRt = { id: Ent, detector: ERt, loader: ARt },
    Ant = LRt;
  var Unt = "sequence",
    gDt = a((e) => /^\s*sequenceDiagram/.test(e), "detector"),
    yDt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Wnt(), znt));
      return { id: Unt, diagram: e };
    }, "loader"),
    xDt = { id: Unt, detector: gDt, loader: yDt },
    jnt = xDt;
  var Qnt = "class",
    CDt = a(
      (e, t) =>
        t?.class?.defaultRenderer === "dagre-wrapper"
          ? !1
          : /^\s*classDiagram/.test(e),
      "detector",
    ),
    wDt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Knt(), Xnt));
      return { id: Qnt, diagram: e };
    }, "loader"),
    vDt = { id: Qnt, detector: CDt, loader: wDt },
    Znt = vDt;
  var eit = "classDiagram",
    ADt = a(
      (e, t) =>
        /^\s*classDiagram/.test(e) &&
        t?.class?.defaultRenderer === "dagre-wrapper"
          ? !0
          : /^\s*classDiagram-v2/.test(e),
      "detector",
    ),
    LDt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (tit(), Jnt));
      return { id: eit, diagram: e };
    }, "loader"),
    RDt = { id: eit, detector: ADt, loader: LDt },
    rit = RDt;
  var Iit = "state",
    eNt = a(
      (e, t) =>
        t?.state?.defaultRenderer === "dagre-wrapper"
          ? !1
          : /^\s*stateDiagram/.test(e),
      "detector",
    ),
    rNt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Nit(), Dit));
      return { id: Iit, diagram: e };
    }, "loader"),
    nNt = { id: Iit, detector: eNt, loader: rNt },
    Mit = nNt;
  var Bit = "stateDiagram",
    sNt = a(
      (e, t) =>
        !!(
          /^\s*stateDiagram-v2/.test(e) ||
          (/^\s*stateDiagram/.test(e) &&
            t?.state?.defaultRenderer === "dagre-wrapper")
        ),
      "detector",
    ),
    aNt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Pit(), Oit));
      return { id: Bit, diagram: e };
    }, "loader"),
    oNt = { id: Bit, detector: sNt, loader: aNt },
    Fit = oNt;
  var tst = "journey",
    ANt = a((e) => /^\s*journey/.test(e), "detector"),
    LNt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Jit(), Zit));
      return { id: tst, diagram: e };
    }, "loader"),
    RNt = { id: tst, detector: ANt, loader: LNt },
    est = RNt;
  Vt();
  Fl();
  On();
  var DNt = a((e, t, r) => {
      P.debug(`rendering svg for syntax error
`);
      let n = Ei(t),
        i = n.append("g");
      (n.attr("viewBox", "0 0 2412 512"),
        Ar(n, 100, 512, !0),
        i
          .append("path")
          .attr("class", "error-icon")
          .attr(
            "d",
            "m411.313,123.313c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32-9.375,9.375-20.688-20.688c-12.484-12.5-32.766-12.5-45.25,0l-16,16c-1.261,1.261-2.304,2.648-3.31,4.051-21.739-8.561-45.324-13.426-70.065-13.426-105.867,0-192,86.133-192,192s86.133,192 192,192 192-86.133 192-192c0-24.741-4.864-48.327-13.426-70.065 1.402-1.007 2.79-2.049 4.051-3.31l16-16c12.5-12.492 12.5-32.758 0-45.25l-20.688-20.688 9.375-9.375 32.001-31.999zm-219.313,100.687c-52.938,0-96,43.063-96,96 0,8.836-7.164,16-16,16s-16-7.164-16-16c0-70.578 57.422-128 128-128 8.836,0 16,7.164 16,16s-7.164,16-16,16z",
          ),
        i
          .append("path")
          .attr("class", "error-icon")
          .attr(
            "d",
            "m459.02,148.98c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l16,16c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16.001-16z",
          ),
        i
          .append("path")
          .attr("class", "error-icon")
          .attr(
            "d",
            "m340.395,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688 6.25-6.25 6.25-16.375 0-22.625l-16-16c-6.25-6.25-16.375-6.25-22.625,0s-6.25,16.375 0,22.625l15.999,16z",
          ),
        i
          .append("path")
          .attr("class", "error-icon")
          .attr(
            "d",
            "m400,64c8.844,0 16-7.164 16-16v-32c0-8.836-7.156-16-16-16-8.844,0-16,7.164-16,16v32c0,8.836 7.156,16 16,16z",
          ),
        i
          .append("path")
          .attr("class", "error-icon")
          .attr(
            "d",
            "m496,96.586h-32c-8.844,0-16,7.164-16,16 0,8.836 7.156,16 16,16h32c8.844,0 16-7.164 16-16 0-8.836-7.156-16-16-16z",
          ),
        i
          .append("path")
          .attr("class", "error-icon")
          .attr(
            "d",
            "m436.98,75.605c3.125,3.125 7.219,4.688 11.313,4.688 4.094,0 8.188-1.563 11.313-4.688l32-32c6.25-6.25 6.25-16.375 0-22.625s-16.375-6.25-22.625,0l-32,32c-6.251,6.25-6.251,16.375-0.001,22.625z",
          ),
        i
          .append("text")
          .attr("class", "error-text")
          .attr("x", 1440)
          .attr("y", 250)
          .attr("font-size", "150px")
          .style("text-anchor", "middle")
          .text("Syntax error in text"),
        i
          .append("text")
          .attr("class", "error-text")
          .attr("x", 1250)
          .attr("y", 400)
          .attr("font-size", "100px")
          .style("text-anchor", "middle")
          .text(`mermaid version ${r}`));
    }, "draw"),
    QN = { draw: DNt },
    rst = QN;
  var NNt = { db: {}, renderer: QN, parser: { parse: a(() => {}, "parse") } },
    nst = NNt;
  var Lst = "timeline",
    QNt = a((e) => /^\s*timeline/.test(e), "detector"),
    ZNt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Ast(), Est));
      return { id: Lst, diagram: e };
    }, "loader"),
    JNt = { id: Lst, detector: QNt, loader: ZNt },
    Rst = JNt;
  var zst = "kanban",
    m8t = a((e) => /^\s*kanban/.test(e), "detector"),
    g8t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Vst(), Gst));
      return { id: zst, diagram: e };
    }, "loader"),
    y8t = { id: zst, detector: m8t, loader: g8t },
    Wst = y8t;
  var Cat = "sankey",
    G8t = a((e) => /^\s*sankey(-beta)?/.test(e), "detector"),
    V8t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (_at(), Sat));
      return { id: Cat, diagram: e };
    }, "loader"),
    z8t = { id: Cat, detector: G8t, loader: V8t },
    wat = z8t;
  var Iat = "packet",
    Q8t = a((e) => /^\s*packet(-beta)?/.test(e), "detector"),
    Z8t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Nat(), Dat));
      return { id: Iat, diagram: e };
    }, "loader"),
    Mat = { id: Iat, detector: Q8t, loader: Z8t };
  var jat = "radar",
    kIt = a((e) => /^\s*radar-beta/.test(e), "detector"),
    TIt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Uat(), Wat));
      return { id: jat, diagram: e };
    }, "loader"),
    qat = { id: jat, detector: kIt, loader: TIt };
  var Xot = "block",
    z7t = a((e) => /^\s*block(-beta)?/.test(e), "detector"),
    W7t = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (Yot(), Hot));
      return { id: Xot, diagram: e };
    }, "loader"),
    U7t = { id: Xot, detector: z7t, loader: W7t },
    Kot = U7t;
  Tu();
  pe();
  var alt = "treemap",
    J7t = a((e) => /^\s*treemap/.test(e), "detector"),
    tMt = a(async () => {
      let { diagram: e } = await Promise.resolve().then(() => (slt(), ilt));
      return { id: alt, diagram: e };
    }, "loader"),
    olt = { id: alt, detector: J7t, loader: tMt };
  var llt = !1,
    Fm = a(() => {
      llt ||
        ((llt = !0),
        Su("error", nst, (e) => e.toLowerCase().trim() === "error"),
        Su(
          "---",
          {
            db: { clear: a(() => {}, "clear") },
            styles: {},
            renderer: { draw: a(() => {}, "draw") },
            parser: {
              parse: a(() => {
                throw new Error(
                  "Diagrams beginning with --- are not valid. If you were trying to use a YAML front-matter, please ensure that you've correctly opened and closed the YAML front-matter with un-indented `---` blocks",
                );
              }, "parse"),
            },
            init: a(() => null, "init"),
          },
          (e) => e.toLowerCase().trimStart().startsWith("---"),
        ),
        Sx(
          nG,
          Wst,
          rit,
          Znt,
          SK,
          crt,
          brt,
          Rrt,
          Ant,
          jnt,
          fK,
          uK,
          Rst,
          Net,
          Fit,
          Mit,
          est,
          Urt,
          wat,
          Mat,
          xnt,
          Kot,
          qat,
          olt,
        ));
    }, "addDiagrams");
  Vt();
  Tu();
  pe();
  var clt = a(async () => {
    P.debug("Loading registered diagrams");
    let t = (
      await Promise.allSettled(
        Object.entries(el).map(async ([r, { detector: n, loader: i }]) => {
          if (i)
            try {
              cg(r);
            } catch {
              try {
                let { diagram: s, id: o } = await i();
                Su(o, s, n);
              } catch (s) {
                throw (
                  P.error(
                    `Failed to load external diagram with key ${r}. Removing from detectors.`,
                  ),
                  delete el[r],
                  s
                );
              }
            }
        }),
      )
    ).filter((r) => r.status === "rejected");
    if (t.length > 0) {
      P.error(`Failed to load ${t.length} external diagrams`);
      for (let r of t) P.error(r);
      throw new Error(`Failed to load ${t.length} external diagrams`);
    }
  }, "loadRegisteredDiagrams");
  Vt();
  Ge();
  var mC = "comm",
    gC = "rule",
    yC = "decl";
  var ult = "@import";
  var hlt = "@namespace",
    flt = "@keyframes";
  var dlt = "@layer";
  var B8 = Math.abs,
    Jy = String.fromCharCode;
  function xC(e) {
    return e.trim();
  }
  a(xC, "trim");
  function tx(e, t, r) {
    return e.replace(t, r);
  }
  a(tx, "replace");
  function plt(e, t, r) {
    return e.indexOf(t, r);
  }
  a(plt, "indexof");
  function lu(e, t) {
    return e.charCodeAt(t) | 0;
  }
  a(lu, "charat");
  function cu(e, t, r) {
    return e.slice(t, r);
  }
  a(cu, "substr");
  function Vs(e) {
    return e.length;
  }
  a(Vs, "strlen");
  function mlt(e) {
    return e.length;
  }
  a(mlt, "sizeof");
  function $m(e, t) {
    return (t.push(e), e);
  }
  a($m, "append");
  var bC = 1,
    Gm = 1,
    glt = 0,
    xa = 0,
    Rn = 0,
    zm = "";
  function kC(e, t, r, n, i, s, o, l) {
    return {
      value: e,
      root: t,
      parent: r,
      type: n,
      props: i,
      children: s,
      line: bC,
      column: Gm,
      length: o,
      return: "",
      siblings: l,
    };
  }
  a(kC, "node");
  function ylt() {
    return Rn;
  }
  a(ylt, "char");
  function xlt() {
    return (
      (Rn = xa > 0 ? lu(zm, --xa) : 0),
      Gm--,
      Rn === 10 && ((Gm = 1), bC--),
      Rn
    );
  }
  a(xlt, "prev");
  function ba() {
    return (
      (Rn = xa < glt ? lu(zm, xa++) : 0),
      Gm++,
      Rn === 10 && ((Gm = 1), bC++),
      Rn
    );
  }
  a(ba, "next");
  function zl() {
    return lu(zm, xa);
  }
  a(zl, "peek");
  function ex() {
    return xa;
  }
  a(ex, "caret");
  function TC(e, t) {
    return cu(zm, e, t);
  }
  a(TC, "slice");
  function Vm(e) {
    switch (e) {
      case 0:
      case 9:
      case 10:
      case 13:
      case 32:
        return 5;
      case 33:
      case 43:
      case 44:
      case 47:
      case 62:
      case 64:
      case 126:
      case 59:
      case 123:
      case 125:
        return 4;
      case 58:
        return 3;
      case 34:
      case 39:
      case 40:
      case 91:
        return 2;
      case 41:
      case 93:
        return 1;
    }
    return 0;
  }
  a(Vm, "token");
  function blt(e) {
    return ((bC = Gm = 1), (glt = Vs((zm = e))), (xa = 0), []);
  }
  a(blt, "alloc");
  function klt(e) {
    return ((zm = ""), e);
  }
  a(klt, "dealloc");
  function SC(e) {
    return xC(TC(xa - 1, F8(e === 91 ? e + 2 : e === 40 ? e + 1 : e)));
  }
  a(SC, "delimit");
  function Tlt(e) {
    for (; (Rn = zl()) && Rn < 33; ) ba();
    return Vm(e) > 2 || Vm(Rn) > 3 ? "" : " ";
  }
  a(Tlt, "whitespace");
  function Slt(e, t) {
    for (
      ;
      --t &&
      ba() &&
      !(Rn < 48 || Rn > 102 || (Rn > 57 && Rn < 65) || (Rn > 70 && Rn < 97));

    );
    return TC(e, ex() + (t < 6 && zl() == 32 && ba() == 32));
  }
  a(Slt, "escaping");
  function F8(e) {
    for (; ba(); )
      switch (Rn) {
        case e:
          return xa;
        case 34:
        case 39:
          e !== 34 && e !== 39 && F8(Rn);
          break;
        case 40:
          e === 41 && F8(e);
          break;
        case 92:
          ba();
          break;
      }
    return xa;
  }
  a(F8, "delimiter");
  function _lt(e, t) {
    for (; ba() && e + Rn !== 57; ) if (e + Rn === 84 && zl() === 47) break;
    return "/*" + TC(t, xa - 1) + "*" + Jy(e === 47 ? e : ba());
  }
  a(_lt, "commenter");
  function Clt(e) {
    for (; !Vm(zl()); ) ba();
    return TC(e, xa);
  }
  a(Clt, "identifier");
  function Elt(e) {
    return klt(_C("", null, null, null, [""], (e = blt(e)), 0, [0], e));
  }
  a(Elt, "compile");
  function _C(e, t, r, n, i, s, o, l, u) {
    for (
      var h = 0,
        f = 0,
        d = o,
        p = 0,
        m = 0,
        g = 0,
        y = 1,
        b = 1,
        k = 1,
        T = 0,
        C = "",
        L = i,
        w = s,
        D = n,
        G = C;
      b;

    )
      switch (((g = T), (T = ba()))) {
        case 40:
          if (g != 108 && lu(G, d - 1) == 58) {
            plt((G += tx(SC(T), "&", "&\f")), "&\f", B8(h ? l[h - 1] : 0)) !=
              -1 && (k = -1);
            break;
          }
        case 34:
        case 39:
        case 91:
          G += SC(T);
          break;
        case 9:
        case 10:
        case 13:
        case 32:
          G += Tlt(g);
          break;
        case 92:
          G += Slt(ex() - 1, 7);
          continue;
        case 47:
          switch (zl()) {
            case 42:
            case 47:
              ($m(eMt(_lt(ba(), ex()), t, r, u), u),
                (Vm(g || 1) == 5 || Vm(zl() || 1) == 5) &&
                  Vs(G) &&
                  cu(G, -1, void 0) !== " " &&
                  (G += " "));
              break;
            default:
              G += "/";
          }
          break;
        case 123 * y:
          l[h++] = Vs(G) * k;
        case 125 * y:
        case 59:
        case 0:
          switch (T) {
            case 0:
            case 125:
              b = 0;
            case 59 + f:
              (k == -1 && (G = tx(G, /\f/g, "")),
                m > 0 &&
                  (Vs(G) - d || (y === 0 && g === 47)) &&
                  $m(
                    m > 32
                      ? vlt(G + ";", n, r, d - 1, u)
                      : vlt(tx(G, " ", "") + ";", n, r, d - 2, u),
                    u,
                  ));
              break;
            case 59:
              G += ";";
            default:
              if (
                ($m(
                  (D = wlt(G, t, r, h, f, i, l, C, (L = []), (w = []), d, s)),
                  s,
                ),
                T === 123)
              )
                if (f === 0) _C(G, t, D, D, L, s, d, l, w);
                else {
                  switch (p) {
                    case 99:
                      if (lu(G, 3) === 110) break;
                    case 108:
                      if (lu(G, 2) === 97) break;
                    default:
                      f = 0;
                    case 100:
                    case 109:
                    case 115:
                  }
                  f
                    ? _C(
                        e,
                        D,
                        D,
                        n &&
                          $m(wlt(e, D, D, 0, 0, i, l, C, i, (L = []), d, w), w),
                        i,
                        w,
                        d,
                        l,
                        n ? L : w,
                      )
                    : _C(G, D, D, D, [""], w, 0, l, w);
                }
          }
          ((h = f = m = 0), (y = k = 1), (C = G = ""), (d = o));
          break;
        case 58:
          ((d = 1 + Vs(G)), (m = g));
        default:
          if (y < 1) {
            if (T == 123) --y;
            else if (T == 125 && y++ == 0 && xlt() == 125) continue;
          }
          switch (((G += Jy(T)), T * y)) {
            case 38:
              k = f > 0 ? 1 : ((G += "\f"), -1);
              break;
            case 44:
              ((l[h++] = (Vs(G) - 1) * k), (k = 1));
              break;
            case 64:
              (zl() === 45 && (G += SC(ba())),
                (p = zl()),
                (f = d = Vs((C = G += Clt(ex())))),
                T++);
              break;
            case 45:
              g === 45 && Vs(G) == 2 && (y = 0);
          }
      }
    return s;
  }
  a(_C, "parse");
  function wlt(e, t, r, n, i, s, o, l, u, h, f, d) {
    for (
      var p = i - 1, m = i === 0 ? s : [""], g = mlt(m), y = 0, b = 0, k = 0;
      y < n;
      ++y
    )
      for (var T = 0, C = cu(e, p + 1, (p = B8((b = o[y])))), L = e; T < g; ++T)
        (L = xC(b > 0 ? m[T] + " " + C : tx(C, /&\f/g, m[T]))) && (u[k++] = L);
    return kC(e, t, r, i === 0 ? gC : l, u, h, f, d);
  }
  a(wlt, "ruleset");
  function eMt(e, t, r, n) {
    return kC(e, t, r, mC, Jy(ylt()), cu(e, 2, -2), 0, n);
  }
  a(eMt, "comment");
  function vlt(e, t, r, n, i) {
    return kC(e, t, r, yC, cu(e, 0, n), cu(e, n + 1, -1), n, i);
  }
  a(vlt, "declaration");
  function CC(e, t) {
    for (var r = "", n = 0; n < e.length; n++) r += t(e[n], n, e, t) || "";
    return r;
  }
  a(CC, "serialize");
  function Alt(e, t, r, n) {
    switch (e.type) {
      case dlt:
        if (e.children.length) break;
      case ult:
      case hlt:
      case yC:
        return (e.return = e.return || e.value);
      case mC:
        return "";
      case flt:
        return (e.return = e.value + "{" + CC(e.children, n) + "}");
      case gC:
        if (!Vs((e.value = e.props.join(",")))) return "";
    }
    return Vs((r = CC(e.children, n)))
      ? (e.return = e.value + "{" + r + "}")
      : "";
  }
  a(Alt, "stringify");
  hw();
  Yk();
  XD();
  var rMt = "graphics-document document";
  function Llt(e, t) {
    (e.attr("role", rMt), t !== "" && e.attr("aria-roledescription", t));
  }
  a(Llt, "setA11yDiagramInfo");
  function Rlt(e, t, r, n) {
    if (e.insert !== void 0) {
      if (r) {
        let i = `chart-desc-${n}`;
        (e.attr("aria-describedby", i),
          e.insert("desc", ":first-child").attr("id", i).text(r));
      }
      if (t) {
        let i = `chart-title-${n}`;
        (e.attr("aria-labelledby", i),
          e.insert("title", ":first-child").attr("id", i).text(t));
      }
    }
  }
  a(Rlt, "addSVGa11yTitleDescription");
  of();
  un();
  un();
  pe();
  Tu();
  gw();
  _e();
  var Wm = class e {
    constructor(t, r, n, i, s) {
      this.type = t;
      this.text = r;
      this.db = n;
      this.parser = i;
      this.renderer = s;
    }
    static {
      a(this, "Diagram");
    }
    static async fromText(t, r = {}) {
      let n = ke(),
        i = pf(t, n);
      t =
        j$(t) +
        `
`;
      try {
        cg(i);
      } catch {
        let h = w7(i);
        if (!h) throw new df(`Diagram ${i} not found.`);
        let { id: f, diagram: d } = await h();
        Su(f, d);
      }
      let { db: s, parser: o, renderer: l, init: u } = cg(i);
      return (
        o.parser && (o.parser.yy = s),
        s.clear?.(),
        u?.(n),
        r.title && s.setDiagramTitle?.(r.title),
        await o.parse(t),
        new e(i, t, s, o, l)
      );
    }
    async render(t, r) {
      await this.renderer.draw(this.text, t, r, this);
    }
    getParser() {
      return this.parser;
    }
    getType() {
      return this.type;
    }
  };
  Be();
  var Dlt = [];
  var Nlt = a(() => {
    (Dlt.forEach((e) => {
      e();
    }),
      (Dlt = []));
  }, "attachFunctions");
  Vt();
  var Ilt = a(
    (e) => e.replace(/^\s*%%(?!{)[^\n]+\n?/gm, "").trimStart(),
    "cleanupComments",
  );
  Tx();
  v0();
  function Mlt(e) {
    let t = e.match(kx);
    if (!t) return { text: e, metadata: {} };
    let r = wc(t[1], { schema: Cc }) ?? {};
    r = typeof r == "object" && !Array.isArray(r) ? r : {};
    let n = {};
    return (
      r.displayMode && (n.displayMode = r.displayMode.toString()),
      r.title && (n.title = r.title.toString()),
      r.config && (n.config = r.config),
      { text: e.slice(t[0].length), metadata: n }
    );
  }
  a(Mlt, "extractFrontMatter");
  _e();
  var nMt = a(
      (e) =>
        e
          .replace(
            /\r\n?/g,
            `
`,
          )
          .replace(
            /<(\w+)([^>]*)>/g,
            (t, r, n) => "<" + r + n.replace(/="([^"]*)"/g, "='$1'") + ">",
          ),
      "cleanupText",
    ),
    iMt = a((e) => {
      let { text: t, metadata: r } = Mlt(e),
        { displayMode: n, title: i, config: s = {} } = r;
      return (
        n && (s.gantt || (s.gantt = {}), (s.gantt.displayMode = n)),
        { title: i, config: s, text: t }
      );
    }, "processFrontmatter"),
    sMt = a((e) => {
      let t = le.detectInit(e) ?? {},
        r = le.detectDirective(e, "wrap");
      return (
        Array.isArray(r)
          ? (t.wrap = r.some(({ type: n }) => n === "wrap"))
          : r?.type === "wrap" && (t.wrap = !0),
        { text: W$(e), directive: t }
      );
    }, "processDirectives");
  function $8(e) {
    let t = nMt(e),
      r = iMt(t),
      n = sMt(r.text),
      i = on(r.config, n.directive);
    return ((e = Ilt(n.text)), { code: e, title: r.title, config: i });
  }
  a($8, "preprocessDiagram");
  bw();
  dx();
  _e();
  function Olt(e) {
    let t = new TextEncoder().encode(e),
      r = Array.from(t, (n) => String.fromCodePoint(n)).join("");
    return btoa(r);
  }
  a(Olt, "toBase64");
  var aMt = 5e4,
    oMt = "graph TB;a[Maximum text size in diagram exceeded];style a fill:#faa",
    lMt = "sandbox",
    cMt = "loose",
    uMt = "http://www.w3.org/2000/svg",
    hMt = "http://www.w3.org/1999/xlink",
    fMt = "http://www.w3.org/1999/xhtml",
    dMt = "100%",
    pMt = "100%",
    mMt = "border:0;margin:0;",
    gMt = "margin:0",
    yMt = "allow-top-navigation-by-user-activation allow-popups",
    xMt = 'The "iframe" tag is not supported by your browser.',
    bMt = ["foreignobject"],
    kMt = ["dominant-baseline"];
  function $lt(e) {
    let t = $8(e);
    return (Jm(), e7(t.config ?? {}), t);
  }
  a($lt, "processAndSetConfigs");
  async function TMt(e, t) {
    Fm();
    try {
      let { code: r, config: n } = $lt(e);
      return { diagramType: (await Glt(r)).type, config: n };
    } catch (r) {
      if (t?.suppressErrors) return !1;
      throw r;
    }
  }
  a(TMt, "parse");
  var Plt = a(
      (e, t, r = []) => `
.${e} ${t} { ${r.join(" !important; ")} !important; }`,
      "cssImportantStyles",
    ),
    SMt = a((e, t = new Map()) => {
      let r = "";
      if (
        (e.themeCSS !== void 0 &&
          (r += `
${e.themeCSS}`),
        e.fontFamily !== void 0 &&
          (r += `
:root { --mermaid-font-family: ${e.fontFamily}}`),
        e.altFontFamily !== void 0 &&
          (r += `
:root { --mermaid-alt-font-family: ${e.altFontFamily}}`),
        t instanceof Map)
      ) {
        let o =
          (e.htmlLabels ?? e.flowchart?.htmlLabels)
            ? ["> *", "span"]
            : ["rect", "polygon", "ellipse", "circle", "path"];
        t.forEach((l) => {
          (De(l.styles) ||
            o.forEach((u) => {
              r += Plt(l.id, u, l.styles);
            }),
            De(l.textStyles) ||
              (r += Plt(
                l.id,
                "tspan",
                (l?.textStyles || []).map((u) => u.replace("color", "fill")),
              )));
        });
      }
      return r;
    }, "createCssStyles"),
    _Mt = a((e, t, r, n) => {
      let i = SMt(e, r),
        s = A7(t, i, e.themeVariables);
      return CC(Elt(`${n}{${s}}`), Alt);
    }, "createUserStyles"),
    CMt = a((e = "", t, r) => {
      let n = e;
      return (
        !r &&
          !t &&
          (n = n.replace(
            /marker-end="url\([\d+./:=?A-Za-z-]*?#/g,
            'marker-end="url(#',
          )),
        (n = Xn(n)),
        (n = n.replace(/<br>/g, "<br/>")),
        n
      );
    }, "cleanUpSvgCode"),
    wMt = a((e = "", t) => {
      let r = t?.viewBox?.baseVal?.height
          ? t.viewBox.baseVal.height + "px"
          : pMt,
        n = Olt(`<body style="${gMt}">${e}</body>`);
      return `<iframe style="width:${dMt};height:${r};${mMt}" src="data:text/html;charset=UTF-8;base64,${n}" sandbox="${yMt}">
  ${xMt}
</iframe>`;
    }, "putIntoIFrame"),
    Blt = a((e, t, r, n, i) => {
      let s = e.append("div");
      (s.attr("id", r), n && s.attr("style", n));
      let o = s
        .append("svg")
        .attr("id", t)
        .attr("width", "100%")
        .attr("xmlns", uMt);
      return (i && o.attr("xmlns:xlink", i), o.append("g"), e);
    }, "appendDivSvgG");
  function Flt(e, t) {
    return e
      .append("iframe")
      .attr("id", t)
      .attr("style", "width: 100%; height: 100%;")
      .attr("sandbox", "");
  }
  a(Flt, "sandboxedIframe");
  var vMt = a((e, t, r, n) => {
      (e.getElementById(t)?.remove(),
        e.getElementById(r)?.remove(),
        e.getElementById(n)?.remove());
    }, "removeExistingElements"),
    EMt = a(async function (e, t, r) {
      Fm();
      let n = $lt(t);
      t = n.code;
      let i = ke();
      (P.debug(i), t.length > (i?.maxTextSize ?? aMt) && (t = oMt));
      let s = "#" + e,
        o = "i" + e,
        l = "#" + o,
        u = "d" + e,
        h = "#" + u,
        f = a(() => {
          let v = xt(p ? l : h).node();
          v && "remove" in v && v.remove();
        }, "removeTempElements"),
        d = xt("body"),
        p = i.securityLevel === lMt,
        m = i.securityLevel === cMt,
        g = i.fontFamily;
      if (r !== void 0) {
        if ((r && (r.innerHTML = ""), p)) {
          let O = Flt(xt(r), o);
          ((d = xt(O.nodes()[0].contentDocument.body)),
            (d.node().style.margin = 0));
        } else d = xt(r);
        Blt(d, e, u, `font-family: ${g}`, hMt);
      } else {
        if ((vMt(document, e, u, o), p)) {
          let O = Flt(xt("body"), o);
          ((d = xt(O.nodes()[0].contentDocument.body)),
            (d.node().style.margin = 0));
        } else d = xt("body");
        Blt(d, e, u);
      }
      let y, b;
      try {
        y = await Wm.fromText(t, { title: n.title });
      } catch (O) {
        if (i.suppressErrorRendering) throw (f(), O);
        ((y = await Wm.fromText("error")), (b = O));
      }
      let k = d.select(h).node(),
        T = y.type,
        C = k.firstChild,
        L = C.firstChild,
        w = y.renderer.getClasses?.(t, y),
        D = _Mt(i, T, w, s),
        G = document.createElement("style");
      ((G.innerHTML = D), C.insertBefore(G, L));
      try {
        await y.renderer.draw(t, e, Py.version, y);
      } catch (O) {
        throw (i.suppressErrorRendering ? f() : rst.draw(t, e, Py.version), O);
      }
      let E = d.select(`${h} svg`),
        R = y.db.getAccTitle?.(),
        F = y.db.getAccDescription?.();
      (LMt(T, E, R, F),
        d
          .select(`[id="${e}"]`)
          .selectAll("foreignobject > *")
          .attr("xmlns", fMt));
      let S = d.select(h).node().innerHTML;
      if (
        (P.debug("config.arrowMarkerAbsolute", i.arrowMarkerAbsolute),
        (S = CMt(S, p, Pe(i.arrowMarkerAbsolute))),
        p)
      ) {
        let O = d.select(h + " svg").node();
        S = wMt(S, O);
      } else
        m ||
          (S = Xl.sanitize(S, {
            ADD_TAGS: bMt,
            ADD_ATTR: kMt,
            HTML_INTEGRATION_POINTS: { foreignobject: !0 },
          }));
      if ((Nlt(), b)) throw b;
      return (
        f(),
        { diagramType: T, svg: S, bindFunctions: y.db.bindFunctions }
      );
    }, "render");
  function AMt(e = {}) {
    let t = Xr({}, e);
    (t?.fontFamily &&
      !t.themeVariables?.fontFamily &&
      (t.themeVariables || (t.themeVariables = {}),
      (t.themeVariables.fontFamily = t.fontFamily)),
      ZI(t),
      t?.theme && t.theme in js
        ? (t.themeVariables = js[t.theme].getThemeVariables(t.themeVariables))
        : t &&
          (t.themeVariables = js.default.getThemeVariables(t.themeVariables)));
    let r = typeof t == "object" ? rw(t) : nw();
    (jm(r.logLevel), Fm());
  }
  a(AMt, "initialize");
  var Glt = a((e, t = {}) => {
    let { code: r } = $8(e);
    return Wm.fromText(r, t);
  }, "getDiagramFromText");
  function LMt(e, t, r, n) {
    (Llt(t, e), Rlt(t, r, n, t.attr("id")));
  }
  a(LMt, "addA11yInfo");
  var uu = Object.freeze({
    render: EMt,
    parse: TMt,
    getDiagramFromText: Glt,
    initialize: AMt,
    getConfig: ke,
    setConfig: mx,
    getSiteConfig: nw,
    updateSiteConfig: JI,
    reset: a(() => {
      Jm();
    }, "reset"),
    globalReset: a(() => {
      Jm(Yl);
    }, "globalReset"),
    defaultConfig: Yl,
  });
  jm(ke().logLevel);
  Jm(ke());
  ph();
  _e();
  var RMt = a((e, t, r) => {
      (P.warn(e),
        N4(e)
          ? (r && r(e.str, e.hash), t.push({ ...e, message: e.str, error: e }))
          : (r && r(e),
            e instanceof Error &&
              t.push({
                str: e.message,
                message: e.message,
                hash: e.name,
                error: e,
              })));
    }, "handleError"),
    Vlt = a(async function (e = { querySelector: ".mermaid" }) {
      try {
        await DMt(e);
      } catch (t) {
        if (
          (N4(t) && P.error(t.str),
          Wl.parseError && Wl.parseError(t),
          !e.suppressErrors)
        )
          throw (
            P.error("Use the suppressErrors option to suppress these errors"),
            t
          );
      }
    }, "run"),
    DMt = a(async function (
      { postRenderCallback: e, querySelector: t, nodes: r } = {
        querySelector: ".mermaid",
      },
    ) {
      let n = uu.getConfig();
      P.debug(`${e ? "" : "No "}Callback function found`);
      let i;
      if (r) i = r;
      else if (t) i = document.querySelectorAll(t);
      else throw new Error("Nodes and querySelector are both undefined");
      (P.debug(`Found ${i.length} diagrams`),
        n?.startOnLoad !== void 0 &&
          (P.debug("Start On Load: " + n?.startOnLoad),
          uu.updateSiteConfig({ startOnLoad: n?.startOnLoad })));
      let s = new le.InitIDGenerator(n.deterministicIds, n.deterministicIDSeed),
        o,
        l = [];
      for (let u of Array.from(i)) {
        P.info("Rendering diagram: " + u.id);
        if (u.getAttribute("data-processed")) continue;
        u.setAttribute("data-processed", "true");
        let h = `mermaid-${s.next()}`;
        ((o = u.innerHTML),
          (o = bx(le.entityDecode(o))
            .trim()
            .replace(/<br\s*\/?>/gi, "<br/>")));
        let f = le.detectInit(o);
        f && P.debug("Detected early reinit: ", f);
        try {
          let { svg: d, bindFunctions: p } = await jlt(h, o, u);
          ((u.innerHTML = d), e && (await e(h)), p && p(u));
        } catch (d) {
          RMt(d, l, Wl.parseError);
        }
      }
      if (l.length > 0) throw l[0];
    }, "runThrowsErrors"),
    zlt = a(function (e) {
      uu.initialize(e);
    }, "initialize"),
    NMt = a(async function (e, t, r) {
      (P.warn("mermaid.init is deprecated. Please use run instead."),
        e && zlt(e));
      let n = { postRenderCallback: r, querySelector: ".mermaid" };
      (typeof t == "string"
        ? (n.querySelector = t)
        : t && (t instanceof HTMLElement ? (n.nodes = [t]) : (n.nodes = t)),
        await Vlt(n));
    }, "init"),
    IMt = a(async (e, { lazyLoad: t = !0 } = {}) => {
      (Fm(), Sx(...e), t === !1 && (await clt()));
    }, "registerExternalDiagrams"),
    Wlt = a(function () {
      if (Wl.startOnLoad) {
        let { startOnLoad: e } = uu.getConfig();
        e && Wl.run().catch((t) => P.error("Mermaid failed to initialize", t));
      }
    }, "contentLoaded");
  if (typeof document < "u") {
    window.addEventListener("load", Wlt, !1);
  }
  var MMt = a(function (e) {
      Wl.parseError = e;
    }, "setParseErrorHandler"),
    wC = [],
    G8 = !1,
    Ult = a(async () => {
      if (!G8) {
        for (G8 = !0; wC.length > 0; ) {
          let e = wC.shift();
          if (e)
            try {
              await e();
            } catch (t) {
              P.error("Error executing queue", t);
            }
        }
        G8 = !1;
      }
    }, "executeQueue"),
    OMt = a(
      async (e, t) =>
        new Promise((r, n) => {
          let i = a(
            () =>
              new Promise((s, o) => {
                uu.parse(e, t).then(
                  (l) => {
                    (s(l), r(l));
                  },
                  (l) => {
                    (P.error("Error parsing", l),
                      Wl.parseError?.(l),
                      o(l),
                      n(l));
                  },
                );
              }),
            "performCall",
          );
          (wC.push(i), Ult().catch(n));
        }),
      "parse",
    ),
    jlt = a(
      (e, t, r) =>
        new Promise((n, i) => {
          let s = a(
            () =>
              new Promise((o, l) => {
                uu.render(e, t, r).then(
                  (u) => {
                    (o(u), n(u));
                  },
                  (u) => {
                    (P.error("Error parsing", u),
                      Wl.parseError?.(u),
                      l(u),
                      i(u));
                  },
                );
              }),
            "performCall",
          );
          (wC.push(s), Ult().catch(i));
        }),
      "render",
    ),
    PMt = a(
      () => Object.keys(el).map((e) => ({ id: e })),
      "getRegisteredDiagramsMetadata",
    ),
    Wl = {
      startOnLoad: !0,
      mermaidAPI: uu,
      parse: OMt,
      render: jlt,
      init: NMt,
      run: Vlt,
      registerExternalDiagrams: IMt,
      registerLayoutLoaders: J5,
      initialize: zlt,
      parseError: void 0,
      contentLoaded: Wlt,
      setParseErrorHandler: MMt,
      detectType: pf,
      registerIconPacks: T7,
      getRegisteredDiagramsMetadata: PMt,
    },
    BMt = Wl;
  return ect(FMt);
})();
/*! Check if previously processed */
/*!
 * Wait for document loaded before starting the execution
 */
/*! Bundled license information:

dompurify/dist/purify.es.mjs:
  (*! @license DOMPurify 3.2.5 | (c) Cure53 and other contributors | Released under the Apache license 2.0 and Mozilla Public License 2.0 | github.com/cure53/DOMPurify/blob/3.2.5/LICENSE *)

js-yaml/dist/js-yaml.mjs:
  (*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT *)

lodash-es/lodash.js:
  (**
   * @license
   * Lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="es" -o ./`
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
globalThis["mermaid"] = globalThis.__esbuild_esm_mermaid_nm["mermaid"].default;
